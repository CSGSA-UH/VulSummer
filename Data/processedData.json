{"func": "int _gnutls_ciphertext2compressed(gnutls_session_t session,\n\t\t\t\t  opaque * compress_data,\n\t\t\t\t  int compress_size,\n\t\t\t\t  gnutls_datum_t ciphertext, uint8 type)\n{\n    uint8 MAC[MAX_HASH_SIZE];\n    uint16 c_length;\n    uint8 pad;\n    int length;\n    mac_hd_t td;\n    uint16 blocksize;\n    int ret, i, pad_failed = 0;\n    uint8 major, minor;\n    gnutls_protocol_t ver;\n    int hash_size =\n\t_gnutls_hash_get_algo_len(session->security_parameters.\n\t\t\t\t  read_mac_algorithm);\n\n    ver = gnutls_protocol_get_version(session);\n    minor = _gnutls_version_get_minor(ver);\n    major = _gnutls_version_get_major(ver);\n\n    blocksize = _gnutls_cipher_get_block_size(session->security_parameters.\n\t\t\t\t\t      read_bulk_cipher_algorithm);\n\n    /* initialize MAC \n     */\n    td = mac_init(session->security_parameters.read_mac_algorithm,\n\t\t  session->connection_state.read_mac_secret.data,\n\t\t  session->connection_state.read_mac_secret.size, ver);\n\n    if (td == GNUTLS_MAC_FAILED\n\t&& session->security_parameters.read_mac_algorithm !=\n\tGNUTLS_MAC_NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n    /* actual decryption (inplace)\n     */\n    switch (_gnutls_cipher_is_block\n\t    (session->security_parameters.read_bulk_cipher_algorithm)) {\n    case CIPHER_STREAM:\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\tlength = ciphertext.size - hash_size;\n\n\tbreak;\n    case CIPHER_BLOCK:\n\tif ((ciphertext.size < blocksize)\n\t    || (ciphertext.size % blocksize != 0)) {\n\t    gnutls_assert();\n\t    return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\t/* ignore the IV in TLS 1.1.\n\t */\n\tif (session->security_parameters.version >= GNUTLS_TLS1_1) {\n\t    ciphertext.size -= blocksize;\n\t    ciphertext.data += blocksize;\n\n\t    if (ciphertext.size == 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n\tpad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n\tlength = ciphertext.size - hash_size - pad;\n\n\tif (pad > ciphertext.size - hash_size) {\n\t    gnutls_assert();\n\t    /* We do not fail here. We check below for the\n\t     * the pad_failed. If zero means success.\n\t     */\n\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\t/* Check the pading bytes (TLS 1.x)\n\t */\n\tif (ver >= GNUTLS_TLS1)\n\t    for (i = 2; i < pad; i++) {\n\t\tif (ciphertext.data[ciphertext.size - i] !=\n\t\t    ciphertext.data[ciphertext.size - 1])\n\t\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\n\tbreak;\n    default:\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (length < 0)\n\tlength = 0;\n    c_length = _gnutls_conv_uint16((uint16) length);\n\n    /* Pass the type, version, length and compressed through\n     * MAC.\n     */\n    if (td != GNUTLS_MAC_FAILED) {\n\t_gnutls_hmac(td,\n\t\t     UINT64DATA(session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n\t_gnutls_hmac(td, &type, 1);\n\tif (ver >= GNUTLS_TLS1) {\t/* TLS 1.x */\n\t    _gnutls_hmac(td, &major, 1);\n\t    _gnutls_hmac(td, &minor, 1);\n\t}\n\t_gnutls_hmac(td, &c_length, 2);\n\n\tif (length > 0)\n\t    _gnutls_hmac(td, ciphertext.data, length);\n\n\tmac_deinit(td, MAC, ver);\n    }\n\n    /* This one was introduced to avoid a timing attack against the TLS\n     * 1.0 protocol.\n     */\n    if (pad_failed != 0)\n\treturn pad_failed;\n\n    /* HMAC was not the same. \n     */\n    if (memcmp(MAC, &ciphertext.data[length], hash_size) != 0) {\n\tgnutls_assert();\n\treturn GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n    /* copy the decrypted stuff to compress_data.\n     */\n    if (compress_size < length) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n    memcpy(compress_data, ciphertext.data, length);\n\n    return length;\n}", "target": 1, "cwe": [], "message": "added an extra check while checking the padding."}
{"func": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1, "cwe": ["CWE-264"], "message": "Improve check for :memory: pseudo-filename in SQlite"}
{"func": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n//error check??\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}", "target": 1, "cwe": [], "message": "uncompress: fix buffer underrun by corrupted input\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t      s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\ts->ds->dpy_copy(s->ds,\n\t\t\tsx, sy, dx, dy,\n\t\t\ts->cirrus_blt_width / depth,\n\t\t\ts->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since dpy_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t\t  s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vram_ptr + s->cirrus_blt_dstaddr;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            /* at least one scan line */\n            do {\n                (*s->cirrus_rop)(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n                                 s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                /* more bytes than needed can be transfered because of\n                   word alignment, so we keep them for the next line */\n                /* XXX: keep alignment to speed up transfer */\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "message": "CVE-2008-4539: fix a heap overflow in Cirrus emulation\n\nThe code in hw/cirrus_vga.c has changed a lot between CVE-2007-1320 has\nbeen announced and the patch has been applied. As a consequence it has\nwrongly applied and QEMU is still vulnerable to this bug if using VNC.\n\n(noticed by Jan Niehusmann)\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5587 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "asmlinkage long compat_sys_mount(char __user * dev_name, char __user * dir_name,\n\t\t\t\t char __user * type, unsigned long flags,\n\t\t\t\t void __user * data)\n{\n\tunsigned long type_page;\n\tunsigned long data_page;\n\tunsigned long dev_page;\n\tchar *dir_page;\n\tint retval;\n\n\tretval = copy_mount_options (type, &type_page);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tdir_page = getname(dir_name);\n\tretval = PTR_ERR(dir_page);\n\tif (IS_ERR(dir_page))\n\t\tgoto out1;\n\n\tretval = copy_mount_options (dev_name, &dev_page);\n\tif (retval < 0)\n\t\tgoto out2;\n\n\tretval = copy_mount_options (data, &data_page);\n\tif (retval < 0)\n\t\tgoto out3;\n\n\tretval = -EINVAL;\n\n\tif (type_page) {\n\t\tif (!strcmp((char *)type_page, SMBFS_NAME)) {\n\t\t\tdo_smb_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NCPFS_NAME)) {\n\t\t\tdo_ncp_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NFS4_NAME)) {\n\t\t\tif (do_nfs4_super_data_conv((void *) data_page))\n\t\t\t\tgoto out4;\n\t\t}\n\t}\n\n\tlock_kernel();\n\tretval = do_mount((char*)dev_page, dir_page, (char*)type_page,\n\t\t\tflags, (void*)data_page);\n\tunlock_kernel();\n\n out4:\n\tfree_page(data_page);\n out3:\n\tfree_page(dev_page);\n out2:\n\tputname(dir_page);\n out1:\n\tfree_page(type_page);\n out:\n\treturn retval;\n}", "target": 1, "cwe": [], "message": "[PATCH] skip data conversion in compat_sys_mount when data_page is NULL\n\nOpenVZ Linux kernel team has found a problem with mounting in compat mode.\n\nSimple command \"mount -t smbfs ...\" on Fedora Core 5 distro in 32-bit mode\nleads to oops:\n\n  Unable to handle kernel NULL pointer dereference at 0000000000000000 RIP: compat_sys_mount+0xd6/0x290\n  Process mount (pid: 14656, veid=300, threadinfo ffff810034d30000, task ffff810034c86bc0)\n  Call Trace: ia32_sysret+0x0/0xa\n\nThe problem is that data_page pointer can be NULL, so we should skip data\nconversion in this case.\n\nSigned-off-by: Andrey Mirkin <amirkin@openvz.org>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "unsigned short atalk_checksum(struct ddpehdr *ddp, int len)\n{\n\tunsigned long sum = 0;\t/* Assume unsigned long is >16 bits */\n\tunsigned char *data = (unsigned char *)ddp;\n\n\tlen  -= 4;\t\t/* skip header 4 bytes */\n\tdata += 4;\n\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data;\n\t\tsum <<= 1;\n\t\tif (sum & 0x10000) {\n\t\t\tsum++;\n\t\t\tsum &= 0xFFFF;\n\t\t}\n\t\tdata++;\n\t}\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : 0xFFFF;\n}", "target": 1, "cwe": [], "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt)\n{\n\t/* Expand any short form frames */\n\tif (skb->mac.raw[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(struct ddpshdr))\n\t\t\tgoto freeit;\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\n\t\tskb_push(skb, sizeof(*ddp) - 4);\n\t\t/* FIXME: use skb->cb to be able to use shared skbs */\n\t\tddp = (struct ddpehdr *)skb->data;\n\n\t\t/* Now fill in the long header */\n\n\t \t/*\n\t \t * These two first. The mac overlays the new source/dest\n\t \t * network information so we MUST copy these before\n\t \t * we write the network numbers !\n\t \t */\n\n\t\tddp->deh_dnode = skb->mac.raw[0];     /* From physical header */\n\t\tddp->deh_snode = skb->mac.raw[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\tddp->deh_len   = skb->len;\n\t\tddp->deh_hops  = DDP_MAXHOPS;\t/* Non routable, so force a drop\n\t\t\t\t\t\t   if we slip up later */\n\t\t/* Mend the byte order */\n\t\t*((__u16 *)ddp) = htons(*((__u16 *)ddp));\n\t}\n\tskb->h.raw = skb->data;\n\n\treturn atalk_rcv(skb, dev, pt);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt)\n{\n\tstruct ddpehdr *ddp = ddp_hdr(skb);\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n        int origlen;\n        struct ddpebits ddphv;\n\n\t/* Size check */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t *\tFix up the length field\t[Ok this is horrible but otherwise\n\t *\tI end up with unions of bit fields and messy bit field order\n\t *\tcompiler/endian dependencies..]\n\t *\n\t *\tFIXME: This is a write to a shared object. Granted it\n\t *\thappens to be safe BUT.. (Its safe as user space will not\n\t *\trun until we put it back)\n\t */\n\t*((__u16 *)&ddphv) = ntohs(*((__u16 *)ddp));\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, ddphv.deh_len));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(ddp, ddphv.deh_len) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto freeit;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\t/* Not ours, so we route the packet via the correct AppleTalk iface */\n\tif (!atif) {\n\t\tatalk_route_packet(skb, dev, ddp, &ddphv, origlen);\n\t\tgoto out;\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto freeit;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto freeit;\nout:\n\treturn 0;\nfreeit:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 1, "cwe": [], "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t int len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~MSG_DONTWAIT)\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sk->sk_zapped)\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk doesn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tprintk(KERN_INFO \"SO_BROADCAST: Fix your netatalk as \"\n\t\t\t\t\t \"it will break before 2.2\\n\");\n#if 0\n\t\t\treturn -EPERM;\n#endif\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t}\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\t\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_pad  = 0;\n\tddp->deh_hops = 0;\n\tddp->deh_len  = len + sizeof(*ddp);\n\t/*\n\t * Fix up the length field [Ok this is horrible but otherwise\n\t * I end up with unions of bit fields and messy bit field order\n\t * compiler/endian dependencies..\n\t */\n\t*((__u16 *)ddp) = ntohs(*((__u16 *)ddp));\n\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%d bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(ddp, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%d).\\n\", sk, len);\n\n\treturn len;\n}", "target": 1, "cwe": [], "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int fat_ioctl_filldir(void *__buf, const char *name, int name_len,\n\t\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct fat_ioctl_filldir_callback *buf = __buf;\n\tstruct dirent __user *d1 = buf->dirent;\n\tstruct dirent __user *d2 = d1 + 1;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\tbuf->result++;\n\n\tif (name != NULL) {\n\t\t/* dirent has only short name */\n\t\tif (name_len >= sizeof(d1->d_name))\n\t\t\tname_len = sizeof(d1->d_name) - 1;\n\n\t\tif (put_user(0, d2->d_name)\t\t\t||\n\t\t    put_user(0, &d2->d_reclen)\t\t\t||\n\t\t    copy_to_user(d1->d_name, name, name_len)\t||\n\t\t    put_user(0, d1->d_name + name_len)\t\t||\n\t\t    put_user(name_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t} else {\n\t\t/* dirent has short and long name */\n\t\tconst char *longname = buf->longname;\n\t\tint long_len = buf->long_len;\n\t\tconst char *shortname = buf->shortname;\n\t\tint short_len = buf->short_len;\n\n\t\tif (long_len >= sizeof(d1->d_name))\n\t\t\tlong_len = sizeof(d1->d_name) - 1;\n\t\tif (short_len >= sizeof(d1->d_name))\n\t\t\tshort_len = sizeof(d1->d_name) - 1;\n\n\t\tif (copy_to_user(d2->d_name, longname, long_len)\t||\n\t\t    put_user(0, d2->d_name + long_len)\t\t\t||\n\t\t    put_user(long_len, &d2->d_reclen)\t\t\t||\n\t\t    put_user(ino, &d2->d_ino)\t\t\t\t||\n\t\t    put_user(offset, &d2->d_off)\t\t\t||\n\t\t    copy_to_user(d1->d_name, shortname, short_len)\t||\n\t\t    put_user(0, d1->d_name + short_len)\t\t\t||\n\t\t    put_user(short_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t}\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}", "target": 1, "cwe": [], "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int fat_dir_ioctl(struct inode * inode, struct file * filp,\n\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct fat_ioctl_filldir_callback buf;\n\tstruct dirent __user *d1;\n\tint ret, short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(inode, filp, cmd, arg);\n\t}\n\n\td1 = (struct dirent __user *)arg;\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\tbuf.dirent = d1;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, filp, &buf, fat_ioctl_filldir,\n\t\t\t\t    short_only, both);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long fat_compat_dir_ioctl(struct file *file, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tcmd = VFAT_IOCTL_READDIR_BOTH;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tcmd = VFAT_IOCTL_READDIR_SHORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tlock_kernel();\n\tret = fat_dir_ioctl(file->f_path.dentry->d_inode, file,\n\t\t\t    cmd, (unsigned long) &d);\n\tunlock_kernel();\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= fat_compat_put_dirent32(&d[0], p);\n\t\tret |= fat_compat_put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long fat_compat_put_dirent32(struct dirent *d,\n\t\t\t\t    struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}", "target": 1, "cwe": [], "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int vfat_ioctl32(unsigned fd, unsigned cmd, unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch(cmd)\n\t{\n        \tcase VFAT_IOCTL_READDIR_BOTH32:\n                \tcmd = VFAT_IOCTL_READDIR_BOTH;\n                \tbreak;\n        \tcase VFAT_IOCTL_READDIR_SHORT32:\n                \tcmd = VFAT_IOCTL_READDIR_SHORT;\n                \tbreak;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sys_ioctl(fd,cmd,(unsigned long)&d);\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= put_dirent32(&d[0], p);\n\t\tret |= put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>"}
{"func": "put_dirent32 (struct dirent *d, struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}", "target": 1, "cwe": [], "message": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>"}
{"func": "unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->rip;\n\tseg = regs->cs & 0xffff;\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->eip;\n\tseg = regs->xcs & 0xffff;\n\tif (regs->eflags & VM_MASK) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "pfm_smpl_buffer_alloc(struct task_struct *task, pfm_context_t *ctx, unsigned long rsize, void **user_vaddr)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tunsigned long size;\n\tvoid *smpl_buf;\n\n\n\t/*\n\t * the fixed header + requested size and align to page boundary\n\t */\n\tsize = PAGE_ALIGN(rsize);\n\n\tDPRINT((\"sampling buffer rsize=%lu size=%lu bytes\\n\", rsize, size));\n\n\t/*\n\t * check requested size to avoid Denial-of-service attacks\n\t * XXX: may have to refine this test\n\t * Check against address space limit.\n\t *\n\t * if ((mm->total_vm << PAGE_SHIFT) + len> task->rlim[RLIMIT_AS].rlim_cur)\n\t * \treturn -ENOMEM;\n\t */\n\tif (size > task->signal->rlim[RLIMIT_MEMLOCK].rlim_cur)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We do the easy to undo allocations first.\n \t *\n\t * pfm_rvmalloc(), clears the buffer, so there is no leak\n\t */\n\tsmpl_buf = pfm_rvmalloc(size);\n\tif (smpl_buf == NULL) {\n\t\tDPRINT((\"Can't allocate sampling buffer\\n\"));\n\t\treturn -ENOMEM;\n\t}\n\n\tDPRINT((\"smpl_buf @%p\\n\", smpl_buf));\n\n\t/* allocate vma */\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma) {\n\t\tDPRINT((\"Cannot allocate vma\\n\"));\n\t\tgoto error_kmem;\n\t}\n\n\t/*\n\t * partially initialize the vma for the sampling buffer\n\t */\n\tvma->vm_mm\t     = mm;\n\tvma->vm_flags\t     = VM_READ| VM_MAYREAD |VM_RESERVED;\n\tvma->vm_page_prot    = PAGE_READONLY; /* XXX may need to change */\n\n\t/*\n\t * Now we have everything we need and we can initialize\n\t * and connect all the data structures\n\t */\n\n\tctx->ctx_smpl_hdr   = smpl_buf;\n\tctx->ctx_smpl_size  = size; /* aligned size */\n\n\t/*\n\t * Let's do the difficult operations next.\n\t *\n\t * now we atomically find some area in the address space and\n\t * remap the buffer in it.\n\t */\n\tdown_write(&task->mm->mmap_sem);\n\n\t/* find some free area in address space, must have mmap sem held */\n\tvma->vm_start = pfm_get_unmapped_area(NULL, 0, size, 0, MAP_PRIVATE|MAP_ANONYMOUS, 0);\n\tif (vma->vm_start == 0UL) {\n\t\tDPRINT((\"Cannot find unmapped area for size %ld\\n\", size));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\tvma->vm_end = vma->vm_start + size;\n\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\n\tDPRINT((\"aligned size=%ld, hdr=%p mapped @0x%lx\\n\", size, ctx->ctx_smpl_hdr, vma->vm_start));\n\n\t/* can only be applied to current task, need to have the mm semaphore held when called */\n\tif (pfm_remap_buffer(vma, (unsigned long)smpl_buf, vma->vm_start, size)) {\n\t\tDPRINT((\"Can't remap buffer\\n\"));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * now insert the vma in the vm list for the process, must be\n\t * done with mmap lock held\n\t */\n\tinsert_vm_struct(mm, vma);\n\n\tmm->total_vm  += size >> PAGE_SHIFT;\n\tvm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file,\n\t\t\t\t\t\t\tvma_pages(vma));\n\tup_write(&task->mm->mmap_sem);\n\n\t/*\n\t * keep track of user level virtual address\n\t */\n\tctx->ctx_smpl_vaddr = (void *)vma->vm_start;\n\t*(unsigned long *)user_vaddr = vma->vm_start;\n\n\treturn 0;\n\nerror:\n\tkmem_cache_free(vm_area_cachep, vma);\nerror_kmem:\n\tpfm_rvfree(smpl_buf, size);\n\n\treturn -ENOMEM;\n}", "target": 1, "cwe": [], "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "pfm_context_create(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)\n{\n\tpfarg_context_t *req = (pfarg_context_t *)arg;\n\tstruct file *filp;\n\tint ctx_flags;\n\tint ret;\n\n\t/* let's check the arguments first */\n\tret = pfarg_is_sane(current, req);\n\tif (ret < 0) return ret;\n\n\tctx_flags = req->ctx_flags;\n\n\tret = -ENOMEM;\n\n\tctx = pfm_context_alloc();\n\tif (!ctx) goto error;\n\n\tret = pfm_alloc_fd(&filp);\n\tif (ret < 0) goto error_file;\n\n\treq->ctx_fd = ctx->ctx_fd = ret;\n\n\t/*\n\t * attach context to file\n\t */\n\tfilp->private_data = ctx;\n\n\t/*\n\t * does the user want to sample?\n\t */\n\tif (pfm_uuid_cmp(req->ctx_smpl_buf_id, pfm_null_uuid)) {\n\t\tret = pfm_setup_buffer_fmt(current, ctx, ctx_flags, 0, req);\n\t\tif (ret) goto buffer_error;\n\t}\n\n\t/*\n\t * init context protection lock\n\t */\n\tspin_lock_init(&ctx->ctx_lock);\n\n\t/*\n\t * context is unloaded\n\t */\n\tctx->ctx_state = PFM_CTX_UNLOADED;\n\n\t/*\n\t * initialization of context's flags\n\t */\n\tctx->ctx_fl_block       = (ctx_flags & PFM_FL_NOTIFY_BLOCK) ? 1 : 0;\n\tctx->ctx_fl_system      = (ctx_flags & PFM_FL_SYSTEM_WIDE) ? 1: 0;\n\tctx->ctx_fl_is_sampling = ctx->ctx_buf_fmt ? 1 : 0; /* assume record() is defined */\n\tctx->ctx_fl_no_msg      = (ctx_flags & PFM_FL_OVFL_NO_MSG) ? 1: 0;\n\t/*\n\t * will move to set properties\n\t * ctx->ctx_fl_excl_idle   = (ctx_flags & PFM_FL_EXCL_IDLE) ? 1: 0;\n\t */\n\n\t/*\n\t * init restart semaphore to locked\n\t */\n\tinit_completion(&ctx->ctx_restart_done);\n\n\t/*\n\t * activation is used in SMP only\n\t */\n\tctx->ctx_last_activation = PFM_INVALID_ACTIVATION;\n\tSET_LAST_CPU(ctx, -1);\n\n\t/*\n\t * initialize notification message queue\n\t */\n\tctx->ctx_msgq_head = ctx->ctx_msgq_tail = 0;\n\tinit_waitqueue_head(&ctx->ctx_msgq_wait);\n\tinit_waitqueue_head(&ctx->ctx_zombieq);\n\n\tDPRINT((\"ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d no_msg=%d ctx_fd=%d \\n\",\n\t\tctx,\n\t\tctx_flags,\n\t\tctx->ctx_fl_system,\n\t\tctx->ctx_fl_block,\n\t\tctx->ctx_fl_excl_idle,\n\t\tctx->ctx_fl_no_msg,\n\t\tctx->ctx_fd));\n\n\t/*\n\t * initialize soft PMU state\n\t */\n\tpfm_reset_pmu_state(ctx);\n\n\treturn 0;\n\nbuffer_error:\n\tpfm_free_fd(ctx->ctx_fd, filp);\n\n\tif (ctx->ctx_buf_fmt) {\n\t\tpfm_buf_fmt_exit(ctx->ctx_buf_fmt, current, NULL, regs);\n\t}\nerror_file:\n\tpfm_context_free(ctx);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "pfm_setup_buffer_fmt(struct task_struct *task, pfm_context_t *ctx, unsigned int ctx_flags,\n\t\t     unsigned int cpu, pfarg_context_t *arg)\n{\n\tpfm_buffer_fmt_t *fmt = NULL;\n\tunsigned long size = 0UL;\n\tvoid *uaddr = NULL;\n\tvoid *fmt_arg = NULL;\n\tint ret = 0;\n#define PFM_CTXARG_BUF_ARG(a)\t(pfm_buffer_fmt_t *)(a+1)\n\n\t/* invoke and lock buffer format, if found */\n\tfmt = pfm_find_buffer_fmt(arg->ctx_smpl_buf_id);\n\tif (fmt == NULL) {\n\t\tDPRINT((\"[%d] cannot find buffer format\\n\", task->pid));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * buffer argument MUST be contiguous to pfarg_context_t\n\t */\n\tif (fmt->fmt_arg_size) fmt_arg = PFM_CTXARG_BUF_ARG(arg);\n\n\tret = pfm_buf_fmt_validate(fmt, task, ctx_flags, cpu, fmt_arg);\n\n\tDPRINT((\"[%d] after validate(0x%x,%d,%p)=%d\\n\", task->pid, ctx_flags, cpu, fmt_arg, ret));\n\n\tif (ret) goto error;\n\n\t/* link buffer format and context */\n\tctx->ctx_buf_fmt = fmt;\n\n\t/*\n\t * check if buffer format wants to use perfmon buffer allocation/mapping service\n\t */\n\tret = pfm_buf_fmt_getsize(fmt, task, ctx_flags, cpu, fmt_arg, &size);\n\tif (ret) goto error;\n\n\tif (size) {\n\t\t/*\n\t\t * buffer is always remapped into the caller's address space\n\t\t */\n\t\tret = pfm_smpl_buffer_alloc(current, ctx, size, &uaddr);\n\t\tif (ret) goto error;\n\n\t\t/* keep track of user address of buffer */\n\t\targ->ctx_smpl_vaddr = uaddr;\n\t}\n\tret = pfm_buf_fmt_init(fmt, task, ctx->ctx_smpl_hdr, ctx_flags, cpu, fmt_arg);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc) {\n\t\tsnd_mem_proc->read_proc = snd_mem_proc_read;\n#ifdef CONFIG_PCI\n\t\tsnd_mem_proc->write_proc = snd_mem_proc_write;\n#endif\n\t}\n#endif\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int snd_mem_proc_read(char *page, char **start, off_t off,\n\t\t\t     int count, int *eof, void *data)\n{\n\tint len = 0;\n\tlong pages = snd_allocated_pages >> (PAGE_SHIFT-12);\n\tstruct snd_mem_list *mem;\n\tint devno;\n\tstatic char *types[] = { \"UNKNOWN\", \"CONT\", \"DEV\", \"DEV-SG\", \"SBUS\" };\n\n\tmutex_lock(&list_mutex);\n\tlen += snprintf(page + len, count - len,\n\t\t\t\"pages  : %li bytes (%li pages per %likB)\\n\",\n\t\t\tpages * PAGE_SIZE, pages, PAGE_SIZE / 1024);\n\tdevno = 0;\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tdevno++;\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"buffer %d : ID %08x : type %s\\n\",\n\t\t\t\tdevno, mem->id, types[mem->buffer.dev.type]);\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"  addr = 0x%lx, size = %d bytes\\n\",\n\t\t\t\t(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn len;\n}", "target": 1, "cwe": [], "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int snd_mem_proc_write(struct file *file, const char __user *buffer,\n\t\t\t      unsigned long count, void *data)\n{\n\tchar buf[128];\n\tchar *token, *p;\n\n\tif (count > ARRAY_SIZE(buf) - 1)\n\t\tcount = ARRAY_SIZE(buf) - 1;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\tbuf[ARRAY_SIZE(buf) - 1] = '\\0';\n\n\tp = buf;\n\ttoken = gettoken(&p);\n\tif (! token || *token == '#')\n\t\treturn (int)count;\n\tif (strcmp(token, \"add\") == 0) {\n\t\tchar *endp;\n\t\tint vendor, device, size, buffers;\n\t\tlong mask;\n\t\tint i, alloced;\n\t\tstruct pci_dev *pci;\n\n\t\tif ((token = gettoken(&p)) == NULL ||\n\t\t    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (device = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (mask = simple_strtol(token, NULL, 0)) < 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (size = memparse(token, &endp)) < 64*1024 ||\n\t\t    size > 16*1024*1024 /* too big */ ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    buffers > 4) {\n\t\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc write format\\n\");\n\t\t\treturn (int)count;\n\t\t}\n\t\tvendor &= 0xffff;\n\t\tdevice &= 0xffff;\n\n\t\talloced = 0;\n\t\tpci = NULL;\n\t\twhile ((pci = pci_get_device(vendor, device, pci)) != NULL) {\n\t\t\tif (mask > 0 && mask < 0xffffffff) {\n\t\t\t\tif (pci_set_dma_mask(pci, mask) < 0 ||\n\t\t\t\t    pci_set_consistent_dma_mask(pci, mask) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\\n\", mask, vendor, device);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tpci_dev_put(pci);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));\n\t\t\t}\n\t\t\talloced++;\n\t\t}\n\t\tif (! alloced) {\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\t/* FIXME: We can allocate only in ZONE_DMA\n\t\t\t\t * without a device pointer!\n\t\t\t\t */\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));\n\t\t\t}\n\t\t}\n\t} else if (strcmp(token, \"erase\") == 0)\n\t\t/* FIXME: need for releasing each buffer chunk? */\n\t\tfree_all_reserved_pages();\n\telse\n\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc cmd\\n\");\n\treturn (int)count;\n}", "target": 1, "cwe": [], "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int putreg(struct task_struct *child,\n\tunsigned long regno, unsigned long value)\n{\n\tunsigned long tmp; \n\t\n\t/* Some code in the 64bit emulation may not be 64bit clean.\n\t   Don't take any chances. */\n\tif (test_tsk_thread_flag(child, TIF_IA32))\n\t\tvalue &= 0xffffffff;\n\tswitch (regno) {\n\t\tcase offsetof(struct user_regs_struct,fs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fsindex = value & 0xffff; \n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gsindex = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ds):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.ds = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,es): \n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.es = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ss):\n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,fs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct, eflags):\n\t\t\tvalue &= FLAG_MASK;\n\t\t\ttmp = get_stack_long(child, EFL_OFFSET); \n\t\t\ttmp &= ~FLAG_MASK; \n\t\t\tvalue |= tmp;\n\t\t\tbreak;\n\t\tcase offsetof(struct user_regs_struct,cs): \n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\tbreak;\n\t}\n\tput_stack_long(child, regno - sizeof(struct pt_regs), value);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "x86_64: Zero extend all registers after ptrace in 32bit entry path.\n\nStrictly it's only needed for eax.\n\nIt actually does a little more than strictly needed -- the other registers\nare already zero extended.\n\nAlso remove the now unnecessary and non functional compat task check\nin ptrace.\n\nThis is CVE-2007-4573\n\nFound by Wojciech Purczynski\n\nSigned-off-by: Andi Kleen <ak@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int pwc_video_close(struct inode *inode, struct file *file)\n{\n\tstruct video_device *vdev = file->private_data;\n\tstruct pwc_device *pdev;\n\tint i;\n\n\tPWC_DEBUG_OPEN(\">> video_close called(vdev = 0x%p).\\n\", vdev);\n\n\tpdev = (struct pwc_device *)vdev->priv;\n\tif (pdev->vopen == 0)\n\t\tPWC_DEBUG_MODULE(\"video_close() called on closed device?\\n\");\n\n\t/* Dump statistics, but only if a reasonable amount of frames were\n\t   processed (to prevent endless log-entries in case of snap-shot\n\t   programs)\n\t */\n\tif (pdev->vframe_count > 20)\n\t\tPWC_DEBUG_MODULE(\"Closing video device: %d frames received, dumped %d frames, %d frames with errors.\\n\", pdev->vframe_count, pdev->vframes_dumped, pdev->vframes_error);\n\n\tif (DEVICE_USE_CODEC1(pdev->type))\n\t    pwc_dec1_exit();\n\telse\n\t    pwc_dec23_exit();\n\n\tpwc_isoc_cleanup(pdev);\n\tpwc_free_buffers(pdev);\n\n\t/* Turn off LEDS and power down camera, but only when not unplugged */\n\tif (pdev->error_status != EPIPE) {\n\t\t/* Turn LEDs off */\n\t\tif (pwc_set_leds(pdev, 0, 0) < 0)\n\t\t\tPWC_DEBUG_MODULE(\"Failed to set LED on/off time.\\n\");\n\t\tif (power_save) {\n\t\t\ti = pwc_camera_power(pdev, 0);\n\t\t\tif (i < 0)\n\t\t\t\tPWC_ERROR(\"Failed to power down camera (%d)\\n\", i);\n\t\t}\n\t}\n\tpdev->vopen--;\n\tPWC_DEBUG_OPEN(\"<< video_close() vopen=%d\\n\", pdev->vopen);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "USB: fix DoS in pwc USB video driver\n\nthe pwc driver has a disconnect method that waits for user space to\nclose the device. This opens up an opportunity for a DoS attack,\nblocking the USB subsystem and making khubd's task busy wait in\nkernel space. This patch shifts freeing resources to close if an opened\ndevice is disconnected.\n\nSigned-off-by: Oliver Neukum <oneukum@suse.de>\nCC: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>"}
{"func": "static void usb_pwc_disconnect(struct usb_interface *intf)\n{\n\tstruct pwc_device *pdev;\n\tint hint;\n\n\tlock_kernel();\n\tpdev = usb_get_intfdata (intf);\n\tusb_set_intfdata (intf, NULL);\n\tif (pdev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() Called without private pointer.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() already called for %p\\n\", pdev);\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev != interface_to_usbdev(intf)) {\n\t\tPWC_ERROR(\"pwc_disconnect() Woops: pointer mismatch udev/pdev.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\n\t/* We got unplugged; this is signalled by an EPIPE error code */\n\tif (pdev->vopen) {\n\t\tPWC_INFO(\"Disconnected while webcam is in use!\\n\");\n\t\tpdev->error_status = EPIPE;\n\t}\n\n\t/* Alert waiting processes */\n\twake_up_interruptible(&pdev->frameq);\n\t/* Wait until device is closed */\n\twhile (pdev->vopen)\n\t\tschedule();\n\t/* Device is now closed, so we can safely unregister it */\n\tPWC_DEBUG_PROBE(\"Unregistering video device in disconnect().\\n\");\n\tpwc_remove_sysfs_files(pdev->vdev);\n\tvideo_unregister_device(pdev->vdev);\n\n\t/* Free memory (don't set pdev to 0 just yet) */\n\tkfree(pdev);\n\ndisconnect_out:\n\t/* search device_hint[] table if we occupy a slot, by any chance */\n\tfor (hint = 0; hint < MAX_DEV_HINTS; hint++)\n\t\tif (device_hint[hint].pdev == pdev)\n\t\t\tdevice_hint[hint].pdev = NULL;\n\n\tunlock_kernel();\n}", "target": 1, "cwe": ["CWE-399"], "message": "USB: fix DoS in pwc USB video driver\n\nthe pwc driver has a disconnect method that waits for user space to\nclose the device. This opens up an opportunity for a DoS attack,\nblocking the USB subsystem and making khubd's task busy wait in\nkernel space. This patch shifts freeing resources to close if an opened\ndevice is disconnected.\n\nSigned-off-by: Oliver Neukum <oneukum@suse.de>\nCC: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>"}
{"func": "static int return_EIO(void)\n{\n\treturn -EIO;\n}", "target": 1, "cwe": [], "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "void make_bad_inode(struct inode * inode) \n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}", "target": 1, "cwe": [], "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "int is_bad_inode(struct inode * inode) \n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}", "target": 1, "cwe": [], "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "void hash_preload(struct mm_struct *mm, unsigned long ea,\n\t\t  unsigned long access, unsigned long trap)\n{\n\tunsigned long vsid;\n\tvoid *pgdir;\n\tpte_t *ptep;\n\tcpumask_t mask;\n\tunsigned long flags;\n\tint local = 0;\n\n\t/* We don't want huge pages prefaulted for now\n\t */\n\tif (unlikely(in_hugepage_area(mm->context, ea)))\n\t\treturn;\n\n\tDBG_LOW(\"hash_preload(mm=%p, mm->pgdir=%p, ea=%016lx, access=%lx,\"\n\t\t\" trap=%lx\\n\", mm, mm->pgd, ea, access, trap);\n\n\t/* Get PTE, VSID, access mask */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn;\n\tptep = find_linux_pte(pgdir, ea);\n\tif (!ptep)\n\t\treturn;\n\tvsid = get_vsid(mm->context.id, ea);\n\n\t/* Hash it in */\n\tlocal_irq_save(flags);\n\tmask = cpumask_of_cpu(smp_processor_id());\n\tif (cpus_equal(mm->cpu_vm_mask, mask))\n\t\tlocal = 1;\n#ifndef CONFIG_PPC_64K_PAGES\n\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (mm->context.user_psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\tget_paca()->context = mm->context;\n\t\t\tslb_flush_and_rebolt();\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t}\n\tif (mm->context.user_psize == MMU_PAGE_64K)\n\t\t__hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\tlocal_irq_restore(flags);\n}", "target": 1, "cwe": ["CWE-200"], "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"}
{"func": "int hash_page(unsigned long ea, unsigned long access, unsigned long trap)\n{\n\tvoid *pgdir;\n\tunsigned long vsid;\n\tstruct mm_struct *mm;\n\tpte_t *ptep;\n\tcpumask_t tmp;\n\tint rc, user_region = 0, local = 0;\n\tint psize;\n\n\tDBG_LOW(\"hash_page(ea=%016lx, access=%lx, trap=%lx\\n\",\n\t\tea, access, trap);\n\n\tif ((ea & ~REGION_MASK) >= PGTABLE_RANGE) {\n\t\tDBG_LOW(\" out of pgtable range !\\n\");\n \t\treturn 1;\n\t}\n\n\t/* Get region & vsid */\n \tswitch (REGION_ID(ea)) {\n\tcase USER_REGION_ID:\n\t\tuser_region = 1;\n\t\tmm = current->mm;\n\t\tif (! mm) {\n\t\t\tDBG_LOW(\" user region with no mm !\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tvsid = get_vsid(mm->context.id, ea);\n\t\tpsize = mm->context.user_psize;\n\t\tbreak;\n\tcase VMALLOC_REGION_ID:\n\t\tmm = &init_mm;\n\t\tvsid = get_kernel_vsid(ea);\n\t\tif (ea < VMALLOC_END)\n\t\t\tpsize = mmu_vmalloc_psize;\n\t\telse\n\t\t\tpsize = mmu_io_psize;\n\t\tbreak;\n\tdefault:\n\t\t/* Not a valid range\n\t\t * Send the problem up to do_page_fault \n\t\t */\n\t\treturn 1;\n\t}\n\tDBG_LOW(\" mm=%p, mm->pgdir=%p, vsid=%016lx\\n\", mm, mm->pgd, vsid);\n\n\t/* Get pgdir */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn 1;\n\n\t/* Check CPU locality */\n\ttmp = cpumask_of_cpu(smp_processor_id());\n\tif (user_region && cpus_equal(mm->cpu_vm_mask, tmp))\n\t\tlocal = 1;\n\n\t/* Handle hugepage regions */\n\tif (unlikely(in_hugepage_area(mm->context, ea))) {\n\t\tDBG_LOW(\" -> huge page !\\n\");\n\t\treturn hash_huge_page(mm, access, ea, vsid, local, trap);\n\t}\n\n\t/* Get PTE and page size from page tables */\n\tptep = find_linux_pte(pgdir, ea);\n\tif (ptep == NULL || !pte_present(*ptep)) {\n\t\tDBG_LOW(\" no PTE !\\n\");\n\t\treturn 1;\n\t}\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" i-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" i-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\t/* Pre-check access permissions (will be re-checked atomically\n\t * in __hash_page_XX but this pre-check is a fast path\n\t */\n\tif (access & ~pte_val(*ptep)) {\n\t\tDBG_LOW(\" no access !\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Do actual hashing */\n#ifndef CONFIG_PPC_64K_PAGES\n\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tif (user_region) {\n\t\t\t\tpsize = MMU_PAGE_4K;\n\t\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\t} else if (ea < VMALLOC_END) {\n\t\t\t\t/*\n\t\t\t\t * some driver did a non-cacheable mapping\n\t\t\t\t * in vmalloc space, so switch vmalloc\n\t\t\t\t * to 4k pages\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ALERT \"Reducing vmalloc segment \"\n\t\t\t\t       \"to 4kB pages because of \"\n\t\t\t\t       \"non-cacheable mapping\\n\");\n\t\t\t\tpsize = mmu_vmalloc_psize = MMU_PAGE_4K;\n\t\t\t}\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t\tif (user_region) {\n\t\t\tif (psize != get_paca()->context.user_psize) {\n\t\t\t\tget_paca()->context = mm->context;\n\t\t\t\tslb_flush_and_rebolt();\n\t\t\t}\n\t\t} else if (get_paca()->vmalloc_sllp !=\n\t\t\t   mmu_psize_defs[mmu_vmalloc_psize].sllp) {\n\t\t\tget_paca()->vmalloc_sllp =\n\t\t\t\tmmu_psize_defs[mmu_vmalloc_psize].sllp;\n\t\t\tslb_flush_and_rebolt();\n\t\t}\n\t}\n\tif (psize == MMU_PAGE_64K)\n\t\trc = __hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" o-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" o-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\tDBG_LOW(\" -> rc=%d\\n\", rc);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"}
{"func": "int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->rssi;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t/* Update spy records */\n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t/* IW_WIRELESS_SPY */\n#endif\t\t\t\t/* CONFIG_WIRELESS_EXT */\n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t/* Top two-bits of byte 3 are the key index */\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t/* ieee->crypt[] is WEP_KEY (4) in length.  Given that keyidx\n\t\t * is only allowed 2-bits of storage, no value of keyidx can\n\t\t * be provided via above code that would result in keyidx\n\t\t * being out of range */\n\t\tcrypt = ieee->crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address (\"individual RA\"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=\" MAC_FMT \")\\n\",\n\t\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from \" MAC_FMT \"\\n\", dev->name,\n\t\t\t       MAC_ARG(hdr->addr2));\n\t\t\t/* TODO: could inform hostapd about this so that it\n\t\t\t * could send auth failure report */\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */\n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t/* Data frame - extract src/dst addresses */\n\tif (skb->len < IEEE80211_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev\n\t    && !compare_ether_addr(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n\tdev->last_rx = jiffies;\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the \"if\" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t/*ieee->ieee802_1x && */\n\t\t\t   ieee80211_is_eapol_frame(ieee, skb)) {\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=\" MAC_FMT\n\t\t\t\t\t     \")\\n\", MAC_ARG(hdr->addr2));\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb)) {\n\t\tIEEE80211_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from \" MAC_FMT\n\t\t\t\t     \" (drop_unencrypted=1)\\n\",\n\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\tgoto rx_dropped;\n\t}\n\n\t/* If the frame was decrypted in hardware, we may need to strip off\n\t * any security data (IV, ICV, etc) that was left behind */\n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t/* Top two-bits of byte 3 are the key index */\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t/* To strip off any security data which appears before the\n\t\t * payload, we simply increase hdrlen (as the header gets\n\t\t * chopped off immediately below). For the security data which\n\t\t * appears after the payload, we use skb_trim. */\n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t/* 4 byte IV */\n\t\t\thdrlen += 4;\n\t\t\t/* 4 byte ICV */\n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t/* 4 byte IV, 4 byte ExtIV */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC, 4 byte ICV */\n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t/* 8 byte CCMP header */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC */\n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possible reassembled) full plaintext payload */\n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t/* If IEEE 802.1X is used, check whether the port is authorized to send\n\t * the received frame. */\n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t/* Send IEEE 802.1X frames to the user\n\t\t\t\t * space daemon for processing */\n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t/* convert hdr + possible LLC headers into Ethernet header */\n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t/* remove RFC1042 or Bridge-Tunnel encapsulation and\n\t\t * replace EtherType */\n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\tu16 len;\n\t\t/* Leave Ethernet header part of hdr and full payload */\n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t/* Non-standard frame: get addr4 from its bogus location after\n\t\t * the payload */\n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t/* copy multicast frame both to the higher layers and\n\t\t\t * to the wireless media */\n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t/* send frame directly to the associated STA using\n\t\t\t * wireless media and not passing to higher layers */\n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t/* send to wireless media */\n\t\tskb2->dev = dev;\n\t\tskb2->protocol = __constant_htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t/* skb2->network_header += ETH_HLEN; */\n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t/* 802.11 crc not sufficient */\n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t/* netif_rx always succeeds, but it might drop\n\t\t\t * the packet.  If it drops the packet, we log that\n\t\t\t * in our stats. */\n\t\t\tIEEE80211_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tstats->rx_dropped++;\n\n\t/* Returning 0 indicates to caller that we have not handled the SKB--\n\t * so it is still allocated and can be used again by underlying\n\t * hardware as a DMA target */\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "[IEEE80211]: avoid integer underflow for runt rx frames\n\nReported by Chris Evans <scarybeasts@gmail.com>:\n\n> The summary is that an evil 80211 frame can crash out a victim's\n> machine. It only applies to drivers using the 80211 wireless code, and\n> only then to certain drivers (and even then depends on a card's\n> firmware not dropping a dubious packet). I must confess I'm not\n> keeping track of Linux wireless support, and the different protocol\n> stacks etc.\n>\n> Details are as follows:\n>\n> ieee80211_rx() does not explicitly check that \"skb->len >= hdrlen\".\n> There are other skb->len checks, but not enough to prevent a subtle\n> off-by-two error if the frame has the IEEE80211_STYPE_QOS_DATA flag\n> set.\n>\n> This leads to integer underflow and crash here:\n>\n> if (frag != 0)\n>    flen -= hdrlen;\n>\n> (flen is subsequently used as a memcpy length parameter).\n\nHow about this?\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int do_dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct dccp_sock *dp;\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tdp = dccp_sk(sk);\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_PACKET_SIZE:\n\t\tDCCP_WARN(\"sockopt(PACKET_SIZE) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_SERVICE:\n\t\treturn dccp_getsockopt_service(sk, len,\n\t\t\t\t\t       (__be32 __user *)optval, optlen);\n\tcase DCCP_SOCKOPT_SEND_CSCOV:\n\t\tval = dp->dccps_pcslen;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RECV_CSCOV:\n\t\tval = dp->dccps_pcrlen;\n\t\tbreak;\n\tcase 128 ... 191:\n\t\treturn ccid_hc_rx_getsockopt(dp->dccps_hc_rx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tcase 192 ... 255:\n\t\treturn ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "[DCCP] getsockopt: Fix DCCP_SOCKOPT_[SEND,RECV]_CSCOV\n\nWe were only checking if there was enough space to put the int, but\nleft len as specified by the (malicious) user, sigh, fix it by setting\nlen to sizeof(val) and transfering just one int worth of data, the one\nasked for.\n\nAlso check for negative len values.\n\nSigned-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "Incorporated changes from patch\njasper-1.900.3-libjasper-stepsizes-overflow.patch"}
{"func": "isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n\t\t\tp->dev->do_ioctl = isdn_ppp_dev_ioctl;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp->dev->do_ioctl = isdn_ciscohdlck_dev_ioctl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrcpy(lp->msn, cfg->eaz);\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 1, "cwe": ["CWE-119"], "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "isdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(n->num, phone->phone);\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 1, "cwe": ["CWE-119"], "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "isdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[32];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrcpy(nr, setup->phone);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = (isdn_net_local *) lp->master->priv;\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif ((isdn_net_local *) mlp->slave->priv == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = (isdn_net_local *) mlp->slave->priv;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tint ret = 0;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (elen <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((nfrags = skb_cow_data(skb, 0, &trailer)) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\tret = crypto_aead_decrypt(req);\n\tif (ret == -EINPROGRESS)\n\t\tgoto out;\n\n\tret = esp_input_done2(skb, ret);\n\nout:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-16"], "message": "[ESP]: Ensure IV is in linear part of the skb to avoid BUG() due to OOB access\n\nESP does not account for the IV size when calling pskb_may_pull() to\nensure everything it accesses directly is within the linear part of a\npotential fragment. This results in a BUG() being triggered when the\nboth the IPv4 and IPv6 ESP stack is fed with an skb where the first\nfragment ends between the end of the esp header and the end of the IV.\n\nThis bug was found by Dirk Nehring <dnehring@gmx.net> .\n\nSigned-off-by: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int esp_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\tint err = -EINVAL;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph)))\n\t\tgoto out;\n\n\tif (elen <= 0)\n\t\tgoto out;\n\n\tif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\terr = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\terr = crypto_aead_decrypt(req);\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = esp_input_done2(skb, err);\n\nout:\n\treturn err;\n}", "target": 1, "cwe": ["CWE-16"], "message": "[ESP]: Ensure IV is in linear part of the skb to avoid BUG() due to OOB access\n\nESP does not account for the IV size when calling pskb_may_pull() to\nensure everything it accesses directly is within the linear part of a\npotential fragment. This results in a BUG() being triggered when the\nboth the IPv4 and IPv6 ESP stack is fed with an skb where the first\nfragment ends between the end of the esp header and the end of the IV.\n\nThis bug was found by Dirk Nehring <dnehring@gmx.net> .\n\nSigned-off-by: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(inode);\n\tisdn_ctrl c;\n\tint drvidx;\n\tint chidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\t\tcase IIOCGETDVR:\n\t\t\t\treturn (TTY_DV +\n\t\t\t\t\t(NET_DV << 8) +\n\t\t\t\t\t(INF_DV << 16));\n\t\t\tcase IIOCGETCPS:\n\t\t\t\tif (arg) {\n\t\t\t\t\tulong __user *p = argp;\n\t\t\t\t\tint i;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, p,\n\t\t\t\t\t\t\tsizeof(ulong) * ISDN_MAX_CHANNELS * 2))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETGPN:\n\t\t\t\t/* Get peer phone number of a connected \n\t\t\t\t * isdn network interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tchidx = isdn_minor2chan(minor);\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefor, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\t\tcase IIOCNETDWRSET:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\t\treturn(-EINVAL);\n\t\t\tcase IIOCNETLCR:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\t\treturn -ENODEV;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETAIF:\n\t\t\t\t/* Add a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\ts = name;\n\t\t\t\t} else {\n\t\t\t\t\ts = NULL;\n\t\t\t\t}\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETASL:\n\t\t\t\t/* Add a slave to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETDIF:\n\t\t\t\t/* Delete a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETSCF:\n\t\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGCF:\n\t\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETANM:\n\t\t\t\t/* Add a phone-number to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGNM:\n\t\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDNM:\n\t\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDIL:\n\t\t\t\t/* Force dialing of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase IIOCNETALN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_dial_slave(name);\n\t\t\tcase IIOCNETDLN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\t\tcase IIOCNETHUP:\n\t\t\t\t/* Force hangup of a network-interface */\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_hangup(name);\n\t\t\t\tbreak;\n#endif                          /* CONFIG_NETDEVICES */\n\t\t\tcase IIOCSETVER:\n\t\t\t\tdev->net_verbose = arg;\n\t\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETGST:\n\t\t\t\tif (arg)\n\t\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\t\telse\n\t\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETBRJ:\n\t\t\t\tdrvidx = -1;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (iocts.arg)\n\t\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\t\telse\n\t\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSIGPRF:\n\t\t\t\tdev->profd = current;\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase IIOCGETPRF:\n\t\t\t\t/* Get all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t      ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETPRF:\n\t\t\t\t/* Set all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_READ, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t     ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETMAP:\n\t\t\tcase IIOCGETMAP:\n\t\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\t\tif (arg) {\n\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (!access_ok(VERIFY_READ, p, 1))\n\t\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\t\tsprintf(bname, \"%s%s\",\n\t\t\t\t\t\t\t\tstrlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t\tdev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t\t(i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCDBGVAR:\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tc.driver = drvidx;\n\t\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\t\tc.arg = cmd;\n\t\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\t\tret = isdn_command(&c);\n\t\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}", "target": 1, "cwe": ["CWE-119"], "message": "I4L: fix isdn_ioctl memory overrun vulnerability\n\nFix possible memory overrun issue in the isdn ioctl code.\n\nFound by ADLAB <adlab@venustech.com.cn>\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nCc: ADLAB <adlab@venustech.com.cn>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "shmem_alloc_page(gfp_t gfp,struct shmem_inode_info *info, unsigned long idx)\n{\n\treturn alloc_page(gfp | __GFP_ZERO);\n}", "target": 1, "cwe": ["CWE-200"], "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}", "target": 1, "cwe": ["CWE-200"], "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "shmem_alloc_page(gfp_t gfp, struct shmem_inode_info *info,\n\t\t unsigned long idx)\n{\n\tstruct vm_area_struct pvma;\n\tstruct page *page;\n\n\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\tpvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);\n\tpvma.vm_pgoff = idx;\n\tpvma.vm_end = PAGE_SIZE;\n\tpage = alloc_page_vma(gfp | __GFP_ZERO, &pvma, 0);\n\tmpol_free(pvma.vm_policy);\n\treturn page;\n}", "target": 1, "cwe": ["CWE-200"], "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "ProcShmCreatePixmap(client)\n    register ClientPtr client;\n{\n    PixmapPtr pMap;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    register int i, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixGetAttrAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n    \n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n\treturn BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n\tif (size < width * height)\n\t    return BadAlloc;\n\t/* thankfully, offset is unsigned */\n\tif (stuff->offset + size < size)\n\t    return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n    pMap = (*shmFuncs[pDraw->pScreen->myNum]->CreatePixmap)(\n\t\t\t    pDraw->pScreen, stuff->width,\n\t\t\t    stuff->height, stuff->depth,\n\t\t\t    shmdesc->addr + stuff->offset);\n    if (pMap)\n    {\n\trc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,\n\t\t      pMap, RT_NONE, NULL, DixCreateAccess);\n\tif (rc != Success) {\n\t    pDraw->pScreen->DestroyPixmap(pMap);\n\t    return rc;\n\t}\n\tdixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n\tshmdesc->refcnt++;\n\tpMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\tpMap->drawable.id = stuff->pid;\n\tif (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))\n\t{\n\t    return(client->noClientException);\n\t}\n\tpDraw->pScreen->DestroyPixmap(pMap);\n    }\n    return (BadAlloc);\n}", "target": 1, "cwe": ["CWE-189"], "message": "CVE-2007-6429: Always test for size+offset wrapping."}
{"func": "ProcPanoramiXShmCreatePixmap(\n    register ClientPtr client)\n{\n    ScreenPtr pScreen = NULL;\n    PixmapPtr pMap = NULL;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    int i, j, result, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n    PanoramiXRes *newPix;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixUnknownAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n\n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n        return BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n        if (size < width * height)\n            return BadAlloc;\n        /* thankfully, offset is unsigned */\n        if (stuff->offset + size < size)\n            return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n\n    if(!(newPix = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))\n\treturn BadAlloc;\n\n    newPix->type = XRT_PIXMAP;\n    newPix->u.pix.shared = TRUE;\n    newPix->info[0].id = stuff->pid;\n    for(j = 1; j < PanoramiXNumScreens; j++)\n\tnewPix->info[j].id = FakeClientID(client->index);\n\n    result = (client->noClientException);\n\n    FOR_NSCREENS(j) {\n\tpScreen = screenInfo.screens[j];\n\n\tpMap = (*shmFuncs[j]->CreatePixmap)(pScreen, \n\t\t\t\tstuff->width, stuff->height, stuff->depth,\n\t\t\t\tshmdesc->addr + stuff->offset);\n\n\tif (pMap) {\n\t    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n            shmdesc->refcnt++;\n\t    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\t    pMap->drawable.id = newPix->info[j].id;\n\t    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {\n\t\t(*pScreen->DestroyPixmap)(pMap);\n\t\tresult = BadAlloc;\n\t\tbreak;\n\t    }\n\t} else {\n\t   result = BadAlloc;\n\t   break;\n\t}\n    }\n\n    if(result == BadAlloc) {\n\twhile(j--) {\n\t    (*pScreen->DestroyPixmap)(pMap);\n\t    FreeResource(newPix->info[j].id, RT_NONE);\n\t}\n\txfree(newPix);\n    } else \n\tAddResource(stuff->pid, XRT_PIXMAP, newPix);\n\n    return result;\n}", "target": 1, "cwe": ["CWE-189"], "message": "CVE-2007-6429: Always test for size+offset wrapping."}
{"func": "static int copy_from_user_mmap_sem(void *dst, const void __user *src, size_t n)\n{\n\tint partial;\n\n\tpagefault_disable();\n\tpartial = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\t/*\n\t * Didn't copy everything, drop the mmap_sem and do a faulting copy\n\t */\n\tif (unlikely(partial)) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tpartial = copy_from_user(dst, src, n);\n\t\tdown_read(&current->mm->mmap_sem);\n\t}\n\n\treturn partial;\n}", "target": 1, "cwe": ["CWE-94"], "message": "splice: missing user pointer access verification\n\nvmsplice_to_user() must always check the user pointer and length\nwith access_ok() before copying. Likewise, for the slow path of\ncopy_from_user_mmap_sem() we need to check that we may read from\nthe user region.\n\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Wojciech Purczynski <cliph@research.coseinc.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long vmsplice_to_user(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct splice_desc sd;\n\tssize_t size;\n\tint error;\n\tlong ret;\n\n\tpipe = pipe_info(file->f_path.dentry->d_inode);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (pipe->inode)\n\t\tmutex_lock(&pipe->inode->i_mutex);\n\n\terror = ret = 0;\n\twhile (nr_segs) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Get user address base and length for this iovec.\n\t\t */\n\t\terror = get_user(base, &iov->iov_base);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = get_user(len, &iov->iov_len);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\tif (unlikely(!base)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsd.len = 0;\n\t\tsd.total_len = len;\n\t\tsd.flags = flags;\n\t\tsd.u.userptr = base;\n\t\tsd.pos = 0;\n\n\t\tsize = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tif (size < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = size;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tret += size;\n\n\t\tif (size < len)\n\t\t\tbreak;\n\n\t\tnr_segs--;\n\t\tiov++;\n\t}\n\n\tif (pipe->inode)\n\t\tmutex_unlock(&pipe->inode->i_mutex);\n\n\tif (!ret)\n\t\tret = error;\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-94"], "message": "splice: missing user pointer access verification\n\nvmsplice_to_user() must always check the user pointer and length\nwith access_ok() before copying. Likewise, for the slow path of\ncopy_from_user_mmap_sem() we need to check that we may read from\nthe user region.\n\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Wojciech Purczynski <cliph@research.coseinc.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\n\tdown_read(&current->mm->mmap_sem);\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tup_read(&current->mm->mmap_sem);\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}", "target": 1, "cwe": ["CWE-94"], "message": "splice: fix user pointer access in get_iovec_page_array()\n\nCommit 8811930dc74a503415b35c4a79d14fb0b408a361 (\"splice: missing user\npointer access verification\") added the proper access_ok() calls to\ncopy_from_user_mmap_sem() which ensures we can copy the struct iovecs\nfrom userspace to the kernel.\n\nBut we also must check whether we can access the actual memory region\npointed to by the struct iovec to fix the access checks properly.\n\nSigned-off-by: Bastian Blank <waldi@debian.org>\nAcked-by: Oliver Pinter <oliver.pntr@gmail.com>\nCc: Jens Axboe <jens.axboe@oracle.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Pekka Enberg <penberg@cs.helsinki.fi>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "CPU time limit patch / setrlimit(RLIMIT_CPU, 0) cheat fix\n\nAs discovered here today, the change in Kernel 2.6.17 intended to inhibit\nusers from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by\n\"cheating\" and setting it to 1 in such a case, does not make a difference,\nas the check is done in the wrong place (too late), and only applies to the\nprofiling code.\n\nOn all systems I checked running kernels above 2.6.17, no matter what the\nhard and soft CPU time limits were before, a user could escape them by\nissuing in the shell (sh/bash/zsh) \"ulimit -t 0\", and then the user's\nprocess was not ever killed.\n\nAttached is a trivial patch to fix that.  Simply moving the check to a\nslightly earlier location (specifically, before the line that actually\nassigns the limit - *old_rlim = new_rlim), does the trick.\n\nDo note that at least the zsh (but not ash, dash, or bash) shell has the\nproblem of \"caching\" the limits set by the ulimit command, so when running\nzsh the fix will not immediately be evident - after entering \"ulimit -t 0\",\n\"ulimit -a\" will show \"-t: cpu time (seconds) 0\", even though the actual\nlimit as returned by getrlimit(...) will be 1.  It can be verified by\nopening a subshell (which will not have the values of the parent shell in\ncache) and checking in it, or just by running a CPU intensive command like\n\"echo '65536^1048576' | bc\" and verifying that it dumps core after one\nsecond.\n\nRegardless of whether that is a misfeature in the shell, perhaps it would\nbe better to return -EINVAL from setrlimit in such a case instead of\ncheating and setting to 1, as that does not really reflect the actual state\nof the process anymore.  I do not however know what the ground for that\ndecision was in the original 2.6.17 change, and whether there would be any\n\"backward\" compatibility issues, so I preferred not to touch that right\nnow.\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct rt_sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr |= __put_user(usig, &frame->sig);\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t        regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up to return from userspace.  */\n\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is movl $,%ax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb8, (char __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_rt_sigreturn, (int __user *)(frame->retcode+1));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+5));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) usig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "int ia32_setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\tcompat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct exec_domain *ed = current_thread_info()->exec_domain;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* __copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu8 movl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t\tu8  pad2;\n\t} __attribute__((packed)) code = {\n\t\t0xb8,\n\t\t__NR_ia32_rt_sigreturn,\n\t\t0x80cd,\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user((ed && ed->signal_invmap && sig < 32\n\t\t\t   ? ed->signal_invmap[sig] : sig), &frame->sig);\n\terr |= __put_user(ptr_to_compat(&frame->info), &frame->pinfo);\n\terr |= __put_user(ptr_to_compat(&frame->uc), &frame->puc);\n\terr |= copy_siginfo_to_user32(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t\t     regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\telse\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t rt_sigreturn);\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * Not actually used anymore, but left because some gdb\n\t * versions need it.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct _fpstate __user *fp = NULL; \n\tint err = 0;\n\tstruct task_struct *me = current;\n\n\tif (used_math()) {\n\t\tfp = get_stack(ka, regs, sizeof(struct _fpstate)); \n\t\tframe = (void __user *)round_down(\n\t\t\t(unsigned long)fp - sizeof(struct rt_sigframe), 16) - 8;\n\n\t\tif (!access_ok(VERIFY_WRITE, fp, sizeof(struct _fpstate)))\n\t\t\tgoto give_sigsegv;\n\n\t\tif (save_i387(fp) < 0) \n\t\t\terr |= -1; \n\t} else\n\t\tframe = get_stack(ka, regs, sizeof(struct rt_sigframe)) - 8;\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_SIGINFO) { \n\t\terr |= copy_siginfo_to_user(&frame->info, info);\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\t\t\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(me->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(me->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0], me);\n\terr |= __put_user(fp, &frame->uc.uc_mcontext.fpstate);\n\tif (sizeof(*set) == 16) { \n\t\t__put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);\n\t\t__put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); \n\t} else\n\t\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\t   already in userspace.  */\n\t/* x86-64 should always use SA_RESTORER. */\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\t} else {\n\t\t/* could use a vstub here */\n\t\tgoto give_sigsegv; \n\t}\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n#ifdef DEBUG_SIG\n\tprintk(\"%d old ip %lx old sp %lx old ax %lx\\n\", current->pid,regs->ip,regs->sp,regs->ax);\n#endif\n\n\t/* Set up registers for signal handler */\n\tregs->di = sig;\n\t/* In case the signal handler was declared without prototypes */ \n\tregs->ax = 0;\n\n\t/* This also works for non SA_SIGINFO handlers because they expect the\n\t   next argument after the signal number on the stack. */\n\tregs->si = (unsigned long)&frame->info;\n\tregs->dx = (unsigned long)&frame->uc;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\tregs->sp = (unsigned long)frame;\n\n\t/* Set up the CS register to run signal handlers in 64-bit mode,\n\t   even if the handler happens to be interrupting 32-bit code. */\n\tregs->cs = __USER_CS;\n\n\t/* This, by contrast, has nothing to do with segment registers -\n\t   see include/asm-x86_64/uaccess.h for details. */\n\tset_fs(USER_DS);\n\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n#ifdef DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%lx ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static int setup_frame(int sig, struct k_sigaction *ka,\n\t\t       sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr = __put_user(usig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr = setup_sigcontext(&frame->sc, &frame->fpstate, regs, set->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_NSIG_WORDS > 1) {\n\t\terr = __copy_to_user(&frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (current->binfmt->hasvdso)\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);\n\telse\n\t\trestorer = &frame->retcode;\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\n\t/* Set up to return from userspace.  */\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is popl %eax ; movl $,%eax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb858, (short __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_sigreturn, (int __user *)(frame->retcode+2));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+6));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) sig;\n\tregs->dx = (unsigned long) 0;\n\tregs->cx = (unsigned long) 0;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "int ia32_setup_frame(int sig, struct k_sigaction *ka,\n\t\t     compat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct sigframe __user *frame;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu16 poplmovl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t} __attribute__((packed)) code = {\n\t\t0xb858,\t\t /* popl %eax ; movl $...,%eax */\n\t\t__NR_ia32_sigreturn,\n\t\t0x80cd,\t\t/* int $0x80 */\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user(sig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr |= ia32_setup_sigcontext(&frame->sc, &frame->fpstate, regs,\n\t\t\t\t\tset->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_COMPAT_NSIG_WORDS > 1) {\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\trestorer = ka->sa.sa_restorer;\n\t} else {\n\t\t/* Return stub is in 32bit vsyscall page */\n\t\tif (current->binfmt->hasvdso)\n\t\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t\t sigreturn);\n\t\telse\n\t\t\trestorer = &frame->retcode;\n\t}\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * These are actually not used anymore, but left because some\n\t * gdb versions depend on them as a marker.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = 0;\n\tregs->cx = 0;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask)\n\t\t\t/* Remove per bit from user psw. */\n\t\t\ttmp &= ~PSW_MASK_PER;\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp &= (unsigned long) FPC_VALID_MASK\n\t\t\t\t<< (BITS_PER_LONG - 32);\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}", "target": 1, "cwe": ["CWE-399"], "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif (tmp != PSW32_MASK_MERGE(psw32_user_bits, tmp))\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\ttask_pt_regs(child)->psw.mask =\n\t\t\t\tPSW_MASK_MERGE(psw_user32_bits, (__u64) tmp << 32);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\ttask_pt_regs(child)->psw.addr =\n\t\t\t\t(__u64) tmp & PSW32_ADDR_INSN;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &task_pt_regs(child)->psw\n\t\t\t\t  + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    (tmp & ~FPC_VALID_MASK) != 0)\n\t\t\t/* Invalid floating point control. */\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure.\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/*\n\t\t * This is magic. See per_struct and per_struct32.\n\t\t * By incident the offsets in per_struct are exactly\n\t\t * twice the offsets in per_struct32 for all fields.\n\t\t * The 8 byte fields need special handling though,\n\t\t * because the second half (bytes 4-7) is needed and\n\t\t * not the first half.\n\t\t */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\t*(__u32 *)((addr_t) &child->thread.per_info + offset) = tmp;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask &&\n#ifdef CONFIG_COMPAT\n\t\t    data != PSW_MASK_MERGE(psw_user32_bits, data) &&\n#endif\n\t\t    data != PSW_MASK_MERGE(psw_user_bits, data))\n\t\t\t/* Invalid psw mask. */\n\t\t\treturn -EINVAL;\n#ifndef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.psw.addr)\n\t\t\t/* I'd like to reject addresses without the\n\t\t\t   high order bit but older gdb's rely on it */\n\t\t\tdata |= PSW_ADDR_AMODE;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc &&\n\t\t    (data & ~((unsigned long) FPC_VALID_MASK\n\t\t\t      << (BITS_PER_LONG - 32))) != 0)\n\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure \n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\t*(addr_t *)((addr_t) &child->thread.per_info + offset) = data;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\taddr_t offset;\n\t__u32 tmp;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Fake a 31 bit psw mask. */\n\t\t\ttmp = (__u32)(task_pt_regs(child)->psw.mask >> 32);\n\t\t\ttmp = PSW32_MASK_MERGE(psw32_user_bits, tmp);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Fake a 31 bit psw address. */\n\t\t\ttmp = (__u32) task_pt_regs(child)->psw.addr |\n\t\t\t\tPSW32_ADDR_AMODE31;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\ttmp = *(__u32 *)((addr_t) &task_pt_regs(child)->psw +\n\t\t\t\t\t addr*2 + 4);\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\ttmp = *(__u32*)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/* This is magic. See per_struct and per_struct32. */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}", "target": 1, "cwe": ["CWE-399"], "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\n\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix dnotify/close race\n\nWe have a race between fcntl() and close() that can lead to\ndnotify_struct inserted into inode's list *after* the last descriptor\nhad been gone from current->files.\n\nSince that's the only point where dnotify_struct gets evicted, we are\nscrewed - it will stick around indefinitely.  Even after struct file in\nquestion is gone and freed.  Worse, we can trigger send_sigio() on it at\nany later point, which allows to send an arbitrary signal to arbitrary\nprocess if we manage to apply enough memory pressure to get the page\nthat used to host that struct file and fill it with the right pattern...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, timer->expires);\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\n\treturn orun;\n}", "target": 1, "cwe": ["CWE-189"], "message": "[PATCH] hrtimer: prevent overrun DoS in hrtimer_forward()\n\nhrtimer_forward() does not check for the possible overflow of\ntimer->expires.  This can happen on 64 bit machines with large interval\nvalues and results currently in an endless loop in the softirq because the\nexpiry value becomes negative and therefor the timer is expired all the\ntime.\n\nCheck for this condition and set the expiry value to the max.  expiry time\nin the future.  The fix should be applied to stable kernel series as well.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nAcked-by: Ingo Molnar <mingo@elte.hu>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix a crash with invalid embedded fonts"}
{"func": "m4_mkstemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  mkstemp_helper (obs, ARG (1));\n}", "target": 1, "cwe": [], "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "mkstemp_helper (struct obstack *obs, const char *name)\n{\n  int fd;\n  int len;\n  int i;\n\n  /* Guarantee that there are six trailing 'X' characters, even if the\n     user forgot to supply them.  */\n  len = strlen (name);\n  obstack_grow (obs, name, len);\n  for (i = 0; len > 0 && i < 6; i++)\n    if (name[--len] != 'X')\n      break;\n  for (; i < 6; i++)\n    obstack_1grow (obs, 'X');\n  obstack_1grow (obs, '\\0');\n\n  errno = 0;\n  fd = mkstemp ((char *) obstack_base (obs));\n  if (fd < 0)\n    {\n      M4ERROR ((0, errno, \"cannot create tempfile `%s'\", name));\n      obstack_free (obs, obstack_finish (obs));\n    }\n  else\n    close (fd);\n}", "target": 1, "cwe": [], "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "m4_maketemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  if (no_gnu_extensions)\n    {\n      /* POSIX states \"any trailing 'X' characters [are] replaced with\n\t the current process ID as a string\", without referencing the\n\t file system.  Horribly insecure, but we have to do it when we\n\t are in traditional mode.\n\n\t For reference, Solaris m4 does:\n\t   maketemp() -> `'\n\t   maketemp(X) -> `X'\n\t   maketemp(XX) -> `Xn', where n is last digit of pid\n\t   maketemp(XXXXXXXX) -> `X00nnnnn', where nnnnn is 16-bit pid\n      */\n      const char *str = ARG (1);\n      int len = strlen (str);\n      int i;\n      int len2;\n\n      M4ERROR ((warning_status, 0, \"recommend using mkstemp instead\"));\n      for (i = len; i > 1; i--)\n\tif (str[i - 1] != 'X')\n\t  break;\n      obstack_grow (obs, str, i);\n      str = ntoa ((int32_t) getpid (), 10);\n      len2 = strlen (str);\n      if (len2 > len - i)\n\tobstack_grow0 (obs, str + len2 - (len - i), len - i);\n      else\n\t{\n\t  while (i++ < len - len2)\n\t    obstack_1grow (obs, '0');\n\t  obstack_grow0 (obs, str, len2);\n\t}\n    }\n  else\n    mkstemp_helper (obs, ARG (1));\n}", "target": 1, "cwe": [], "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "produce_frozen_state (const char *name)\n{\n  FILE *file;\n  int h;\n  symbol *sym;\n  const builtin *bp;\n\n  if (file = fopen (name, O_BINARY ? \"wb\" : \"w\"), !file)\n    {\n      M4ERROR ((warning_status, errno, name));\n      return;\n    }\n\n  /* Write a recognizable header.  */\n\n  xfprintf (file, \"# This is a frozen state file generated by %s\\n\",\n\t   PACKAGE_STRING);\n  xfprintf (file, \"V1\\n\");\n\n  /* Dump quote delimiters.  */\n\n  if (strcmp (lquote.string, DEF_LQUOTE) || strcmp (rquote.string, DEF_RQUOTE))\n    {\n      xfprintf (file, \"Q%d,%d\\n\", (int) lquote.length, (int) rquote.length);\n      fputs (lquote.string, file);\n      fputs (rquote.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump comment delimiters.  */\n\n  if (strcmp (bcomm.string, DEF_BCOMM) || strcmp (ecomm.string, DEF_ECOMM))\n    {\n      xfprintf (file, \"C%d,%d\\n\", (int) bcomm.length, (int) ecomm.length);\n      fputs (bcomm.string, file);\n      fputs (ecomm.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump all symbols.  */\n\n  for (h = 0; h < hash_table_size; h++)\n    {\n\n      /* Process all entries in one bucket, from the last to the first.\n\t This order ensures that, at reload time, pushdef's will be\n\t executed with the oldest definitions first.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n      for (sym = symtab[h]; sym; sym = SYMBOL_NEXT (sym))\n\t{\n\t  switch (SYMBOL_TYPE (sym))\n\t    {\n\t    case TOKEN_TEXT:\n\t      xfprintf (file, \"T%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (SYMBOL_TEXT (sym)));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (SYMBOL_TEXT (sym), file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_FUNC:\n\t      bp = find_builtin_by_addr (SYMBOL_FUNC (sym));\n\t      if (bp == NULL)\n\t\t{\n\t\t  M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: builtin not found in builtin table!\"));\n\t\t  abort ();\n\t\t}\n\t      xfprintf (file, \"F%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (bp->name));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (bp->name, file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_VOID:\n\t      /* Ignore placeholder tokens that exist due to traceon.  */\n\t      break;\n\n\t    default:\n\t      M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: bad token data type in freeze_one_symbol ()\"));\n\t      abort ();\n\t      break;\n\t    }\n\t}\n\n      /* Reverse the bucket once more, putting it back as it was.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n    }\n\n  /* Let diversions be issued from output.c module, its cleaner to have this\n     piece of code there.  */\n\n  freeze_diversions (file);\n\n  /* All done.  */\n\n  fputs (\"# End of frozen state file\\n\", file);\n  if (close_stream (file) != 0)\n    M4ERROR ((EXIT_FAILURE, errno, \"unable to create frozen state\"));\n}", "target": 1, "cwe": [], "message": "Security fix: avoid arbitrary code execution with 'm4 -F'.\n\n* src/freeze.c (produce_frozen_state): Never pass raw file name as\nprintf format.\n* NEWS: Document this fix.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit 031a71a80442ed2ad3c2ee14d5811c786a12c51b)"}
{"func": "static unsigned char asn1_oid_decode(struct asn1_ctx *ctx,\n\t\t\t\t     unsigned char *eoc,\n\t\t\t\t     unsigned long **oid,\n\t\t\t\t     unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int  size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(\"OOM in bsalg (%d)\\n\", __LINE__);\n\t\treturn 0;\n\t}\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr [0] = 0;\n\t\toptr [1] = subid;\n\t} else if (subid < 80) {\n\t\toptr [0] = 1;\n\t\toptr [1] = subid - 40;\n\t} else {\n\t\toptr [0] = 2;\n\t\toptr [1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_oid_decode(struct asn1_ctx *ctx,\n\t\tunsigned char *eoc, unsigned long **oid, unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL)\n\t\treturn 0;\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr[0] = 0;\n\t\toptr[1] = subid;\n\t} else if (subid < 80) {\n\t\toptr[0] = 1;\n\t\toptr[1] = subid - 40;\n\t} else {\n\t\toptr[0] = 2;\n\t\toptr[1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_header_decode(struct asn1_ctx *ctx,\n\t\t   unsigned char **eoc,\n\t\t   unsigned int *cls, unsigned int *con, unsigned int *tag)\n{\n\tunsigned int def = 0;\n\tunsigned int len = 0;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned char asn1_header_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned char **eoc,\n\t\t\t\t\tunsigned int *cls,\n\t\t\t\t\tunsigned int *con,\n\t\t\t\t\tunsigned int *tag)\n{\n\tunsigned int def, len;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tdef = len = 0;\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned char asn1_length_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned int *def,\n\t\t\t\t\tunsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = ch & 0x7F;\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = (unsigned char) (ch & 0x7F);\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "sit: Add missing kfree_skb() on pskb_may_pull() failure.\n\nNoticed by Paul Marks <paul@pmarks.net>.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tslice *= se->load.weight;\n\tdo_div(slice, cfs_rq->load.weight);\n\n\treturn slice;\n}", "target": 1, "cwe": [], "message": "sched: simplify sched_slice()\n\nUse the existing calc_delta_mine() calculation for sched_slice(). This\nsaves a divide and simplifies the code because we share it with the\nother /cfs_rq->load users.\n\nIt also improves code size:\n\n      text    data     bss     dec     hex filename\n     42659    2740     144   45543    b1e7 sched.o.before\n     42093    2740     144   44977    afb1 sched.o.after\n\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>"}
{"func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn __sched_vslice(cfs_rq->load.weight + se->load.weight,\n\t\t\tcfs_rq->nr_running + 1);\n}", "target": 1, "cwe": [], "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 __sched_vslice(unsigned long rq_weight, unsigned long nr_running)\n{\n\tu64 vslice = __sched_period(nr_running);\n\n\tvslice *= NICE_0_LOAD;\n\tdo_div(vslice, rq_weight);\n\n\treturn vslice;\n}", "target": 1, "cwe": [], "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn calc_delta_mine(__sched_period(cfs_rq->nr_running),\n\t\t\t       se->load.weight, &cfs_rq->load);\n}", "target": 1, "cwe": [], "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tunsigned long nr_running = cfs_rq->nr_running;\n\tunsigned long weight;\n\tu64 vslice;\n\n\tif (!se->on_rq)\n\t\tnr_running++;\n\n\tvslice = __sched_period(nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tweight = cfs_rq->load.weight;\n\t\tif (!se->on_rq)\n\t\t\tweight += se->load.weight;\n\n\t\tvslice *= NICE_0_LOAD;\n\t\tdo_div(vslice, weight);\n\t}\n\n\treturn vslice;\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static unsigned long wakeup_gran(struct sched_entity *se)\n{\n\tunsigned long gran = sysctl_sched_wakeup_granularity;\n\n\t/*\n\t * More easily preempt - nice tasks, while not making\n\t * it harder for + nice tasks.\n\t */\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\n\treturn gran;\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tslice *= se->load.weight;\n\t\tdo_div(slice, cfs_rq->load.weight);\n\t}\n\n\n\treturn slice;\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "calc_delta_fair(unsigned long delta_exec, struct load_weight *lw)\n{\n\treturn calc_delta_mine(delta_exec, NICE_0_LOAD, lw);\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)\n{\n\tu64 vruntime;\n\n\tif (first_fair(cfs_rq)) {\n\t\tvruntime = min_vruntime(cfs_rq->min_vruntime,\n\t\t\t\t__pick_next_entity(cfs_rq)->vruntime);\n\t} else\n\t\tvruntime = cfs_rq->min_vruntime;\n\n\t/*\n\t * The 'current' period is already promised to the current tasks,\n\t * however the extra weight of the new task will slow them down a\n\t * little, place the new task so that it fits in the slot that\n\t * stays open at the end.\n\t */\n\tif (initial && sched_feat(START_DEBIT))\n\t\tvruntime += sched_vslice_add(cfs_rq, se);\n\n\tif (!initial) {\n\t\t/* sleeps upto a single latency don't count. */\n\t\tif (sched_feat(NEW_FAIR_SLEEPERS)) {\n\t\t\tif (sched_feat(NORMALIZED_SLEEPER))\n\t\t\t\tvruntime -= calc_delta_fair(sysctl_sched_latency,\n\t\t\t\t\t\t&cfs_rq->load);\n\t\t\telse\n\t\t\t\tvruntime -= sysctl_sched_latency;\n\t\t}\n\n\t\t/* ensure we never gain time by being placed backwards. */\n\t\tvruntime = max_vruntime(se->vruntime, vruntime);\n\t}\n\n\tse->vruntime = vruntime;\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,\n\t      unsigned long delta_exec)\n{\n\tunsigned long delta_exec_weighted;\n\n\tschedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq, exec_clock, delta_exec);\n\tdelta_exec_weighted = delta_exec;\n\tif (unlikely(curr->load.weight != NICE_0_LOAD)) {\n\t\tdelta_exec_weighted = calc_delta_fair(delta_exec_weighted,\n\t\t\t\t\t\t\t&curr->load);\n\t}\n\tcurr->vruntime += delta_exec_weighted;\n}", "target": 1, "cwe": [], "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      if ((int)pad > (int)ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix broken debug check for GNUTLS-SA-2008-1."}
{"func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = -ENOENT;\n\t\t/* Use PageReserved to check for zero page */\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int do_move_pages(struct mm_struct *mm, struct page_to_node *pm,\n\t\t\t\tint migrate_all)\n{\n\tint err;\n\tstruct page_to_node *pp;\n\tLIST_HEAD(pagelist);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Build a list of pages to migrate\n\t */\n\tmigrate_prep();\n\tfor (pp = pm; pp->node != MAX_NUMNODES; pp++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * A valid page pointer that will not match any of the\n\t\t * pages that will be moved.\n\t\t */\n\t\tpp->page = ZERO_PAGE(0);\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pp->addr);\n\t\tif (!vma || !vma_migratable(vma))\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pp->addr, FOLL_GET);\n\t\terr = -ENOENT;\n\t\tif (!page)\n\t\t\tgoto set_status;\n\n\t\tif (PageReserved(page))\t\t/* Check for zero page */\n\t\t\tgoto put_and_set;\n\n\t\tpp->page = page;\n\t\terr = page_to_nid(page);\n\n\t\tif (err == pp->node)\n\t\t\t/*\n\t\t\t * Node already in the right place\n\t\t\t */\n\t\t\tgoto put_and_set;\n\n\t\terr = -EACCES;\n\t\tif (page_mapcount(page) > 1 &&\n\t\t\t\t!migrate_all)\n\t\t\tgoto put_and_set;\n\n\t\terr = isolate_lru_page(page, &pagelist);\nput_and_set:\n\t\t/*\n\t\t * Either remove the duplicate refcount from\n\t\t * isolate_lru_page() or drop the page ref if it was\n\t\t * not isolated.\n\t\t */\n\t\tput_page(page);\nset_status:\n\t\tpp->status = err;\n\t}\n\n\tif (!list_empty(&pagelist))\n\t\terr = migrate_pages(&pagelist, new_page_node,\n\t\t\t\t(unsigned long)pm);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void dump_one_vdso_page(struct page *pg, struct page *upg)\n{\n\tprintk(\"kpg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(pg) << PAGE_SHIFT),\n\t       page_count(pg),\n\t       pg->flags);\n\tif (upg/* && pg != upg*/) {\n\t\tprintk(\" upg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(upg)\n\t\t\t\t\t\t       << PAGE_SHIFT),\n\t\t       page_count(upg),\n\t\t       upg->flags);\n\t}\n\tprintk(\"\\n\");\n}", "target": 1, "cwe": ["CWE-20"], "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\tunsigned int flags)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpage = follow_huge_addr(mm, address, flags & FOLL_WRITE);\n\tif (!IS_ERR(page)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tgoto out;\n\t}\n\n\tpage = NULL;\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto no_page_table;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto no_page_table;\n\t\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none(*pmd))\n\t\tgoto no_page_table;\n\n\tif (pmd_huge(*pmd)) {\n\t\tBUG_ON(flags & FOLL_GET);\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags & FOLL_WRITE);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(pmd_bad(*pmd)))\n\t\tgoto no_page_table;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!ptep)\n\t\tgoto out;\n\n\tpte = *ptep;\n\tif (!pte_present(pte))\n\t\tgoto unlock;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte))\n\t\tgoto unlock;\n\tpage = vm_normal_page(vma, address, pte);\n\tif (unlikely(!page))\n\t\tgoto unlock;\n\n\tif (flags & FOLL_GET)\n\t\tget_page(page);\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\tmark_page_accessed(page);\n\t}\nunlock:\n\tpte_unmap_unlock(ptep, ptl);\nout:\n\treturn page;\n\nno_page_table:\n\t/*\n\t * When core dumping an enormous anonymous area that nobody\n\t * has touched so far, we don't want to allocate page tables.\n\t */\n\tif (flags & FOLL_ANON) {\n\t\tpage = ZERO_PAGE(0);\n\t\tif (flags & FOLL_GET)\n\t\t\tget_page(page);\n\t\tBUG_ON(flags & FOLL_WRITE);\n\t}\n\treturn page;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn i ? i : PTR_ERR(page);\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix ZERO_PAGE breakage with vmware\n\nCommit 89f5b7da2a6bad2e84670422ab8192382a5aeb9f (\"Reinstate ZERO_PAGE\noptimization in 'get_user_pages()' and fix XIP\") broke vmware, as\nreported by Jeff Chua:\n\n  \"This broke vmware 6.0.4.\n   Jun 22 14:53:03.845: vmx| NOT_IMPLEMENTED\n   /build/mts/release/bora-93057/bora/vmx/main/vmmonPosix.c:774\"\n\nand the reason seems to be that there's an old bug in how we handle do\nFOLL_ANON on VM_SHARED areas in get_user_pages(), but since it only\ntriggered if the whole page table was missing, nobody had apparently hit\nit before.\n\nThe recent changes to 'follow_page()' made the FOLL_ANON logic trigger\nnot just for whole missing page tables, but for individual pages as\nwell, and exposed this problem.\n\nThis fixes it by making the test for when FOLL_ANON is used more\ncareful, and also makes the code easier to read and understand by moving\nthe logic to a separate inline function.\n\nReported-and-tested-by: Jeff Chua <jeff.chua.linux@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-269"], "message": "check privileges before setting mount propagation\n\nThere's a missing check for CAP_SYS_ADMIN in do_change_type().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int udp_get_port(struct sock *sk, unsigned short snum,\n\t\t\tint (*scmp)(const struct sock *, const struct sock *))\n{\n\treturn  __udp_lib_get_port(sk, snum, udp_hash, &udp_port_rover, scmp);\n}", "target": 1, "cwe": [], "message": "[UDP]: Randomize port selection.\n\nThis patch causes UDP port allocation to be randomized like TCP.\nThe earlier code would always choose same port (ie first empty list).\n\nSigned-off-by: Stephen Hemminger <shemminger@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int udplite_get_port(struct sock *sk, unsigned short p,\n\t\t     int (*c)(const struct sock *, const struct sock *))\n{\n\treturn  __udp_lib_get_port(sk, p, udplite_hash, &udplite_port_rover, c);\n}", "target": 1, "cwe": [], "message": "[UDP]: Randomize port selection.\n\nThis patch causes UDP port allocation to be randomized like TCP.\nThe earlier code would always choose same port (ie first empty list).\n\nSigned-off-by: Stephen Hemminger <shemminger@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int __udp_lib_get_port(struct sock *sk, unsigned short snum,\n\t\t       struct hlist_head udptable[], int *port_rover,\n\t\t       int (*saddr_comp)(const struct sock *sk1,\n\t\t\t\t\t const struct sock *sk2 )    )\n{\n\tstruct hlist_node *node;\n\tstruct hlist_head *head;\n\tstruct sock *sk2;\n\tint    error = 1;\n\n\twrite_lock_bh(&udp_hash_lock);\n\tif (snum == 0) {\n\t\tint best_size_so_far, best, result, i;\n\n\t\tif (*port_rover > sysctl_local_port_range[1] ||\n\t\t    *port_rover < sysctl_local_port_range[0])\n\t\t\t*port_rover = sysctl_local_port_range[0];\n\t\tbest_size_so_far = 32767;\n\t\tbest = result = *port_rover;\n\t\tfor (i = 0; i < UDP_HTABLE_SIZE; i++, result++) {\n\t\t\tint size;\n\n\t\t\thead = &udptable[result & (UDP_HTABLE_SIZE - 1)];\n\t\t\tif (hlist_empty(head)) {\n\t\t\t\tif (result > sysctl_local_port_range[1])\n\t\t\t\t\tresult = sysctl_local_port_range[0] +\n\t\t\t\t\t\t((result - sysctl_local_port_range[0]) &\n\t\t\t\t\t\t (UDP_HTABLE_SIZE - 1));\n\t\t\t\tgoto gotit;\n\t\t\t}\n\t\t\tsize = 0;\n\t\t\tsk_for_each(sk2, node, head) {\n\t\t\t\tif (++size >= best_size_so_far)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbest_size_so_far = size;\n\t\t\tbest = result;\n\t\tnext:\n\t\t\t;\n\t\t}\n\t\tresult = best;\n\t\tfor (i = 0; i < (1 << 16) / UDP_HTABLE_SIZE;\n\t\t     i++, result += UDP_HTABLE_SIZE) {\n\t\t\tif (result > sysctl_local_port_range[1])\n\t\t\t\tresult = sysctl_local_port_range[0]\n\t\t\t\t\t+ ((result - sysctl_local_port_range[0]) &\n\t\t\t\t\t   (UDP_HTABLE_SIZE - 1));\n\t\t\tif (! __udp_lib_lport_inuse(result, udptable))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= (1 << 16) / UDP_HTABLE_SIZE)\n\t\t\tgoto fail;\ngotit:\n\t\t*port_rover = snum = result;\n\t} else {\n\t\thead = &udptable[snum & (UDP_HTABLE_SIZE - 1)];\n\n\t\tsk_for_each(sk2, node, head)\n\t\t\tif (sk2->sk_hash == snum                             &&\n\t\t\t    sk2 != sk                                        &&\n\t\t\t    (!sk2->sk_reuse        || !sk->sk_reuse)         &&\n\t\t\t    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if\n\t\t\t     || sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&\n\t\t\t    (*saddr_comp)(sk, sk2)                             )\n\t\t\t\tgoto fail;\n\t}\n\tinet_sk(sk)->num = snum;\n\tsk->sk_hash = snum;\n\tif (sk_unhashed(sk)) {\n\t\thead = &udptable[snum & (UDP_HTABLE_SIZE - 1)];\n\t\tsk_add_node(sk, head);\n\t\tsock_prot_inc_use(sk->sk_prot);\n\t}\n\terror = 0;\nfail:\n\twrite_unlock_bh(&udp_hash_lock);\n\treturn error;\n}", "target": 1, "cwe": [], "message": "[UDP]: Randomize port selection.\n\nThis patch causes UDP port allocation to be randomized like TCP.\nThe earlier code would always choose same port (ie first empty list).\n\nSigned-off-by: Stephen Hemminger <shemminger@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline int __udp_lib_lport_inuse(__u16 num, struct hlist_head udptable[])\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\n\tsk_for_each(sk, node, &udptable[num & (UDP_HTABLE_SIZE - 1)])\n\t\tif (sk->sk_hash == num)\n\t\t\treturn 1;\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "[UDP]: Randomize port selection.\n\nThis patch causes UDP port allocation to be randomized like TCP.\nThe earlier code would always choose same port (ie first empty list).\n\nSigned-off-by: Stephen Hemminger <shemminger@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "x86: fix ldt limit for 64 bit\n\nFix size of LDT entries. On x86-64, ldt_desc is a double-sized descriptor.\n\nSigned-off-by: Michael Karcher <kernel@mkarcher.dialup.fu-berlin.de>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "shmem_get_inode(struct super_block *sb, int mode, dev_t dev)\n{\n\tstruct inode *inode;\n\tstruct shmem_inode_info *info;\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\n\tif (shmem_reserve_inode(sb))\n\t\treturn NULL;\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current->fsuid;\n\t\tinode->i_gid = current->fsgid;\n\t\tinode->i_blocks = 0;\n\t\tinode->i_mapping->a_ops = &shmem_aops;\n\t\tinode->i_mapping->backing_dev_info = &shmem_backing_dev_info;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_generation = get_seconds();\n\t\tinfo = SHMEM_I(inode);\n\t\tmemset(info, 0, (char *)inode - (char *)info);\n\t\tspin_lock_init(&info->lock);\n\t\tINIT_LIST_HEAD(&info->swaplist);\n\n\t\tswitch (mode & S_IFMT) {\n\t\tdefault:\n\t\t\tinode->i_op = &shmem_special_inode_operations;\n\t\t\tinit_special_inode(inode, mode, dev);\n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_op = &shmem_inode_operations;\n\t\t\tinode->i_fop = &shmem_file_operations;\n\t\t\tmpol_shared_policy_init(&info->policy,\n\t\t\t\t\t\t shmem_get_sbmpol(sbinfo));\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tinc_nlink(inode);\n\t\t\t/* Some things misbehave if size == 0 on a directory */\n\t\t\tinode->i_size = 2 * BOGO_DIRENT_SIZE;\n\t\t\tinode->i_op = &shmem_dir_inode_operations;\n\t\t\tinode->i_fop = &simple_dir_operations;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\t/*\n\t\t\t * Must not load anything in the rbtree,\n\t\t\t * mpol_free_shared_policy will not be called.\n\t\t\t */\n\t\t\tmpol_shared_policy_init(&info->policy, NULL);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tshmem_free_inode(sb);\n\treturn inode;\n}", "target": 1, "cwe": ["CWE-400"], "message": "tmpfs: fix kernel BUG in shmem_delete_inode\n\nSuSE's insserve initscript ordering program hits kernel BUG at mm/shmem.c:814\non 2.6.26.  It's using posix_fadvise on directories, and the shmem_readpage\nmethod added in 2.6.23 is letting POSIX_FADV_WILLNEED allocate useless pages\nto a tmpfs directory, incrementing i_blocks count but never decrementing it.\n\nFix this by assigning shmem_aops (pointing to readpage and writepage and\nset_page_dirty) only when it's needed, on a regular file or a long symlink.\n\nMany thanks to Kel for outstanding bugreport and steps to reproduce it.\n\nReported-by: Kel Modderman <kel@otaku42.de>\nTested-by: Kel Modderman <kel@otaku42.de>\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nCc: <stable@kernel.org>\t\t[2.6.25.x, 2.6.26.x]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int shmem_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tint error;\n\tint len;\n\tstruct inode *inode;\n\tstruct page *page = NULL;\n\tchar *kaddr;\n\tstruct shmem_inode_info *info;\n\n\tlen = strlen(symname) + 1;\n\tif (len > PAGE_CACHE_SIZE)\n\t\treturn -ENAMETOOLONG;\n\n\tinode = shmem_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\terror = security_inode_init_security(inode, dir, NULL, NULL,\n\t\t\t\t\t     NULL);\n\tif (error) {\n\t\tif (error != -EOPNOTSUPP) {\n\t\t\tiput(inode);\n\t\t\treturn error;\n\t\t}\n\t\terror = 0;\n\t}\n\n\tinfo = SHMEM_I(inode);\n\tinode->i_size = len-1;\n\tif (len <= (char *)inode - (char *)info) {\n\t\t/* do it inline */\n\t\tmemcpy(info, symname, len);\n\t\tinode->i_op = &shmem_symlink_inline_operations;\n\t} else {\n\t\terror = shmem_getpage(inode, 0, &page, SGP_WRITE, NULL);\n\t\tif (error) {\n\t\t\tiput(inode);\n\t\t\treturn error;\n\t\t}\n\t\tunlock_page(page);\n\t\tinode->i_op = &shmem_symlink_inode_operations;\n\t\tkaddr = kmap_atomic(page, KM_USER0);\n\t\tmemcpy(kaddr, symname, len);\n\t\tkunmap_atomic(kaddr, KM_USER0);\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (dir->i_mode & S_ISGID)\n\t\tinode->i_gid = dir->i_gid;\n\tdir->i_size += BOGO_DIRENT_SIZE;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-400"], "message": "tmpfs: fix kernel BUG in shmem_delete_inode\n\nSuSE's insserve initscript ordering program hits kernel BUG at mm/shmem.c:814\non 2.6.26.  It's using posix_fadvise on directories, and the shmem_readpage\nmethod added in 2.6.23 is letting POSIX_FADV_WILLNEED allocate useless pages\nto a tmpfs directory, incrementing i_blocks count but never decrementing it.\n\nFix this by assigning shmem_aops (pointing to readpage and writepage and\nset_page_dirty) only when it's needed, on a regular file or a long symlink.\n\nMany thanks to Kel for outstanding bugreport and steps to reproduce it.\n\nReported-by: Kel Modderman <kel@otaku42.de>\nTested-by: Kel Modderman <kel@otaku42.de>\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nCc: <stable@kernel.org>\t\t[2.6.25.x, 2.6.26.x]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments (without overruning the iovec).\n\t\t */\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1, "cwe": ["CWE-193"], "message": "Fix off-by-one error in iov_iter_advance()\n\nThe iov_iter_advance() function would look at the iov->iov_len entry\neven though it might have iterated over the whole array, and iov was\npointing past the end.  This would cause DEBUG_PAGEALLOC to trigger a\nkernel page fault if the allocation was at the end of a page, and the\nnext page was unallocated.\n\nThe quick fix is to just change the order of the tests: check that there\nis any iovec data left before we check the iov entry itself.\n\nThanks to Alexey Dobriyan for finding this case, and testing the fix.\n\nReported-and-tested-by: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Nick Piggin <npiggin@suse.de>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: <stable@kernel.org> [2.6.25.x, 2.6.26.x]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void __cpuinit cpu_init (void)\n{\n\tint cpu = stack_smp_processor_id();\n\tstruct tss_struct *t = &per_cpu(init_tss, cpu);\n\tstruct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);\n\tunsigned long v; \n\tchar *estacks = NULL; \n\tstruct task_struct *me;\n\tint i;\n\n\t/* CPU 0 is initialised in head64.c */\n\tif (cpu != 0) {\n\t\tpda_init(cpu);\n\t\tzap_low_mappings(cpu);\n\t} else \n\t\testacks = boot_exception_stacks; \n\n\tme = current;\n\n\tif (cpu_test_and_set(cpu, cpu_initialized))\n\t\tpanic(\"CPU#%d already initialized!\\n\", cpu);\n\n\tprintk(\"Initializing CPU#%d\\n\", cpu);\n\n\tclear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);\n\n\t/*\n\t * Initialize the per-CPU GDT with the boot GDT,\n\t * and set up the GDT descriptor:\n\t */\n\tif (cpu)\n \t\tmemcpy(cpu_gdt(cpu), cpu_gdt_table, GDT_SIZE);\n\n\tcpu_gdt_descr[cpu].size = GDT_SIZE;\n\tasm volatile(\"lgdt %0\" :: \"m\" (cpu_gdt_descr[cpu]));\n\tasm volatile(\"lidt %0\" :: \"m\" (idt_descr));\n\n\tmemset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);\n\tsyscall_init();\n\n\twrmsrl(MSR_FS_BASE, 0);\n\twrmsrl(MSR_KERNEL_GS_BASE, 0);\n\tbarrier(); \n\n\tcheck_efer();\n\n\t/*\n\t * set up and load the per-CPU TSS\n\t */\n\tfor (v = 0; v < N_EXCEPTION_STACKS; v++) {\n\t\tstatic const unsigned int order[N_EXCEPTION_STACKS] = {\n\t\t\t[0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,\n\t\t\t[DEBUG_STACK - 1] = DEBUG_STACK_ORDER\n\t\t};\n\t\tif (cpu) {\n\t\t\testacks = (char *)__get_free_pages(GFP_ATOMIC, order[v]);\n\t\t\tif (!estacks)\n\t\t\t\tpanic(\"Cannot allocate exception stack %ld %d\\n\",\n\t\t\t\t      v, cpu); \n\t\t}\n\t\testacks += PAGE_SIZE << order[v];\n\t\torig_ist->ist[v] = t->ist[v] = (unsigned long)estacks;\n\t}\n\n\tt->io_bitmap_base = offsetof(struct tss_struct, io_bitmap);\n\t/*\n\t * <= is required because the CPU will access up to\n\t * 8 bits beyond the end of the IO permission bitmap.\n\t */\n\tfor (i = 0; i <= IO_BITMAP_LONGS; i++)\n\t\tt->io_bitmap[i] = ~0UL;\n\n\tatomic_inc(&init_mm.mm_count);\n\tme->active_mm = &init_mm;\n\tif (me->mm)\n\t\tBUG();\n\tenter_lazy_tlb(&init_mm, me);\n\n\tset_tss_desc(cpu, t);\n\tload_TR_desc();\n\tload_LDT(&init_mm.context);\n\n\t/*\n\t * Clear all 6 debug registers:\n\t */\n\n\tset_debugreg(0UL, 0);\n\tset_debugreg(0UL, 1);\n\tset_debugreg(0UL, 2);\n\tset_debugreg(0UL, 3);\n\tset_debugreg(0UL, 6);\n\tset_debugreg(0UL, 7);\n\n\tfpu_init(); \n}", "target": 1, "cwe": [], "message": "[PATCH] Don't leak NT bit into next task\n\nSYSENTER can cause a NT to be set which might cause crashes on the IRET\nin the next task.\n\nFollowing similar i386 patch from Linus.\n\nSigned-off-by: Andi Kleen <ak@suse.de>"}
{"func": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\n\tmutex_lock(&dir->i_mutex);\n\t/*\n\t * First re-do the cached lookup just in case it was created\n\t * while we waited for the directory semaphore..\n\t *\n\t * FIXME! This could use version numbering or similar to\n\t * avoid unnecessary cache lookups.\n\t *\n\t * The \"dcache_lock\" is purely to protect the RCU list walker\n\t * from concurrent renames at this point (we mustn't get false\n\t * negatives from the RCU list walk here, unlike the optimistic\n\t * fast walk).\n\t *\n\t * so doing d_lookup() (with seqlock), instead of lockfree __d_lookup\n\t */\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Uhhuh! Nasty case: the cache was re-populated while\n\t * we waited on the semaphore. Need to revalidate.\n\t */\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1, "cwe": ["CWE-120"], "message": "[patch] vfs: fix lookup on deleted directory\n\nLookup can install a child dentry for a deleted directory.  This keeps\nthe directory dentry alive, and the inode pinned in the cache and on\ndisk, even after all external references have gone away.\n\nThis isn't a big problem normally, since memory pressure or umount\nwill clear out the directory dentry and its children, releasing the\ninode.  But for UBIFS this causes problems because its orphan area can\noverflow.\n\nFix this by returning ENOENT for all lookups on a S_DEAD directory\nbefore creating a child dentry.\n\nThanks to Zoltan Sogor for noticing this while testing UBIFS, and\nArtem for the excellent analysis of the problem and testing.\n\nReported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nTested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"}
{"func": "static struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = base->d_inode;\n\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tdentry = cached_lookup(base, name, nd);\n\tif (!dentry) {\n\t\tstruct dentry *new = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}", "target": 1, "cwe": ["CWE-120"], "message": "[patch] vfs: fix lookup on deleted directory\n\nLookup can install a child dentry for a deleted directory.  This keeps\nthe directory dentry alive, and the inode pinned in the cache and on\ndisk, even after all external references have gone away.\n\nThis isn't a big problem normally, since memory pressure or umount\nwill clear out the directory dentry and its children, releasing the\ninode.  But for UBIFS this causes problems because its orphan area can\noverflow.\n\nFix this by returning ENOENT for all lookups on a S_DEAD directory\nbefore creating a child dentry.\n\nThanks to Zoltan Sogor for noticing this while testing UBIFS, and\nArtem for the excellent analysis of the problem and testing.\n\nReported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nTested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>"}
{"func": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "sound: ensure device number is valid in snd_seq_oss_synth_make_info\n\nsnd_seq_oss_synth_make_info() incorrectly reports information\nto userspace without first checking for the validity of the\ndevice number, leading to possible information leak (CVE-2008-3272).\n\nReported-By: Tobias Klein <tk@trapkit.de>\nAcked-and-tested-by: Takashi Iwai <tiwai@suse.de>\nCc: stable@kernel.org\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void file_add_remove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tint diff = REV_TREE_DIFFERENT;\n\n\t/*\n\t * Is it an add of a new file? It means that the old tree\n\t * didn't have it at all, so we will turn \"REV_TREE_SAME\" ->\n\t * \"REV_TREE_NEW\", but leave any \"REV_TREE_DIFFERENT\" alone\n\t * (and if it already was \"REV_TREE_NEW\", we'll keep it\n\t * \"REV_TREE_NEW\" of course).\n\t */\n\tif (addremove == '+') {\n\t\tdiff = tree_difference;\n\t\tif (diff != REV_TREE_SAME)\n\t\t\treturn;\n\t\tdiff = REV_TREE_NEW;\n\t}\n\ttree_difference = diff;\n\tif (tree_difference == REV_TREE_DIFFERENT)\n\t\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static int show_modified(struct oneway_unpack_data *cbdata,\n\t\t\t struct cache_entry *old,\n\t\t\t struct cache_entry *new,\n\t\t\t int report_missing,\n\t\t\t int cached, int match_missing)\n{\n\tunsigned int mode, oldmode;\n\tconst unsigned char *sha1;\n\tstruct rev_info *revs = cbdata->revs;\n\n\tif (get_stat_data(new, &sha1, &mode, cached, match_missing, cbdata) < 0) {\n\t\tif (report_missing)\n\t\t\tdiff_index_show_file(revs, \"-\", old,\n\t\t\t\t\t     old->sha1, old->ce_mode);\n\t\treturn -1;\n\t}\n\n\tif (revs->combine_merges && !cached &&\n\t    (hashcmp(sha1, old->sha1) || hashcmp(old->sha1, new->sha1))) {\n\t\tstruct combine_diff_path *p;\n\t\tint pathlen = ce_namelen(new);\n\n\t\tp = xmalloc(combine_diff_path_size(2, pathlen));\n\t\tp->path = (char *) &p->parent[2];\n\t\tp->next = NULL;\n\t\tp->len = pathlen;\n\t\tmemcpy(p->path, new->name, pathlen);\n\t\tp->path[pathlen] = 0;\n\t\tp->mode = mode;\n\t\thashclr(p->sha1);\n\t\tmemset(p->parent, 0, 2 * sizeof(struct combine_diff_parent));\n\t\tp->parent[0].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[0].mode = new->ce_mode;\n\t\thashcpy(p->parent[0].sha1, new->sha1);\n\t\tp->parent[1].status = DIFF_STATUS_MODIFIED;\n\t\tp->parent[1].mode = old->ce_mode;\n\t\thashcpy(p->parent[1].sha1, old->sha1);\n\t\tshow_combined_diff(p, 2, revs->dense_combined_merges, revs);\n\t\tfree(p);\n\t\treturn 0;\n\t}\n\n\toldmode = old->ce_mode;\n\tif (mode == oldmode && !hashcmp(sha1, old->sha1) &&\n\t    !DIFF_OPT_TST(&revs->diffopt, FIND_COPIES_HARDER))\n\t\treturn 0;\n\n\tdiff_change(&revs->diffopt, oldmode, mode,\n\t\t    old->sha1, sha1, old->name, NULL);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static int compare_tree_entry(struct tree_desc *t1, struct tree_desc *t2, const char *base, int baselen, struct diff_options *opt)\n{\n\tunsigned mode1, mode2;\n\tconst char *path1, *path2;\n\tconst unsigned char *sha1, *sha2;\n\tint cmp, pathlen1, pathlen2;\n\n\tsha1 = tree_entry_extract(t1, &path1, &mode1);\n\tsha2 = tree_entry_extract(t2, &path2, &mode2);\n\n\tpathlen1 = tree_entry_len(path1, sha1);\n\tpathlen2 = tree_entry_len(path2, sha2);\n\tcmp = base_name_compare(path1, pathlen1, mode1, path2, pathlen2, mode2);\n\tif (cmp < 0) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\treturn -1;\n\t}\n\tif (cmp > 0) {\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 1;\n\t}\n\tif (!DIFF_OPT_TST(opt, FIND_COPIES_HARDER) && !hashcmp(sha1, sha2) && mode1 == mode2)\n\t\treturn 0;\n\n\t/*\n\t * If the filemode has changed to/from a directory from/to a regular\n\t * file, we need to consider it a remove and an add.\n\t */\n\tif (S_ISDIR(mode1) != S_ISDIR(mode2)) {\n\t\tshow_entry(opt, \"-\", t1, base, baselen);\n\t\tshow_entry(opt, \"+\", t2, base, baselen);\n\t\treturn 0;\n\t}\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode1)) {\n\t\tint retval;\n\t\tchar *newbase = malloc_base(base, baselen, path1, pathlen1);\n\t\tif (DIFF_OPT_TST(opt, TREE_IN_RECURSIVE))\n\t\t\topt->change(opt, mode1, mode2,\n\t\t\t\t    sha1, sha2, base, path1);\n\t\tretval = diff_tree_sha1(sha1, sha2, newbase, opt);\n\t\tfree(newbase);\n\t\treturn retval;\n\t}\n\n\topt->change(opt, mode1, mode2, sha1, sha2, base, path1);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static void diff_index_show_file(struct rev_info *revs,\n\t\t\t\t const char *prefix,\n\t\t\t\t struct cache_entry *ce,\n\t\t\t\t const unsigned char *sha1, unsigned int mode)\n{\n\tdiff_addremove(&revs->diffopt, prefix[0], mode,\n\t\t       sha1, ce->name, NULL);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "void diff_addremove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(mode))\n\t\treturn;\n\n\t/* This may look odd, but it is a preparation for\n\t * feeding \"there are unchanged files which should\n\t * not produce diffs, but when you are doing copy\n\t * detection you would need them, so here they are\"\n\t * entries to the diff-core.  They will be prefixed\n\t * with something like '=' or '*' (I haven't decided\n\t * which but should not make any difference).\n\t * Feeding the same new and old to diff_change()\n\t * also has the same effect.\n\t * Before the final output happens, they are pruned after\n\t * merged into rename/copy pairs as appropriate.\n\t */\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF))\n\t\taddremove = (addremove == '+' ? '-' :\n\t\t\t     addremove == '-' ? '+' : addremove);\n\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\n\tif (addremove != '+')\n\t\tfill_filespec(one, sha1, mode);\n\tif (addremove != '-')\n\t\tfill_filespec(two, sha1, mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,\n\t\t       const char *base, int baselen)\n{\n\tunsigned mode;\n\tconst char *path;\n\tconst unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {\n\t\tenum object_type type;\n\t\tint pathlen = tree_entry_len(path, sha1);\n\t\tchar *newbase = malloc_base(base, baselen, path, pathlen);\n\t\tstruct tree_desc inner;\n\t\tvoid *tree;\n\t\tunsigned long size;\n\n\t\ttree = read_sha1_file(sha1, &type, &size);\n\t\tif (!tree || type != OBJ_TREE)\n\t\t\tdie(\"corrupt tree sha %s\", sha1_to_hex(sha1));\n\n\t\tinit_tree_desc(&inner, tree, size);\n\t\tshow_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);\n\n\t\tfree(tree);\n\t\tfree(newbase);\n\t} else {\n\t\topt->add_remove(opt, prefix[0], mode, sha1, base, path);\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "int run_diff_files(struct rev_info *revs, unsigned int option)\n{\n\tint entries, i;\n\tint diff_unmerged_stage = revs->max_count;\n\tint silent_on_removed = option & DIFF_SILENT_ON_REMOVED;\n\tunsigned ce_option = ((option & DIFF_RACY_IS_MODIFIED)\n\t\t\t      ? CE_MATCH_RACY_IS_DIRTY : 0);\n\tchar symcache[PATH_MAX];\n\n\tif (diff_unmerged_stage < 0)\n\t\tdiff_unmerged_stage = 2;\n\tentries = active_nr;\n\tsymcache[0] = '\\0';\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct stat st;\n\t\tunsigned int oldmode, newmode;\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tint changed;\n\n\t\tif (DIFF_OPT_TST(&revs->diffopt, QUIET) &&\n\t\t\tDIFF_OPT_TST(&revs->diffopt, HAS_CHANGES))\n\t\t\tbreak;\n\n\t\tif (!ce_path_match(ce, revs->prune_data))\n\t\t\tcontinue;\n\n\t\tif (ce_stage(ce)) {\n\t\t\tstruct combine_diff_path *dpath;\n\t\t\tint num_compare_stages = 0;\n\t\t\tsize_t path_len;\n\n\t\t\tpath_len = ce_namelen(ce);\n\n\t\t\tdpath = xmalloc(combine_diff_path_size(5, path_len));\n\t\t\tdpath->path = (char *) &(dpath->parent[5]);\n\n\t\t\tdpath->next = NULL;\n\t\t\tdpath->len = path_len;\n\t\t\tmemcpy(dpath->path, ce->name, path_len);\n\t\t\tdpath->path[path_len] = '\\0';\n\t\t\thashclr(dpath->sha1);\n\t\t\tmemset(&(dpath->parent[0]), 0,\n\t\t\t       sizeof(struct combine_diff_parent)*5);\n\n\t\t\tchanged = check_removed(ce, &st);\n\t\t\tif (!changed)\n\t\t\t\tdpath->mode = ce_mode_from_stat(ce, st.st_mode);\n\t\t\telse {\n\t\t\t\tif (changed < 0) {\n\t\t\t\t\tperror(ce->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (silent_on_removed)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (i < entries) {\n\t\t\t\tstruct cache_entry *nce = active_cache[i];\n\t\t\t\tint stage;\n\n\t\t\t\tif (strcmp(ce->name, nce->name))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Stage #2 (ours) is the first parent,\n\t\t\t\t * stage #3 (theirs) is the second.\n\t\t\t\t */\n\t\t\t\tstage = ce_stage(nce);\n\t\t\t\tif (2 <= stage) {\n\t\t\t\t\tint mode = nce->ce_mode;\n\t\t\t\t\tnum_compare_stages++;\n\t\t\t\t\thashcpy(dpath->parent[stage-2].sha1, nce->sha1);\n\t\t\t\t\tdpath->parent[stage-2].mode = ce_mode_from_stat(nce, mode);\n\t\t\t\t\tdpath->parent[stage-2].status =\n\t\t\t\t\t\tDIFF_STATUS_MODIFIED;\n\t\t\t\t}\n\n\t\t\t\t/* diff against the proper unmerged stage */\n\t\t\t\tif (stage == diff_unmerged_stage)\n\t\t\t\t\tce = nce;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Compensate for loop update\n\t\t\t */\n\t\t\ti--;\n\n\t\t\tif (revs->combine_merges && num_compare_stages == 2) {\n\t\t\t\tshow_combined_diff(dpath, 2,\n\t\t\t\t\t\t   revs->dense_combined_merges,\n\t\t\t\t\t\t   revs);\n\t\t\t\tfree(dpath);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(dpath);\n\t\t\tdpath = NULL;\n\n\t\t\t/*\n\t\t\t * Show the diff for the 'ce' if we found the one\n\t\t\t * from the desired stage.\n\t\t\t */\n\t\t\tdiff_unmerge(&revs->diffopt, ce->name, 0, null_sha1);\n\t\t\tif (ce_stage(ce) != diff_unmerged_stage)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (ce_uptodate(ce))\n\t\t\tcontinue;\n\n\t\tchanged = check_removed(ce, &st);\n\t\tif (changed) {\n\t\t\tif (changed < 0) {\n\t\t\t\tperror(ce->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (silent_on_removed)\n\t\t\t\tcontinue;\n\t\t\tdiff_addremove(&revs->diffopt, '-', ce->ce_mode,\n\t\t\t\t       ce->sha1, ce->name, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tchanged = ce_match_stat(ce, &st, ce_option);\n\t\tif (!changed) {\n\t\t\tce_mark_uptodate(ce);\n\t\t\tif (!DIFF_OPT_TST(&revs->diffopt, FIND_COPIES_HARDER))\n\t\t\t\tcontinue;\n\t\t}\n\t\toldmode = ce->ce_mode;\n\t\tnewmode = ce_mode_from_stat(ce, st.st_mode);\n\t\tdiff_change(&revs->diffopt, oldmode, newmode,\n\t\t\t    ce->sha1, (changed ? null_sha1 : ce->sha1),\n\t\t\t    ce->name, NULL);\n\n\t}\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix buffer overflow in git diff\n\nIf PATH_MAX on your system is smaller than a path stored, it may cause\nbuffer overflow and stack corruption in diff_addremove() and diff_change()\nfunctions when running git-diff\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tchar pathbuf[PATH_MAX];\n\n\t/*\n\t * At the bottom of the attribute stack is the built-in\n\t * set of attribute definitions.  Then, contents from\n\t * .gitattribute files from directories closer to the\n\t * root to the ones in deeper directories are pushed\n\t * to the stack.  Finally, at the very top of the stack\n\t * we always keep the contents of $GIT_DIR/info/attributes.\n\t *\n\t * When checking, we use entries from near the top of the\n\t * stack, preferring $GIT_DIR/info/attributes, then\n\t * .gitattributes in deeper directories to shallower ones,\n\t * and finally use the built-in set as the default.\n\t */\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\n\t/*\n\t * Pop the \"info\" one that is always at the top of the stack.\n\t */\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\n\t/*\n\t * Pop the ones from directories that are not the prefix of\n\t * the path we are checking.\n\t */\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\n\t/*\n\t * Read from parent directories and push them down\n\t */\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tmemcpy(pathbuf, path, dirlen);\n\t\t\tmemcpy(pathbuf + dirlen, \"/\", 2);\n\t\t\tcp = strchr(pathbuf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\n\t/*\n\t * Finally push the \"info\" one at the top of the stack.\n\t */\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 1, "cwe": [], "message": "Fix buffer overflow in prepare_attr_stack\n\nIf PATH_MAX on your system is smaller than a path stored in the git repo,\nit may cause the buffer overflow in prepare_attr_stack.\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static int grep_tree(struct grep_opt *opt, const char **paths,\n\t\t     struct tree_desc *tree,\n\t\t     const char *tree_name, const char *base)\n{\n\tint len;\n\tint hit = 0;\n\tstruct name_entry entry;\n\tchar *down;\n\tint tn_len = strlen(tree_name);\n\tchar *path_buf = xmalloc(PATH_MAX + tn_len + 100);\n\n\tif (tn_len) {\n\t\ttn_len = sprintf(path_buf, \"%s:\", tree_name);\n\t\tdown = path_buf + tn_len;\n\t\tstrcat(down, base);\n\t}\n\telse {\n\t\tdown = path_buf;\n\t\tstrcpy(down, base);\n\t}\n\tlen = strlen(path_buf);\n\n\twhile (tree_entry(tree, &entry)) {\n\t\tstrcpy(path_buf + len, entry.path);\n\n\t\tif (S_ISDIR(entry.mode))\n\t\t\t/* Match \"abc/\" against pathspec to\n\t\t\t * decide if we want to descend into \"abc\"\n\t\t\t * directory.\n\t\t\t */\n\t\t\tstrcpy(path_buf + len + tree_entry_len(entry.path, entry.sha1), \"/\");\n\n\t\tif (!pathspec_matches(paths, down))\n\t\t\t;\n\t\telse if (S_ISREG(entry.mode))\n\t\t\thit |= grep_sha1(opt, entry.sha1, path_buf, tn_len);\n\t\telse if (S_ISDIR(entry.mode)) {\n\t\t\tenum object_type type;\n\t\t\tstruct tree_desc sub;\n\t\t\tvoid *data;\n\t\t\tunsigned long size;\n\n\t\t\tdata = read_sha1_file(entry.sha1, &type, &size);\n\t\t\tif (!data)\n\t\t\t\tdie(\"unable to read tree (%s)\",\n\t\t\t\t    sha1_to_hex(entry.sha1));\n\t\t\tinit_tree_desc(&sub, data, size);\n\t\t\thit |= grep_tree(opt, paths, &sub, tree_name, down);\n\t\t\tfree(data);\n\t\t}\n\t}\n\treturn hit;\n}", "target": 1, "cwe": [], "message": "Fix buffer overflow in git-grep\n\nIf PATH_MAX on your system is smaller than any path stored in the git\nrepository, that can cause memory corruption inside of the grep_tree\nfunction used by git-grep.\n\nSigned-off-by: Dmitry Potapov <dpotapov@gmail.com>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>"}
{"func": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\n\nout:\n\treturn rc;\n\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-189"], "message": "dccp: change L/R must have at least one byte in the dccpsf_val field\n    \nThanks to Eugene Teo for reporting this problem.\n    \nSigned-off-by: Eugene Teo <eugenete@kernel.sg>\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>\nSigned-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authchunk val;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (val.sauth_chunk) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\tcase SCTP_CID_AUTH:\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* add this chunk id to the endpoint */\n\treturn sctp_auth_ep_add_chunkid(sctp_sk(sk)->ep, val.sauth_chunk);\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_del_key_id(sctp_sk(sk)->ep, asoc,\n\t\t\t\t    val.scact_keynumber);\n\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks;\n\tchar __user *to;\n\n\tif (len <= sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tch = (struct sctp_chunks_param*)asoc->c.auth_chunks;\n\telse\n\t\tch = sctp_sk(sk)->ep->auth_chunk_list;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tlen = num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to, ch->chunks, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_hmac_algo_param *auth_hmacs = NULL;\n\tstruct sctp_chunks_param *auth_chunks = NULL;\n\tstruct sctp_shared_key *null_key;\n\tint err;\n\n\tmemset(ep, 0, sizeof(struct sctp_endpoint));\n\n\tep->digest = kzalloc(SCTP_SIGNATURE_SIZE, gfp);\n\tif (!ep->digest)\n\t\treturn NULL;\n\n\tif (sctp_auth_enable) {\n\t\t/* Allocate space for HMACS and CHUNKS authentication\n\t\t * variables.  There are arrays that we encode directly\n\t\t * into parameters to make the rest of the operations easier.\n\t\t */\n\t\tauth_hmacs = kzalloc(sizeof(sctp_hmac_algo_param_t) +\n\t\t\t\tsizeof(__u16) * SCTP_AUTH_NUM_HMACS, gfp);\n\t\tif (!auth_hmacs)\n\t\t\tgoto nomem;\n\n\t\tauth_chunks = kzalloc(sizeof(sctp_chunks_param_t) +\n\t\t\t\t\tSCTP_NUM_CHUNK_TYPES, gfp);\n\t\tif (!auth_chunks)\n\t\t\tgoto nomem;\n\n\t\t/* Initialize the HMACS parameter.\n\t\t * SCTP-AUTH: Section 3.3\n\t\t *    Every endpoint supporting SCTP chunk authentication MUST\n\t\t *    support the HMAC based on the SHA-1 algorithm.\n\t\t */\n\t\tauth_hmacs->param_hdr.type = SCTP_PARAM_HMAC_ALGO;\n\t\tauth_hmacs->param_hdr.length =\n\t\t\t\t\thtons(sizeof(sctp_paramhdr_t) + 2);\n\t\tauth_hmacs->hmac_ids[0] = htons(SCTP_AUTH_HMAC_ID_SHA1);\n\n\t\t/* Initialize the CHUNKS parameter */\n\t\tauth_chunks->param_hdr.type = SCTP_PARAM_CHUNKS;\n\n\t\t/* If the Add-IP functionality is enabled, we must\n\t\t * authenticate, ASCONF and ASCONF-ACK chunks\n\t\t */\n\t\tif (sctp_addip_enable) {\n\t\t\tauth_chunks->chunks[0] = SCTP_CID_ASCONF;\n\t\t\tauth_chunks->chunks[1] = SCTP_CID_ASCONF_ACK;\n\t\t\tauth_chunks->param_hdr.length =\n\t\t\t\t\thtons(sizeof(sctp_paramhdr_t) + 2);\n\t\t}\n\t}\n\n\t/* Initialize the base structure. */\n\t/* What type of endpoint are we?  */\n\tep->base.type = SCTP_EP_TYPE_SOCKET;\n\n\t/* Initialize the basic object fields. */\n\tatomic_set(&ep->base.refcnt, 1);\n\tep->base.dead = 0;\n\tep->base.malloced = 1;\n\n\t/* Create an input queue.  */\n\tsctp_inq_init(&ep->base.inqueue);\n\n\t/* Set its top-half handler */\n\tsctp_inq_set_th_handler(&ep->base.inqueue, sctp_endpoint_bh_rcv);\n\n\t/* Initialize the bind addr area */\n\tsctp_bind_addr_init(&ep->base.bind_addr, 0);\n\n\t/* Remember who we are attached to.  */\n\tep->base.sk = sk;\n\tsock_hold(ep->base.sk);\n\n\t/* Create the lists of associations.  */\n\tINIT_LIST_HEAD(&ep->asocs);\n\n\t/* Use SCTP specific send buffer space queues.  */\n\tep->sndbuf_policy = sctp_sndbuf_policy;\n\n\tsk->sk_write_space = sctp_write_space;\n\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t/* Get the receive buffer policy for this endpoint */\n\tep->rcvbuf_policy = sctp_rcvbuf_policy;\n\n\t/* Initialize the secret key used with cookie. */\n\tget_random_bytes(&ep->secret_key[0], SCTP_SECRET_SIZE);\n\tep->last_key = ep->current_key = 0;\n\tep->key_changed_at = jiffies;\n\n\t/* SCTP-AUTH extensions*/\n\tINIT_LIST_HEAD(&ep->endpoint_shared_keys);\n\tnull_key = sctp_auth_shkey_create(0, GFP_KERNEL);\n\tif (!null_key)\n\t\tgoto nomem;\n\n\tlist_add(&null_key->key_list, &ep->endpoint_shared_keys);\n\n\t/* Allocate and initialize transorms arrays for suported HMACs. */\n\terr = sctp_auth_init_hmacs(ep, gfp);\n\tif (err)\n\t\tgoto nomem_hmacs;\n\n\t/* Add the null key to the endpoint shared keys list and\n\t * set the hmcas and chunks pointers.\n\t */\n\tep->auth_hmacs_list = auth_hmacs;\n\tep->auth_chunk_list = auth_chunks;\n\n\treturn ep;\n\nnomem_hmacs:\n\tsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\nnomem:\n\t/* Free all allocations */\n\tkfree(auth_hmacs);\n\tkfree(auth_chunks);\n\tkfree(ep->digest);\n\treturn NULL;\n\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_hmacalgo *hmacs;\n\tint err;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = kmalloc(optlen, GFP_KERNEL);\n\tif (!hmacs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(hmacs, optval, optlen)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hmacs->shmac_num_idents == 0 ||\n\t    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tval.scact_keynumber = asoc->active_key_id;\n\telse\n\t\tval.scact_keynumber = sctp_sk(sk)->ep->active_key_id;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 param_len;\n\n\thmacs = sctp_sk(sk)->ep->auth_hmacs_list;\n\tparam_len = ntohs(hmacs->param_hdr.length);\n\n\tif (len < param_len)\n\t\treturn -EINVAL;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, hmacs->hmac_ids, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_set_active_key(sctp_sk(sk)->ep, asoc,\n\t\t\t\t\tval.scact_keynumber);\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks;\n\tchar __user *to;\n\n\tif (len <= sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, p, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tch = asoc->peer.peer_chunks;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tlen = num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\tif (copy_to_user(to, ch->chunks, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "sctp: fix potential panics in the SCTP-AUTH API.\n\nAll of the SCTP-AUTH socket options could cause a panic\nif the extension is disabled and the API is envoked.\n\nAdditionally, there were some additional assumptions that\ncertain pointers would always be valid which may not\nalways be the case.\n\nThis patch hardens the API and address all of the crash\nscenarios.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-189"], "message": "sctp: add verification checks to SCTP_AUTH_KEY option\n\nThe structure used for SCTP_AUTH_KEY option contains a\nlength that needs to be verfied to prevent buffer overflow\nconditions.  Spoted by Eugene Teo <eteo@redhat.com>.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t/* Allocate the shared key */\n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\tatomic_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}", "target": 1, "cwe": ["CWE-189"], "message": "sctp: add verification checks to SCTP_AUTH_KEY option\n\nThe structure used for SCTP_AUTH_KEY option contains a\nlength that needs to be verfied to prevent buffer overflow\nconditions.  Spoted by Eugene Teo <eteo@redhat.com>.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (authkey->sca_keylength > optlen) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-189"], "message": "sctp: correct bounds check in sctp_setsockopt_auth_key\n\nThe bonds check to prevent buffer overlflow was not exactly\nright.  It still allowed overflow of up to 8 bytes which is\nsizeof(struct sctp_authkey).\n\nSince optlen is already checked against the size of that struct,\nwe are guaranteed not to cause interger overflow either.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int __init sysenter_setup(void)\n{\n\tsyscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\n\n#ifdef CONFIG_COMPAT_VDSO\n\t__set_fixmap(FIX_VDSO, __pa(syscall_page), PAGE_READONLY);\n\tprintk(\"Compat vDSO mapped to %08lx.\\n\", __fix_to_virt(FIX_VDSO));\n#endif\n\n\tif (!boot_cpu_has(X86_FEATURE_SEP)) {\n\t\tmemcpy(syscall_page,\n\t\t       &vsyscall_int80_start,\n\t\t       &vsyscall_int80_end - &vsyscall_int80_start);\n\t\treturn 0;\n\t}\n\n\tmemcpy(syscall_page,\n\t       &vsyscall_sysenter_start,\n\t       &vsyscall_sysenter_end - &vsyscall_sysenter_start);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] i386 vDSO: use install_special_mapping\n\nThis patch uses install_special_mapping for the i386 vDSO setup, consolidating\nduplicated code.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Andi Kleen <ak@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void syscall_vma_close(struct vm_area_struct *vma)\n{\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] i386 vDSO: use install_special_mapping\n\nThis patch uses install_special_mapping for the i386 vDSO setup, consolidating\nduplicated code.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Andi Kleen <ak@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static struct page *syscall_nopage(struct vm_area_struct *vma,\n\t\t\t\tunsigned long adr, int *type)\n{\n\tstruct page *p = virt_to_page(adr - vma->vm_start + syscall_page);\n\tget_page(p);\n\treturn p;\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] i386 vDSO: use install_special_mapping\n\nThis patch uses install_special_mapping for the i386 vDSO setup, consolidating\nduplicated code.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Andi Kleen <ak@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int arch_setup_additional_pages(struct linux_binprm *bprm, int exstack)\n{\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr;\n\tint ret;\n\n\tdown_write(&mm->mmap_sem);\n\taddr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);\n\tif (IS_ERR_VALUE(addr)) {\n\t\tret = addr;\n\t\tgoto up_fail;\n\t}\n\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma) {\n\t\tret = -ENOMEM;\n\t\tgoto up_fail;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + PAGE_SIZE;\n\t/* MAYWRITE to allow gdb to COW and set breakpoints */\n\tvma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYWRITE;\n\t/*\n\t * Make sure the vDSO gets into every core dump.\n\t * Dumping its contents makes post-mortem fully interpretable later\n\t * without matching up the same kernel and hardware config to see\n\t * what PC values meant.\n\t */\n\tvma->vm_flags |= VM_ALWAYSDUMP;\n\tvma->vm_flags |= mm->def_flags;\n\tvma->vm_page_prot = protection_map[vma->vm_flags & 7];\n\tvma->vm_ops = &syscall_vm_ops;\n\tvma->vm_mm = mm;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (unlikely(ret)) {\n\t\tkmem_cache_free(vm_area_cachep, vma);\n\t\tgoto up_fail;\n\t}\n\n\tcurrent->mm->context.vdso = (void *)addr;\n\tcurrent_thread_info()->sysenter_return =\n\t\t\t\t    (void *)VDSO_SYM(&SYSENTER_RETURN);\n\tmm->total_vm++;\nup_fail:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] i386 vDSO: use install_special_mapping\n\nThis patch uses install_special_mapping for the i386 vDSO setup, consolidating\nduplicated code.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Andi Kleen <ak@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n{\n\tstruct net_local  *nl = (struct net_local *) dev->priv; \n\tstruct sbni_flags  flags;\n\tint  error = 0;\n\n#ifdef CONFIG_SBNI_MULTILINE\n\tstruct net_device  *slave_dev;\n\tchar  slave_name[ 8 ];\n#endif\n  \n\tswitch( cmd ) {\n\tcase  SIOCDEVGETINSTATS :\n\t\tif (copy_to_user( ifr->ifr_data, &nl->in_stats,\n\t\t\t\t\tsizeof(struct sbni_in_stats) ))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\n\tcase  SIOCDEVRESINSTATS :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\t\tmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\n\t\tbreak;\n\n\tcase  SIOCDEVGHWSTATE :\n\t\tflags.mac_addr\t= *(u32 *)(dev->dev_addr + 3);\n\t\tflags.rate\t= nl->csr1.rate;\n\t\tflags.slow_mode\t= (nl->state & FL_SLOW_MODE) != 0;\n\t\tflags.rxl\t= nl->cur_rxl_index;\n\t\tflags.fixed_rxl\t= nl->delta_rxl == 0;\n\n\t\tif (copy_to_user( ifr->ifr_data, &flags, sizeof flags ))\n\t\t\terror = -EFAULT;\n\t\tbreak;\n\n\tcase  SIOCDEVSHWSTATE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\tspin_lock( &nl->lock );\n\t\tflags = *(struct sbni_flags*) &ifr->ifr_ifru;\n\t\tif( flags.fixed_rxl )\n\t\t\tnl->delta_rxl = 0,\n\t\t\tnl->cur_rxl_index = flags.rxl;\n\t\telse\n\t\t\tnl->delta_rxl = DEF_RXL_DELTA,\n\t\t\tnl->cur_rxl_index = DEF_RXL;\n\n\t\tnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\n\t\tnl->csr1.rate = flags.rate;\n\t\toutb( *(u8 *)&nl->csr1 | PR_RES, dev->base_addr + CSR1 );\n\t\tspin_unlock( &nl->lock );\n\t\tbreak;\n\n#ifdef CONFIG_SBNI_MULTILINE\n\n\tcase  SIOCDEVENSLAVE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\tif (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))\n\t\t\treturn -EFAULT;\n\t\tslave_dev = dev_get_by_name(&init_net, slave_name );\n\t\tif( !slave_dev  ||  !(slave_dev->flags & IFF_UP) ) {\n\t\t\tprintk( KERN_ERR \"%s: trying to enslave non-active \"\n\t\t\t\t\"device %s\\n\", dev->name, slave_name );\n\t\t\treturn  -EPERM;\n\t\t}\n\n\t\treturn  enslave( dev, slave_dev );\n\n\tcase  SIOCDEVEMANSIPATE :\n\t\tif( current->euid != 0 )\t/* root only */\n\t\t\treturn  -EPERM;\n\n\t\treturn  emancipate( dev );\n\n#endif\t/* CONFIG_SBNI_MULTILINE */\n\n\tdefault :\n\t\treturn  -EOPNOTSUPP;\n\t}\n\n\treturn  error;\n}", "target": 1, "cwe": ["CWE-264"], "message": "wan: Missing capability checks in sbni_ioctl()\n\nThere are missing capability checks in the following code:\n\n1300 static int\n1301 sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd)\n1302 {\n[...]\n1319     case  SIOCDEVRESINSTATS :\n1320         if( current->euid != 0 )    /* root only */\n1321             return  -EPERM;\n[...]\n1336     case  SIOCDEVSHWSTATE :\n1337         if( current->euid != 0 )    /* root only */\n1338             return  -EPERM;\n[...]\n1357     case  SIOCDEVENSLAVE :\n1358         if( current->euid != 0 )    /* root only */\n1359             return  -EPERM;\n[...]\n1372     case  SIOCDEVEMANSIPATE :\n1373         if( current->euid != 0 )    /* root only */\n1374             return  -EPERM;\n\nHere's my proposed fix:\n\nMissing capability checks.\n\nSigned-off-by: Eugene Teo <eugeneteo@kernel.sg>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, const struct iovec *iov, loff_t offset, \n\tunsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,\n\tint dio_lock_type)\n{\n\tint seg;\n\tsize_t size;\n\tunsigned long addr;\n\tunsigned blkbits = inode->i_blkbits;\n\tunsigned bdev_blkbits = 0;\n\tunsigned blocksize_mask = (1 << blkbits) - 1;\n\tssize_t retval = -EINVAL;\n\tloff_t end = offset;\n\tstruct dio *dio;\n\tint release_i_mutex = 0;\n\tint acquire_i_mutex = 0;\n\n\tif (rw & WRITE)\n\t\trw = WRITE_SYNC;\n\n\tif (bdev)\n\t\tbdev_blkbits = blksize_bits(bdev_hardsect_size(bdev));\n\n\tif (offset & blocksize_mask) {\n\t\tif (bdev)\n\t\t\t blkbits = bdev_blkbits;\n\t\tblocksize_mask = (1 << blkbits) - 1;\n\t\tif (offset & blocksize_mask)\n\t\t\tgoto out;\n\t}\n\n\t/* Check the memory alignment.  Blocks cannot straddle pages */\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\taddr = (unsigned long)iov[seg].iov_base;\n\t\tsize = iov[seg].iov_len;\n\t\tend += size;\n\t\tif ((addr & blocksize_mask) || (size & blocksize_mask))  {\n\t\t\tif (bdev)\n\t\t\t\t blkbits = bdev_blkbits;\n\t\t\tblocksize_mask = (1 << blkbits) - 1;\n\t\t\tif ((addr & blocksize_mask) || (size & blocksize_mask))  \n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdio = kmalloc(sizeof(*dio), GFP_KERNEL);\n\tretval = -ENOMEM;\n\tif (!dio)\n\t\tgoto out;\n\n\t/*\n\t * For block device access DIO_NO_LOCKING is used,\n\t *\tneither readers nor writers do any locking at all\n\t * For regular files using DIO_LOCKING,\n\t *\treaders need to grab i_mutex and i_alloc_sem\n\t *\twriters need to grab i_alloc_sem only (i_mutex is already held)\n\t * For regular files using DIO_OWN_LOCKING,\n\t *\tneither readers nor writers take any locks here\n\t */\n\tdio->lock_type = dio_lock_type;\n\tif (dio_lock_type != DIO_NO_LOCKING) {\n\t\t/* watch out for a 0 len io from a tricksy fs */\n\t\tif (rw == READ && end > offset) {\n\t\t\tstruct address_space *mapping;\n\n\t\t\tmapping = iocb->ki_filp->f_mapping;\n\t\t\tif (dio_lock_type != DIO_OWN_LOCKING) {\n\t\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\t\trelease_i_mutex = 1;\n\t\t\t}\n\n\t\t\tretval = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t\t      end - 1);\n\t\t\tif (retval) {\n\t\t\t\tkfree(dio);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dio_lock_type == DIO_OWN_LOCKING) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tacquire_i_mutex = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (dio_lock_type == DIO_LOCKING)\n\t\t\t/* lockdep: not the owner will release it */\n\t\t\tdown_read_non_owner(&inode->i_alloc_sem);\n\t}\n\n\t/*\n\t * For file extending writes updating i_size before data\n\t * writeouts complete can expose uninitialized blocks. So\n\t * even for AIO, we need to wait for i/o to complete before\n\t * returning in this case.\n\t */\n\tdio->is_async = !is_sync_kiocb(iocb) && !((rw & WRITE) &&\n\t\t(end > i_size_read(inode)));\n\n\tretval = direct_io_worker(rw, iocb, inode, iov, offset,\n\t\t\t\tnr_segs, blkbits, get_block, end_io, dio);\n\n\tif (rw == READ && dio_lock_type == DIO_LOCKING)\n\t\trelease_i_mutex = 0;\n\nout:\n\tif (release_i_mutex)\n\t\tmutex_unlock(&inode->i_mutex);\n\telse if (acquire_i_mutex)\n\t\tmutex_lock(&inode->i_mutex);\n\treturn retval;\n}", "target": 1, "cwe": [], "message": "dio: zero struct dio with kzalloc instead of manually\n\nThis patch uses kzalloc to zero all of struct dio rather than manually\ntrying to track which fields we rely on being zero.  It passed aio+dio\nstress testing and some bug regression testing on ext3.\n\nThis patch was introduced by Linus in the conversation that lead up to\nBadari's minimal fix to manually zero .map_bh.b_state in commit:\n\n  6a648fa72161d1f6468dabd96c5d3c0db04f598a\n\nIt makes the code a bit smaller.  Maybe a couple fewer cachelines to\nload, if we're lucky:\n\n   text    data     bss     dec     hex filename\n3285925  568506 1304616 5159047  4eb887 vmlinux\n3285797  568506 1304616 5158919  4eb807 vmlinux.patched\n\nI was unable to measure a stable difference in the number of cpu cycles\nspent in blockdev_direct_IO() when pushing aio+dio 256K reads at\n~340MB/s.\n\nSo the resulting intent of the patch isn't a performance gain but to\navoid exposing ourselves to the risk of finding another field like\n.map_bh.b_state where we rely on zeroing but don't enforce it in the\ncode.\n\nSigned-off-by: Zach Brown <zach.brown@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode, \n\tconst struct iovec *iov, loff_t offset, unsigned long nr_segs, \n\tunsigned blkbits, get_block_t get_block, dio_iodone_t end_io,\n\tstruct dio *dio)\n{\n\tunsigned long user_addr; \n\tunsigned long flags;\n\tint seg;\n\tssize_t ret = 0;\n\tssize_t ret2;\n\tsize_t bytes;\n\n\tdio->bio = NULL;\n\tdio->inode = inode;\n\tdio->rw = rw;\n\tdio->blkbits = blkbits;\n\tdio->blkfactor = inode->i_blkbits - blkbits;\n\tdio->start_zero_done = 0;\n\tdio->size = 0;\n\tdio->block_in_file = offset >> blkbits;\n\tdio->blocks_available = 0;\n\tdio->cur_page = NULL;\n\n\tdio->boundary = 0;\n\tdio->reap_counter = 0;\n\tdio->get_block = get_block;\n\tdio->end_io = end_io;\n\tdio->map_bh.b_private = NULL;\n\tdio->map_bh.b_state = 0;\n\tdio->final_block_in_bio = -1;\n\tdio->next_block_for_io = -1;\n\n\tdio->page_errors = 0;\n\tdio->io_error = 0;\n\tdio->result = 0;\n\tdio->iocb = iocb;\n\tdio->i_size = i_size_read(inode);\n\n\tspin_lock_init(&dio->bio_lock);\n\tdio->refcount = 1;\n\tdio->bio_list = NULL;\n\tdio->waiter = NULL;\n\n\t/*\n\t * In case of non-aligned buffers, we may need 2 more\n\t * pages since we need to zero out first and last block.\n\t */\n\tif (unlikely(dio->blkfactor))\n\t\tdio->pages_in_io = 2;\n\telse\n\t\tdio->pages_in_io = 0;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tuser_addr = (unsigned long)iov[seg].iov_base;\n\t\tdio->pages_in_io +=\n\t\t\t((user_addr+iov[seg].iov_len +PAGE_SIZE-1)/PAGE_SIZE\n\t\t\t\t- user_addr/PAGE_SIZE);\n\t}\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tuser_addr = (unsigned long)iov[seg].iov_base;\n\t\tdio->size += bytes = iov[seg].iov_len;\n\n\t\t/* Index into the first page of the first block */\n\t\tdio->first_block_in_page = (user_addr & ~PAGE_MASK) >> blkbits;\n\t\tdio->final_block_in_request = dio->block_in_file +\n\t\t\t\t\t\t(bytes >> blkbits);\n\t\t/* Page fetching state */\n\t\tdio->head = 0;\n\t\tdio->tail = 0;\n\t\tdio->curr_page = 0;\n\n\t\tdio->total_pages = 0;\n\t\tif (user_addr & (PAGE_SIZE-1)) {\n\t\t\tdio->total_pages++;\n\t\t\tbytes -= PAGE_SIZE - (user_addr & (PAGE_SIZE - 1));\n\t\t}\n\t\tdio->total_pages += (bytes + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tdio->curr_user_address = user_addr;\n\t\n\t\tret = do_direct_IO(dio);\n\n\t\tdio->result += iov[seg].iov_len -\n\t\t\t((dio->final_block_in_request - dio->block_in_file) <<\n\t\t\t\t\tblkbits);\n\n\t\tif (ret) {\n\t\t\tdio_cleanup(dio);\n\t\t\tbreak;\n\t\t}\n\t} /* end iovec loop */\n\n\tif (ret == -ENOTBLK && (rw & WRITE)) {\n\t\t/*\n\t\t * The remaining part of the request will be\n\t\t * be handled by buffered I/O when we return\n\t\t */\n\t\tret = 0;\n\t}\n\t/*\n\t * There may be some unwritten disk at the end of a part-written\n\t * fs-block-sized block.  Go zero that now.\n\t */\n\tdio_zero_block(dio, 1);\n\n\tif (dio->cur_page) {\n\t\tret2 = dio_send_cur_page(dio);\n\t\tif (ret == 0)\n\t\t\tret = ret2;\n\t\tpage_cache_release(dio->cur_page);\n\t\tdio->cur_page = NULL;\n\t}\n\tif (dio->bio)\n\t\tdio_bio_submit(dio);\n\n\t/* All IO is now issued, send it on its way */\n\tblk_run_address_space(inode->i_mapping);\n\n\t/*\n\t * It is possible that, we return short IO due to end of file.\n\t * In that case, we need to release all the pages we got hold on.\n\t */\n\tdio_cleanup(dio);\n\n\t/*\n\t * All block lookups have been performed. For READ requests\n\t * we can let i_mutex go now that its achieved its purpose\n\t * of protecting us from looking up uninitialized blocks.\n\t */\n\tif ((rw == READ) && (dio->lock_type == DIO_LOCKING))\n\t\tmutex_unlock(&dio->inode->i_mutex);\n\n\t/*\n\t * The only time we want to leave bios in flight is when a successful\n\t * partial aio read or full aio write have been setup.  In that case\n\t * bio completion will call aio_complete.  The only time it's safe to\n\t * call aio_complete is when we return -EIOCBQUEUED, so we key on that.\n\t * This had *better* be the only place that raises -EIOCBQUEUED.\n\t */\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (dio->is_async && ret == 0 && dio->result &&\n\t    ((rw & READ) || (dio->result == dio->size)))\n\t\tret = -EIOCBQUEUED;\n\n\tif (ret != -EIOCBQUEUED)\n\t\tdio_await_completion(dio);\n\n\t/*\n\t * Sync will always be dropping the final ref and completing the\n\t * operation.  AIO can if it was a broken operation described above or\n\t * in fact if all the bios race to complete before we get here.  In\n\t * that case dio_complete() translates the EIOCBQUEUED into the proper\n\t * return code that the caller will hand to aio_complete().\n\t *\n\t * This is managed by the bio_lock instead of being an atomic_t so that\n\t * completion paths can drop their ref and use the remaining count to\n\t * decide to wake the submission path atomically.\n\t */\n\tspin_lock_irqsave(&dio->bio_lock, flags);\n\tret2 = --dio->refcount;\n\tspin_unlock_irqrestore(&dio->bio_lock, flags);\n\n\tif (ret2 == 0) {\n\t\tret = dio_complete(dio, offset, ret);\n\t\tkfree(dio);\n\t} else\n\t\tBUG_ON(ret != -EIOCBQUEUED);\n\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "dio: zero struct dio with kzalloc instead of manually\n\nThis patch uses kzalloc to zero all of struct dio rather than manually\ntrying to track which fields we rely on being zero.  It passed aio+dio\nstress testing and some bug regression testing on ext3.\n\nThis patch was introduced by Linus in the conversation that lead up to\nBadari's minimal fix to manually zero .map_bh.b_state in commit:\n\n  6a648fa72161d1f6468dabd96c5d3c0db04f598a\n\nIt makes the code a bit smaller.  Maybe a couple fewer cachelines to\nload, if we're lucky:\n\n   text    data     bss     dec     hex filename\n3285925  568506 1304616 5159047  4eb887 vmlinux\n3285797  568506 1304616 5158919  4eb807 vmlinux.patched\n\nI was unable to measure a stable difference in the number of cpu cycles\nspent in blockdev_direct_IO() when pushing aio+dio 256K reads at\n~340MB/s.\n\nSo the resulting intent of the patch isn't a performance gain but to\navoid exposing ourselves to the risk of finding another field like\n.map_bh.b_state where we rely on zeroing but don't enforce it in the\ncode.\n\nSigned-off-by: Zach Brown <zach.brown@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\t/*\n\t * In the worst case, each individual acl could be for a distinct\n\t * named user or group, but we don't no which, so we allocate\n\t * enough space for either:\n\t */\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "nfsd: fix buffer overrun decoding NFSv4 acl\n\nThe array we kmalloc() here is not large enough.\n\nThanks to Johann Dahm and David Richter for bug report and testing.\n\nSigned-off-by: J. Bruce Fields <bfields@citi.umich.edu>\nCc: David Richter <richterd@citi.umich.edu>\nTested-by: Johann Dahm <jdahm@umich.edu>"}
{"func": "static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint n;\n\tint c;\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\ttxtdesc->ascdata = 0;\n\ttxtdesc->ucdata = 0;\n\tif (jas_iccgetuint32(in, &txtdesc->asclen))\n\t\tgoto error;\n\tif (!(txtdesc->ascdata = jas_malloc(txtdesc->asclen)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ascdata, txtdesc->asclen) !=\n\t  JAS_CAST(int, txtdesc->asclen))\n\t\tgoto error;\n\ttxtdesc->ascdata[txtdesc->asclen - 1] = '\\0';\n\tif (jas_iccgetuint32(in, &txtdesc->uclangcode) ||\n\t  jas_iccgetuint32(in, &txtdesc->uclen))\n\t\tgoto error;\n\tif (!(txtdesc->ucdata = jas_malloc(txtdesc->uclen * 2)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) !=\n\t  JAS_CAST(int, txtdesc->uclen * 2))\n\t\tgoto error;\n\tif (jas_iccgetuint16(in, &txtdesc->sccode))\n\t\tgoto error;\n\tif ((c = jas_stream_getc(in)) == EOF)\n\t\tgoto error;\n\ttxtdesc->maclen = c;\n\tif (jas_stream_read(in, txtdesc->macdata, 67) != 67)\n\t\tgoto error;\n\ttxtdesc->asclen = strlen(txtdesc->ascdata) + 1;\n#define WORKAROUND_BAD_PROFILES\n#ifdef WORKAROUND_BAD_PROFILES\n\tn = txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67;\n\tif (n > cnt) {\n\t\treturn -1;\n\t}\n\tif (n < cnt) {\n\t\tif (jas_stream_gobble(in, cnt - n) != cnt - n)\n\t\t\tgoto error;\n\t}\n#else\n\tif (txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67 != cnt)\n\t\treturn -1;\n#endif\n\treturn 0;\nerror:\n\tjas_icctxtdesc_destroy(attrval);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numcols, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numcols >= 2) {\n\t\thstartcol = (numcols + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numcols - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[1 - parity];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += 2;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[1 - parity];\n\t\tsrcptr = &a[2 - parity];\n\t\tn = numcols - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += 2;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_malloc(maxcmpts * sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc(image->cmpts_, maxcmpts * sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab)\n{\n\tint i;\n\tjas_icctagtabent_t *tagtabent;\n\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\tif (jas_iccgetuint32(in, &tagtab->numents))\n\t\tgoto error;\n\tif (!(tagtab->ents = jas_malloc(tagtab->numents *\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtabent = tagtab->ents;\n\tfor (i = 0; i < JAS_CAST(long, tagtab->numents); ++i) {\n\t\tif (jas_iccgetuint32(in, &tagtabent->tag) ||\n\t\tjas_iccgetuint32(in, &tagtabent->off) ||\n\t\tjas_iccgetuint32(in, &tagtabent->len))\n\t\t\tgoto error;\n\t\t++tagtabent;\n\t}\n\treturn 0;\nerror:\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_malloc(cmap->numchans * sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_mqdec_t *jpc_mqdec_create(int maxctxs, jas_stream_t *in)\n{\n\tjpc_mqdec_t *mqdec;\n\n\t/* There must be at least one context. */\n\tassert(maxctxs > 0);\n\n\t/* Allocate memory for the MQ decoder. */\n\tif (!(mqdec = jas_malloc(sizeof(jpc_mqdec_t)))) {\n\t\tgoto error;\n\t}\n\tmqdec->in = in;\n\tmqdec->maxctxs = maxctxs;\n\t/* Allocate memory for the per-context state information. */\n\tif (!(mqdec->ctxs = jas_malloc(mqdec->maxctxs * sizeof(jpc_mqstate_t *)))) {\n\t\tgoto error;\n\t}\n\t/* Set the current context to the first context. */\n\tmqdec->curctx = mqdec->ctxs;\n\n\t/* If an input stream has been associated with the MQ decoder,\n\t  initialize the decoder state from the stream. */\n\tif (mqdec->in) {\n\t\tjpc_mqdec_init(mqdec);\n\t}\n\t/* Initialize the per-context state information. */\n\tjpc_mqdec_setctxs(mqdec, 0, 0);\n\n\treturn mqdec;\n\nerror:\n\t/* Oops...  Something has gone wrong. */\n\tif (mqdec) {\n\t\tjpc_mqdec_destroy(mqdec);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\"unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->numcolors > 0) {\n\t\tif (!(info->palents = jas_malloc(info->numcolors *\n\t\t  sizeof(bmp_palent_t)))) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tinfo->palents = 0;\n\t}\n\n\tfor (i = 0; i < info->numcolors; ++i) {\n\t\tpalent = &info->palents[i];\n\t\tif ((palent->blu = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->grn = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->red = jas_stream_getc(in)) == EOF ||\n\t\t  (palent->res = jas_stream_getc(in)) == EOF) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn info;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void *jas_realloc(void *ptr, size_t size)\n{\n\treturn realloc(ptr, size);\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_icclut8_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint i;\n\tint j;\n\tint clutsize;\n\tjas_icclut8_t *lut8 = &attrval->data.lut8;\n\tlut8->clut = 0;\n\tlut8->intabs = 0;\n\tlut8->intabsbuf = 0;\n\tlut8->outtabs = 0;\n\tlut8->outtabsbuf = 0;\n\tif (jas_iccgetuint8(in, &lut8->numinchans) ||\n\t  jas_iccgetuint8(in, &lut8->numoutchans) ||\n\t  jas_iccgetuint8(in, &lut8->clutlen) ||\n\t  jas_stream_getc(in) == EOF)\n\t\tgoto error;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 3; ++j) {\n\t\t\tif (jas_iccgetsint32(in, &lut8->e[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (jas_iccgetuint16(in, &lut8->numintabents) ||\n\t  jas_iccgetuint16(in, &lut8->numouttabents))\n\t\tgoto error;\n\tclutsize = jas_iccpowi(lut8->clutlen, lut8->numinchans) * lut8->numoutchans;\n\tif (!(lut8->clut = jas_malloc(clutsize * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->intabsbuf = jas_malloc(lut8->numinchans *\n\t  lut8->numintabents * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->intabs = jas_malloc(lut8->numinchans *\n\t  sizeof(jas_iccuint8_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut8->numinchans; ++i)\n\t\tlut8->intabs[i] = &lut8->intabsbuf[i * lut8->numintabents];\n\tif (!(lut8->outtabsbuf = jas_malloc(lut8->numoutchans *\n\t  lut8->numouttabents * sizeof(jas_iccuint8_t))) ||\n\t  !(lut8->outtabs = jas_malloc(lut8->numoutchans *\n\t  sizeof(jas_iccuint8_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut8->numoutchans; ++i)\n\t\tlut8->outtabs[i] = &lut8->outtabsbuf[i * lut8->numouttabents];\n\tfor (i = 0; i < lut8->numinchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut8->numintabents); ++j) {\n\t\t\tif (jas_iccgetuint8(in, &lut8->intabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < lut8->numoutchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut8->numouttabents); ++j) {\n\t\t\tif (jas_iccgetuint8(in, &lut8->outtabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < clutsize; ++i) {\n\t\tif (jas_iccgetuint8(in, &lut8->clut[i]))\n\t\t\tgoto error;\n\t}\n\tif (JAS_CAST(int, 44 + lut8->numinchans * lut8->numintabents +\n\t  lut8->numoutchans * lut8->numouttabents +\n\t  jas_iccpowi(lut8->clutlen, lut8->numinchans) * lut8->numoutchans) !=\n\t  cnt)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tjas_icclut8_destroy(attrval);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_enc_encodemainhdr(jpc_enc_t *enc)\n{\n\tjpc_siz_t *siz;\n\tjpc_cod_t *cod;\n\tjpc_qcd_t *qcd;\n\tint i;\nlong startoff;\nlong mainhdrlen;\n\tjpc_enc_cp_t *cp;\n\tjpc_qcc_t *qcc;\n\tjpc_enc_tccp_t *tccp;\n\tuint_fast16_t cmptno;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\tjpc_fix_t mctsynweight;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_tsfb_t *tsfb;\n\tjpc_tsfb_band_t *bandinfo;\n\tuint_fast16_t numbands;\n\tuint_fast16_t bandno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t analgain;\n\tjpc_fix_t absstepsize;\n\tchar buf[1024];\n\tjpc_com_t *com;\n\n\tcp = enc->cp;\n\nstartoff = jas_stream_getrwcount(enc->out);\n\n\t/* Write SOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {\n\t\treturn -1;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\t/* Write SIZ marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {\n\t\treturn -1;\n\t}\n\tsiz = &enc->mrk->parms.siz;\n\tsiz->caps = 0;\n\tsiz->xoff = cp->imgareatlx;\n\tsiz->yoff = cp->imgareatly;\n\tsiz->width = cp->refgrdwidth;\n\tsiz->height = cp->refgrdheight;\n\tsiz->tilexoff = cp->tilegrdoffx;\n\tsiz->tileyoff = cp->tilegrdoffy;\n\tsiz->tilewidth = cp->tilewidth;\n\tsiz->tileheight = cp->tileheight;\n\tsiz->numcomps = cp->numcmpts;\n\tsiz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t));\n\tassert(siz->comps);\n\tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {\n\t\tsiz->comps[i].prec = cp->ccps[i].prec;\n\t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;\n\t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;\n\t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = strlen(buf);\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {\n\t\treturn -1;\n\t}\n\tcrg = &enc->mrk->parms.crg;\n\tcrg->comps = jas_malloc(crg->numcomps * sizeof(jpc_crgcomp_t));\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write CRG marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n#endif\n\n\ttcp = &cp->tcp;\n\ttccp = &cp->tccp;\n\tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {\n\t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);\n\t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,\n\t\t  bandinfos);\n\t\tjpc_tsfb_destroy(tsfb);\n\t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);\n\t\tnumbands = 3 * tccp->maxrlvls - 2;\n\t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;\n\t\t  ++bandno, ++bandinfo) {\n\t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;\n\t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,\n\t\t\t  rlvlno, bandinfo->orient);\n\t\t\tif (!tcp->intmode) {\n\t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<\n\t\t\t\t  (analgain + 1)), bandinfo->synenergywt);\n\t\t\t} else {\n\t\t\t\tabsstepsize = jpc_inttofix(1);\n\t\t\t}\t\n\t\t\tcp->ccps[cmptno].stepsizes[bandno] =\n\t\t\t  jpc_abstorelstepsize(absstepsize,\n\t\t\t  cp->ccps[cmptno].prec + analgain);\n\t\t}\n\t\tcp->ccps[cmptno].numstepsizes = numbands;\n\t}\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\treturn -1;\n\t}\n\tcod = &enc->mrk->parms.cod;\n\tcod->csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;\n\tcod->compparms.numrlvls = cp->tccp.maxrlvls;\n\tcod->prg = cp->tcp.prg;\n\tcod->numlyrs = cp->tcp.numlyrs;\n\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);\n\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);\n\tcod->compparms.cblksty = cp->tccp.cblksty;\n\tcod->compparms.qmfbid = cp->tccp.qmfbid;\n\tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);\n\tif (tccp->csty & JPC_COX_PRT) {\n\t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];\n\t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];\n\t\t}\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COD marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {\n\t\treturn -1;\n\t}\n\tqcd = &enc->mrk->parms.qcd;\n\tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;\n\tqcd->compparms.numguard = cp->tccp.numgbits;\n\tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\treturn -1;\n\t}\n\t/* We do not want the step size array to be freed! */\n\tqcd->compparms.stepsizes = 0;\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\ttccp = &cp->tccp;\n\tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc = &enc->mrk->parms.qcc;\n\t\tqcc->compno = cmptno;\n\t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;\n\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;\n\t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\t\treturn -1;\n\t\t}\n\t\t/* We do not want the step size array to be freed! */\n\t\tqcc->compparms.stepsizes = 0;\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t}\n\n#define MAINTLRLEN\t2\n\tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;\n\tenc->len += mainhdrlen;\n\tif (enc->cp->totalsize != UINT_FAST32_MAX) {\n\t\tuint_fast32_t overhead;\n\t\toverhead = mainhdrlen + MAINTLRLEN;\n\t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?\n\t\t  (enc->cp->totalsize - overhead) : 0;\n\t} else {\n\t\tenc->mainbodysize = UINT_FAST32_MAX;\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jas_iccprof_save(jas_iccprof_t *prof, jas_stream_t *out)\n{\n\tlong curoff;\n\tlong reloff;\n\tlong newoff;\n\tint i;\n\tint j;\n\tjas_icctagtabent_t *tagtabent;\n\tjas_icctagtabent_t *sharedtagtabent;\n\tjas_icctagtabent_t *tmptagtabent;\n\tjas_iccuint32_t attrname;\n\tjas_iccattrval_t *attrval;\n\tjas_icctagtab_t *tagtab;\n\n\ttagtab = &prof->tagtab;\n\tif (!(tagtab->ents = jas_malloc(prof->attrtab->numattrs *\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtab->numents = prof->attrtab->numattrs;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents); ++i) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tassert(attrval->ops->output);\n\t\ttagtabent->tag = attrname;\n\t\ttagtabent->data = &attrval->data;\n\t\tsharedtagtabent = 0;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\ttmptagtabent = &tagtab->ents[j];\n\t\t\tif (tagtabent->data == tmptagtabent->data) {\n\t\t\t\tsharedtagtabent = tmptagtabent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sharedtagtabent) {\n\t\t\ttagtabent->off = sharedtagtabent->off;\n\t\t\ttagtabent->len = sharedtagtabent->len;\n\t\t\ttagtabent->first = sharedtagtabent;\n\t\t} else {\n\t\t\ttagtabent->off = curoff;\n\t\t\ttagtabent->len = (*attrval->ops->getsize)(attrval) + 8;\n\t\t\ttagtabent->first = 0;\n\t\t\tif (i < JAS_CAST(int, tagtab->numents - 1)) {\n\t\t\t\tcuroff = jas_iccpadtomult(curoff + tagtabent->len, 4);\n\t\t\t} else {\n\t\t\t\tcuroff += tagtabent->len;\n\t\t\t}\n\t\t}\n\t\tjas_iccattrval_destroy(attrval);\n\t}\n\tprof->hdr.size = curoff;\n\tif (jas_iccprof_writehdr(out, &prof->hdr))\n\t\tgoto error;\n\tif (jas_iccprof_puttagtab(out, &prof->tagtab))\n\t\tgoto error;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents);) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tassert(curoff == JAS_CAST(long, tagtabent->off));\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tif (jas_iccputuint32(out, attrval->type) || jas_stream_pad(out,\n\t\t  4, 0) != 4)\n\t\t\tgoto error;\n\t\tif ((*attrval->ops->output)(attrval, out))\n\t\t\tgoto error;\n\t\tjas_iccattrval_destroy(attrval);\n\t\tcuroff += tagtabent->len;\n\t\t++i;\n\t\twhile (i < JAS_CAST(int, tagtab->numents) &&\n\t\t  tagtab->ents[i].first)\n\t\t\t++i;\n\t\tnewoff = (i < JAS_CAST(int, tagtab->numents)) ?\n\t\t  tagtab->ents[i].off : prof->hdr.size;\n\t\treloff = newoff - curoff;\n\t\tassert(reloff >= 0);\n\t\tif (reloff > 0) {\n\t\t\tif (jas_stream_pad(out, reloff, 0) != reloff)\n\t\t\t\tgoto error;\n\t\t\tcuroff += reloff;\n\t\t}\n\t}\t\n\treturn 0;\nerror:\n\t/* XXX - need to free some resources here */\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_cmshapmatlut_set(jas_cmshapmatlut_t *lut, jas_icccurv_t *curv)\n{\n\tjas_cmreal_t gamma;\n\tint i;\n\tgamma = 0;\n\tjas_cmshapmatlut_cleanup(lut);\n\tif (curv->numents == 0) {\n\t\tlut->size = 2;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tlut->data[0] = 0.0;\n\t\tlut->data[1] = 1.0;\n\t} else if (curv->numents == 1) {\n\t\tlut->size = 256;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tgamma = curv->ents[0] / 256.0;\n\t\tfor (i = 0; i < lut->size; ++i) {\n\t\t\tlut->data[i] = gammafn(i / (double) (lut->size - 1), gamma);\n\t\t}\n\t} else {\n\t\tlut->size = curv->numents;\n\t\tif (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))\n\t\t\tgoto error;\n\t\tfor (i = 0; i < lut->size; ++i) {\n\t\t\tlut->data[i] = curv->ents[i] / 65535.0;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(m->buf_);\n\tif (!(buf = jas_realloc(m->buf_, bufsize * sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_malloc(colr->iccplen * sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_mqenc_t *jpc_mqenc_create(int maxctxs, jas_stream_t *out)\n{\n\tjpc_mqenc_t *mqenc;\n\n\t/* Allocate memory for the MQ encoder. */\n\tif (!(mqenc = jas_malloc(sizeof(jpc_mqenc_t)))) {\n\t\tgoto error;\n\t}\n\tmqenc->out = out;\n\tmqenc->maxctxs = maxctxs;\n\n\t/* Allocate memory for the per-context state information. */\n\tif (!(mqenc->ctxs = jas_malloc(mqenc->maxctxs * sizeof(jpc_mqstate_t *)))) {\n\t\tgoto error;\n\t}\n\n\t/* Set the current context to the first one. */\n\tmqenc->curctx = mqenc->ctxs;\n\n\tjpc_mqenc_init(mqenc);\n\n\t/* Initialize the per-context state information to something sane. */\n\tjpc_mqenc_setctxs(mqenc, 0, 0);\n\n\treturn mqenc;\n\nerror:\n\tif (mqenc) {\n\t\tjpc_mqenc_destroy(mqenc);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_enc_rlvl_t *rlvl_create(jpc_enc_rlvl_t *rlvl, jpc_enc_cp_t *cp,\n  jpc_enc_tcmpt_t *tcmpt, jpc_tsfb_band_t *bandinfos)\n{\n\tuint_fast16_t rlvlno;\n\tuint_fast32_t tlprctlx;\n\tuint_fast32_t tlprctly;\n\tuint_fast32_t brprcbrx;\n\tuint_fast32_t brprcbry;\n\tuint_fast16_t bandno;\n\tjpc_enc_band_t *band;\n\n\t/* Deduce the resolution level. */\n\trlvlno = rlvl - tcmpt->rlvls;\n\n\t/* Initialize members required for error recovery. */\n\trlvl->bands = 0;\n\trlvl->tcmpt = tcmpt;\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of the tile-component at this resolution. */\n\trlvl->tlx = JPC_CEILDIVPOW2(jas_seq2d_xstart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->tly = JPC_CEILDIVPOW2(jas_seq2d_ystart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->brx = JPC_CEILDIVPOW2(jas_seq2d_xend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->bry = JPC_CEILDIVPOW2(jas_seq2d_yend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\n\tif (rlvl->tlx >= rlvl->brx || rlvl->tly >= rlvl->bry) {\n\t\trlvl->numhprcs = 0;\n\t\trlvl->numvprcs = 0;\n\t\trlvl->numprcs = 0;\n\t\treturn rlvl;\n\t}\n\n\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\trlvl->prcwidthexpn = cp->tccp.prcwidthexpns[rlvlno];\n\trlvl->prcheightexpn = cp->tccp.prcheightexpns[rlvlno];\n\tif (!rlvlno) {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t} else {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t}\n\trlvl->cblkwidthexpn = JAS_MIN(cp->tccp.cblkwidthexpn, rlvl->cbgwidthexpn);\n\trlvl->cblkheightexpn = JAS_MIN(cp->tccp.cblkheightexpn, rlvl->cbgheightexpn);\n\n\t/* Compute the number of precincts. */\n\ttlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn);\n\ttlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn);\n\tbrprcbrx = JPC_CEILTOMULTPOW2(rlvl->brx, rlvl->prcwidthexpn);\n\tbrprcbry = JPC_CEILTOMULTPOW2(rlvl->bry, rlvl->prcheightexpn);\n\trlvl->numhprcs = JPC_FLOORDIVPOW2(brprcbrx - tlprctlx, rlvl->prcwidthexpn);\n\trlvl->numvprcs = JPC_FLOORDIVPOW2(brprcbry - tlprctly, rlvl->prcheightexpn);\n\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\tif (!(rlvl->bands = jas_malloc(rlvl->numbands * sizeof(jpc_enc_band_t)))) {\n\t\tgoto error;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tband->prcs = 0;\n\t\tband->data = 0;\n\t\tband->rlvl = rlvl;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tif (!band_create(band, cp, rlvl, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn rlvl;\nerror:\n\n\trlvl_destroy(rlvl);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void *jas_malloc(size_t size)\n{\n#if defined(MEMALLOC_ALIGN2)\n\tvoid *ptr;\nabort();\n\tif (posix_memalign(&ptr, MEMALLOC_ALIGNMENT, size)) {\n\t\treturn 0;\n\t}\n\treturn ptr;\n#endif\n\treturn malloc(size);\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_enc_tcmpt_t *tcomp;\n\tint rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->pktno = -1;\n\tpi->numcomps = cp->numcmpts;\n\tif (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (rlvl->numprcs) {\n\t\t\t\tif (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *\n\t\t\t\t  sizeof(long)))) {\n\t\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpirlvl->prclyrnos = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->hsamp = cp->ccps[compno].sampgrdstepx;\n\t\tpicomp->vsamp = cp->ccps[compno].sampgrdstepy;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->numlyrs;\n\tpi->xstart = tile->tlx;\n\tpi->ystart = tile->tly;\n\tpi->xend = tile->brx;\n\tpi->yend = tile->bry;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->prg;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jpc_atoaf(char *s, int *numvalues, double **values)\n{\n\tstatic char delim[] = \", \\t\\n\";\n\tchar buf[4096];\n\tint n;\n\tdouble *vs;\n\tchar *cp;\n\n\tstrncpy(buf, s, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tn = 0;\n\tif ((cp = strtok(buf, delim))) {\n\t\t++n;\n\t\twhile ((cp = strtok(0, delim))) {\n\t\t\tif (cp != '\\0') {\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n) {\n\t\tif (!(vs = jas_malloc(n * sizeof(double)))) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrncpy(buf, s, sizeof(buf));\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tn = 0;\n\t\tif ((cp = strtok(buf, delim))) {\n\t\t\tvs[n] = atof(cp);\n\t\t\t++n;\n\t\t\twhile ((cp = strtok(0, delim))) {\n\t\t\t\tif (cp != '\\0') {\n\t\t\t\t\tvs[n] = atof(cp);\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvs = 0;\n\t}\n\n\t*numvalues = n;\n\t*values = vs;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_join_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * numcols * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += numcols;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += numcols;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n{\n\tint cmptno;\n\tmif_cmpt_t **newcmpts;\n\tassert(maxcmpts >= hdr->numcmpts);\n\tnewcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :\n\t  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\thdr->maxcmpts = maxcmpts;\n\thdr->cmpts = newcmpts;\n\tfor (cmptno = hdr->numcmpts; cmptno < hdr->maxcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = 0;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tjas_icccurv_t *curv = &attrval->data.curv;\n\tunsigned int i;\n\n\tcurv->numents = 0;\n\tcurv->ents = 0;\n\n\tif (jas_iccgetuint32(in, &curv->numents))\n\t\tgoto error;\n\tif (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))\n\t\tgoto error;\n\tfor (i = 0; i < curv->numents; ++i) {\n\t\tif (jas_iccgetuint16(in, &curv->ents[i]))\n\t\t\tgoto error;\n\t}\n\n\tif (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tjas_icccurv_destroy(attrval);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n{\n\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds);\n}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\nrlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_malloc(rlvl->numbands *\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\tcbgxstart = tlcbgxstart;\n\tcbgystart = tlcbgystart;\n\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t  prccnt > 0; --prccnt, ++prc) {\n\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data)));\n\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data)));\n\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data)));\n\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data)));\n\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t  rlvl->cblkwidthexpn;\n\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t  rlvl->cblkheightexpn;\n\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\tassert(prc->numcblks > 0);\n\n\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcblkxstart = cbgxstart;\n\t\t\tcblkystart = cbgystart;\n\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t++cblk;\n\t\t\t\t\t--cblkcnt;\n\t\t\t\t}\n\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tprc->cblks = 0;\n\t\t\tprc->incltagtree = 0;\n\t\t\tprc->numimsbstagtree = 0;\n\t\t}\n\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\tif (cbgxstart >= brcbgxend) {\n\t\t\tcbgxstart = tlcbgxstart;\n\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t}\n\n\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\nif (!(tile->pi = jpc_dec_pi_create(dec, tile)))\n{\n\treturn -1;\n}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_malloc(compparms->numstepsizes *\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,\n  int r1, int c1)\n{\n\tint i;\n\n\tif (mat0->data_) {\n\t\tif (!(mat0->flags_ & JAS_MATRIX_REF)) {\n\t\t\tjas_free(mat0->data_);\n\t\t}\n\t\tmat0->data_ = 0;\n\t\tmat0->datasize_ = 0;\n\t}\n\tif (mat0->rows_) {\n\t\tjas_free(mat0->rows_);\n\t\tmat0->rows_ = 0;\n\t}\n\tmat0->flags_ |= JAS_MATRIX_REF;\n\tmat0->numrows_ = r1 - r0 + 1;\n\tmat0->numcols_ = c1 - c0 + 1;\n\tmat0->maxrows_ = mat0->numrows_;\n\tmat0->rows_ = jas_malloc(mat0->maxrows_ * sizeof(jas_seqent_t *));\n\tfor (i = 0; i < mat0->numrows_; ++i) {\n\t\tmat0->rows_[i] = mat1->rows_[r0 + i] + c0;\n\t}\n\n\tmat0->xstart_ = mat1->xstart_ + c0;\n\tmat0->ystart_ = mat1->ystart_ + r0;\n\tmat0->xend_ = mat0->xstart_ + mat0->numcols_;\n\tmat0->yend_ = mat0->ystart_ + mat0->numrows_;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_cmpxformseq_resize(jas_cmpxformseq_t *pxformseq, int n)\n{\n\tjas_cmpxform_t **p;\n\tassert(n >= pxformseq->numpxforms);\n\tp = (!pxformseq->pxforms) ? jas_malloc(n * sizeof(jas_cmpxform_t *)) :\n\t  jas_realloc(pxformseq->pxforms, n * sizeof(jas_cmpxform_t *));\n\tif (!p) {\n\t\treturn -1;\n\t}\n\tpxformseq->pxforms = p;\n\tpxformseq->maxpxforms = n;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len * sizeof(unsigned char)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_malloc(image->maxcmpts_ *\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len * sizeof(unsigned char)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_malloc(poc->numpchgs * sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_enc_band_t *band_create(jpc_enc_band_t *band, jpc_enc_cp_t *cp,\n  jpc_enc_rlvl_t *rlvl, jpc_tsfb_band_t *bandinfos)\n{\n\tuint_fast16_t bandno;\n\tuint_fast16_t gblbandno;\n\tuint_fast16_t rlvlno;\n\tjpc_tsfb_band_t *bandinfo;\n\tjpc_enc_tcmpt_t *tcmpt;\n\tuint_fast32_t prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttcmpt = rlvl->tcmpt;\n\tband->data = 0;\n\tband->prcs = 0;\n\tband->rlvl = rlvl;\n\n\t/* Deduce the resolution level and band number. */\n\trlvlno = rlvl - rlvl->tcmpt->rlvls;\n\tbandno = band - rlvl->bands;\n\tgblbandno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1);\n\n\tbandinfo = &bandinfos[gblbandno];\n\nif (bandinfo->xstart != bandinfo->xend && bandinfo->ystart != bandinfo->yend) {\n\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\tgoto error;\n\t}\n\tjas_seq2d_bindsub(band->data, tcmpt->data, bandinfo->locxstart,\n\t  bandinfo->locystart, bandinfo->locxend, bandinfo->locyend);\n\tjas_seq2d_setshift(band->data, bandinfo->xstart, bandinfo->ystart);\n}\n\tband->orient = bandinfo->orient;\n\tband->analgain = JPC_NOMINALGAIN(cp->tccp.qmfbid, tcmpt->numrlvls, rlvlno,\n\t  band->orient);\n\tband->numbps = 0;\n\tband->absstepsize = 0;\n\tband->stepsize = 0;\n\tband->synweight = bandinfo->synenergywt;\n\nif (band->data) {\n\tif (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_enc_prc_t)))) {\n\t\tgoto error;\n\t}\n\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,\n\t  ++prc) {\n\t\tprc->cblks = 0;\n\t\tprc->incltree = 0;\n\t\tprc->nlibtree = 0;\n\t\tprc->savincltree = 0;\n\t\tprc->savnlibtree = 0;\n\t\tprc->band = band;\n\t}\n\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,\n\t  ++prc) {\n\t\tif (!prc_create(prc, cp, band)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n}\n\n\treturn band;\n\nerror:\n\tband_destroy(band);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint, jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) != JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans : JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint, jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >= dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_malloc(dec->numchans * sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_malloc(pclrd->numlutents * sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno, pclrd->numlutents, lutents, JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type, dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_cmshapmatlut_invert(jas_cmshapmatlut_t *invlut,\n  jas_cmshapmatlut_t *lut, int n)\n{\n\tint i;\n\tint j;\n\tint k;\n\tjas_cmreal_t ax;\n\tjas_cmreal_t ay;\n\tjas_cmreal_t bx;\n\tjas_cmreal_t by;\n\tjas_cmreal_t sx;\n\tjas_cmreal_t sy;\n\tassert(n >= 2);\n\tif (invlut->data) {\n\t\tjas_free(invlut->data);\n\t\tinvlut->data = 0;\n\t}\n\t/* The sample values should be nondecreasing. */\n\tfor (i = 1; i < lut->size; ++i) {\n\t\tif (lut->data[i - 1] > lut->data[i]) {\n\t\t\tassert(0);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(invlut->data = jas_malloc(n * sizeof(jas_cmreal_t))))\n\t\treturn -1;\n\tinvlut->size = n;\n\tfor (i = 0; i < invlut->size; ++i) {\n\t\tsy = ((double) i) / (invlut->size - 1);\n\t\tsx = 1.0;\n\t\tfor (j = 0; j < lut->size; ++j) {\n\t\t\tay = lut->data[j];\n\t\t\tif (sy == ay) {\n\t\t\t\tfor (k = j + 1; k < lut->size; ++k) {\n\t\t\t\t\tby = lut->data[k];\n\t\t\t\t\tif (by != sy)\n\t\t\t\t\t\tbreak;\n#if 0\nassert(0);\n#endif\n\t\t\t\t}\n\t\t\t\tif (k < lut->size) {\n\t\t\t\t\t--k;\n\t\t\t\t\tax = ((double) j) / (lut->size - 1);\n\t\t\t\t\tbx = ((double) k) / (lut->size - 1);\n\t\t\t\t\tsx = (ax + bx) / 2.0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < lut->size - 1) {\n\t\t\t\tby = lut->data[j + 1];\n\t\t\t\tif (sy > ay && sy < by) {\n\t\t\t\t\tax = ((double) j) / (lut->size - 1);\n\t\t\t\t\tbx = ((double) j + 1) / (lut->size - 1);\n\t\t\t\t\tsx = ax +\n\t\t\t\t\t  (sy - ay) / (by - ay) * (bx - ax);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinvlut->data[i] = sx;\n\t}\n#if 0\nfor (i=0;i<lut->size;++i)\n\tjas_eprintf(\"lut[%d]=%f \", i, lut->data[i]);\nfor (i=0;i<invlut->size;++i)\n\tjas_eprintf(\"invlut[%d]=%f \", i, invlut->data[i]);\n#endif\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_malloc(cstate->numcomps * sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jp2_encode(jas_image_t *image, jas_stream_t *out, char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\njas_iccprof_t *iccprof;\njas_stream_t *iccstream;\nint pos;\nint needcdef;\nint prec;\nint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts *\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\ticcprof = jas_iccprof_createfromcmprof(jas_image_cmprof(image));\n\t\tassert(iccprof);\n\t\ticcstream = jas_stream_memopen(0, 0);\n\t\tassert(iccstream);\n\t\tif (jas_iccprof_save(iccprof, iccstream))\n\t\t\tabort();\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0)\n\t\t\tabort();\n\t\tcolr->iccplen = pos;\n\t\tcolr->iccp = jas_malloc(pos);\n\t\tassert(colr->iccp);\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) != colr->iccplen)\n\t\t\tabort();\n\t\tjas_stream_close(iccstream);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_join_row(jpc_fix_t *a, int numcols, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numcols, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numcols + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\t++srcptr;\n\t\t++dstptr;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol];\n\tdstptr = &a[1 - parity];\n\tn = numcols - hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2;\n\t\t++srcptr;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2;\n\t\t++srcptr;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc(streamlist->streams,\n\t\t  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int tileno)\n{\n\tjpc_enc_tile_t *tile;\n\tuint_fast32_t htileno;\n\tuint_fast32_t vtileno;\n\tuint_fast16_t lyrno;\n\tuint_fast16_t cmptno;\n\tjpc_enc_tcmpt_t *tcmpt;\n\n\tif (!(tile = jas_malloc(sizeof(jpc_enc_tile_t)))) {\n\t\tgoto error;\n\t}\n\n\t/* Initialize a few members used in error recovery. */\n\ttile->tcmpts = 0;\n\ttile->lyrsizes = 0;\n\ttile->numtcmpts = cp->numcmpts;\n\ttile->pi = 0;\n\n\ttile->tileno = tileno;\n\thtileno = tileno % cp->numhtiles;\n\tvtileno = tileno / cp->numhtiles;\n\n\t/* Calculate the coordinates of the top-left and bottom-right\n\t  corners of the tile. */\n\ttile->tlx = JAS_MAX(cp->tilegrdoffx + htileno * cp->tilewidth,\n\t  cp->imgareatlx);\n\ttile->tly = JAS_MAX(cp->tilegrdoffy + vtileno * cp->tileheight,\n\t  cp->imgareatly);\n\ttile->brx = JAS_MIN(cp->tilegrdoffx + (htileno + 1) * cp->tilewidth,\n\t  cp->refgrdwidth);\n\ttile->bry = JAS_MIN(cp->tilegrdoffy + (vtileno + 1) * cp->tileheight,\n\t  cp->refgrdheight);\n\n\t/* Initialize some tile coding parameters. */\n\ttile->intmode = cp->tcp.intmode;\n\ttile->csty = cp->tcp.csty;\n\ttile->prg = cp->tcp.prg;\n\ttile->mctid = cp->tcp.mctid;\n\n\ttile->numlyrs = cp->tcp.numlyrs;\n\tif (!(tile->lyrsizes = jas_malloc(tile->numlyrs *\n\t  sizeof(uint_fast32_t)))) {\n\t\tgoto error;\n\t}\n\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\ttile->lyrsizes[lyrno] = 0;\n\t}\n\n\t/* Allocate an array for the per-tile-component information. */\n\tif (!(tile->tcmpts = jas_malloc(cp->numcmpts * sizeof(jpc_enc_tcmpt_t)))) {\n\t\tgoto error;\n\t}\n\t/* Initialize a few members critical for error recovery. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\ttcmpt->rlvls = 0;\n\t\ttcmpt->tsfb = 0;\n\t\ttcmpt->data = 0;\n\t}\n\t/* Initialize the per-tile-component information. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\tif (!tcmpt_create(tcmpt, cp, image, tile)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Initialize the synthesis weights for the MCT. */\n\tswitch (tile->mctid) {\n\tcase JPC_MCT_RCT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0000));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(3.2584));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(2.4755));\n\t\tbreak;\n\tdefault:\n\tcase JPC_MCT_NONE:\n\t\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t\t  ++cmptno, ++tcmpt) {\n\t\t\ttcmpt->synweight = JPC_FIX_ONE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(tile->pi = jpc_enc_pi_create(cp, tile))) {\n\t\tgoto error;\n\t}\n\n\treturn tile;\n\nerror:\n\n\tif (tile) {\n\t\tjpc_enc_tile_destroy(tile);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv)\n{\n\tint nplh[JPC_TAGTREE_MAXDEPTH];\n\tint nplv[JPC_TAGTREE_MAXDEPTH];\n\tjpc_tagtreenode_t *node;\n\tjpc_tagtreenode_t *parentnode;\n\tjpc_tagtreenode_t *parentnode0;\n\tjpc_tagtree_t *tree;\n\tint i;\n\tint j;\n\tint k;\n\tint numlvls;\n\tint n;\n\n\tassert(numleafsh > 0 && numleafsv > 0);\n\n\tif (!(tree = jpc_tagtree_alloc())) {\n\t\treturn 0;\n\t}\n\ttree->numleafsh_ = numleafsh;\n\ttree->numleafsv_ = numleafsv;\n\n\tnumlvls = 0;\n\tnplh[0] = numleafsh;\n\tnplv[0] = numleafsv;\n\tdo {\n\t\tn = nplh[numlvls] * nplv[numlvls];\n\t\tnplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;\n\t\tnplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;\n\t\ttree->numnodes_ += n;\n\t\t++numlvls;\n\t} while (n > 1);\n\n\tif (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {\n\t\treturn 0;\n\t}\n\n\t/* Initialize the parent links for all nodes in the tree. */\n\n\tnode = tree->nodes_;\n\tparentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];\n\tparentnode0 = parentnode;\n\n\tfor (i = 0; i < numlvls - 1; ++i) {\n\t\tfor (j = 0; j < nplv[i]; ++j) {\n\t\t\tk = nplh[i];\n\t\t\twhile (--k >= 0) {\n\t\t\t\tnode->parent_ = parentnode;\n\t\t\t\t++node;\n\t\t\t\tif (--k >= 0) {\n\t\t\t\t\tnode->parent_ = parentnode;\n\t\t\t\t\t++node;\n\t\t\t\t}\n\t\t\t\t++parentnode;\n\t\t\t}\n\t\t\tif ((j & 1) || j == nplv[i] - 1) {\n\t\t\t\tparentnode0 = parentnode;\n\t\t\t} else {\n\t\t\t\tparentnode = parentnode0;\n\t\t\t\tparentnode0 += nplh[i];\n\t\t\t}\n\t\t}\n\t}\n\tnode->parent_ = 0;\n\n\t/* Initialize the data values to something sane. */\n\n\tjpc_tagtree_reset(tree);\n\n\treturn tree;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {\n\t\treturn 0;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tjas_free(cp->ccps);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)\n{\n\tint i;\n\tint newmaxpchgs;\n\tjpc_pchg_t **newpchgs;\n\tif (pchgno < 0) {\n\t\tpchgno = pchglist->numpchgs;\n\t}\n\tif (pchglist->numpchgs >= pchglist->maxpchgs) {\n\t\tnewmaxpchgs = pchglist->maxpchgs + 128;\n\t\tif (!(newpchgs = jas_realloc(pchglist->pchgs, newmaxpchgs * sizeof(jpc_pchg_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tpchglist->maxpchgs = newmaxpchgs;\n\t\tpchglist->pchgs = newpchgs;\n\t}\n\tfor (i = pchglist->numpchgs; i > pchgno; --i) {\n\t\tpchglist->pchgs[i] = pchglist->pchgs[i - 1];\n\t}\n\tpchglist->pchgs[pchgno] = pchg;\n\t++pchglist->numpchgs;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_malloc(ms->len * sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jpc_enc_enccblk(jpc_enc_t *enc, jas_stream_t *out, jpc_enc_tcmpt_t *tcmpt, jpc_enc_band_t *band, jpc_enc_cblk_t *cblk)\n{\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *endpasses;\n\tint bitpos;\n\tint n;\n\tint adjust;\n\tint ret;\n\tint passtype;\n\tint t;\n\tjpc_bitstream_t *bout;\n\tjpc_enc_pass_t *termpass;\n\tjpc_enc_rlvl_t *rlvl;\n\tint vcausal;\n\tint segsym;\n\tint termmode;\n\tint c;\n\n\tbout = 0;\n\trlvl = band->rlvl;\n\n\tcblk->stream = jas_stream_memopen(0, 0);\n\tassert(cblk->stream);\n\tcblk->mqenc = jpc_mqenc_create(JPC_NUMCTXS, cblk->stream);\n\tassert(cblk->mqenc);\n\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\n\tcblk->numpasses = (cblk->numbps > 0) ? (3 * cblk->numbps - 2) : 0;\n\tif (cblk->numpasses > 0) {\n\t\tcblk->passes = jas_malloc(cblk->numpasses * sizeof(jpc_enc_pass_t));\n\t\tassert(cblk->passes);\n\t} else {\n\t\tcblk->passes = 0;\n\t}\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tpass->start = 0;\n\t\tpass->end = 0;\n\t\tpass->term = JPC_ISTERMINATED(pass - cblk->passes, 0, cblk->numpasses, (tcmpt->cblksty & JPC_COX_TERMALL) != 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->type = JPC_SEGTYPE(pass - cblk->passes, 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->lyrno = -1;\nif (pass == endpasses - 1) {\nassert(pass->term == 1);\n\tpass->term = 1;\n}\n\t}\n\n\tcblk->flags = jas_matrix_create(jas_matrix_numrows(cblk->data) + 2,\n\t  jas_matrix_numcols(cblk->data) + 2);\n\tassert(cblk->flags);\n\n\n\tbitpos = cblk->numbps - 1;\n\tpass = cblk->passes;\n\tn = cblk->numpasses;\n\twhile (--n >= 0) {\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t/* NOP */\n\t\t} else {\n\t\t\tassert(pass->type == JPC_SEG_RAW);\n\t\t\tif (!bout) {\n\t\t\t\tbout = jpc_bitstream_sopen(cblk->stream, \"w\");\n\t\t\t\tassert(bout);\n\t\t\t}\n\t\t}\n\n#if 1\n\t\tpasstype = (pass - cblk->passes + 2) % 3;\n#else\n\t\tpasstype = JPC_PASSTYPE(pass - cblk->passes + 2);\n#endif\n\t\tpass->start = jas_stream_tell(cblk->stream);\n#if 0\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\t\tassert(bitpos >= 0);\n\t\tvcausal = (tcmpt->cblksty & JPC_COX_VSC) != 0;\n\t\tsegsym = (tcmpt->cblksty & JPC_COX_SEGSYM) != 0;\n\t\tif (pass->term) {\n\t\t\ttermmode = ((tcmpt->cblksty & JPC_COX_PTERM) ?\n\t\t\t  JPC_MQENC_PTERM : JPC_MQENC_DEFTERM) + 1;\n\t\t} else {\n\t\t\ttermmode = 0;\n\t\t}\n\t\tswitch (passtype) {\n\t\tcase JPC_SIGPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encsigpass(cblk->mqenc,\n\t\t\t  bitpos, band->orient, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec) :\n\t\t\t  jpc_encrawsigpass(bout, bitpos, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_REFPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encrefpass(cblk->mqenc,\n\t\t\t  bitpos, vcausal, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec) : jpc_encrawrefpass(bout, bitpos,\n\t\t\t  vcausal, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_CLNPASS:\n\t\t\tassert(pass->type == JPC_SEG_MQ);\n\t\t\tret = jpc_encclnpass(cblk->mqenc, bitpos, band->orient,\n\t\t\t  vcausal, segsym, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\tif (pass->term) {\n\t\t\t\tjpc_mqenc_init(cblk->mqenc);\n\t\t\t}\n\t\t\tjpc_mqenc_getstate(cblk->mqenc, &pass->mqencstate);\n\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\tif (tcmpt->cblksty & JPC_COX_RESET) {\n\t\t\t\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pass->term) {\n\t\t\t\tif (jpc_bitstream_pending(bout)) {\n\t\t\t\t\tjpc_bitstream_outalign(bout, 0x2a);\n\t\t\t\t}\n\t\t\t\tjpc_bitstream_close(bout);\n\t\t\t\tbout = 0;\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\t} else {\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream) +\n\t\t\t\t  jpc_bitstream_pending(bout);\n/* NOTE - This will not work.  need to adjust by # of pending output bytes */\n\t\t\t}\n\t\t}\n#if 0\n/* XXX - This assertion fails sometimes when various coding modes are used.\nThis seems to be harmless, but why does it happen at all? */\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\n\t\tpass->wmsedec = jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->absstepsize) * jpc_fixtodbl(band->absstepsize) *\n\t\t  ((double) (1 << bitpos)) * ((double)(1 << bitpos)) *\n\t\t  jpc_fixtodbl(pass->nmsedec);\n\t\tpass->cumwmsedec = pass->wmsedec;\n\t\tif (pass != cblk->passes) {\n\t\t\tpass->cumwmsedec += pass[-1].cumwmsedec;\n\t\t}\n\t\tif (passtype == JPC_CLNPASS) {\n\t\t\t--bitpos;\n\t\t}\n\t\t++pass;\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tn = 0;\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tif (pass->start < n) {\n\t\t\tpass->start = n;\n\t\t}\n\t\tif (pass->end < n) {\n\t\t\tpass->end = n;\n\t\t}\n\t\tif (!pass->term) {\n\t\t\ttermpass = pass;\n\t\t\twhile (termpass - pass < cblk->numpasses &&\n\t\t\t  !termpass->term) {\n\t\t\t\t++termpass;\n\t\t\t}\n\t\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t\tt = (pass->mqencstate.lastbyte == 0xff) ? 1 : 0;\n\t\t\t\tif (pass->mqencstate.ctreg >= 5) {\n\t\t\t\t\tadjust = 4 + t;\n\t\t\t\t} else {\n\t\t\t\t\tadjust = 5 + t;\n\t\t\t\t}\n\t\t\t\tpass->end += adjust;\n\t\t\t}\n\t\t\tif (pass->end > termpass->end) {\n\t\t\t\tpass->end = termpass->end;\n\t\t\t}\n\t\t\tif ((c = getthebyte(cblk->stream, pass->end - 1)) == EOF) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tif (c == 0xff) {\n\t\t\t\t++pass->end;\n\t\t\t}\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t} else {\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t}\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tif (bout) {\n\t\tjpc_bitstream_close(bout);\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_enc_cp_t *cp_create(char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tint cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_malloc(cp->numcmpts * sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_malloc((tcp->numlyrs - 1) *\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc(tab->ents, maxents *\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_iccattrtab_resize(jas_iccattrtab_t *tab, int maxents)\n{\n\tjas_iccattr_t *newattrs;\n\tassert(maxents >= tab->numattrs);\n\tnewattrs = tab->attrs ? jas_realloc(tab->attrs, maxents *\n\t  sizeof(jas_iccattr_t)) : jas_malloc(maxents * sizeof(jas_iccattr_t));\n\tif (!newattrs)\n\t\treturn -1;\n\ttab->attrs = newattrs;\n\ttab->maxattrs = maxents;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tcompinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));\n\t\tassert(compinfos);\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tif (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\tif (!(tile->tcomps = jas_malloc(dec->numcomps *\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_malloc(matrix->maxrows_ *\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_malloc(matrix->datasize_ *\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void *jas_calloc(size_t nmemb, size_t size)\n{\n\tvoid *ptr;\n\tsize_t n;\n\tn = nmemb * size;\n\tif (!(ptr = jas_malloc(n * sizeof(char)))) {\n\t\treturn 0;\n\t}\n\tmemset(ptr, 0, n);\n\treturn ptr;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "char *jas_strdup(const char *s)\n{\n\tint n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n * sizeof(char)))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_join_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tsrcptr += stride;\n\t\t++dstptr;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\t*dstptr = *srcptr;\n\t\tdstptr += 2 * stride;\n\t\t++srcptr;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jas_icclut16_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint i;\n\tint j;\n\tint clutsize;\n\tjas_icclut16_t *lut16 = &attrval->data.lut16;\n\tlut16->clut = 0;\n\tlut16->intabs = 0;\n\tlut16->intabsbuf = 0;\n\tlut16->outtabs = 0;\n\tlut16->outtabsbuf = 0;\n\tif (jas_iccgetuint8(in, &lut16->numinchans) ||\n\t  jas_iccgetuint8(in, &lut16->numoutchans) ||\n\t  jas_iccgetuint8(in, &lut16->clutlen) ||\n\t  jas_stream_getc(in) == EOF)\n\t\tgoto error;\n\tfor (i = 0; i < 3; ++i) {\n\t\tfor (j = 0; j < 3; ++j) {\n\t\t\tif (jas_iccgetsint32(in, &lut16->e[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (jas_iccgetuint16(in, &lut16->numintabents) ||\n\t  jas_iccgetuint16(in, &lut16->numouttabents))\n\t\tgoto error;\n\tclutsize = jas_iccpowi(lut16->clutlen, lut16->numinchans) * lut16->numoutchans;\n\tif (!(lut16->clut = jas_malloc(clutsize * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->intabsbuf = jas_malloc(lut16->numinchans *\n\t  lut16->numintabents * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->intabs = jas_malloc(lut16->numinchans *\n\t  sizeof(jas_iccuint16_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut16->numinchans; ++i)\n\t\tlut16->intabs[i] = &lut16->intabsbuf[i * lut16->numintabents];\n\tif (!(lut16->outtabsbuf = jas_malloc(lut16->numoutchans *\n\t  lut16->numouttabents * sizeof(jas_iccuint16_t))) ||\n\t  !(lut16->outtabs = jas_malloc(lut16->numoutchans *\n\t  sizeof(jas_iccuint16_t *))))\n\t\tgoto error;\n\tfor (i = 0; i < lut16->numoutchans; ++i)\n\t\tlut16->outtabs[i] = &lut16->outtabsbuf[i * lut16->numouttabents];\n\tfor (i = 0; i < lut16->numinchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut16->numintabents); ++j) {\n\t\t\tif (jas_iccgetuint16(in, &lut16->intabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < lut16->numoutchans; ++i) {\n\t\tfor (j = 0; j < JAS_CAST(int, lut16->numouttabents); ++j) {\n\t\t\tif (jas_iccgetuint16(in, &lut16->outtabs[i][j]))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < clutsize; ++i) {\n\t\tif (jas_iccgetuint16(in, &lut16->clut[i]))\n\t\t\tgoto error;\n\t}\n\tif (JAS_CAST(int, 44 + 2 * (lut16->numinchans * lut16->numintabents +\n          lut16->numoutchans * lut16->numouttabents +\n          jas_iccpowi(lut16->clutlen, lut16->numinchans) *\n\t  lut16->numoutchans)) != cnt)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tjas_icclut16_destroy(attrval);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_enc_prc_t *prc_create(jpc_enc_prc_t *prc, jpc_enc_cp_t *cp, jpc_enc_band_t *band)\n{\n\tuint_fast32_t prcno;\n\tuint_fast32_t prcxind;\n\tuint_fast32_t prcyind;\n\tuint_fast32_t cbgtlx;\n\tuint_fast32_t cbgtly;\n\tuint_fast32_t tlprctlx;\n\tuint_fast32_t tlprctly;\n\tuint_fast32_t tlcbgtlx;\n\tuint_fast32_t tlcbgtly;\n\tuint_fast16_t rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast32_t tlcblktlx;\n\tuint_fast32_t tlcblktly;\n\tuint_fast32_t brcblkbrx;\n\tuint_fast32_t brcblkbry;\n\tuint_fast32_t cblkno;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_tcmpt_t *tcmpt;\n\n\tprc->cblks = 0;\n\tprc->incltree = 0;\n\tprc->savincltree = 0;\n\tprc->nlibtree = 0;\n\tprc->savnlibtree = 0;\n\n\trlvl = band->rlvl;\n\ttcmpt = rlvl->tcmpt;\nrlvlno = rlvl - tcmpt->rlvls;\n\tprcno = prc - band->prcs;\n\tprcxind = prcno % rlvl->numhprcs;\n\tprcyind = prcno / rlvl->numhprcs;\n\tprc->band = band;\n\ntlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn);\ntlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn);\nif (!rlvlno) {\n\ttlcbgtlx = tlprctlx;\n\ttlcbgtly = tlprctly;\n} else {\n\ttlcbgtlx = JPC_CEILDIVPOW2(tlprctlx, 1);\n\ttlcbgtly = JPC_CEILDIVPOW2(tlprctly, 1);\n}\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of the precinct. */\n\tcbgtlx = tlcbgtlx + (prcxind << rlvl->cbgwidthexpn);\n\tcbgtly = tlcbgtly + (prcyind << rlvl->cbgheightexpn);\n\tprc->tlx = JAS_MAX(jas_seq2d_xstart(band->data), cbgtlx);\n\tprc->tly = JAS_MAX(jas_seq2d_ystart(band->data), cbgtly);\n\tprc->brx = JAS_MIN(jas_seq2d_xend(band->data), cbgtlx +\n\t  (1 << rlvl->cbgwidthexpn));\n\tprc->bry = JAS_MIN(jas_seq2d_yend(band->data), cbgtly +\n\t  (1 << rlvl->cbgheightexpn));\n\n\tif (prc->tlx < prc->brx && prc->tly < prc->bry) {\n\t\t/* The precinct contains at least one code block. */\n\n\t\ttlcblktlx = JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn);\n\t\ttlcblktly = JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn);\n\t\tbrcblkbrx = JPC_CEILTOMULTPOW2(prc->brx, rlvl->cblkwidthexpn);\n\t\tbrcblkbry = JPC_CEILTOMULTPOW2(prc->bry, rlvl->cblkheightexpn);\n\t\tprc->numhcblks = JPC_FLOORDIVPOW2(brcblkbrx - tlcblktlx,\n\t\t  rlvl->cblkwidthexpn);\n\t\tprc->numvcblks = JPC_FLOORDIVPOW2(brcblkbry - tlcblktly,\n\t\t  rlvl->cblkheightexpn);\n\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\n\t\tif (!(prc->incltree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->nlibtree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->savincltree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(prc->savnlibtree = jpc_tagtree_create(prc->numhcblks,\n\t\t  prc->numvcblks))) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_enc_cblk_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t  ++cblkno, ++cblk) {\n\t\t\tcblk->passes = 0;\n\t\t\tcblk->stream = 0;\n\t\t\tcblk->mqenc = 0;\n\t\t\tcblk->data = 0;\n\t\t\tcblk->flags = 0;\n\t\t\tcblk->prc = prc;\n\t\t}\n\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t  ++cblkno, ++cblk) {\n\t\t\tif (!cblk_create(cblk, cp, prc)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* The precinct does not contain any code blocks. */\n\t\tprc->tlx = prc->brx;\n\t\tprc->tly = prc->bry;\n\t\tprc->numcblks = 0;\n\t\tprc->numhcblks = 0;\n\t\tprc->numvcblks = 0;\n\t\tprc->cblks = 0;\n\t\tprc->incltree = 0;\n\t\tprc->nlibtree = 0;\n\t\tprc->savincltree = 0;\n\t\tprc->savnlibtree = 0;\n\t}\n\n\treturn prc;\n\nerror:\n\tprc_destroy(prc);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * JPC_QMFB_COLGRPSIZE * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_dec_tcomp_t *tcomp;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->numcomps = dec->numcomps;\n\tif (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *\n\t\t\t  sizeof(long)))) {\n\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps, cmpt =\n\t  dec->cmpts; compno < pi->numcomps; ++compno, ++tcomp, ++picomp,\n\t  ++cmpt) {\n\t\tpicomp->hsamp = cmpt->hstep;\n\t\tpicomp->vsamp = cmpt->vstep;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->cp->numlyrs;\n\tpi->xstart = tile->xstart;\n\tpi->ystart = tile->ystart;\n\tpi->xend = tile->xend;\n\tpi->yend = tile->yend;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->cp->prgord;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts * sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static jpc_enc_tcmpt_t *tcmpt_create(jpc_enc_tcmpt_t *tcmpt, jpc_enc_cp_t *cp,\n  jas_image_t *image, jpc_enc_tile_t *tile)\n{\n\tuint_fast16_t cmptno;\n\tuint_fast16_t rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast32_t tlx;\n\tuint_fast32_t tly;\n\tuint_fast32_t brx;\n\tuint_fast32_t bry;\n\tuint_fast32_t cmpttlx;\n\tuint_fast32_t cmpttly;\n\tjpc_enc_ccp_t *ccp;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\n\ttcmpt->tile = tile;\n\ttcmpt->tsfb = 0;\n\ttcmpt->data = 0;\n\ttcmpt->rlvls = 0;\n\n\t/* Deduce the component number. */\n\tcmptno = tcmpt - tile->tcmpts;\n\n\tccp = &cp->ccps[cmptno];\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of this tile-component. */\n\ttlx = JPC_CEILDIV(tile->tlx, ccp->sampgrdstepx);\n\ttly = JPC_CEILDIV(tile->tly, ccp->sampgrdstepy);\n\tbrx = JPC_CEILDIV(tile->brx, ccp->sampgrdstepx);\n\tbry = JPC_CEILDIV(tile->bry, ccp->sampgrdstepy);\n\n\t/* Create a sequence to hold the tile-component sample data. */\n\tif (!(tcmpt->data = jas_seq2d_create(tlx, tly, brx, bry))) {\n\t\tgoto error;\n\t}\n\n\t/* Get the image data associated with this tile-component. */\n\tcmpttlx = JPC_CEILDIV(cp->imgareatlx, ccp->sampgrdstepx);\n\tcmpttly = JPC_CEILDIV(cp->imgareatly, ccp->sampgrdstepy);\n\tif (jas_image_readcmpt(image, cmptno, tlx - cmpttlx, tly - cmpttly,\n\t  brx - tlx, bry - tly, tcmpt->data)) {\n\t\tgoto error;\n\t}\n\n\ttcmpt->synweight = 0;\n\ttcmpt->qmfbid = cp->tccp.qmfbid;\n\ttcmpt->numrlvls = cp->tccp.maxrlvls;\n\ttcmpt->numbands = 3 * tcmpt->numrlvls - 2;\n\tif (!(tcmpt->tsfb = jpc_cod_gettsfb(tcmpt->qmfbid, tcmpt->numrlvls - 1))) {\n\t\tgoto error;\n\t}\n\n\tfor (rlvlno = 0; rlvlno < tcmpt->numrlvls; ++rlvlno) {\n\t\ttcmpt->prcwidthexpns[rlvlno] = cp->tccp.prcwidthexpns[rlvlno];\n\t\ttcmpt->prcheightexpns[rlvlno] = cp->tccp.prcheightexpns[rlvlno];\n\t}\n\ttcmpt->cblkwidthexpn = cp->tccp.cblkwidthexpn;\n\ttcmpt->cblkheightexpn = cp->tccp.cblkheightexpn;\n\ttcmpt->cblksty = cp->tccp.cblksty;\n\ttcmpt->csty = cp->tccp.csty;\n\n\ttcmpt->numstepsizes = tcmpt->numbands;\n\tassert(tcmpt->numstepsizes <= JPC_MAXBANDS);\n\tmemset(tcmpt->stepsizes, 0, tcmpt->numstepsizes * sizeof(uint_fast16_t));\n\n\t/* Retrieve information about the various bands. */\n\tjpc_tsfb_getbands(tcmpt->tsfb, jas_seq2d_xstart(tcmpt->data),\n\t  jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data),\n\t  jas_seq2d_yend(tcmpt->data), bandinfos);\n\n\tif (!(tcmpt->rlvls = jas_malloc(tcmpt->numrlvls * sizeof(jpc_enc_rlvl_t)))) {\n\t\tgoto error;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\trlvl->bands = 0;\n\t\trlvl->tcmpt = tcmpt;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\tif (!rlvl_create(rlvl, cp, tcmpt, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn tcmpt;\n\nerror:\n\n\ttcmpt_destroy(tcmpt);\n\treturn 0;\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_ * sizeof(char));\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = (parity) ? hstartcol : (numrows - hstartcol);\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_malloc(lutsize * sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_malloc(pclr->numchans * sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "At many places in the code, jas_malloc or jas_recalloc was being\ninvoked with the size argument being computed in a manner that would not\nallow integer overflow to be detected.  Now, these places in the code\nhave been modified to use special-purpose memory allocation functions\n(e.g., jas_alloc2, jas_alloc3, jas_realloc2) that check for overflow.\nThis should fix many security problems."}
{"func": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "CVE-2008-3522"}
{"func": "static inline int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}", "target": 1, "cwe": [], "message": "netlink: fix overrun in attribute iteration\n\nkmemcheck reported this:\n\n  kmemcheck: Caught 16-bit read from uninitialized memory (f6c1ba30)\n  0500110001508abf050010000500000002017300140000006f72672e66726565\n   i i i i i i i i i i i i i u u u u u u u u u u u u u u u u u u u\n                                   ^\n\n  Pid: 3462, comm: wpa_supplicant Not tainted (2.6.27-rc3-00054-g6397ab9-dirty #13)\n  EIP: 0060:[<c05de64a>] EFLAGS: 00010296 CPU: 0\n  EIP is at nla_parse+0x5a/0xf0\n  EAX: 00000008 EBX: fffffffd ECX: c06f16c0 EDX: 00000005\n  ESI: 00000010 EDI: f6c1ba30 EBP: f6367c6c ESP: c0a11e88\n   DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\n  CR0: 8005003b CR2: f781cc84 CR3: 3632f000 CR4: 000006d0\n  DR0: c0ead9bc DR1: 00000000 DR2: 00000000 DR3: 00000000\n  DR6: ffff4ff0 DR7: 00000400\n   [<c05d4b23>] rtnl_setlink+0x63/0x130\n   [<c05d5f75>] rtnetlink_rcv_msg+0x165/0x200\n   [<c05ddf66>] netlink_rcv_skb+0x76/0xa0\n   [<c05d5dfe>] rtnetlink_rcv+0x1e/0x30\n   [<c05dda21>] netlink_unicast+0x281/0x290\n   [<c05ddbe9>] netlink_sendmsg+0x1b9/0x2b0\n   [<c05beef2>] sock_sendmsg+0xd2/0x100\n   [<c05bf945>] sys_sendto+0xa5/0xd0\n   [<c05bf9a6>] sys_send+0x36/0x40\n   [<c05c03d6>] sys_socketcall+0x1e6/0x2c0\n   [<c020353b>] sysenter_do_call+0x12/0x3f\n   [<ffffffff>] 0xffffffff\n\nThis is the line in nla_ok():\n\n  /**\n   * nla_ok - check if the netlink attribute fits into the remaining bytes\n   * @nla: netlink attribute\n   * @remaining: number of bytes remaining in attribute stream\n   */\n  static inline int nla_ok(const struct nlattr *nla, int remaining)\n  {\n          return remaining >= sizeof(*nla) &&\n                 nla->nla_len >= sizeof(*nla) &&\n                 nla->nla_len <= remaining;\n  }\n\nIt turns out that remaining can become negative due to alignment in\nnla_next(). But GCC promotes \"remaining\" to unsigned in the test\nagainst sizeof(*nla) above. Therefore the test succeeds, and the\nnla_for_each_attr() may access memory outside the received buffer.\n\nA short example illustrating this point is here:\n\n  #include <stdio.h>\n\n  main(void)\n  {\n          printf(\"%d\\n\", -1 >= sizeof(int));\n  }\n\n...which prints \"1\".\n\nThis patch adds a cast in front of the sizeof so that GCC will make\na signed comparison and fix the illegal memory dereference. With the\npatch applied, there is no kmemcheck report.\n\nSigned-off-by: Vegard Nossum <vegard.nossum@gmail.com>\nAcked-by: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\t/*\n\t * make sure the data in this buffer is uptodate\n\t */\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\n\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\n\t\t/*\n\t\t * This will also lock the page\n\t\t */\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\n\t\t/*\n\t\t * prepare_write() may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again.\n\t\t */\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\n\t\tgoto out_ret;\n\t}\n\n\tif (buf->page != page) {\n\t\t/*\n\t\t * Careful, ->map() uses KM_USER0!\n\t\t */\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Partial write has happened, so 'ret' already initialized by\n\t\t * number of bytes written, Where is nothing we have to do here.\n\t\t */\n\t} else\n\t\tret = this_len;\n\t/*\n\t * Return the number of bytes written and mark page as\n\t * accessed, we are now done!\n\t */\n\tmark_page_accessed(page);\nout:\n\tpage_cache_release(page);\n\tunlock_page(page);\nout_ret:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "splice: fix bad unlock_page() in error case\n\nIf add_to_page_cache_lru() fails, the page will not be locked. But\nsplice jumps to an error path that does a page release and unlock,\ncausing a BUG() in unlock_page().\n\nFix this by adding one more label that just releases the page. This bug\nwas actually triggered on EL5 by gurudas pai <gurudas.pai@oracle.com>\nusing fio.\n\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_hmacalgo *hmacs;\n\tint err;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = kmalloc(optlen, GFP_KERNEL);\n\tif (!hmacs)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(hmacs, optval, optlen)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hmacs->shmac_num_idents == 0 ||\n\t    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-200"], "message": "sctp: fix random memory dereference with SCTP_HMAC_IDENT option.\n\nThe number of identifiers needs to be checked against the option\nlength.  Also, the identifier index provided needs to be verified\nto make sure that it doesn't exceed the bounds of the array.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t/* Scan the list looking for unsupported id.  Also make sure that\n\t * SHA1 is specified.\n\t */\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "sctp: fix random memory dereference with SCTP_HMAC_IDENT option.\n\nThe number of identifiers needs to be checked against the option\nlength.  Also, the identifier index provided needs to be verified\nto make sure that it doesn't exceed the bounds of the array.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Remove suid/sgid bits on [f]truncate()\n\n.. to match what we do on write().  This way, people who write to files\nby using [f]truncate + writable mmap have the same semantics as if they\nwere using the write() family of system calls.\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);\n\tif (ret > 0) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t*ppos += ret;\n\n\t\t/*\n\t\t * If file or inode is SYNC and we actually wrote some data,\n\t\t * sync it.\n\t\t */\n\t\tif (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {\n\t\t\tint err;\n\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\terr = generic_osync_inode(inode, mapping,\n\t\t\t\t\t\t  OSYNC_METADATA|OSYNC_DATA);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] Remove SUID when splicing into an inode\n\nOriginally from Mark Fasheh <mark.fasheh@oracle.com>\n\ngeneric_file_splice_write() does not remove S_ISUID or S_ISGID. This is\ninconsistent with the way we generally write to files.\n\nSigned-off-by: Mark Fasheh <mark.fasheh@oracle.com>\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>"}
{"func": "generic_file_splice_write_nolock(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\t loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tssize_t ret;\n\tint err;\n\n\tret = __splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\n\t\t/*\n\t\t * If file or inode is SYNC and we actually wrote some data,\n\t\t * sync it.\n\t\t */\n\t\tif (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {\n\t\t\terr = generic_osync_inode(inode, mapping,\n\t\t\t\t\t\t  OSYNC_METADATA|OSYNC_DATA);\n\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "[PATCH] Remove SUID when splicing into an inode\n\nOriginally from Mark Fasheh <mark.fasheh@oracle.com>\n\ngeneric_file_splice_write() does not remove S_ISUID or S_ISGID. This is\ninconsistent with the way we generally write to files.\n\nSigned-off-by: Mark Fasheh <mark.fasheh@oracle.com>\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>"}
{"func": "_dbus_validate_signature_with_reason (const DBusString *type_str,\n                                      int               type_pos,\n                                      int               len)\n{\n  const unsigned char *p;\n  const unsigned char *end;\n  int last;\n  int struct_depth;\n  int array_depth;\n  int dict_entry_depth;\n  DBusValidity result;\n\n  int element_count;\n  DBusList *element_count_stack;\n\n  result = DBUS_VALID;\n  element_count_stack = NULL;\n\n  if (!_dbus_list_append (&element_count_stack, _DBUS_INT_TO_POINTER (0)))\n    {\n      result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n      goto out;\n    }\n\n  _dbus_assert (type_str != NULL);\n  _dbus_assert (type_pos < _DBUS_INT32_MAX - len);\n  _dbus_assert (len >= 0);\n  _dbus_assert (type_pos >= 0);\n\n  if (len > DBUS_MAXIMUM_SIGNATURE_LENGTH)\n    {\n      result = DBUS_INVALID_SIGNATURE_TOO_LONG;\n      goto out;\n    }\n\n  p = _dbus_string_get_const_data_len (type_str, type_pos, 0);\n\n  end = _dbus_string_get_const_data_len (type_str, type_pos + len, 0);\n  struct_depth = 0;\n  array_depth = 0;\n  dict_entry_depth = 0;\n  last = DBUS_TYPE_INVALID;\n\n  while (p != end)\n    {\n      switch (*p)\n        {\n        case DBUS_TYPE_BYTE:\n        case DBUS_TYPE_BOOLEAN:\n        case DBUS_TYPE_INT16:\n        case DBUS_TYPE_UINT16:\n        case DBUS_TYPE_INT32:\n        case DBUS_TYPE_UINT32:\n        case DBUS_TYPE_INT64:\n        case DBUS_TYPE_UINT64:\n        case DBUS_TYPE_DOUBLE:\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n        case DBUS_TYPE_VARIANT:\n          break;\n\n        case DBUS_TYPE_ARRAY:\n          array_depth += 1;\n          if (array_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_ARRAY_RECURSION;\n              goto out;\n            }\n          break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n          struct_depth += 1;\n\n          if (struct_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_STRUCT_RECURSION;\n              goto out;\n            }\n          \n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_STRUCT_END_CHAR:\n          if (struct_depth == 0)\n            {\n              result = DBUS_INVALID_STRUCT_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n\n          if (last == DBUS_STRUCT_BEGIN_CHAR)\n            {\n              result = DBUS_INVALID_STRUCT_HAS_NO_FIELDS;\n              goto out;\n            }\n\n          _dbus_list_pop_last (&element_count_stack);\n\n          struct_depth -= 1;\n          break;\n\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n          if (last != DBUS_TYPE_ARRAY)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY;\n              goto out;\n            }\n            \n          dict_entry_depth += 1;\n\n          if (dict_entry_depth > DBUS_MAXIMUM_TYPE_RECURSION_DEPTH)\n            {\n              result = DBUS_INVALID_EXCEEDED_MAXIMUM_DICT_ENTRY_RECURSION;\n              goto out;\n            }\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (0)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n\n          break;\n\n        case DBUS_DICT_ENTRY_END_CHAR:\n          if (dict_entry_depth == 0)\n            {\n              result = DBUS_INVALID_DICT_ENTRY_ENDED_BUT_NOT_STARTED;\n              goto out;\n            }\n            \n          dict_entry_depth -= 1;\n\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          if (element_count != 2)\n            {\n              if (element_count == 0)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;\n              else if (element_count == 1)\n                result = DBUS_INVALID_DICT_ENTRY_HAS_ONLY_ONE_FIELD;\n              else\n                result = DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS;\n              \n              goto out;\n            }\n          break;\n          \n        case DBUS_TYPE_STRUCT:     /* doesn't appear in signatures */\n        case DBUS_TYPE_DICT_ENTRY: /* ditto */\n        default:\n          result = DBUS_INVALID_UNKNOWN_TYPECODE;\n\t  goto out;\n        }\n\n      if (*p != DBUS_TYPE_ARRAY && \n          *p != DBUS_DICT_ENTRY_BEGIN_CHAR && \n\t  *p != DBUS_STRUCT_BEGIN_CHAR) \n        {\n          element_count = \n            _DBUS_POINTER_TO_INT (_dbus_list_pop_last (&element_count_stack));\n\n          ++element_count;\n\n          if (!_dbus_list_append (&element_count_stack, \n                             _DBUS_INT_TO_POINTER (element_count)))\n            {\n              result = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;\n              goto out;\n            }\n        }\n      \n      if (array_depth > 0)\n        {\n          if (*p == DBUS_TYPE_ARRAY && p != end)\n            {\n\t       const char *p1;\n\t       p1 = p + 1;\n               if (*p1 == DBUS_STRUCT_END_CHAR ||\n                   *p1 == DBUS_DICT_ENTRY_END_CHAR)\n                 {\n                   result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n                   goto out;\n                 }\n            }\n          else\n\t    {\n              array_depth = 0;\n\t    }\n        }\n\n      if (last == DBUS_DICT_ENTRY_BEGIN_CHAR &&\n          !dbus_type_is_basic (*p))\n        {\n          result = DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE;\n          goto out;\n        }\n        \n      last = *p;\n      ++p;\n    }\n\n\n  if (array_depth > 0)\n    {\n      result = DBUS_INVALID_MISSING_ARRAY_ELEMENT_TYPE;\n      goto out;\n    }\n    \n  if (struct_depth > 0)\n    {\n       result = DBUS_INVALID_STRUCT_STARTED_BUT_NOT_ENDED;\n       goto out;\n    }\n    \n  if (dict_entry_depth > 0)\n    {\n      result =  DBUS_INVALID_DICT_ENTRY_STARTED_BUT_NOT_ENDED;\n      goto out;\n    }\n    \n  _dbus_assert (last != DBUS_TYPE_ARRAY);\n  _dbus_assert (last != DBUS_STRUCT_BEGIN_CHAR);\n  _dbus_assert (last != DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n  result = DBUS_VALID;\n\nout:\n  _dbus_list_clear (&element_count_stack);\n  return result;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Bug 17803: Panic from dbus_signature_validate\n\n\t* dbus/dbus-marshal-validate.c: Ensure we validate\n\ta basic type before calling is_basic on it.\n\t* dbus-marshal-validate-util.c: Test."}
{"func": "_dbus_marshal_validate_test (void)\n{\n  DBusString str;\n  int i;\n\n  const char *valid_paths[] = {\n    \"/\",\n    \"/foo/bar\",\n    \"/foo\",\n    \"/foo/bar/baz\"\n  };\n  const char *invalid_paths[] = {\n    \"bar\",\n    \"bar/baz\",\n    \"/foo/bar/\",\n    \"/foo/\"\n    \"foo/\",\n    \"boo//blah\",\n    \"//\",\n    \"///\",\n    \"foo///blah/\",\n    \"Hello World\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_interfaces[] = {\n    \"org.freedesktop.Foo\",\n    \"Bar.Baz\",\n    \"Blah.Blah.Blah.Blah.Blah\",\n    \"a.b\",\n    \"a.b.c.d.e.f.g\",\n    \"a0.b1.c2.d3.e4.f5.g6\",\n    \"abc123.foo27\"\n  };\n  const char *invalid_interfaces[] = {\n    \".\",\n    \"\",\n    \"..\",\n    \".Foo.Bar\",\n    \"..Foo.Bar\",\n    \"Foo.Bar.\",\n    \"Foo.Bar..\",\n    \"Foo\",\n    \"9foo.bar.baz\",\n    \"foo.bar..baz\",\n    \"foo.bar...baz\",\n    \"foo.bar.b..blah\",\n    \":\",\n    \":0-1\",\n    \"10\",\n    \":11.34324\",\n    \"0.0.0\",\n    \"0..0\",\n    \"foo.Bar.%\",\n    \"foo.Bar!!\",\n    \"!Foo.bar.bz\",\n    \"foo.$.blah\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_unique_names[] = {\n    \":0\",\n    \":a\",\n    \":\",\n    \":.a\",\n    \":.1\",\n    \":0.1\",\n    \":000.2222\",\n    \":.blah\",\n    \":abce.freedesktop.blah\"\n  };\n  const char *invalid_unique_names[] = {\n    //\":-\",\n    \":!\",\n    //\":0-10\",\n    \":blah.\",\n    \":blah.\",\n    \":blah..org\",\n    \":blah.org..\",\n    \":..blah.org\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_members[] = {\n    \"Hello\",\n    \"Bar\",\n    \"foobar\",\n    \"_foobar\",\n    \"foo89\"\n  };\n\n  const char *invalid_members[] = {\n    \"9Hello\",\n    \"10\",\n    \"1\",\n    \"foo-bar\",\n    \"blah.org\",\n    \".blah\",\n    \"blah.\",\n    \"Hello.\",\n    \"!foo\",\n    \"\",\n    \"   \",\n    \"foo bar\"\n  };\n\n  const char *valid_signatures[] = {\n    \"\",\n    \"sss\",\n    \"i\",\n    \"b\"\n  };\n\n  const char *invalid_signatures[] = {\n    \" \",\n    \"not a valid signature\",\n    \"123\",\n    \".\",\n    \"(\"\n  };\n\n  /* Signature with reason */\n\n  run_validity_tests (signature_tests, _DBUS_N_ELEMENTS (signature_tests),\n                      _dbus_validate_signature_with_reason);\n\n  /* Path validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_paths))\n    {\n      _dbus_string_init_const (&str, valid_paths[i]);\n\n      if (!_dbus_validate_path (&str, 0,\n                                _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been valid\\n\", valid_paths[i]);\n          _dbus_assert_not_reached (\"invalid path\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_paths))\n    {\n      _dbus_string_init_const (&str, invalid_paths[i]);\n\n      if (_dbus_validate_path (&str, 0,\n                               _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Path \\\"%s\\\" should have been invalid\\n\", invalid_paths[i]);\n          _dbus_assert_not_reached (\"valid path\");\n        }\n\n      ++i;\n    }\n\n  /* Interface validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_interface (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid interface\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n      if (_dbus_validate_interface (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Interface \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n          _dbus_assert_not_reached (\"valid interface\");\n        }\n\n      ++i;\n    }\n\n  /* Bus name validation (check that valid interfaces are valid bus names,\n   * and invalid interfaces are invalid services except if they start with ':')\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid bus name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_bus_name (&str, 0,\n                                       _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid bus name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* unique name validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_unique_names))\n    {\n      _dbus_string_init_const (&str, valid_unique_names[i]);\n\n      if (!_dbus_validate_bus_name (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been valid\\n\", valid_unique_names[i]);\n          _dbus_assert_not_reached (\"invalid unique name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_unique_names))\n    {\n      _dbus_string_init_const (&str, invalid_unique_names[i]);\n\n      if (_dbus_validate_bus_name (&str, 0,\n                                   _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Bus name \\\"%s\\\" should have been invalid\\n\", invalid_unique_names[i]);\n          _dbus_assert_not_reached (\"valid unique name\");\n        }\n\n      ++i;\n    }\n\n\n  /* Error name validation (currently identical to interfaces)\n   */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_interfaces))\n    {\n      _dbus_string_init_const (&str, valid_interfaces[i]);\n\n      if (!_dbus_validate_error_name (&str, 0,\n                                      _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Error name \\\"%s\\\" should have been valid\\n\", valid_interfaces[i]);\n          _dbus_assert_not_reached (\"invalid error name\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_interfaces))\n    {\n      if (invalid_interfaces[i][0] != ':')\n        {\n          _dbus_string_init_const (&str, invalid_interfaces[i]);\n\n          if (_dbus_validate_error_name (&str, 0,\n                                         _dbus_string_get_length (&str)))\n            {\n              _dbus_warn (\"Error name \\\"%s\\\" should have been invalid\\n\", invalid_interfaces[i]);\n              _dbus_assert_not_reached (\"valid error name\");\n            }\n        }\n\n      ++i;\n    }\n\n  /* Member validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_members))\n    {\n      _dbus_string_init_const (&str, valid_members[i]);\n\n      if (!_dbus_validate_member (&str, 0,\n                                  _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been valid\\n\", valid_members[i]);\n          _dbus_assert_not_reached (\"invalid member\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_members))\n    {\n      _dbus_string_init_const (&str, invalid_members[i]);\n\n      if (_dbus_validate_member (&str, 0,\n                                 _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Member \\\"%s\\\" should have been invalid\\n\", invalid_members[i]);\n          _dbus_assert_not_reached (\"valid member\");\n        }\n\n      ++i;\n    }\n\n  /* Signature validation */\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (valid_signatures))\n    {\n      _dbus_string_init_const (&str, valid_signatures[i]);\n\n      if (!_dbus_validate_signature (&str, 0,\n                                     _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been valid\\n\", valid_signatures[i]);\n          _dbus_assert_not_reached (\"invalid signature\");\n        }\n\n      ++i;\n    }\n\n  i = 0;\n  while (i < (int) _DBUS_N_ELEMENTS (invalid_signatures))\n    {\n      _dbus_string_init_const (&str, invalid_signatures[i]);\n\n      if (_dbus_validate_signature (&str, 0,\n                                    _dbus_string_get_length (&str)))\n        {\n          _dbus_warn (\"Signature \\\"%s\\\" should have been invalid\\n\", invalid_signatures[i]);\n          _dbus_assert_not_reached (\"valid signature\");\n        }\n\n      ++i;\n    }\n\n  /* Validate claimed length longer than real length */\n  _dbus_string_init_const (&str, \"abc.efg\");\n  if (_dbus_validate_bus_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_interface (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n  if (_dbus_validate_error_name (&str, 0, 8))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"abc\");\n  if (_dbus_validate_member (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long string\");\n\n  _dbus_string_init_const (&str, \"sss\");\n  if (_dbus_validate_signature (&str, 0, 4))\n    _dbus_assert_not_reached (\"validated too-long signature\");\n\n  /* Validate string exceeding max name length */\n  if (!_dbus_string_init (&str))\n    _dbus_assert_not_reached (\"no memory\");\n\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc.def\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_interface (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n  if (_dbus_validate_error_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong member */\n  _dbus_string_set_length (&str, 0);\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_member (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  /* overlong unique name */\n  _dbus_string_set_length (&str, 0);\n  _dbus_string_append (&str, \":\");\n  while (_dbus_string_get_length (&str) <= DBUS_MAXIMUM_NAME_LENGTH)\n    if (!_dbus_string_append (&str, \"abc\"))\n      _dbus_assert_not_reached (\"no memory\");\n\n  if (_dbus_validate_bus_name (&str, 0, _dbus_string_get_length (&str)))\n    _dbus_assert_not_reached (\"validated overmax string\");\n\n  _dbus_string_free (&str);\n\n  /* Body validation; test basic validation of valid bodies for both endian */\n  \n  {\n    int sequence;\n    DBusString signature;\n    DBusString body;\n\n    if (!_dbus_string_init (&signature) || !_dbus_string_init (&body))\n      _dbus_assert_not_reached (\"oom\");\n\n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_LITTLE_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_LITTLE_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d little endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n                                                     \n    sequence = 0;\n    while (dbus_internal_do_not_use_generate_bodies (sequence,\n                                                     DBUS_BIG_ENDIAN,\n                                                     &signature, &body))\n      {\n        DBusValidity validity;\n\n        validity = _dbus_validate_body_with_reason (&signature, 0,\n                                                    DBUS_BIG_ENDIAN,\n                                                    NULL, &body, 0,\n                                                    _dbus_string_get_length (&body));\n        if (validity != DBUS_VALID)\n          {\n            _dbus_warn (\"invalid code %d expected valid on sequence %d big endian\\n\",\n                        validity, sequence);\n            _dbus_verbose_bytes_of_string (&signature, 0, _dbus_string_get_length (&signature));\n            _dbus_verbose_bytes_of_string (&body, 0, _dbus_string_get_length (&body));\n            _dbus_assert_not_reached (\"test failed\");\n          }\n\n        _dbus_string_set_length (&signature, 0);\n        _dbus_string_set_length (&body, 0);\n        ++sequence;\n      }\n\n    _dbus_string_free (&signature);\n    _dbus_string_free (&body);\n  }\n  \n  return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Bug 17803: Panic from dbus_signature_validate\n\n\t* dbus/dbus-marshal-validate.c: Ensure we validate\n\ta basic type before calling is_basic on it.\n\t* dbus-marshal-validate-util.c: Test."}
{"func": "sctp_disposition_t sctp_sf_do_asconf_ack(const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)&err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET,SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}", "target": 1, "cwe": ["CWE-20"], "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands) {\n\tstatic const char err_str[] = \"The following parameter had invalid length:\";\n\n\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}", "target": 1, "cwe": ["CWE-20"], "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t\t\tpayload_len = WORD_ROUND(sizeof(error)) +\n\t\t\t\t\t\tsizeof(sctp_paramhdr_t);\n\n\n\t/* This is a fatal error.  Any accumulated non-fatal errors are\n\t * not reported.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t/* Create an error chunk and fill it in with our payload. */\n\t*errp = sctp_make_op_error_space(asoc, chunk, payload_len);\n\n\tif (*errp) {\n\t\tsctp_init_cause(*errp, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\t\tsizeof(error) + sizeof(sctp_paramhdr_t));\n\t\tsctp_addto_chunk(*errp, sizeof(error), error);\n\t\tsctp_addto_param(*errp, sizeof(sctp_paramhdr_t), param);\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "sctp_disposition_t sctp_sf_do_asconf(const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!sctp_addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(ep, asoc, type,\n\t\t\t\t\t\t  (void *)&err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created untill we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 1, "cwe": ["CWE-20"], "message": "sctp: Fix kernel panic while process protocol violation parameter\n\nSince call to function sctp_sf_abort_violation() need paramter 'arg' with\n'struct sctp_chunk' type, it will read the chunk type and chunk length from\nthe chunk_hdr member of chunk. But call to sctp_sf_violation_paramlen()\nalways with 'struct sctp_paramhdr' type's parameter, it will be passed to\nsctp_sf_abort_violation(). This may cause kernel panic.\n\n   sctp_sf_violation_paramlen()\n     |-- sctp_sf_abort_violation()\n        |-- sctp_make_abort_violation()\n\nThis patch fixed this problem. This patch also fix two place which called\nsctp_sf_violation_paramlen() with wrong paramter type.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int rtc_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tclear_uie(rtc);\n#endif\n\trtc_irq_set_state(rtc, NULL, 0);\n\n\tif (rtc->ops->release)\n\t\trtc->ops->release(rtc->dev.parent);\n\n\tclear_bit_unlock(RTC_DEV_BUSY, &rtc->flags);\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "rtc: fix kernel panic on second use of SIGIO nofitication\n\nWhen userspace uses SIGIO notification and forgets to disable it before\nclosing file descriptor, rtc->async_queue contains stale pointer to struct\nfile.  When user space enables again SIGIO notification in different\nprocess, kernel dereferences this (poisoned) pointer and crashes.\n\nSo disable SIGIO notification on close.\n\nKernel panic:\n(second run of qemu (requires echo 1024 > /sys/class/rtc/rtc0/max_user_freq))\n\ngeneral protection fault: 0000 [1] PREEMPT\nCPU 0\nModules linked in: af_packet snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq usbhid tuner tea5767 tda8290 tuner_xc2028 xc5000 tda9887 tuner_simple tuner_types mt20xx tea5761 tda9875 uhci_hcd ehci_hcd usbcore bttv snd_via82xx snd_ac97_codec ac97_bus snd_pcm snd_timer ir_common compat_ioctl32 snd_page_alloc videodev v4l1_compat snd_mpu401_uart snd_rawmidi v4l2_common videobuf_dma_sg videobuf_core snd_seq_device snd btcx_risc soundcore tveeprom i2c_viapro\nPid: 5781, comm: qemu-system-x86 Not tainted 2.6.27-rc6 #363\nRIP: 0010:[<ffffffff8024f891>]  [<ffffffff8024f891>] __lock_acquire+0x3db/0x73f\nRSP: 0000:ffffffff80674cb8  EFLAGS: 00010002\nRAX: ffff8800224c62f0 RBX: 0000000000000046 RCX: 0000000000000002\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff8800224c62f0\nRBP: ffffffff80674d08 R08: 0000000000000002 R09: 0000000000000001\nR10: ffffffff80238941 R11: 0000000000000001 R12: 0000000000000000\nR13: 6b6b6b6b6b6b6b6b R14: ffff88003a450080 R15: 0000000000000000\nFS:  00007f98b69516f0(0000) GS:ffffffff80623200(0000) knlGS:00000000f7cc86d0\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000a87000 CR3: 0000000022598000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess qemu-system-x86 (pid: 5781, threadinfo ffff880028812000, task ffff88003a450080)\nStack:  ffffffff80674cf8 0000000180238440 0000000200000002 0000000000000000\n ffff8800224c62f0 0000000000000046 0000000000000000 0000000000000002\n 0000000000000002 0000000000000000 ffffffff80674d68 ffffffff8024fc7a\nCall Trace:\n <IRQ>  [<ffffffff8024fc7a>] lock_acquire+0x85/0xa9\n [<ffffffff8029cb62>] ? send_sigio+0x2a/0x184\n [<ffffffff80491d1f>] _read_lock+0x3e/0x4a\n [<ffffffff8029cb62>] ? send_sigio+0x2a/0x184\n [<ffffffff8029cb62>] send_sigio+0x2a/0x184\n [<ffffffff8024fb97>] ? __lock_acquire+0x6e1/0x73f\n [<ffffffff8029cd4d>] ? kill_fasync+0x2c/0x4e\n [<ffffffff8029cd10>] __kill_fasync+0x54/0x65\n [<ffffffff8029cd5b>] kill_fasync+0x3a/0x4e\n [<ffffffff80402896>] rtc_update_irq+0x9c/0xa5\n [<ffffffff80404640>] cmos_interrupt+0xae/0xc0\n [<ffffffff8025d1c1>] handle_IRQ_event+0x25/0x5a\n [<ffffffff8025e5e4>] handle_edge_irq+0xdd/0x123\n [<ffffffff8020da34>] do_IRQ+0xe4/0x144\n [<ffffffff8020bad6>] ret_from_intr+0x0/0xf\n <EOI>  [<ffffffff8026fdc2>] ? __alloc_pages_internal+0xe7/0x3ad\n [<ffffffff8033fe67>] ? clear_page_c+0x7/0x10\n [<ffffffff8026fc10>] ? get_page_from_freelist+0x385/0x450\n [<ffffffff8026fdc2>] ? __alloc_pages_internal+0xe7/0x3ad\n [<ffffffff80280aac>] ? anon_vma_prepare+0x2e/0xf6\n [<ffffffff80279400>] ? handle_mm_fault+0x227/0x6a5\n [<ffffffff80494716>] ? do_page_fault+0x494/0x83f\n [<ffffffff8049251d>] ? error_exit+0x0/0xa9\n\nCode: cc 41 39 45 28 74 24 e8 5e 1d 0f 00 85 c0 0f 84 6a 03 00 00 83 3d 8f a9 aa 00 00 be 47 03 00 00 0f 84 6a 02 00 00 e9 53 03 00 00 <41> ff 85 38 01 00 00 45 8b be 90 06 00 00 41 83 ff 2f 76 24 e8\nRIP  [<ffffffff8024f891>] __lock_acquire+0x3db/0x73f\n RSP <ffffffff80674cb8>\n---[ end trace 431877d860448760 ]---\nKernel panic - not syncing: Aiee, killing interrupt handler!\n\nSigned-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>\nAcked-by: Alessandro Zummo <alessandro.zummo@towertech.it>\nAcked-by: David Brownell <dbrownell@users.sourceforge.net>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int rtc_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct rtc_device *rtc = file->private_data;\n\treturn fasync_helper(fd, file, on, &rtc->async_queue);\n}", "target": 1, "cwe": [], "message": "rtc: fix kernel panic on second use of SIGIO nofitication\n\nWhen userspace uses SIGIO notification and forgets to disable it before\nclosing file descriptor, rtc->async_queue contains stale pointer to struct\nfile.  When user space enables again SIGIO notification in different\nprocess, kernel dereferences this (poisoned) pointer and crashes.\n\nSo disable SIGIO notification on close.\n\nKernel panic:\n(second run of qemu (requires echo 1024 > /sys/class/rtc/rtc0/max_user_freq))\n\ngeneral protection fault: 0000 [1] PREEMPT\nCPU 0\nModules linked in: af_packet snd_pcm_oss snd_mixer_oss snd_seq_oss snd_seq_midi_event snd_seq usbhid tuner tea5767 tda8290 tuner_xc2028 xc5000 tda9887 tuner_simple tuner_types mt20xx tea5761 tda9875 uhci_hcd ehci_hcd usbcore bttv snd_via82xx snd_ac97_codec ac97_bus snd_pcm snd_timer ir_common compat_ioctl32 snd_page_alloc videodev v4l1_compat snd_mpu401_uart snd_rawmidi v4l2_common videobuf_dma_sg videobuf_core snd_seq_device snd btcx_risc soundcore tveeprom i2c_viapro\nPid: 5781, comm: qemu-system-x86 Not tainted 2.6.27-rc6 #363\nRIP: 0010:[<ffffffff8024f891>]  [<ffffffff8024f891>] __lock_acquire+0x3db/0x73f\nRSP: 0000:ffffffff80674cb8  EFLAGS: 00010002\nRAX: ffff8800224c62f0 RBX: 0000000000000046 RCX: 0000000000000002\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff8800224c62f0\nRBP: ffffffff80674d08 R08: 0000000000000002 R09: 0000000000000001\nR10: ffffffff80238941 R11: 0000000000000001 R12: 0000000000000000\nR13: 6b6b6b6b6b6b6b6b R14: ffff88003a450080 R15: 0000000000000000\nFS:  00007f98b69516f0(0000) GS:ffffffff80623200(0000) knlGS:00000000f7cc86d0\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000a87000 CR3: 0000000022598000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess qemu-system-x86 (pid: 5781, threadinfo ffff880028812000, task ffff88003a450080)\nStack:  ffffffff80674cf8 0000000180238440 0000000200000002 0000000000000000\n ffff8800224c62f0 0000000000000046 0000000000000000 0000000000000002\n 0000000000000002 0000000000000000 ffffffff80674d68 ffffffff8024fc7a\nCall Trace:\n <IRQ>  [<ffffffff8024fc7a>] lock_acquire+0x85/0xa9\n [<ffffffff8029cb62>] ? send_sigio+0x2a/0x184\n [<ffffffff80491d1f>] _read_lock+0x3e/0x4a\n [<ffffffff8029cb62>] ? send_sigio+0x2a/0x184\n [<ffffffff8029cb62>] send_sigio+0x2a/0x184\n [<ffffffff8024fb97>] ? __lock_acquire+0x6e1/0x73f\n [<ffffffff8029cd4d>] ? kill_fasync+0x2c/0x4e\n [<ffffffff8029cd10>] __kill_fasync+0x54/0x65\n [<ffffffff8029cd5b>] kill_fasync+0x3a/0x4e\n [<ffffffff80402896>] rtc_update_irq+0x9c/0xa5\n [<ffffffff80404640>] cmos_interrupt+0xae/0xc0\n [<ffffffff8025d1c1>] handle_IRQ_event+0x25/0x5a\n [<ffffffff8025e5e4>] handle_edge_irq+0xdd/0x123\n [<ffffffff8020da34>] do_IRQ+0xe4/0x144\n [<ffffffff8020bad6>] ret_from_intr+0x0/0xf\n <EOI>  [<ffffffff8026fdc2>] ? __alloc_pages_internal+0xe7/0x3ad\n [<ffffffff8033fe67>] ? clear_page_c+0x7/0x10\n [<ffffffff8026fc10>] ? get_page_from_freelist+0x385/0x450\n [<ffffffff8026fdc2>] ? __alloc_pages_internal+0xe7/0x3ad\n [<ffffffff80280aac>] ? anon_vma_prepare+0x2e/0xf6\n [<ffffffff80279400>] ? handle_mm_fault+0x227/0x6a5\n [<ffffffff80494716>] ? do_page_fault+0x494/0x83f\n [<ffffffff8049251d>] ? error_exit+0x0/0xa9\n\nCode: cc 41 39 45 28 74 24 e8 5e 1d 0f 00 85 c0 0f 84 6a 03 00 00 83 3d 8f a9 aa 00 00 be 47 03 00 00 0f 84 6a 02 00 00 e9 53 03 00 00 <41> ff 85 38 01 00 00 45 8b be 90 06 00 00 41 83 ff 2f 76 24 e8\nRIP  [<ffffffff8024f891>] __lock_acquire+0x3db/0x73f\n RSP <ffffffff80674cb8>\n---[ end trace 431877d860448760 ]---\nKernel panic - not syncing: Aiee, killing interrupt handler!\n\nSigned-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>\nAcked-by: Alessandro Zummo <alessandro.zummo@towertech.it>\nAcked-by: David Brownell <dbrownell@users.sourceforge.net>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_addr *addr,\n\t\t\t\t\t   const gfp_t gfp,\n\t\t\t\t\t   const int peer_state)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_sock *sp;\n\tunsigned short port;\n\n\tsp = sctp_sk(asoc->base.sk);\n\n\t/* AF_INET and AF_INET6 share common port field. */\n\tport = ntohs(addr->v4.sin_port);\n\n\tSCTP_DEBUG_PRINTK_IPADDR(\"sctp_assoc_add_peer:association %p addr: \",\n\t\t\t\t \" port: %d state:%d\\n\",\n\t\t\t\t asoc,\n\t\t\t\t addr,\n\t\t\t\t port,\n\t\t\t\t peer_state);\n\n\t/* Set the port if it has not been set yet.  */\n\tif (0 == asoc->peer.port)\n\t\tasoc->peer.port = port;\n\n\t/* Check to see if this is a duplicate. */\n\tpeer = sctp_assoc_lookup_paddr(asoc, addr);\n\tif (peer) {\n\t\tif (peer->state == SCTP_UNKNOWN) {\n\t\t\tif (peer_state == SCTP_ACTIVE)\n\t\t\t\tpeer->state = SCTP_ACTIVE;\n\t\t\tif (peer_state == SCTP_UNCONFIRMED)\n\t\t\t\tpeer->state = SCTP_UNCONFIRMED;\n\t\t}\n\t\treturn peer;\n\t}\n\n\tpeer = sctp_transport_new(addr, gfp);\n\tif (!peer)\n\t\treturn NULL;\n\n\tsctp_transport_set_owner(peer, asoc);\n\n\t/* Initialize the peer's heartbeat interval based on the\n\t * association configured value.\n\t */\n\tpeer->hbinterval = asoc->hbinterval;\n\n\t/* Set the path max_retrans.  */\n\tpeer->pathmaxrxt = asoc->pathmaxrxt;\n\n\t/* Initialize the peer's SACK delay timeout based on the\n\t * association configured value.\n\t */\n\tpeer->sackdelay = asoc->sackdelay;\n\tpeer->sackfreq = asoc->sackfreq;\n\n\t/* Enable/disable heartbeat, SACK delay, and path MTU discovery\n\t * based on association setting.\n\t */\n\tpeer->param_flags = asoc->param_flags;\n\n\t/* Initialize the pmtu of the transport. */\n\tif (peer->param_flags & SPP_PMTUD_ENABLE)\n\t\tsctp_transport_pmtu(peer);\n\telse if (asoc->pathmtu)\n\t\tpeer->pathmtu = asoc->pathmtu;\n\telse\n\t\tpeer->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\n\n\t/* If this is the first transport addr on this association,\n\t * initialize the association PMTU to the peer's PMTU.\n\t * If not and the current association PMTU is higher than the new\n\t * peer's PMTU, reset the association PMTU to the new peer's PMTU.\n\t */\n\tif (asoc->pathmtu)\n\t\tasoc->pathmtu = min_t(int, peer->pathmtu, asoc->pathmtu);\n\telse\n\t\tasoc->pathmtu = peer->pathmtu;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_assoc_add_peer:association %p PMTU set to \"\n\t\t\t  \"%d\\n\", asoc, asoc->pathmtu);\n\tpeer->pmtu_pending = 0;\n\n\tasoc->frag_point = sctp_frag_point(sp, asoc->pathmtu);\n\n\t/* The asoc->peer.port might not be meaningful yet, but\n\t * initialize the packet structure anyway.\n\t */\n\tsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\n\t\t\t asoc->peer.port);\n\n\t/* 7.2.1 Slow-Start\n\t *\n\t * o The initial cwnd before DATA transmission or after a sufficiently\n\t *   long idle period MUST be set to\n\t *      min(4*MTU, max(2*MTU, 4380 bytes))\n\t *\n\t * o The initial value of ssthresh MAY be arbitrarily high\n\t *   (for example, implementations MAY use the size of the\n\t *   receiver advertised window).\n\t */\n\tpeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\n\t/* At this point, we may not have the receiver's advertised window,\n\t * so initialize ssthresh to the default value and it will be set\n\t * later when we process the INIT.\n\t */\n\tpeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\n\n\tpeer->partial_bytes_acked = 0;\n\tpeer->flight_size = 0;\n\n\t/* Set the transport's RTO.initial value */\n\tpeer->rto = asoc->rto_initial;\n\n\t/* Set the peer's active state. */\n\tpeer->state = peer_state;\n\n\t/* Attach the remote transport to our asoc.  */\n\tlist_add_tail(&peer->transports, &asoc->peer.transport_addr_list);\n\tasoc->peer.transport_count++;\n\n\t/* If we do not yet have a primary path, set one.  */\n\tif (!asoc->peer.primary_path) {\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\tif (asoc->peer.active_path == asoc->peer.retran_path) {\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\treturn peer;\n}", "target": 1, "cwe": ["CWE-287"], "message": "sctp: Fix oops when INIT-ACK indicates that peer doesn't support AUTH\n\nIf INIT-ACK is received with SupportedExtensions parameter which\nindicates that the peer does not support AUTH, the packet will be\nsilently ignore, and sctp_process_init() do cleanup all of the\ntransports in the association.\nWhen T1-Init timer is expires, OOPS happen while we try to choose\na different init transport.\n\nThe solution is to only clean up the non-active transports, i.e\nthe ones that the peer added.  However, that introduces a problem\nwith sctp_connectx(), because we don't mark the proper state for\nthe transports provided by the user.  So, we'll simply mark\nuser-provided transports as ACTIVE.  That will allow INIT\nretransmissions to work properly in the sctp_connectx() context\nand prevent the crash.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int sctp_process_init(struct sctp_association *asoc, sctp_cid_t cid,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      sctp_init_chunk_t *peer_init, gfp_t gfp)\n{\n\tunion sctp_params param;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tchar *cookie;\n\n\t/* We must include the address that the INIT packet came from.\n\t * This is the only address that matters for an INIT packet.\n\t * When processing a COOKIE ECHO, we retrieve the from address\n\t * of the INIT from the cookie.\n\t */\n\n\t/* This implementation defaults to making the first transport\n\t * added as the primary transport.  The source address seems to\n\t * be a a better choice than any of the embedded addresses.\n\t */\n\tif (peer_addr) {\n\t\tif(!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\t\tgoto nomem;\n\t}\n\n\t/* Process the initialization parameters.  */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t/* AUTH: After processing the parameters, make sure that we\n\t * have all the required info to potentially do authentications.\n\t */\n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t/* In a non-backward compatible mode, if the peer claims\n\t * support for ADD-IP but not AUTH,  the ADD-IP spec states\n\t * that we MUST ABORT the association. Section 6.  The section\n\t * also give us an option to silently ignore the packet, which\n\t * is what we'll do here.\n\t */\n\tif (!sctp_addip_noauth &&\n\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t/* Walk list of transports, removing transports in the UNKNOWN state. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t/* The fixed INIT headers are always in network byte\n\t * order.\n\t */\n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\t/* Apply the upper bounds for output streams based on peer's\n\t * number of inbound streams.\n\t */\n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */\n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */\n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t/* Copy cookie in case we need to resend COOKIE-ECHO. */\n\tcookie = asoc->peer.cookie;\n\tif (cookie) {\n\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily\n\t * high (for example, implementations MAY use the size of the receiver\n\t * advertised window).\n\t */\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t/* Set up the TSN tracking pieces.  */\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_SIZE,\n\t\t\t asoc->peer.i.initial_tsn);\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * The stream sequence number in all the streams shall start\n\t * from 0 when the association is established.  Also, when the\n\t * stream sequence number reaches the value 65535 the next\n\t * stream sequence number shall be set to 0.\n\t */\n\n\t/* Allocate storage for the negotiated streams if it is not a temporary\n\t * association.\n\t */\n\tif (!asoc->temp) {\n\t\tint error;\n\n\t\tasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\n\t\t\t\t\t       asoc->c.sinit_num_ostreams, gfp);\n\t\tif (!asoc->ssnmap)\n\t\t\tgoto clean_up;\n\n\t\terror = sctp_assoc_set_id(asoc, gfp);\n\t\tif (error)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* ADDIP Section 4.1 ASCONF Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) A serial number should be assigned to the Chunk. The serial\n\t * number should be a monotonically increasing number. All serial\n\t * numbers are defined to be initialized at the start of the\n\t * association to the same value as the Initial TSN.\n\t */\n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_init(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\nnomem:\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-287"], "message": "sctp: Fix oops when INIT-ACK indicates that peer doesn't support AUTH\n\nIf INIT-ACK is received with SupportedExtensions parameter which\nindicates that the peer does not support AUTH, the packet will be\nsilently ignore, and sctp_process_init() do cleanup all of the\ntransports in the association.\nWhen T1-Init timer is expires, OOPS happen while we try to choose\na different init transport.\n\nThe solution is to only clean up the non-active transports, i.e\nthe ones that the peer added.  However, that introduces a problem\nwith sctp_connectx(), because we don't mark the proper state for\nthe transports provided by the user.  So, we'll simply mark\nuser-provided transports as ACTIVE.  That will allow INIT\nretransmissions to work properly in the sctp_connectx() context\nand prevent the crash.\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tint ret;\n\n\tif (unlikely(!out->f_op || !out->f_op->splice_write))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(WRITE, out, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't allow splice() to files opened with O_APPEND\n\nThis is debatable, but while we're debating it, let's disallow the\ncombination of splice and an O_APPEND destination.\n\nIt's not entirely clear what the semantics of O_APPEND should be, and\nPOSIX apparently expects pwrite() to ignore O_APPEND, for example.  So\nwe could make up any semantics we want, including the old ones.\n\nBut Miklos convinced me that we should at least give it some thought,\nand that accepting writes at arbitrary offsets is wrong at least for\nIS_APPEND() files (which always have O_APPEND set, even if the reverse\nisn't true: you can obviously have O_APPEND set on a regular file).\n\nSo disallow O_APPEND entirely for now.  I doubt anybody cares, and this\nway we have one less gray area to worry about.\n\nReported-and-argued-for-by: Miklos Szeredi <miklos@szeredi.hu>\nAcked-by: Jens Axboe <ens.axboe@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1, "cwe": ["CWE-119"], "message": "hfsplus: fix Buffer overflow with a corrupted image\n\nWhen an hfsplus image gets corrupted it might happen that the catalog\nnamelength field gets b0rked.  If we mount such an image the memcpy() in\nhfsplus_cat_build_key_uni() writes more than the 255 that fit in the name\nfield.  Depending on the size of the overwritten data, we either only get\nmemory corruption or also trigger an oops like this:\n\n[  221.628020] BUG: unable to handle kernel paging request at c82b0000\n[  221.629066] IP: [<c022d4b1>] hfsplus_find_cat+0x10d/0x151\n[  221.629066] *pde = 0ea29163 *pte = 082b0160\n[  221.629066] Oops: 0002 [#1] PREEMPT DEBUG_PAGEALLOC\n[  221.629066] Modules linked in:\n[  221.629066]\n[  221.629066] Pid: 4845, comm: mount Not tainted (2.6.27-rc4-00123-gd3ee1b4-dirty #28)\n[  221.629066] EIP: 0060:[<c022d4b1>] EFLAGS: 00010206 CPU: 0\n[  221.629066] EIP is at hfsplus_find_cat+0x10d/0x151\n[  221.629066] EAX: 00000029 EBX: 00016210 ECX: 000042c2 EDX: 00000002\n[  221.629066] ESI: c82d70ca EDI: c82b0000 EBP: c82d1bcc ESP: c82d199c\n[  221.629066]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068\n[  221.629066] Process mount (pid: 4845, ti=c82d1000 task=c8224060 task.ti=c82d1000)\n[  221.629066] Stack: c080b3c4 c82aa8f8 c82d19c2 00016210 c080b3be c82d1bd4 c82aa8f0 00000300\n[  221.629066]        01000000 750008b1 74006e00 74006900 65006c00 c82d6400 c013bd35 c8224060\n[  221.629066]        00000036 00000046 c82d19f0 00000082 c8224548 c8224060 00000036 c0d653cc\n[  221.629066] Call Trace:\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c01302d2>] ? __kernel_text_address+0x1b/0x27\n[  221.629066]  [<c010487a>] ? dump_trace+0xca/0xd6\n[  221.629066]  [<c0109e32>] ? save_stack_address+0x0/0x2c\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c013b571>] ? save_trace+0x37/0x8d\n[  221.629066]  [<c013b62e>] ? add_lock_to_list+0x67/0x8d\n[  221.629066]  [<c013ea1c>] ? validate_chain+0x8a4/0x9f4\n[  221.629066]  [<c013553d>] ? down+0xc/0x2f\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c013da5d>] ? mark_held_locks+0x43/0x5a\n[  221.629066]  [<c013dc3a>] ? trace_hardirqs_on+0xb/0xd\n[  221.629066]  [<c013dbf4>] ? trace_hardirqs_on_caller+0xf4/0x12f\n[  221.629066]  [<c06abec8>] ? _spin_unlock_irqrestore+0x42/0x58\n[  221.629066]  [<c013555c>] ? down+0x2b/0x2f\n[  221.629066]  [<c022aa68>] ? hfsplus_iget+0xa0/0x154\n[  221.629066]  [<c022b0b9>] ? hfsplus_fill_super+0x280/0x447\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c041c9e4>] ? string+0x2b/0x74\n[  221.629066]  [<c041cd16>] ? vsnprintf+0x2e9/0x512\n[  221.629066]  [<c010487a>] ? dump_trace+0xca/0xd6\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c0109eaf>] ? save_stack_trace+0x1c/0x3a\n[  221.629066]  [<c013b571>] ? save_trace+0x37/0x8d\n[  221.629066]  [<c013b62e>] ? add_lock_to_list+0x67/0x8d\n[  221.629066]  [<c013ea1c>] ? validate_chain+0x8a4/0x9f4\n[  221.629066]  [<c01354d3>] ? up+0xc/0x2f\n[  221.629066]  [<c013f1f6>] ? __lock_acquire+0x68a/0x6e0\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c013bca3>] ? trace_hardirqs_off_caller+0x14/0x9b\n[  221.629066]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[  221.629066]  [<c0107aa3>] ? native_sched_clock+0x82/0x96\n[  221.629066]  [<c041cfb7>] ? snprintf+0x1b/0x1d\n[  221.629066]  [<c01ba466>] ? disk_name+0x25/0x67\n[  221.629066]  [<c0183960>] ? get_sb_bdev+0xcd/0x10b\n[  221.629066]  [<c016ad92>] ? kstrdup+0x2a/0x4c\n[  221.629066]  [<c022a7b3>] ? hfsplus_get_sb+0x13/0x15\n[  221.629066]  [<c022ae39>] ? hfsplus_fill_super+0x0/0x447\n[  221.629066]  [<c0183583>] ? vfs_kern_mount+0x3b/0x76\n[  221.629066]  [<c0183602>] ? do_kern_mount+0x32/0xba\n[  221.629066]  [<c01960d4>] ? do_new_mount+0x46/0x74\n[  221.629066]  [<c0196277>] ? do_mount+0x175/0x193\n[  221.629066]  [<c013dbf4>] ? trace_hardirqs_on_caller+0xf4/0x12f\n[  221.629066]  [<c01663b2>] ? __get_free_pages+0x1e/0x24\n[  221.629066]  [<c06ac07b>] ? lock_kernel+0x19/0x8c\n[  221.629066]  [<c01962e6>] ? sys_mount+0x51/0x9b\n[  221.629066]  [<c01962f9>] ? sys_mount+0x64/0x9b\n[  221.629066]  [<c01038bd>] ? sysenter_do_call+0x12/0x31\n[  221.629066]  =======================\n[  221.629066] Code: 89 c2 c1 e2 08 c1 e8 08 09 c2 8b 85 e8 fd ff ff 66 89 50 06 89 c7 53 83 c7 08 56 57 68 c4 b3 80 c0 e8 8c 5c ef ff 89 d9 c1 e9 02 <f3> a5 89 d9 83 e1 03 74 02 f3 a4 83 c3 06 8b 95 e8 fd ff ff 0f\n[  221.629066] EIP: [<c022d4b1>] hfsplus_find_cat+0x10d/0x151 SS:ESP 0068:c82d199c\n[  221.629066] ---[ end trace e417a1d67f0d0066 ]---\n\nSince hfsplus_cat_build_key_uni() returns void and only has one callsite,\nthe check is performed at the callsite.\n\nSigned-off-by: Eric Sesterhenn <snakebyte@gmx.de>\nReviewed-by: Pekka Enberg <penberg@cs.helsinki.fi>\nCc: Roman Zippel <zippel@linux-m68k.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}", "target": 1, "cwe": ["CWE-20"], "message": "hfsplus: check read_mapping_page() return value\n\nWhile testing more corrupted images with hfsplus, i came across\none which triggered the following bug:\n\n[15840.675016] BUG: unable to handle kernel paging request at fffffffb\n[15840.675016] IP: [<c0116a4f>] kmap+0x15/0x56\n[15840.675016] *pde = 00008067 *pte = 00000000\n[15840.675016] Oops: 0000 [#1] PREEMPT DEBUG_PAGEALLOC\n[15840.675016] Modules linked in:\n[15840.675016]\n[15840.675016] Pid: 11575, comm: ln Not tainted (2.6.27-rc4-00123-gd3ee1b4-dirty #29)\n[15840.675016] EIP: 0060:[<c0116a4f>] EFLAGS: 00010202 CPU: 0\n[15840.675016] EIP is at kmap+0x15/0x56\n[15840.675016] EAX: 00000246 EBX: fffffffb ECX: 00000000 EDX: cab919c0\n[15840.675016] ESI: 000007dd EDI: cab0bcf4 EBP: cab0bc98 ESP: cab0bc94\n[15840.675016]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068\n[15840.675016] Process ln (pid: 11575, ti=cab0b000 task=cab919c0 task.ti=cab0b000)\n[15840.675016] Stack: 00000000 cab0bcdc c0231cfb 00000000 cab0bce0 00000800 ca9290c0 fffffffb\n[15840.675016]        cab145d0 cab919c0 cab15998 22222222 22222222 22222222 00000001 cab15960\n[15840.675016]        000007dd cab0bcf4 cab0bd04 c022cb3a cab0bcf4 cab15a6c ca9290c0 00000000\n[15840.675016] Call Trace:\n[15840.675016]  [<c0231cfb>] ? hfsplus_block_allocate+0x6f/0x2d3\n[15840.675016]  [<c022cb3a>] ? hfsplus_file_extend+0xc4/0x1db\n[15840.675016]  [<c022ce41>] ? hfsplus_get_block+0x8c/0x19d\n[15840.675016]  [<c06adde4>] ? sub_preempt_count+0x9d/0xab\n[15840.675016]  [<c019ece6>] ? __block_prepare_write+0x147/0x311\n[15840.675016]  [<c0161934>] ? __grab_cache_page+0x52/0x73\n[15840.675016]  [<c019ef4f>] ? block_write_begin+0x79/0xd5\n[15840.675016]  [<c022cdb5>] ? hfsplus_get_block+0x0/0x19d\n[15840.675016]  [<c019f22a>] ? cont_write_begin+0x27f/0x2af\n[15840.675016]  [<c022cdb5>] ? hfsplus_get_block+0x0/0x19d\n[15840.675016]  [<c0139ebe>] ? tick_program_event+0x28/0x4c\n[15840.675016]  [<c013bd35>] ? trace_hardirqs_off+0xb/0xd\n[15840.675016]  [<c022b723>] ? hfsplus_write_begin+0x2d/0x32\n[15840.675016]  [<c022cdb5>] ? hfsplus_get_block+0x0/0x19d\n[15840.675016]  [<c0161988>] ? pagecache_write_begin+0x33/0x107\n[15840.675016]  [<c01879e5>] ? __page_symlink+0x3c/0xae\n[15840.675016]  [<c019ad34>] ? __mark_inode_dirty+0x12f/0x137\n[15840.675016]  [<c0187a70>] ? page_symlink+0x19/0x1e\n[15840.675016]  [<c022e6eb>] ? hfsplus_symlink+0x41/0xa6\n[15840.675016]  [<c01886a9>] ? vfs_symlink+0x99/0x101\n[15840.675016]  [<c018a2f6>] ? sys_symlinkat+0x6b/0xad\n[15840.675016]  [<c018a348>] ? sys_symlink+0x10/0x12\n[15840.675016]  [<c01038bd>] ? sysenter_do_call+0x12/0x31\n[15840.675016]  =======================\n[15840.675016] Code: 00 00 75 10 83 3d 88 2f ec c0 02 75 07 89 d0 e8 12 56 05 00 5d c3 55 ba 06 00 00 00 89 e5 53 89 c3 b8 3d eb 7e c0 e8 16 74 00 00 <8b> 03 c1 e8 1e 69 c0 d8 02 00 00 05 b8 69 8e c0 2b 80 c4 02 00\n[15840.675016] EIP: [<c0116a4f>] kmap+0x15/0x56 SS:ESP 0068:cab0bc94\n[15840.675016] ---[ end trace 4fea40dad6b70e5f ]---\n\nThis happens because the return value of read_mapping_page() is passed on\nto kmap unchecked.  The bug is triggered after the first\nread_mapping_page() in hfsplus_block_allocate(), this patch fixes all\nthree usages in this functions but leaves the ones further down in the\nfile unchanged.\n\nSigned-off-by: Eric Sesterhenn <snakebyte@gmx.de>\nCc: Roman Zippel <zippel@linux-m68k.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int hfs_cat_find_brec(struct super_block *sb, u32 cnid,\n\t\t      struct hfs_find_data *fd)\n{\n\thfs_cat_rec rec;\n\tint res, len, type;\n\n\thfs_cat_build_key(sb, fd->search_key, cnid, NULL);\n\tres = hfs_brec_read(fd, &rec, sizeof(rec));\n\tif (res)\n\t\treturn res;\n\n\ttype = rec.type;\n\tif (type != HFS_CDR_THD && type != HFS_CDR_FTH) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfd->search_key->cat.ParID = rec.thread.ParID;\n\tlen = fd->search_key->cat.CName.len = rec.thread.CName.len;\n\tmemcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);\n\treturn hfs_brec_find(fd);\n}", "target": 1, "cwe": [], "message": "hfs: fix namelength memory corruption\n\nFix a stack corruption caused by a corrupted hfs filesystem.  If the\ncatalog name length is corrupted the memcpy overwrites the catalog btree\nstructure.  Since the field is limited to HFS_NAMELEN bytes in the\nstructure and the file format, we throw an error if it is too long.\n\nCc: Roman Zippel <zippel@linux-m68k.org>\nSigned-off-by: Eric Sesterhenn <snakebyte@gmx.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tkfree(fpl);\n\t}\n}", "target": 1, "cwe": [], "message": "net: Fix recursive descent in __scm_destroy().\n\n__scm_destroy() walks the list of file descriptors in the scm_fp_list\npointed to by the scm_cookie argument.\n\nThose, in turn, can close sockets and invoke __scm_destroy() again.\n\nThere is nothing which limits how deeply this can occur.\n\nThe idea for how to fix this is from Linus.  Basically, we do all of\nthe fput()s at the top level by collecting all of the scm_fp_list\nobjects hit by an fput().  Inside of the initial __scm_destroy() we\nkeep running the list until it is empty.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\treturn num;\n}", "target": 1, "cwe": [], "message": "net: Fix recursive descent in __scm_destroy().\n\n__scm_destroy() walks the list of file descriptors in the scm_fp_list\npointed to by the scm_cookie argument.\n\nThose, in turn, can close sockets and invoke __scm_destroy() again.\n\nThere is nothing which limits how deeply this can occur.\n\nThe idea for how to fix this is from Linus.  Basically, we do all of\nthe fput()s at the top level by collecting all of the scm_fp_list\nobjects hit by an fput().  Inside of the initial __scm_destroy() we\nkeep running the list until it is empty.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmalloc(sizeof(*fpl), GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tget_file(fpl->fp[i]);\n\t\tmemcpy(new_fpl, fpl, sizeof(*fpl));\n\t}\n\treturn new_fpl;\n}", "target": 1, "cwe": [], "message": "net: Fix recursive descent in __scm_destroy().\n\n__scm_destroy() walks the list of file descriptors in the scm_fp_list\npointed to by the scm_cookie argument.\n\nThose, in turn, can close sockets and invoke __scm_destroy() again.\n\nThere is nothing which limits how deeply this can occur.\n\nThe idea for how to fix this is from Linus.  Basically, we do all of\nthe fput()s at the top level by collecting all of the scm_fp_list\nobjects hit by an fput().  Inside of the initial __scm_destroy() we\nkeep running the list until it is empty.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void inc_inflight_move_tail(struct unix_sock *u)\n{\n\tatomic_long_inc(&u->inflight);\n\t/*\n\t * If this is still a candidate, move it to the end of the\n\t * list, so that it's checked even if it was already passed\n\t * over\n\t */\n\tif (u->gc_candidate)\n\t\tlist_move_tail(&u->link, &gc_candidates);\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tfor (i=scm->fp->count-1; i>=0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\tUNIXCB(skb).fp = scm->fp;\n\tskb->destructor = unix_destruct_fds;\n\tscm->fp = NULL;\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *next;\n\n\tspin_lock(&x->sk_receive_queue.lock);\n\treceive_queue_for_each_skb(x, next, skb) {\n\t\t/*\n\t\t *\tDo we have file descriptors ?\n\t\t */\n\t\tif (UNIXCB(skb).fp) {\n\t\t\tbool hit = false;\n\t\t\t/*\n\t\t\t *\tProcess the descriptors of this socket\n\t\t\t */\n\t\t\tint nfd = UNIXCB(skb).fp->count;\n\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\t\t\twhile (nfd--) {\n\t\t\t\t/*\n\t\t\t\t *\tGet the socket the fd matches\n\t\t\t\t *\tif it indeed does so\n\t\t\t\t */\n\t\t\t\tstruct sock *sk = unix_get_socket(*fp++);\n\t\t\t\tif (sk) {\n\t\t\t\t\thit = true;\n\t\t\t\t\tfunc(unix_sk(sk));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hit && hitlist != NULL) {\n\t\t\t\t__skb_unlink(skb, &x->sk_receive_queue);\n\t\t\t\t__skb_queue_tail(hitlist, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&x->sk_receive_queue.lock);\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void unix_gc(void)\n{\n\tstatic bool gc_in_progress = false;\n\n\tstruct unix_sock *u;\n\tstruct unix_sock *next;\n\tstruct sk_buff_head hitlist;\n\tstruct list_head cursor;\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* Avoid a recursive GC. */\n\tif (gc_in_progress)\n\t\tgoto out;\n\n\tgc_in_progress = true;\n\t/*\n\t * First, select candidates for garbage collection.  Only\n\t * in-flight sockets are considered, and from those only ones\n\t * which don't have any external reference.\n\t *\n\t * Holding unix_gc_lock will protect these candidates from\n\t * being detached, and hence from gaining an external\n\t * reference.  This also means, that since there are no\n\t * possible receivers, the receive queues of these sockets are\n\t * static during the GC, even though the dequeue is done\n\t * before the detach without atomicity guarantees.\n\t */\n\tlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\t\tlong total_refs;\n\t\tlong inflight_refs;\n\n\t\ttotal_refs = file_count(u->sk.sk_socket->file);\n\t\tinflight_refs = atomic_long_read(&u->inflight);\n\n\t\tBUG_ON(inflight_refs < 1);\n\t\tBUG_ON(total_refs < inflight_refs);\n\t\tif (total_refs == inflight_refs) {\n\t\t\tlist_move_tail(&u->link, &gc_candidates);\n\t\t\tu->gc_candidate = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Now remove all internal in-flight reference to children of\n\t * the candidates.\n\t */\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, dec_inflight, NULL);\n\n\t/*\n\t * Restore the references for children of all candidates,\n\t * which have remaining references.  Do this recursively, so\n\t * only those remain, which form cyclic references.\n\t *\n\t * Use a \"cursor\" link, to make the list traversal safe, even\n\t * though elements might be moved about.\n\t */\n\tlist_add(&cursor, &gc_candidates);\n\twhile (cursor.next != &gc_candidates) {\n\t\tu = list_entry(cursor.next, struct unix_sock, link);\n\n\t\t/* Move cursor to after the current position. */\n\t\tlist_move(&cursor, &u->link);\n\n\t\tif (atomic_long_read(&u->inflight) > 0) {\n\t\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\t\t\tu->gc_candidate = 0;\n\t\t\tscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\t\t}\n\t}\n\tlist_del(&cursor);\n\n\t/*\n\t * Now gc_candidates contains only garbage.  Restore original\n\t * inflight counters for these as well, and remove the skbuffs\n\t * which are creating the cycle(s).\n\t */\n\tskb_queue_head_init(&hitlist);\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, inc_inflight, &hitlist);\n\n\tspin_unlock(&unix_gc_lock);\n\n\t/* Here we are. Hitlist is filled. Die. */\n\t__skb_queue_purge(&hitlist);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* All candidates should have been detached by now. */\n\tBUG_ON(!list_empty(&gc_candidates));\n\tgc_in_progress = false;\n\n out:\n\tspin_unlock(&unix_gc_lock);\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb==NULL)\n\t\tgoto out;\n\n\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\tif (siocb->scm->fp)\n\t\tunix_attach_fds(siocb->scm, skb);\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_reset_transport_header(skb);\n\terr = memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other==NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk)=NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tint err,size;\n\tstruct sk_buff *skb;\n\tint sent=0;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile(sent < len)\n\t{\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb=sock_alloc_send_skb(sk,size,msg->msg_flags&MSG_DONTWAIT, &err);\n\n\t\tif (skb==NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\t\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\t\tif (siocb->scm->fp)\n\t\t\tunix_attach_fds(siocb->scm, skb);\n\n\t\tif ((err = memcpy_fromiovec(skb_put(skb,size), msg->msg_iov, size)) != 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent+=size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent==0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE,current,0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}", "target": 1, "cwe": [], "message": "net: unix: fix inflight counting bug in garbage collector\n\nPreviously I assumed that the receive queues of candidates don't\nchange during the GC.  This is only half true, nothing can be received\nfrom the queues (see comment in unix_gc()), but buffers could be added\nthrough the other half of the socket pair, which may still have file\ndescriptors referring to it.\n\nThis can result in inc_inflight_move_tail() erronously increasing the\n\"inflight\" counter for a unix socket for which dec_inflight() wasn't\npreviously called.  This in turn can trigger the \"BUG_ON(total_refs <\ninflight_refs)\" in a later garbage collection run.\n\nFix this by only manipulating the \"inflight\" counter for sockets which\nare candidates themselves.  Duplicating the file references in\nunix_attach_fds() is also needed to prevent a socket becoming a\ncandidate for GC while the skb that contains it is not yet queued.\n\nReported-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int addr_len, int flags)\n{\n\tstruct sockaddr_un *sunaddr=(struct sockaddr_un *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk), *newu, *otheru;\n\tstruct sock *newsk = NULL;\n\tstruct sock *other = NULL;\n\tstruct sk_buff *skb = NULL;\n\tunsigned hash;\n\tint st;\n\tint err;\n\tlong timeo;\n\n\terr = unix_mkname(sunaddr, addr_len, &hash);\n\tif (err < 0)\n\t\tgoto out;\n\taddr_len = err;\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\t/* First of all allocate resources.\n\t   If we will make it after state is locked,\n\t   we will have to recheck all again in any case.\n\t */\n\n\terr = -ENOMEM;\n\n\t/* create new sock for complete connection */\n\tnewsk = unix_create1(NULL);\n\tif (newsk == NULL)\n\t\tgoto out;\n\n\t/* Allocate skb for sending to listening sock */\n\tskb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\nrestart:\n\t/*  Find listening sock. */\n\tother = unix_find_other(sunaddr, addr_len, sk->sk_type, hash, &err);\n\tif (!other)\n\t\tgoto out;\n\n\t/* Latch state of peer */\n\tunix_state_lock(other);\n\n\t/* Apparently VFS overslept socket death. Retry. */\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\terr = -ECONNREFUSED;\n\tif (other->sk_state != TCP_LISTEN)\n\t\tgoto out_unlock;\n\n\tif (skb_queue_len(&other->sk_receive_queue) >\n\t    other->sk_max_ack_backlog) {\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto out_unlock;\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\t/* Latch our state.\n\n\t   It is tricky place. We need to grab write lock and cannot\n\t   drop lock on peer. It is dangerous because deadlock is\n\t   possible. Connect to self case and simultaneous\n\t   attempt to connect are eliminated by checking socket\n\t   state. other is TCP_LISTEN, if sk is TCP_LISTEN we\n\t   check this before attempt to grab lock.\n\n\t   Well, and we have to recheck the state after socket locked.\n\t */\n\tst = sk->sk_state;\n\n\tswitch (st) {\n\tcase TCP_CLOSE:\n\t\t/* This is ok... continue with connect */\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\t/* Socket is already connected */\n\t\terr = -EISCONN;\n\t\tgoto out_unlock;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tunix_state_lock_nested(sk);\n\n\tif (sk->sk_state != st) {\n\t\tunix_state_unlock(sk);\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\t\tgoto restart;\n\t}\n\n\terr = security_unix_stream_connect(sock, other->sk_socket, newsk);\n\tif (err) {\n\t\tunix_state_unlock(sk);\n\t\tgoto out_unlock;\n\t}\n\n\t/* The way is open! Fastly set all the necessary fields... */\n\n\tsock_hold(sk);\n\tunix_peer(newsk)\t= sk;\n\tnewsk->sk_state\t\t= TCP_ESTABLISHED;\n\tnewsk->sk_type\t\t= sk->sk_type;\n\tnewsk->sk_peercred.pid\t= current->tgid;\n\tnewsk->sk_peercred.uid\t= current->euid;\n\tnewsk->sk_peercred.gid\t= current->egid;\n\tnewu = unix_sk(newsk);\n\tnewsk->sk_sleep\t\t= &newu->peer_wait;\n\totheru = unix_sk(other);\n\n\t/* copy address information from listening to new sock*/\n\tif (otheru->addr) {\n\t\tatomic_inc(&otheru->addr->refcnt);\n\t\tnewu->addr = otheru->addr;\n\t}\n\tif (otheru->dentry) {\n\t\tnewu->dentry\t= dget(otheru->dentry);\n\t\tnewu->mnt\t= mntget(otheru->mnt);\n\t}\n\n\t/* Set credentials */\n\tsk->sk_peercred = other->sk_peercred;\n\n\tsock->state\t= SS_CONNECTED;\n\tsk->sk_state\t= TCP_ESTABLISHED;\n\tsock_hold(newsk);\n\n\tsmp_mb__after_atomic_inc();\t/* sock_hold() does an atomic_inc() */\n\tunix_peer(sk)\t= newsk;\n\n\tunix_state_unlock(sk);\n\n\t/* take ten and and send info to listening sock */\n\tspin_lock(&other->sk_receive_queue.lock);\n\t__skb_queue_tail(&other->sk_receive_queue, skb);\n\t/* Undo artificially decreased inflight after embrion\n\t * is installed to listening socket. */\n\tatomic_inc(&newu->inflight);\n\tspin_unlock(&other->sk_receive_queue.lock);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, 0);\n\tsock_put(other);\n\treturn 0;\n\nout_unlock:\n\tif (other)\n\t\tunix_state_unlock(other);\n\nout:\n\tif (skb)\n\t\tkfree_skb(skb);\n\tif (newsk)\n\t\tunix_release_sock(newsk, 0);\n\tif (other)\n\t\tsock_put(other);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline int empty_stack(void)\n{\n\treturn gc_current == GC_HEAD;\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void maybe_unmark_and_push(struct sock *x)\n{\n\tstruct unix_sock *u = unix_sk(x);\n\n\tif (u->gc_tree != GC_ORPHAN)\n\t\treturn;\n\tsock_hold(x);\n\tu->gc_tree = gc_current;\n\tgc_current = x;\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void unix_gc(void)\n{\n\tstatic DEFINE_MUTEX(unix_gc_sem);\n\tint i;\n\tstruct sock *s;\n\tstruct sk_buff_head hitlist;\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tAvoid a recursive GC.\n\t */\n\n\tif (!mutex_trylock(&unix_gc_sem))\n\t\treturn;\n\n\tspin_lock(&unix_table_lock);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tunix_sk(s)->gc_tree = GC_ORPHAN;\n\t}\n\t/*\n\t *\tEverything is now marked\n\t */\n\n\t/* Invariant to be maintained:\n\t\t- everything unmarked is either:\n\t\t-- (a) on the stack, or\n\t\t-- (b) has all of its children unmarked\n\t\t- everything on the stack is always unmarked\n\t\t- nothing is ever pushed onto the stack twice, because:\n\t\t-- nothing previously unmarked is ever pushed on the stack\n\t */\n\n\t/*\n\t *\tPush root set\n\t */\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tint open_count = 0;\n\n\t\t/*\n\t\t *\tIf all instances of the descriptor are not\n\t\t *\tin flight we are in use.\n\t\t *\n\t\t *\tSpecial case: when socket s is embrion, it may be\n\t\t *\thashed but still not in queue of listening socket.\n\t\t *\tIn this case (see unix_create1()) we set artificial\n\t\t *\tnegative inflight counter to close race window.\n\t\t *\tIt is trick of course and dirty one.\n\t\t */\n\t\tif (s->sk_socket && s->sk_socket->file)\n\t\t\topen_count = file_count(s->sk_socket->file);\n\t\tif (open_count > atomic_read(&unix_sk(s)->inflight))\n\t\t\tmaybe_unmark_and_push(s);\n\t}\n\n\t/*\n\t *\tMark phase\n\t */\n\n\twhile (!empty_stack())\n\t{\n\t\tstruct sock *x = pop_stack();\n\t\tstruct sock *sk;\n\n\t\tspin_lock(&x->sk_receive_queue.lock);\n\t\tskb = skb_peek(&x->sk_receive_queue);\n\n\t\t/*\n\t\t *\tLoop through all but first born\n\t\t */\n\n\t\twhile (skb && skb != (struct sk_buff *)&x->sk_receive_queue) {\n\t\t\t/*\n\t\t\t *\tDo we have file descriptors ?\n\t\t\t */\n\t\t\tif(UNIXCB(skb).fp)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t *\tProcess the descriptors of this socket\n\t\t\t\t */\n\t\t\t\tint nfd=UNIXCB(skb).fp->count;\n\t\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\t\t\t\twhile(nfd--)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t *\tGet the socket the fd matches if\n\t\t\t\t\t *\tit indeed does so\n\t\t\t\t\t */\n\t\t\t\t\tif((sk=unix_get_socket(*fp++))!=NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tmaybe_unmark_and_push(sk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We have to scan not-yet-accepted ones too */\n\t\t\tif (x->sk_state == TCP_LISTEN)\n\t\t\t\tmaybe_unmark_and_push(skb->sk);\n\t\t\tskb=skb->next;\n\t\t}\n\t\tspin_unlock(&x->sk_receive_queue.lock);\n\t\tsock_put(x);\n\t}\n\n\tskb_queue_head_init(&hitlist);\n\n\tforall_unix_sockets(i, s)\n\t{\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (u->gc_tree == GC_ORPHAN) {\n\t\t\tstruct sk_buff *nextsk;\n\n\t\t\tspin_lock(&s->sk_receive_queue.lock);\n\t\t\tskb = skb_peek(&s->sk_receive_queue);\n\t\t\twhile (skb &&\n\t\t\t       skb != (struct sk_buff *)&s->sk_receive_queue) {\n\t\t\t\tnextsk = skb->next;\n\t\t\t\t/*\n\t\t\t\t *\tDo we have file descriptors ?\n\t\t\t\t */\n\t\t\t\tif (UNIXCB(skb).fp) {\n\t\t\t\t\t__skb_unlink(skb,\n\t\t\t\t\t\t     &s->sk_receive_queue);\n\t\t\t\t\t__skb_queue_tail(&hitlist, skb);\n\t\t\t\t}\n\t\t\t\tskb = nextsk;\n\t\t\t}\n\t\t\tspin_unlock(&s->sk_receive_queue.lock);\n\t\t}\n\t\tu->gc_tree = GC_ORPHAN;\n\t}\n\tspin_unlock(&unix_table_lock);\n\n\t/*\n\t *\tHere we are. Hitlist is filled. Die.\n\t */\n\n\t__skb_queue_purge(&hitlist);\n\tmutex_unlock(&unix_gc_sem);\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_inc(&unix_sk(s)->inflight);\n\t\tatomic_inc(&unix_tot_inflight);\n\t}\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline struct sock *pop_stack(void)\n{\n\tstruct sock *p = gc_current;\n\tgc_current = unix_sk(p)->gc_tree;\n\treturn p;\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct sock * unix_create1(struct socket *sock)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tif (atomic_read(&unix_nr_socks) >= 2*get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(PF_UNIX, GFP_KERNEL, &unix_proto, 1);\n\tif (!sk)\n\t\tgoto out;\n\n\tatomic_inc(&unix_nr_socks);\n\n\tsock_init_data(sock,sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= sysctl_unix_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->dentry = NULL;\n\tu->mnt\t  = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_set(&u->inflight, sock ? 0 : -1);\n\tmutex_init(&u->readlock); /* single task reading lock */\n\tinit_waitqueue_head(&u->peer_wait);\n\tunix_insert_socket(unix_sockets_unbound, sk);\nout:\n\treturn sk;\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_dec(&unix_sk(s)->inflight);\n\t\tatomic_dec(&unix_tot_inflight);\n\t}\n}", "target": 1, "cwe": [], "message": "[AF_UNIX]: Rewrite garbage collector, fixes race.\n\nThrow out the old mark & sweep garbage collector and put in a\nrefcounting cycle detecting one.\n\nThe old one had a race with recvmsg, that resulted in false positives\nand hence data loss.  The old algorithm operated on all unix sockets\nin the system, so any additional locking would have meant performance\nproblems for all users of these.\n\nThe new algorithm instead only operates on \"in flight\" sockets, which\nare very rare, and the additional locking for these doesn't negatively\nimpact the vast majority of users.\n\nIn fact it's probable, that there weren't *any* heavy senders of\nsockets over sockets, otherwise the above race would have been\ndiscovered long ago.\n\nThe patch works OK with the app that exposed the race with the old\ncode.  The garbage collection has also been verified to work in a few\nsimple cases.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int uvc_parse_format(struct uvc_device *dev,\n\tstruct uvc_streaming *streaming, struct uvc_format *format,\n\t__u32 **intervals, unsigned char *buffer, int buflen)\n{\n\tstruct usb_interface *intf = streaming->intf;\n\tstruct usb_host_interface *alts = intf->cur_altsetting;\n\tstruct uvc_format_desc *fmtdesc;\n\tstruct uvc_frame *frame;\n\tconst unsigned char *start = buffer;\n\tunsigned int interval;\n\tunsigned int i, n;\n\t__u8 ftype;\n\n\tformat->type = buffer[2];\n\tformat->index = buffer[3];\n\n\tswitch (buffer[2]) {\n\tcase VS_FORMAT_UNCOMPRESSED:\n\tcase VS_FORMAT_FRAME_BASED:\n\t\tif (buflen < 27) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Find the format descriptor from its GUID. */\n\t\tfmtdesc = uvc_format_by_guid(&buffer[5]);\n\n\t\tif (fmtdesc != NULL) {\n\t\t\tstrncpy(format->name, fmtdesc->name,\n\t\t\t\tsizeof format->name);\n\t\t\tformat->fcc = fmtdesc->fcc;\n\t\t} else {\n\t\t\tuvc_printk(KERN_INFO, \"Unknown video format \"\n\t\t\t\tUVC_GUID_FORMAT \"\\n\",\n\t\t\t\tUVC_GUID_ARGS(&buffer[5]));\n\t\t\tsnprintf(format->name, sizeof format->name,\n\t\t\t\tUVC_GUID_FORMAT, UVC_GUID_ARGS(&buffer[5]));\n\t\t\tformat->fcc = 0;\n\t\t}\n\n\t\tformat->bpp = buffer[21];\n\t\tif (buffer[2] == VS_FORMAT_UNCOMPRESSED) {\n\t\t\tftype = VS_FRAME_UNCOMPRESSED;\n\t\t} else {\n\t\t\tftype = VS_FRAME_FRAME_BASED;\n\t\t\tif (buffer[27])\n\t\t\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\t}\n\t\tbreak;\n\n\tcase VS_FORMAT_MJPEG:\n\t\tif (buflen < 11) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstrncpy(format->name, \"MJPEG\", sizeof format->name);\n\t\tformat->fcc = V4L2_PIX_FMT_MJPEG;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED;\n\t\tformat->bpp = 0;\n\t\tftype = VS_FRAME_MJPEG;\n\t\tbreak;\n\n\tcase VS_FORMAT_DV:\n\t\tif (buflen < 9) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (buffer[8] & 0x7f) {\n\t\tcase 0:\n\t\t\tstrncpy(format->name, \"SD-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstrncpy(format->name, \"SDL-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstrncpy(format->name, \"HD-DV\", sizeof format->name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d: unknown DV format %u\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber, buffer[8]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstrncat(format->name, buffer[8] & (1 << 7) ? \" 60Hz\" : \" 50Hz\",\n\t\t\tsizeof format->name);\n\n\t\tformat->fcc = V4L2_PIX_FMT_DV;\n\t\tformat->flags = UVC_FMT_FLAG_COMPRESSED | UVC_FMT_FLAG_STREAM;\n\t\tformat->bpp = 0;\n\t\tftype = 0;\n\n\t\t/* Create a dummy frame descriptor. */\n\t\tframe = &format->frame[0];\n\t\tmemset(&format->frame[0], 0, sizeof format->frame[0]);\n\t\tframe->bFrameIntervalType = 1;\n\t\tframe->dwDefaultFrameInterval = 1;\n\t\tframe->dwFrameInterval = *intervals;\n\t\t*(*intervals)++ = 1;\n\t\tformat->nframes = 1;\n\t\tbreak;\n\n\tcase VS_FORMAT_MPEG2TS:\n\tcase VS_FORMAT_STREAM_BASED:\n\t\t/* Not supported yet. */\n\tdefault:\n\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t       \"interface %d unsupported format %u\\n\",\n\t\t       dev->udev->devnum, alts->desc.bInterfaceNumber,\n\t\t       buffer[2]);\n\t\treturn -EINVAL;\n\t}\n\n\tuvc_trace(UVC_TRACE_DESCR, \"Found format %s.\\n\", format->name);\n\n\tbuflen -= buffer[0];\n\tbuffer += buffer[0];\n\n\t/* Parse the frame descriptors. Only uncompressed, MJPEG and frame\n\t * based formats have frame descriptors.\n\t */\n\twhile (buflen > 2 && buffer[2] == ftype) {\n\t\tframe = &format->frame[format->nframes];\n\n\t\tif (ftype != VS_FRAME_FRAME_BASED)\n\t\t\tn = buflen > 25 ? buffer[25] : 0;\n\t\telse\n\t\t\tn = buflen > 21 ? buffer[21] : 0;\n\n\t\tn = n ? n : 3;\n\n\t\tif (buflen < 26 + 4*n) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d FRAME error\\n\", dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tframe->bFrameIndex = buffer[3];\n\t\tframe->bmCapabilities = buffer[4];\n\t\tframe->wWidth = le16_to_cpup((__le16 *)&buffer[5]);\n\t\tframe->wHeight = le16_to_cpup((__le16 *)&buffer[7]);\n\t\tframe->dwMinBitRate = le32_to_cpup((__le32 *)&buffer[9]);\n\t\tframe->dwMaxBitRate = le32_to_cpup((__le32 *)&buffer[13]);\n\t\tif (ftype != VS_FRAME_FRAME_BASED) {\n\t\t\tframe->dwMaxVideoFrameBufferSize =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[17]);\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[21]);\n\t\t\tframe->bFrameIntervalType = buffer[25];\n\t\t} else {\n\t\t\tframe->dwMaxVideoFrameBufferSize = 0;\n\t\t\tframe->dwDefaultFrameInterval =\n\t\t\t\tle32_to_cpup((__le32 *)&buffer[17]);\n\t\t\tframe->bFrameIntervalType = buffer[21];\n\t\t}\n\t\tframe->dwFrameInterval = *intervals;\n\n\t\t/* Several UVC chipsets screw up dwMaxVideoFrameBufferSize\n\t\t * completely. Observed behaviours range from setting the\n\t\t * value to 1.1x the actual frame size of hardwiring the\n\t\t * 16 low bits to 0. This results in a higher than necessary\n\t\t * memory usage as well as a wrong image size information. For\n\t\t * uncompressed formats this can be fixed by computing the\n\t\t * value from the frame size.\n\t\t */\n\t\tif (!(format->flags & UVC_FMT_FLAG_COMPRESSED))\n\t\t\tframe->dwMaxVideoFrameBufferSize = format->bpp\n\t\t\t\t* frame->wWidth * frame->wHeight / 8;\n\n\t\t/* Some bogus devices report dwMinFrameInterval equal to\n\t\t * dwMaxFrameInterval and have dwFrameIntervalStep set to\n\t\t * zero. Setting all null intervals to 1 fixes the problem and\n\t\t * some other divisions by zero which could happen.\n\t\t */\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tinterval = le32_to_cpup((__le32 *)&buffer[26+4*i]);\n\t\t\t*(*intervals)++ = interval ? interval : 1;\n\t\t}\n\n\t\t/* Make sure that the default frame interval stays between\n\t\t * the boundaries.\n\t\t */\n\t\tn -= frame->bFrameIntervalType ? 1 : 2;\n\t\tframe->dwDefaultFrameInterval =\n\t\t\tmin(frame->dwFrameInterval[n],\n\t\t\t    max(frame->dwFrameInterval[0],\n\t\t\t\tframe->dwDefaultFrameInterval));\n\n\t\tuvc_trace(UVC_TRACE_DESCR, \"- %ux%u (%u.%u fps)\\n\",\n\t\t\tframe->wWidth, frame->wHeight,\n\t\t\t10000000/frame->dwDefaultFrameInterval,\n\t\t\t(100000000/frame->dwDefaultFrameInterval)%10);\n\n\t\tformat->nframes++;\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[2] == VS_STILL_IMAGE_FRAME) {\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\tif (buflen > 2 && buffer[2] == VS_COLORFORMAT) {\n\t\tif (buflen < 6) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"device %d videostreaming\"\n\t\t\t       \"interface %d COLORFORMAT error\\n\",\n\t\t\t       dev->udev->devnum,\n\t\t\t       alts->desc.bInterfaceNumber);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tformat->colorspace = uvc_colorspace(buffer[3]);\n\n\t\tbuflen -= buffer[0];\n\t\tbuffer += buffer[0];\n\t}\n\n\treturn buffer - start;\n}", "target": 1, "cwe": ["CWE-120"], "message": "V4L/DVB (8207): uvcvideo: Fix a buffer overflow in format descriptor parsing\n\nThanks to Oliver Neukum for catching and reporting this bug.\n\nSigned-off-by: Laurent Pinchart <laurent.pinchart@skynet.be>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>"}
{"func": "static int get_file_caps(struct linux_binprm *bprm)\n{\n\tstruct dentry *dentry;\n\tint rc = 0;\n\tstruct vfs_cap_data vcaps;\n\tstruct inode *inode;\n\n\tif (bprm->file->f_vfsmnt->mnt_flags & MNT_NOSUID) {\n\t\tbprm_clear_caps(bprm);\n\t\treturn 0;\n\t}\n\n\tdentry = dget(bprm->file->f_dentry);\n\tinode = dentry->d_inode;\n\tif (!inode->i_op || !inode->i_op->getxattr)\n\t\tgoto out;\n\n\trc = inode->i_op->getxattr(dentry, XATTR_NAME_CAPS, &vcaps,\n\t\t\t\t   XATTR_CAPS_SZ);\n\tif (rc == -ENODATA || rc == -EOPNOTSUPP) {\n\t\t/* no data, that's ok */\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = cap_from_disk(&vcaps, bprm, rc);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tdput(dentry);\n\tif (rc)\n\t\tbprm_clear_caps(bprm);\n\n\treturn rc;\n}", "target": 1, "cwe": [], "message": "file caps: always start with clear bprm->caps_*\n\nWhile Linux doesn't honor setuid on scripts.  However, it mistakenly\nbehaves differently for file capabilities.\n\nThis patch fixes that behavior by making sure that get_file_caps()\nbegins with empty bprm->caps_*.  That way when a script is loaded,\nits bprm->caps_* may be filled when binfmt_misc calls prepare_binprm(),\nbut they will be cleared again when binfmt_elf calls prepare_binprm()\nnext to read the interpreter's file capabilities.\n\nSigned-off-by: Serge Hallyn <serue@us.ibm.com>\nAcked-by: David Howells <dhowells@redhat.com>\nAcked-by: Andrew G. Morgan <morgan@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline int get_file_caps(struct linux_binprm *bprm)\n{\n\tbprm_clear_caps(bprm);\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "file caps: always start with clear bprm->caps_*\n\nWhile Linux doesn't honor setuid on scripts.  However, it mistakenly\nbehaves differently for file capabilities.\n\nThis patch fixes that behavior by making sure that get_file_caps()\nbegins with empty bprm->caps_*.  That way when a script is loaded,\nits bprm->caps_* may be filled when binfmt_misc calls prepare_binprm(),\nbut they will be cleared again when binfmt_elf calls prepare_binprm()\nnext to read the interpreter's file capabilities.\n\nSigned-off-by: Serge Hallyn <serue@us.ibm.com>\nAcked-by: David Howells <dhowells@redhat.com>\nAcked-by: Andrew G. Morgan <morgan@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int lbs_process_bss(struct bss_descriptor *bss,\n\t\t\t   uint8_t **pbeaconinfo, int *bytesleft)\n{\n\tstruct ieeetypes_fhparamset *pFH;\n\tstruct ieeetypes_dsparamset *pDS;\n\tstruct ieeetypes_cfparamset *pCF;\n\tstruct ieeetypes_ibssparamset *pibss;\n\tDECLARE_MAC_BUF(mac);\n\tstruct ieeetypes_countryinfoset *pcountryinfo;\n\tuint8_t *pos, *end, *p;\n\tuint8_t n_ex_rates = 0, got_basic_rates = 0, n_basic_rates = 0;\n\tuint16_t beaconsize = 0;\n\tint ret;\n\n\tlbs_deb_enter(LBS_DEB_SCAN);\n\n\tif (*bytesleft >= sizeof(beaconsize)) {\n\t\t/* Extract & convert beacon size from the command buffer */\n\t\tbeaconsize = get_unaligned_le16(*pbeaconinfo);\n\t\t*bytesleft -= sizeof(beaconsize);\n\t\t*pbeaconinfo += sizeof(beaconsize);\n\t}\n\n\tif (beaconsize == 0 || beaconsize > *bytesleft) {\n\t\t*pbeaconinfo += *bytesleft;\n\t\t*bytesleft = 0;\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/* Initialize the current working beacon pointer for this BSS iteration */\n\tpos = *pbeaconinfo;\n\tend = pos + beaconsize;\n\n\t/* Advance the return beacon pointer past the current beacon */\n\t*pbeaconinfo += beaconsize;\n\t*bytesleft -= beaconsize;\n\n\tmemcpy(bss->bssid, pos, ETH_ALEN);\n\tlbs_deb_scan(\"process_bss: BSSID %s\\n\", print_mac(mac, bss->bssid));\n\tpos += ETH_ALEN;\n\n\tif ((end - pos) < 12) {\n\t\tlbs_deb_scan(\"process_bss: Not enough bytes left\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * next 4 fields are RSSI, time stamp, beacon interval,\n\t *   and capability information\n\t */\n\n\t/* RSSI is 1 byte long */\n\tbss->rssi = *pos;\n\tlbs_deb_scan(\"process_bss: RSSI %d\\n\", *pos);\n\tpos++;\n\n\t/* time stamp is 8 bytes long */\n\tpos += 8;\n\n\t/* beacon interval is 2 bytes long */\n\tbss->beaconperiod = get_unaligned_le16(pos);\n\tpos += 2;\n\n\t/* capability information is 2 bytes long */\n\tbss->capability = get_unaligned_le16(pos);\n\tlbs_deb_scan(\"process_bss: capabilities 0x%04x\\n\", bss->capability);\n\tpos += 2;\n\n\tif (bss->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tlbs_deb_scan(\"process_bss: WEP enabled\\n\");\n\tif (bss->capability & WLAN_CAPABILITY_IBSS)\n\t\tbss->mode = IW_MODE_ADHOC;\n\telse\n\t\tbss->mode = IW_MODE_INFRA;\n\n\t/* rest of the current buffer are IE's */\n\tlbs_deb_scan(\"process_bss: IE len %zd\\n\", end - pos);\n\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: IE info\", pos, end - pos);\n\n\t/* process variable IE */\n\twhile (pos <= end - 2) {\n\t\tstruct ieee80211_info_element * elem = (void *)pos;\n\n\t\tif (pos + elem->len > end) {\n\t\t\tlbs_deb_scan(\"process_bss: error in processing IE, \"\n\t\t\t\t     \"bytes left < IE length\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (elem->id) {\n\t\tcase MFIE_TYPE_SSID:\n\t\t\tbss->ssid_len = elem->len;\n\t\t\tmemcpy(bss->ssid, elem->data, elem->len);\n\t\t\tlbs_deb_scan(\"got SSID IE: '%s', len %u\\n\",\n\t\t\t             escape_essid(bss->ssid, bss->ssid_len),\n\t\t\t             bss->ssid_len);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES:\n\t\t\tn_basic_rates = min_t(uint8_t, MAX_RATES, elem->len);\n\t\t\tmemcpy(bss->rates, elem->data, n_basic_rates);\n\t\t\tgot_basic_rates = 1;\n\t\t\tlbs_deb_scan(\"got RATES IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_FH_SET:\n\t\t\tpFH = (struct ieeetypes_fhparamset *) pos;\n\t\t\tmemmove(&bss->phyparamset.fhparamset, pFH,\n\t\t\t\tsizeof(struct ieeetypes_fhparamset));\n\t\t\tlbs_deb_scan(\"got FH IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_DS_SET:\n\t\t\tpDS = (struct ieeetypes_dsparamset *) pos;\n\t\t\tbss->channel = pDS->currentchan;\n\t\t\tmemcpy(&bss->phyparamset.dsparamset, pDS,\n\t\t\t       sizeof(struct ieeetypes_dsparamset));\n\t\t\tlbs_deb_scan(\"got DS IE, channel %d\\n\", bss->channel);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_CF_SET:\n\t\t\tpCF = (struct ieeetypes_cfparamset *) pos;\n\t\t\tmemcpy(&bss->ssparamset.cfparamset, pCF,\n\t\t\t       sizeof(struct ieeetypes_cfparamset));\n\t\t\tlbs_deb_scan(\"got CF IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_IBSS_SET:\n\t\t\tpibss = (struct ieeetypes_ibssparamset *) pos;\n\t\t\tbss->atimwindow = le16_to_cpu(pibss->atimwindow);\n\t\t\tmemmove(&bss->ssparamset.ibssparamset, pibss,\n\t\t\t\tsizeof(struct ieeetypes_ibssparamset));\n\t\t\tlbs_deb_scan(\"got IBSS IE\\n\");\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_COUNTRY:\n\t\t\tpcountryinfo = (struct ieeetypes_countryinfoset *) pos;\n\t\t\tlbs_deb_scan(\"got COUNTRY IE\\n\");\n\t\t\tif (pcountryinfo->len < sizeof(pcountryinfo->countrycode)\n\t\t\t    || pcountryinfo->len > 254) {\n\t\t\t\tlbs_deb_scan(\"process_bss: 11D- Err CountryInfo len %d, min %zd, max 254\\n\",\n\t\t\t\t\t     pcountryinfo->len, sizeof(pcountryinfo->countrycode));\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tmemcpy(&bss->countryinfo, pcountryinfo, pcountryinfo->len + 2);\n\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: 11d countryinfo\",\n\t\t\t\t    (uint8_t *) pcountryinfo,\n\t\t\t\t    (int) (pcountryinfo->len + 2));\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RATES_EX:\n\t\t\t/* only process extended supported rate if data rate is\n\t\t\t * already found. Data rate IE should come before\n\t\t\t * extended supported rate IE\n\t\t\t */\n\t\t\tlbs_deb_scan(\"got RATESEX IE\\n\");\n\t\t\tif (!got_basic_rates) {\n\t\t\t\tlbs_deb_scan(\"... but ignoring it\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn_ex_rates = elem->len;\n\t\t\tif (n_basic_rates + n_ex_rates > MAX_RATES)\n\t\t\t\tn_ex_rates = MAX_RATES - n_basic_rates;\n\n\t\t\tp = bss->rates + n_basic_rates;\n\t\t\tmemcpy(p, elem->data, n_ex_rates);\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_GENERIC:\n\t\t\tif (elem->len >= 4 &&\n\t\t\t    elem->data[0] == 0x00 && elem->data[1] == 0x50 &&\n\t\t\t    elem->data[2] == 0xf2 && elem->data[3] == 0x01) {\n\t\t\t\tbss->wpa_ie_len = min(elem->len + 2, MAX_WPA_IE_LEN);\n\t\t\t\tmemcpy(bss->wpa_ie, elem, bss->wpa_ie_len);\n\t\t\t\tlbs_deb_scan(\"got WPA IE\\n\");\n\t\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"WPA IE\", bss->wpa_ie, elem->len);\n\t\t\t} else if (elem->len >= MARVELL_MESH_IE_LENGTH &&\n\t\t\t\t   elem->data[0] == 0x00 && elem->data[1] == 0x50 &&\n\t\t\t\t   elem->data[2] == 0x43 && elem->data[3] == 0x04) {\n\t\t\t\tlbs_deb_scan(\"got mesh IE\\n\");\n\t\t\t\tbss->mesh = 1;\n\t\t\t} else {\n\t\t\t\tlbs_deb_scan(\"got generic IE: %02x:%02x:%02x:%02x, len %d\\n\",\n\t\t\t\t\telem->data[0], elem->data[1],\n\t\t\t\t\telem->data[2], elem->data[3],\n\t\t\t\t\telem->len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MFIE_TYPE_RSN:\n\t\t\tlbs_deb_scan(\"got RSN IE\\n\");\n\t\t\tbss->rsn_ie_len = min(elem->len + 2, MAX_WPA_IE_LEN);\n\t\t\tmemcpy(bss->rsn_ie, elem, bss->rsn_ie_len);\n\t\t\tlbs_deb_hex(LBS_DEB_SCAN, \"process_bss: RSN_IE\",\n\t\t\t\t    bss->rsn_ie, elem->len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlbs_deb_scan(\"got IE 0x%04x, len %d\\n\",\n\t\t\t\t     elem->id, elem->len);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += elem->len + 2;\n\t}\n\n\t/* Timestamp */\n\tbss->last_scanned = jiffies;\n\tlbs_unset_basic_rate_flags(bss->rates, sizeof(bss->rates));\n\n\tret = 0;\n\ndone:\n\tlbs_deb_leave_args(LBS_DEB_SCAN, \"ret %d\", ret);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "libertas: fix buffer overrun\n\nIf somebody sends an invalid beacon/probe response, that can trash the\nwhole BSS descriptor. The descriptor is, luckily, large enough so that\nit cannot scribble past the end of it; it's well above 400 bytes long.\n\nSigned-off-by: Johannes Berg <johannes@sipsolutions.net>\nCc: stable@kernel.org [2.6.24-2.6.27, bug present in some form since driver was added (2.6.22)]\nSigned-off-by: John W. Linville <linville@tuxdriver.com>"}
{"func": "static int tvaudio_get_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tctrl->value=chip->muted;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tctrl->value = max(chip->left,chip->right);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tctrl->value=(32768*min(chip->left,chip->right))/volume;\n\t\telse\n\t\t\tctrl->value=32768;\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tctrl->value = chip->bass;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\t\tctrl->value = chip->treble;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 1, "cwe": ["CWE-399"], "message": "V4L/DVB (9624): CVE-2008-5033: fix OOPS on tvaudio when controlling bass/treble\n\nThis bug were supposed to be fixed by 5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1,\nwhere a call to NULL happens.\n\nNot all tvaudio chips allow controlling bass/treble. So, the driver\nhas a table with a flag to indicate if the chip does support it.\n\nUnfortunately, the handling of this logic were broken for a very long\ntime (probably since the first module version). Due to that, an OOPS\nwere generated for devices that don't support bass/treble.\n\nThis were the resulting OOPS message before the patch, with debug messages\nenabled:\n\ntvaudio' 1-005b: VIDIOC_S_CTRL\nBUG: unable to handle kernel NULL pointer dereference at 00000000\nIP: [<00000000>]\n*pde = 22fda067 *pte = 00000000\nOops: 0000 [#1] SMP\nModules linked in: snd_hda_intel snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device\nsnd_pcm_oss snd_mixer_oss snd_pcm snd_timer snd_hwdep snd soundcore tuner_simple tuner_types tea5767 tuner\ntvaudio bttv bridgebnep rfcomm l2cap bluetooth it87 hwmon_vid hwmon fuse sunrpc ipt_REJECT\nnf_conntrack_ipv4 iptable_filter ip_tables ip6t_REJECT xt_tcpudp nf_conntrack_ipv6 xt_state nf_conntrack\nip6table_filter ip6_tables x_tables ipv6 dm_mirrordm_multipath dm_mod configfs videodev v4l1_compat\nir_common 8139cp compat_ioctl32 v4l2_common 8139too videobuf_dma_sg videobuf_core mii btcx_risc tveeprom\ni915 button snd_page_alloc serio_raw drm pcspkr i2c_algo_bit i2c_i801 i2c_core iTCO_wdt\niTCO_vendor_support sr_mod cdrom sg ata_generic pata_acpi ata_piix libata sd_mod scsi_mod ext3 jbdmbcache\nuhci_hcd ohci_hcd ehci_hcd [last unloaded: soundcore]\n\nPid: 15413, comm: qv4l2 Not tainted (2.6.25.14-108.fc9.i686 #1)\nEIP: 0060:[<00000000>] EFLAGS: 00210246 CPU: 0\nEIP is at 0x0\nEAX: 00008000 EBX: ebd21600 ECX: e2fd9ec4 EDX: 00200046\nESI: f8c0f0c4 EDI: f8c0f0c4 EBP: e2fd9d50 ESP: e2fd9d2c\n DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\nProcess qv4l2 (pid: 15413, ti=e2fd9000 task=ebe44000 task.ti=e2fd9000)\nStack: f8c0c6ae e2ff2a00 00000d00 e2fd9ec4 ebc4e000 e2fd9d5c f8c0c448 00000000\n       f899c12a e2fd9d5c f899c154 e2fd9d68 e2fd9d80 c0560185 e2fd9d88 f8f3e1d8\n       f8f3e1dc ebc4e034 f8f3e18c e2fd9ec4 00000000 e2fd9d90 f899c286 c008561c\nCall Trace:\n [<f8c0c6ae>] ? chip_command+0x266/0x4b6 [tvaudio]\n [<f8c0c448>] ? chip_command+0x0/0x4b6 [tvaudio]\n [<f899c12a>] ? i2c_cmd+0x0/0x2f [i2c_core]\n [<f899c154>] ? i2c_cmd+0x2a/0x2f [i2c_core]\n [<c0560185>] ? device_for_each_child+0x21/0x49\n [<f899c286>] ? i2c_clients_command+0x1c/0x1e [i2c_core]\n [<f8f283d8>] ? bttv_call_i2c_clients+0x14/0x16 [bttv]\n [<f8f23601>] ? bttv_s_ctrl+0x1bc/0x313 [bttv]\n [<f8f23445>] ? bttv_s_ctrl+0x0/0x313 [bttv]\n [<f8b6096d>] ? __video_do_ioctl+0x1f84/0x3726 [videodev]\n [<c05abb4e>] ? sock_aio_write+0x100/0x10d\n [<c041b23e>] ? kmap_atomic_prot+0x1dd/0x1df\n [<c043a0c9>] ? enqueue_hrtimer+0xc2/0xcd\n [<c04f4fa4>] ? copy_from_user+0x39/0x121\n [<f8b622b9>] ? __video_ioctl2+0x1aa/0x24a [videodev]\n [<c04054fd>] ? do_notify_resume+0x768/0x795\n [<c043c0f7>] ? getnstimeofday+0x34/0xd1\n [<c0437b77>] ? autoremove_wake_function+0x0/0x33\n [<f8b62368>] ? video_ioctl2+0xf/0x13 [videodev]\n [<c048c6f0>] ? vfs_ioctl+0x50/0x69\n [<c048c942>] ? do_vfs_ioctl+0x239/0x24c\n [<c048c995>] ? sys_ioctl+0x40/0x5b\n [<c0405bf2>] ? syscall_call+0x7/0xb\n [<c0620000>] ? cpuid4_cache_sysfs_exit+0x3d/0x69\n =======================\nCode:  Bad EIP value.\nEIP: [<00000000>] 0x0 SS:ESP 0068:e2fd9d2c\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static int chip_command(struct i2c_client *client,\n\t\t\tunsigned int cmd, void *arg)\n{\n\tstruct CHIPSTATE *chip = i2c_get_clientdata(client);\n\tstruct CHIPDESC  *desc = chip->desc;\n\n\tif (debug > 0) {\n\t\tv4l_i2c_print_ioctl(chip->c, cmd);\n\t\tprintk(\"\\n\");\n\t}\n\n\tswitch (cmd) {\n\tcase AUDC_SET_RADIO:\n\t\tchip->radio = 1;\n\t\tchip->watch_stereo = 0;\n\t\t/* del_timer(&chip->wt); */\n\t\tbreak;\n\t/* --- v4l ioctls --- */\n\t/* take care: bttv does userspace copying, we'll get a\n\tkernel pointer here... */\n\tcase VIDIOC_QUERYCTRL:\n\t{\n\t\tstruct v4l2_queryctrl *qc = arg;\n\n\t\tswitch (qc->id) {\n\t\t\tcase V4L2_CID_AUDIO_MUTE:\n\t\t\t\tbreak;\n\t\t\tcase V4L2_CID_AUDIO_VOLUME:\n\t\t\tcase V4L2_CID_AUDIO_BALANCE:\n\t\t\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase V4L2_CID_AUDIO_BASS:\n\t\t\tcase V4L2_CID_AUDIO_TREBLE:\n\t\t\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn v4l2_ctrl_query_fill_std(qc);\n\t}\n\tcase VIDIOC_S_CTRL:\n\t\treturn tvaudio_set_ctrl(chip, arg);\n\n\tcase VIDIOC_G_CTRL:\n\t\treturn tvaudio_get_ctrl(chip, arg);\n\tcase VIDIOC_INT_G_AUDIO_ROUTING:\n\t{\n\t\tstruct v4l2_routing *rt = arg;\n\n\t\trt->input = chip->input;\n\t\trt->output = 0;\n\t\tbreak;\n\t}\n\tcase VIDIOC_INT_S_AUDIO_ROUTING:\n\t{\n\t\tstruct v4l2_routing *rt = arg;\n\n\t\tif (!(desc->flags & CHIP_HAS_INPUTSEL) || rt->input >= 4)\n\t\t\t\treturn -EINVAL;\n\t\t/* There are four inputs: tuner, radio, extern and intern. */\n\t\tchip->input = rt->input;\n\t\tif (chip->muted)\n\t\t\tbreak;\n\t\tchip_write_masked(chip, desc->inputreg,\n\t\t\t\tdesc->inputmap[chip->input], desc->inputmask);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_TUNER:\n\t{\n\t\tstruct v4l2_tuner *vt = arg;\n\t\tint mode = 0;\n\n\t\tif (chip->radio)\n\t\t\tbreak;\n\t\tswitch (vt->audmode) {\n\t\tcase V4L2_TUNER_MODE_MONO:\n\t\tcase V4L2_TUNER_MODE_STEREO:\n\t\tcase V4L2_TUNER_MODE_LANG1:\n\t\tcase V4L2_TUNER_MODE_LANG2:\n\t\t\tmode = vt->audmode;\n\t\t\tbreak;\n\t\tcase V4L2_TUNER_MODE_LANG1_LANG2:\n\t\t\tmode = V4L2_TUNER_MODE_STEREO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchip->audmode = vt->audmode;\n\n\t\tif (desc->setmode && mode) {\n\t\t\tchip->watch_stereo = 0;\n\t\t\t/* del_timer(&chip->wt); */\n\t\t\tchip->mode = mode;\n\t\t\tdesc->setmode(chip, mode);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_TUNER:\n\t{\n\t\tstruct v4l2_tuner *vt = arg;\n\t\tint mode = V4L2_TUNER_MODE_MONO;\n\n\t\tif (chip->radio)\n\t\t\tbreak;\n\t\tvt->audmode = chip->audmode;\n\t\tvt->rxsubchans = 0;\n\t\tvt->capability = V4L2_TUNER_CAP_STEREO |\n\t\t\tV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\n\n\t\tif (desc->getmode)\n\t\t\tmode = desc->getmode(chip);\n\n\t\tif (mode & V4L2_TUNER_MODE_MONO)\n\t\t\tvt->rxsubchans |= V4L2_TUNER_SUB_MONO;\n\t\tif (mode & V4L2_TUNER_MODE_STEREO)\n\t\t\tvt->rxsubchans |= V4L2_TUNER_SUB_STEREO;\n\t\t/* Note: for SAP it should be mono/lang2 or stereo/lang2.\n\t\t   When this module is converted fully to v4l2, then this\n\t\t   should change for those chips that can detect SAP. */\n\t\tif (mode & V4L2_TUNER_MODE_LANG1)\n\t\t\tvt->rxsubchans = V4L2_TUNER_SUB_LANG1 |\n\t\t\t\t\t V4L2_TUNER_SUB_LANG2;\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_STD:\n\t\tchip->radio = 0;\n\t\tbreak;\n\tcase VIDIOC_S_FREQUENCY:\n\t\tchip->mode = 0; /* automatic */\n\n\t\t/* For chips that provide getmode and setmode, and doesn't\n\t\t   automatically follows the stereo carrier, a kthread is\n\t\t   created to set the audio standard. In this case, when then\n\t\t   the video channel is changed, tvaudio starts on MONO mode.\n\t\t   After waiting for 2 seconds, the kernel thread is called,\n\t\t   to follow whatever audio standard is pointed by the\n\t\t   audio carrier.\n\t\t */\n\t\tif (chip->thread) {\n\t\t\tdesc->setmode(chip,V4L2_TUNER_MODE_MONO);\n\t\t\tif (chip->prevmode != V4L2_TUNER_MODE_MONO)\n\t\t\t\tchip->prevmode = -1; /* reset previous mode */\n\t\t\tmod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));\n\t\t}\n\t\tbreak;\n\n\tcase VIDIOC_G_CHIP_IDENT:\n\t\treturn v4l2_chip_ident_i2c_client(client, arg, V4L2_IDENT_TVAUDIO, 0);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "V4L/DVB (9624): CVE-2008-5033: fix OOPS on tvaudio when controlling bass/treble\n\nThis bug were supposed to be fixed by 5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1,\nwhere a call to NULL happens.\n\nNot all tvaudio chips allow controlling bass/treble. So, the driver\nhas a table with a flag to indicate if the chip does support it.\n\nUnfortunately, the handling of this logic were broken for a very long\ntime (probably since the first module version). Due to that, an OOPS\nwere generated for devices that don't support bass/treble.\n\nThis were the resulting OOPS message before the patch, with debug messages\nenabled:\n\ntvaudio' 1-005b: VIDIOC_S_CTRL\nBUG: unable to handle kernel NULL pointer dereference at 00000000\nIP: [<00000000>]\n*pde = 22fda067 *pte = 00000000\nOops: 0000 [#1] SMP\nModules linked in: snd_hda_intel snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device\nsnd_pcm_oss snd_mixer_oss snd_pcm snd_timer snd_hwdep snd soundcore tuner_simple tuner_types tea5767 tuner\ntvaudio bttv bridgebnep rfcomm l2cap bluetooth it87 hwmon_vid hwmon fuse sunrpc ipt_REJECT\nnf_conntrack_ipv4 iptable_filter ip_tables ip6t_REJECT xt_tcpudp nf_conntrack_ipv6 xt_state nf_conntrack\nip6table_filter ip6_tables x_tables ipv6 dm_mirrordm_multipath dm_mod configfs videodev v4l1_compat\nir_common 8139cp compat_ioctl32 v4l2_common 8139too videobuf_dma_sg videobuf_core mii btcx_risc tveeprom\ni915 button snd_page_alloc serio_raw drm pcspkr i2c_algo_bit i2c_i801 i2c_core iTCO_wdt\niTCO_vendor_support sr_mod cdrom sg ata_generic pata_acpi ata_piix libata sd_mod scsi_mod ext3 jbdmbcache\nuhci_hcd ohci_hcd ehci_hcd [last unloaded: soundcore]\n\nPid: 15413, comm: qv4l2 Not tainted (2.6.25.14-108.fc9.i686 #1)\nEIP: 0060:[<00000000>] EFLAGS: 00210246 CPU: 0\nEIP is at 0x0\nEAX: 00008000 EBX: ebd21600 ECX: e2fd9ec4 EDX: 00200046\nESI: f8c0f0c4 EDI: f8c0f0c4 EBP: e2fd9d50 ESP: e2fd9d2c\n DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\nProcess qv4l2 (pid: 15413, ti=e2fd9000 task=ebe44000 task.ti=e2fd9000)\nStack: f8c0c6ae e2ff2a00 00000d00 e2fd9ec4 ebc4e000 e2fd9d5c f8c0c448 00000000\n       f899c12a e2fd9d5c f899c154 e2fd9d68 e2fd9d80 c0560185 e2fd9d88 f8f3e1d8\n       f8f3e1dc ebc4e034 f8f3e18c e2fd9ec4 00000000 e2fd9d90 f899c286 c008561c\nCall Trace:\n [<f8c0c6ae>] ? chip_command+0x266/0x4b6 [tvaudio]\n [<f8c0c448>] ? chip_command+0x0/0x4b6 [tvaudio]\n [<f899c12a>] ? i2c_cmd+0x0/0x2f [i2c_core]\n [<f899c154>] ? i2c_cmd+0x2a/0x2f [i2c_core]\n [<c0560185>] ? device_for_each_child+0x21/0x49\n [<f899c286>] ? i2c_clients_command+0x1c/0x1e [i2c_core]\n [<f8f283d8>] ? bttv_call_i2c_clients+0x14/0x16 [bttv]\n [<f8f23601>] ? bttv_s_ctrl+0x1bc/0x313 [bttv]\n [<f8f23445>] ? bttv_s_ctrl+0x0/0x313 [bttv]\n [<f8b6096d>] ? __video_do_ioctl+0x1f84/0x3726 [videodev]\n [<c05abb4e>] ? sock_aio_write+0x100/0x10d\n [<c041b23e>] ? kmap_atomic_prot+0x1dd/0x1df\n [<c043a0c9>] ? enqueue_hrtimer+0xc2/0xcd\n [<c04f4fa4>] ? copy_from_user+0x39/0x121\n [<f8b622b9>] ? __video_ioctl2+0x1aa/0x24a [videodev]\n [<c04054fd>] ? do_notify_resume+0x768/0x795\n [<c043c0f7>] ? getnstimeofday+0x34/0xd1\n [<c0437b77>] ? autoremove_wake_function+0x0/0x33\n [<f8b62368>] ? video_ioctl2+0xf/0x13 [videodev]\n [<c048c6f0>] ? vfs_ioctl+0x50/0x69\n [<c048c942>] ? do_vfs_ioctl+0x239/0x24c\n [<c048c995>] ? sys_ioctl+0x40/0x5b\n [<c0405bf2>] ? syscall_call+0x7/0xb\n [<c0620000>] ? cpuid4_cache_sysfs_exit+0x3d/0x69\n =======================\nCode:  Bad EIP value.\nEIP: [<00000000>] 0x0 SS:ESP 0068:e2fd9d2c\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static int tvaudio_set_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tif (ctrl->value < 0 || ctrl->value >= 2)\n\t\t\treturn -ERANGE;\n\t\tchip->muted = ctrl->value;\n\t\tif (chip->muted)\n\t\t\tchip_write_masked(chip,desc->inputreg,desc->inputmute,desc->inputmask);\n\t\telse\n\t\t\tchip_write_masked(chip,desc->inputreg,\n\t\t\t\t\tdesc->inputmap[chip->input],desc->inputmask);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t{\n\t\tint volume,balance;\n\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tbalance=(32768*min(chip->left,chip->right))/volume;\n\t\telse\n\t\t\tbalance=32768;\n\n\t\tvolume=ctrl->value;\n\t\tchip->left = (min(65536 - balance,32768) * volume) / 32768;\n\t\tchip->right = (min(balance,volume *(__u16)32768)) / 32768;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume, balance;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\n\t\tvolume = max(chip->left,chip->right);\n\t\tbalance = ctrl->value;\n\n\t\tchip_write(chip,desc->leftreg,desc->volfunc(chip->left));\n\t\tchip_write(chip,desc->rightreg,desc->volfunc(chip->right));\n\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tchip->bass = ctrl->value;\n\t\tchip_write(chip,desc->bassreg,desc->bassfunc(chip->bass));\n\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\n\t\tchip->treble = ctrl->value;\n\t\tchip_write(chip,desc->treblereg,desc->treblefunc(chip->treble));\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 1, "cwe": ["CWE-399"], "message": "V4L/DVB (9624): CVE-2008-5033: fix OOPS on tvaudio when controlling bass/treble\n\nThis bug were supposed to be fixed by 5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1,\nwhere a call to NULL happens.\n\nNot all tvaudio chips allow controlling bass/treble. So, the driver\nhas a table with a flag to indicate if the chip does support it.\n\nUnfortunately, the handling of this logic were broken for a very long\ntime (probably since the first module version). Due to that, an OOPS\nwere generated for devices that don't support bass/treble.\n\nThis were the resulting OOPS message before the patch, with debug messages\nenabled:\n\ntvaudio' 1-005b: VIDIOC_S_CTRL\nBUG: unable to handle kernel NULL pointer dereference at 00000000\nIP: [<00000000>]\n*pde = 22fda067 *pte = 00000000\nOops: 0000 [#1] SMP\nModules linked in: snd_hda_intel snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device\nsnd_pcm_oss snd_mixer_oss snd_pcm snd_timer snd_hwdep snd soundcore tuner_simple tuner_types tea5767 tuner\ntvaudio bttv bridgebnep rfcomm l2cap bluetooth it87 hwmon_vid hwmon fuse sunrpc ipt_REJECT\nnf_conntrack_ipv4 iptable_filter ip_tables ip6t_REJECT xt_tcpudp nf_conntrack_ipv6 xt_state nf_conntrack\nip6table_filter ip6_tables x_tables ipv6 dm_mirrordm_multipath dm_mod configfs videodev v4l1_compat\nir_common 8139cp compat_ioctl32 v4l2_common 8139too videobuf_dma_sg videobuf_core mii btcx_risc tveeprom\ni915 button snd_page_alloc serio_raw drm pcspkr i2c_algo_bit i2c_i801 i2c_core iTCO_wdt\niTCO_vendor_support sr_mod cdrom sg ata_generic pata_acpi ata_piix libata sd_mod scsi_mod ext3 jbdmbcache\nuhci_hcd ohci_hcd ehci_hcd [last unloaded: soundcore]\n\nPid: 15413, comm: qv4l2 Not tainted (2.6.25.14-108.fc9.i686 #1)\nEIP: 0060:[<00000000>] EFLAGS: 00210246 CPU: 0\nEIP is at 0x0\nEAX: 00008000 EBX: ebd21600 ECX: e2fd9ec4 EDX: 00200046\nESI: f8c0f0c4 EDI: f8c0f0c4 EBP: e2fd9d50 ESP: e2fd9d2c\n DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\nProcess qv4l2 (pid: 15413, ti=e2fd9000 task=ebe44000 task.ti=e2fd9000)\nStack: f8c0c6ae e2ff2a00 00000d00 e2fd9ec4 ebc4e000 e2fd9d5c f8c0c448 00000000\n       f899c12a e2fd9d5c f899c154 e2fd9d68 e2fd9d80 c0560185 e2fd9d88 f8f3e1d8\n       f8f3e1dc ebc4e034 f8f3e18c e2fd9ec4 00000000 e2fd9d90 f899c286 c008561c\nCall Trace:\n [<f8c0c6ae>] ? chip_command+0x266/0x4b6 [tvaudio]\n [<f8c0c448>] ? chip_command+0x0/0x4b6 [tvaudio]\n [<f899c12a>] ? i2c_cmd+0x0/0x2f [i2c_core]\n [<f899c154>] ? i2c_cmd+0x2a/0x2f [i2c_core]\n [<c0560185>] ? device_for_each_child+0x21/0x49\n [<f899c286>] ? i2c_clients_command+0x1c/0x1e [i2c_core]\n [<f8f283d8>] ? bttv_call_i2c_clients+0x14/0x16 [bttv]\n [<f8f23601>] ? bttv_s_ctrl+0x1bc/0x313 [bttv]\n [<f8f23445>] ? bttv_s_ctrl+0x0/0x313 [bttv]\n [<f8b6096d>] ? __video_do_ioctl+0x1f84/0x3726 [videodev]\n [<c05abb4e>] ? sock_aio_write+0x100/0x10d\n [<c041b23e>] ? kmap_atomic_prot+0x1dd/0x1df\n [<c043a0c9>] ? enqueue_hrtimer+0xc2/0xcd\n [<c04f4fa4>] ? copy_from_user+0x39/0x121\n [<f8b622b9>] ? __video_ioctl2+0x1aa/0x24a [videodev]\n [<c04054fd>] ? do_notify_resume+0x768/0x795\n [<c043c0f7>] ? getnstimeofday+0x34/0xd1\n [<c0437b77>] ? autoremove_wake_function+0x0/0x33\n [<f8b62368>] ? video_ioctl2+0xf/0x13 [videodev]\n [<c048c6f0>] ? vfs_ioctl+0x50/0x69\n [<c048c942>] ? do_vfs_ioctl+0x239/0x24c\n [<c048c995>] ? sys_ioctl+0x40/0x5b\n [<c0405bf2>] ? syscall_call+0x7/0xb\n [<c0620000>] ? cpuid4_cache_sysfs_exit+0x3d/0x69\n =======================\nCode:  Bad EIP value.\nEIP: [<00000000>] 0x0 SS:ESP 0068:e2fd9d2c\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static int chip_write_masked(struct CHIPSTATE *chip, int subaddr, int val, int mask)\n{\n\tif (mask != 0) {\n\t\tif (-1 == subaddr) {\n\t\t\tval = (chip->shadow.bytes[1] & ~mask) | (val & mask);\n\t\t} else {\n\t\t\tval = (chip->shadow.bytes[subaddr+1] & ~mask) | (val & mask);\n\t\t}\n\t}\n\treturn chip_write(chip, subaddr, val);\n}", "target": 1, "cwe": [], "message": "V4L/DVB (9621): Avoid writing outside shadow.bytes[] array\n\nThere were no check about the limits of shadow.bytes array. This offers\na risk of writing values outside the limits, overriding other data\nareas.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static int chip_write(struct CHIPSTATE *chip, int subaddr, int val)\n{\n\tunsigned char buffer[2];\n\n\tif (-1 == subaddr) {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: 0x%x\\n\",\n\t\t\tchip->c->name, val);\n\t\tchip->shadow.bytes[1] = val;\n\t\tbuffer[0] = val;\n\t\tif (1 != i2c_master_send(chip->c,buffer,1)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write 0x%x)\\n\",\n\t\t\t\tchip->c->name, val);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tv4l_dbg(1, debug, chip->c, \"%s: chip_write: reg%d=0x%x\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\tchip->shadow.bytes[subaddr+1] = val;\n\t\tbuffer[0] = subaddr;\n\t\tbuffer[1] = val;\n\t\tif (2 != i2c_master_send(chip->c,buffer,2)) {\n\t\t\tv4l_warn(chip->c, \"%s: I/O error (write reg%d=0x%x)\\n\",\n\t\t\tchip->c->name, subaddr, val);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "V4L/DVB (9621): Avoid writing outside shadow.bytes[] array\n\nThere were no check about the limits of shadow.bytes array. This offers\na risk of writing values outside the limits, overriding other data\nareas.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static int chip_cmd(struct CHIPSTATE *chip, char *name, audiocmd *cmd)\n{\n\tint i;\n\n\tif (0 == cmd->count)\n\t\treturn 0;\n\n\t/* update our shadow register set; print bytes if (debug > 0) */\n\tv4l_dbg(1, debug, chip->c, \"%s: chip_cmd(%s): reg=%d, data:\",\n\t\tchip->c->name, name,cmd->bytes[0]);\n\tfor (i = 1; i < cmd->count; i++) {\n\t\tif (debug)\n\t\t\tprintk(\" 0x%x\",cmd->bytes[i]);\n\t\tchip->shadow.bytes[i+cmd->bytes[0]] = cmd->bytes[i];\n\t}\n\tif (debug)\n\t\tprintk(\"\\n\");\n\n\t/* send data to the chip */\n\tif (cmd->count != i2c_master_send(chip->c,cmd->bytes,cmd->count)) {\n\t\tv4l_warn(chip->c, \"%s: I/O error (%s)\\n\", chip->c->name, name);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "V4L/DVB (9621): Avoid writing outside shadow.bytes[] array\n\nThere were no check about the limits of shadow.bytes array. This offers\na risk of writing values outside the limits, overriding other data\nareas.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>"}
{"func": "static void audit_inotify_unregister(struct list_head *in_list)\n{\n\tstruct audit_parent *p, *n;\n\n\tlist_for_each_entry_safe(p, n, in_list, ilist) {\n\t\tlist_del(&p->ilist);\n\t\tinotify_rm_watch(audit_ih, &p->wdata);\n\t\t/* the put matching the get in audit_do_del_rule() */\n\t\tput_inotify_watch(&p->wdata);\n\t}\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void untag_chunk(struct audit_chunk *chunk, struct node *p)\n{\n\tstruct audit_chunk *new;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tmutex_lock(&chunk->watch.inode->inotify_mutex);\n\tif (chunk->dead) {\n\t\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\t\treturn;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tinotify_evict_watch(&chunk->watch);\n\t\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\t\tput_inotify_watch(&chunk->watch);\n\t\treturn;\n\t}\n\n\tnew = alloc_chunk(size);\n\tif (!new)\n\t\tgoto Fallback;\n\tif (inotify_clone_watch(&chunk->watch, &new->watch) < 0) {\n\t\tfree_chunk(new);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; i < size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[i].list, &new->owners[j].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tinotify_evict_watch(&chunk->watch);\n\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n\tput_inotify_watch(&chunk->watch);\n\treturn;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&chunk->watch.inode->inotify_mutex);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\t\tstruct audit_chunk *chunk;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tchunk = find_chunk(node);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, node);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline void free_chunk(struct audit_chunk *chunk)\n{\n\tcall_rcu(&chunk->head, __free_chunk);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void inotify_destroy(struct inotify_handle *ih)\n{\n\t/*\n\t * Destroy all of the watches for this handle. Unfortunately, not very\n\t * pretty.  We cannot do a simple iteration over the list, because we\n\t * do not know the inode until we iterate to the watch.  But we need to\n\t * hold inode->inotify_mutex before ih->mutex.  The following works.\n\t */\n\twhile (1) {\n\t\tstruct inotify_watch *watch;\n\t\tstruct list_head *watches;\n\t\tstruct inode *inode;\n\n\t\tmutex_lock(&ih->mutex);\n\t\twatches = &ih->watches;\n\t\tif (list_empty(watches)) {\n\t\t\tmutex_unlock(&ih->mutex);\n\t\t\tbreak;\n\t\t}\n\t\twatch = list_first_entry(watches, struct inotify_watch, h_list);\n\t\tget_inotify_watch(watch);\n\t\tmutex_unlock(&ih->mutex);\n\n\t\tinode = watch->inode;\n\t\tmutex_lock(&inode->inotify_mutex);\n\t\tmutex_lock(&ih->mutex);\n\n\t\t/* make sure we didn't race with another list removal */\n\t\tif (likely(idr_find(&ih->idr, watch->wd))) {\n\t\t\tremove_watch_no_event(watch, ih);\n\t\t\tput_inotify_watch(watch);\n\t\t}\n\n\t\tmutex_unlock(&ih->mutex);\n\t\tmutex_unlock(&inode->inotify_mutex);\n\t\tput_inotify_watch(watch);\n\t}\n\n\t/* free this handle: the put matching the get in inotify_init() */\n\tput_inotify_handle(ih);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tstruct list_head *list = chunk_hash(inode);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (p->watch.inode == inode) {\n\t\t\tget_inotify_watch(&p->watch);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int inotify_rm_wd(struct inotify_handle *ih, u32 wd)\n{\n\tstruct inotify_watch *watch;\n\tstruct inode *inode;\n\n\tmutex_lock(&ih->mutex);\n\twatch = idr_find(&ih->idr, wd);\n\tif (unlikely(!watch)) {\n\t\tmutex_unlock(&ih->mutex);\n\t\treturn -EINVAL;\n\t}\n\tget_inotify_watch(watch);\n\tinode = watch->inode;\n\tmutex_unlock(&ih->mutex);\n\n\tmutex_lock(&inode->inotify_mutex);\n\tmutex_lock(&ih->mutex);\n\n\t/* make sure that we did not race */\n\tif (likely(idr_find(&ih->idr, wd) == watch))\n\t\tinotify_remove_watch_locked(ih, watch);\n\n\tmutex_unlock(&ih->mutex);\n\tmutex_unlock(&inode->inotify_mutex);\n\tput_inotify_watch(watch);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline int audit_del_rule(struct audit_entry *entry,\n\t\t\t\t struct list_head *list)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_field *inode_f = entry->rule.inode_f;\n\tstruct audit_watch *watch, *tmp_watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tLIST_HEAD(inotify_list);\n\tint h, ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t/* If either of these, don't count towards total */\n\tif (entry->rule.listnr == AUDIT_FILTER_USER ||\n\t\tentry->rule.listnr == AUDIT_FILTER_TYPE)\n\t\tdont_count = 1;\n#endif\n\n\tif (inode_f) {\n\t\th = audit_hash_ino(inode_f->val);\n\t\tlist = &audit_inode_hash[h];\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, list);\n\tif (!e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\twatch = e->rule.watch;\n\tif (watch) {\n\t\tstruct audit_parent *parent = watch->parent;\n\n\t\tlist_del(&e->rule.rlist);\n\n\t\tif (list_empty(&watch->rules)) {\n\t\t\taudit_remove_watch(watch);\n\n\t\t\tif (list_empty(&parent->watches)) {\n\t\t\t\t/* Put parent on the inotify un-registration\n\t\t\t\t * list.  Grab a reference before releasing\n\t\t\t\t * audit_filter_mutex, to be released in\n\t\t\t\t * audit_inotify_unregister(). */\n\t\t\t\tlist_add(&parent->ilist, &inotify_list);\n\t\t\t\tget_inotify_watch(&parent->wdata);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tlist_del_rcu(&e->list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (!list_empty(&inotify_list))\n\t\taudit_inotify_unregister(&inotify_list);\n\nout:\n\tif (tmp_watch)\n\t\taudit_put_watch(tmp_watch); /* match initial get */\n\tif (tree)\n\t\taudit_put_tree(tree);\t/* that's the temporary one */\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void destroy_watch(struct inotify_watch *watch)\n{\n\tstruct audit_chunk *chunk = container_of(watch, struct audit_chunk, watch);\n\tfree_chunk(chunk);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tinotify_init_watch(&chunk->watch);\n\treturn chunk;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tput_inotify_watch(&chunk->watch);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\t\tstruct audit_chunk *chunk;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\t\tchunk = find_chunk(p);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, p);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void __free_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}", "target": 1, "cwe": ["CWE-362"], "message": "Fix inotify watch removal/umount races\n\nInotify watch removals suck violently.\n\nTo kick the watch out we need (in this order) inode->inotify_mutex and\nih->mutex.  That's fine if we have a hold on inode; however, for all\nother cases we need to make damn sure we don't race with umount.  We can\n*NOT* just grab a reference to a watch - inotify_unmount_inodes() will\nhappily sail past it and we'll end with reference to inode potentially\noutliving its superblock.\n\nIdeally we just want to grab an active reference to superblock if we\ncan; that will make sure we won't go into inotify_umount_inodes() until\nwe are done.  Cleanup is just deactivate_super().\n\nHowever, that leaves a messy case - what if we *are* racing with\numount() and active references to superblock can't be acquired anymore?\nWe can bump ->s_count, grab ->s_umount, which will almost certainly wait\nuntil the superblock is shut down and the watch in question is pining\nfor fjords.  That's fine, but there is a problem - we might have hit the\nwindow between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.\nthe moment when superblock is past the point of no return and is heading\nfor shutdown) and the moment when deactivate_super() acquires\n->s_umount.\n\nWe could just do drop_super() yield() and retry, but that's rather\nantisocial and this stuff is luser-triggerable.  OTOH, having grabbed\n->s_umount and having found that we'd got there first (i.e.  that\n->s_root is non-NULL) we know that we won't race with\ninotify_umount_inodes().\n\nSo we could grab a reference to watch and do the rest as above, just\nwith drop_super() instead of deactivate_super(), right? Wrong.  We had\nto drop ih->mutex before we could grab ->s_umount.  So the watch\ncould've been gone already.\n\nThat still can be dealt with - we need to save watch->wd, do idr_find()\nand compare its result with our pointer.  If they match, we either have\nthe damn thing still alive or we'd lost not one but two races at once,\nthe watch had been killed and a new one got created with the same ->wd\nat the same address.  That couldn't have happened in inotify_destroy(),\nbut inotify_rm_wd() could run into that.  Still, \"new one got created\"\nis not a problem - we have every right to kill it or leave it alone,\nwhatever's more convenient.\n\nSo we can use idr_find(...) == watch && watch->inode->i_sb == sb as\n\"grab it and kill it\" check.  If it's been our original watch, we are\nfine, if it's a newcomer - nevermind, just pretend that we'd won the\nrace and kill the fscker anyway; we are safe since we know that its\nsuperblock won't be going away.\n\nAnd yes, this is far beyond mere \"not very pretty\"; so's the entire\nconcept of inotify to start with.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nAcked-by: Greg KH <greg@kroah.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tint err,size;\n\tstruct sk_buff *skb;\n\tint sent=0;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile(sent < len)\n\t{\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb=sock_alloc_send_skb(sk,size,msg->msg_flags&MSG_DONTWAIT, &err);\n\n\t\tif (skb==NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\t\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\t\tif (siocb->scm->fp) {\n\t\t\terr = unix_attach_fds(siocb->scm, skb);\n\t\t\tif (err) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tif ((err = memcpy_fromiovec(skb_put(skb,size), msg->msg_iov, size)) != 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent+=size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent==0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE,current,0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}", "target": 1, "cwe": ["CWE-399"], "message": "net: Fix soft lockups/OOM issues w/ unix garbage collector\n\nThis is an implementation of David Miller's suggested fix in:\n  https://bugzilla.redhat.com/show_bug.cgi?id=470201\n\nIt has been updated to use wait_event() instead of\nwait_event_interruptible().\n\nParaphrasing the description from the above report, it makes sendmsg()\nblock while UNIX garbage collection is in progress. This avoids a\nsituation where child processes continue to queue new FDs over a\nAF_UNIX socket to a parent which is in the exit path and running\ngarbage collection on these FDs. This contention can result in soft\nlockups and oom-killing of unrelated processes.\n\nSigned-off-by: dann frazier <dannf@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void unix_gc(void)\n{\n\tstatic bool gc_in_progress = false;\n\n\tstruct unix_sock *u;\n\tstruct unix_sock *next;\n\tstruct sk_buff_head hitlist;\n\tstruct list_head cursor;\n\tLIST_HEAD(not_cycle_list);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* Avoid a recursive GC. */\n\tif (gc_in_progress)\n\t\tgoto out;\n\n\tgc_in_progress = true;\n\t/*\n\t * First, select candidates for garbage collection.  Only\n\t * in-flight sockets are considered, and from those only ones\n\t * which don't have any external reference.\n\t *\n\t * Holding unix_gc_lock will protect these candidates from\n\t * being detached, and hence from gaining an external\n\t * reference.  Since there are no possible receivers, all\n\t * buffers currently on the candidates' queues stay there\n\t * during the garbage collection.\n\t *\n\t * We also know that no new candidate can be added onto the\n\t * receive queues.  Other, non candidate sockets _can_ be\n\t * added to queue, so we must make sure only to touch\n\t * candidates.\n\t */\n\tlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\t\tlong total_refs;\n\t\tlong inflight_refs;\n\n\t\ttotal_refs = file_count(u->sk.sk_socket->file);\n\t\tinflight_refs = atomic_long_read(&u->inflight);\n\n\t\tBUG_ON(inflight_refs < 1);\n\t\tBUG_ON(total_refs < inflight_refs);\n\t\tif (total_refs == inflight_refs) {\n\t\t\tlist_move_tail(&u->link, &gc_candidates);\n\t\t\tu->gc_candidate = 1;\n\t\t\tu->gc_maybe_cycle = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Now remove all internal in-flight reference to children of\n\t * the candidates.\n\t */\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, dec_inflight, NULL);\n\n\t/*\n\t * Restore the references for children of all candidates,\n\t * which have remaining references.  Do this recursively, so\n\t * only those remain, which form cyclic references.\n\t *\n\t * Use a \"cursor\" link, to make the list traversal safe, even\n\t * though elements might be moved about.\n\t */\n\tlist_add(&cursor, &gc_candidates);\n\twhile (cursor.next != &gc_candidates) {\n\t\tu = list_entry(cursor.next, struct unix_sock, link);\n\n\t\t/* Move cursor to after the current position. */\n\t\tlist_move(&cursor, &u->link);\n\n\t\tif (atomic_long_read(&u->inflight) > 0) {\n\t\t\tlist_move_tail(&u->link, &not_cycle_list);\n\t\t\tu->gc_maybe_cycle = 0;\n\t\t\tscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\t\t}\n\t}\n\tlist_del(&cursor);\n\n\t/*\n\t * not_cycle_list contains those sockets which do not make up a\n\t * cycle.  Restore these to the inflight list.\n\t */\n\twhile (!list_empty(&not_cycle_list)) {\n\t\tu = list_entry(not_cycle_list.next, struct unix_sock, link);\n\t\tu->gc_candidate = 0;\n\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\t}\n\n\t/*\n\t * Now gc_candidates contains only garbage.  Restore original\n\t * inflight counters for these as well, and remove the skbuffs\n\t * which are creating the cycle(s).\n\t */\n\tskb_queue_head_init(&hitlist);\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, inc_inflight, &hitlist);\n\n\tspin_unlock(&unix_gc_lock);\n\n\t/* Here we are. Hitlist is filled. Die. */\n\t__skb_queue_purge(&hitlist);\n\n\tspin_lock(&unix_gc_lock);\n\n\t/* All candidates should have been detached by now. */\n\tBUG_ON(!list_empty(&gc_candidates));\n\tgc_in_progress = false;\n\n out:\n\tspin_unlock(&unix_gc_lock);\n}", "target": 1, "cwe": ["CWE-399"], "message": "net: Fix soft lockups/OOM issues w/ unix garbage collector\n\nThis is an implementation of David Miller's suggested fix in:\n  https://bugzilla.redhat.com/show_bug.cgi?id=470201\n\nIt has been updated to use wait_event() instead of\nwait_event_interruptible().\n\nParaphrasing the description from the above report, it makes sendmsg()\nblock while UNIX garbage collection is in progress. This avoids a\nsituation where child processes continue to queue new FDs over a\nAF_UNIX socket to a parent which is in the exit path and running\ngarbage collection on these FDs. This contention can result in soft\nlockups and oom-killing of unrelated processes.\n\nSigned-off-by: dann frazier <dannf@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr=msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags)\n\t\t&& !u->addr && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb==NULL)\n\t\tgoto out;\n\n\tmemcpy(UNIXCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\tif (siocb->scm->fp) {\n\t\terr = unix_attach_fds(siocb->scm, skb);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_reset_transport_header(skb);\n\terr = memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other==NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk)=NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-399"], "message": "net: Fix soft lockups/OOM issues w/ unix garbage collector\n\nThis is an implementation of David Miller's suggested fix in:\n  https://bugzilla.redhat.com/show_bug.cgi?id=470201\n\nIt has been updated to use wait_event() instead of\nwait_event_interruptible().\n\nParaphrasing the description from the above report, it makes sendmsg()\nblock while UNIX garbage collection is in progress. This avoids a\nsituation where child processes continue to queue new FDs over a\nAF_UNIX socket to a parent which is in the exit path and running\ngarbage collection on these FDs. This contention can result in soft\nlockups and oom-killing of unrelated processes.\n\nSigned-off-by: dann frazier <dannf@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int svc_listen(struct socket *sock,int backlog)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\n\tpr_debug(\"svc_listen %p\\n\",vcc);\n\tlock_sock(sk);\n\t/* let server handle listen on unbound sockets */\n\tif (test_bit(ATM_VF_SESSION,&vcc->flags)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tvcc_insert_socket(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\tsigd_enq(vcc,as_listen,NULL,NULL,&vcc->local);\n\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\tschedule();\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_LISTEN,&vcc->flags);\n\tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-399"], "message": "ATM: CVE-2008-5079: duplicate listen() on socket corrupts the vcc table\n\nAs reported by Hugo Dias that it is possible to cause a local denial\nof service attack by calling the svc_listen function twice on the same\nsocket and reading /proc/net/atm/*vc\n\nSigned-off-by: Chas Williams <chas@cmf.nrl.navy.mil>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t     struct sg_io_hdr *hdr, fmode_t mode)\n{\n\tif (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))\n\t\treturn -EFAULT;\n\tif (blk_verify_command(&q->cmd_filter, rq->cmd, mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->cmd_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = msecs_to_jiffies(hdr->timeout);\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Enforce a minimum SG_IO timeout\n\nThere's no point in having too short SG_IO timeouts, since if the\ncommand does end up timing out, we'll end up through the reset sequence\nthat is several seconds long in order to abort the command that timed\nout.\n\nAs a result, shorter timeouts than a few seconds simply do not make\nsense, as the recovery would be longer than the timeout itself.\n\nAdd a BLK_MIN_SG_TIMEOUT to match the existign BLK_DEFAULT_SG_TIMEOUT.\n\nSuggested-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nAcked-by: Tejun Heo <tj@kernel.org>\nAcked-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Jeff Garzik <jeff@garzik.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int blk_fill_sgv4_hdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t\tstruct sg_io_v4 *hdr, struct bsg_device *bd,\n\t\t\t\tfmode_t has_write_perm)\n{\n\tif (hdr->request_len > BLK_MAX_CDB) {\n\t\trq->cmd = kzalloc(hdr->request_len, GFP_KERNEL);\n\t\tif (!rq->cmd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(rq->cmd, (void *)(unsigned long)hdr->request,\n\t\t\t   hdr->request_len))\n\t\treturn -EFAULT;\n\n\tif (hdr->subprotocol == BSG_SUB_PROTOCOL_SCSI_CMD) {\n\t\tif (blk_verify_command(&q->cmd_filter, rq->cmd, has_write_perm))\n\t\t\treturn -EPERM;\n\t} else if (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->request_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = (hdr->timeout * HZ) / 1000;\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Enforce a minimum SG_IO timeout\n\nThere's no point in having too short SG_IO timeouts, since if the\ncommand does end up timing out, we'll end up through the reset sequence\nthat is several seconds long in order to abort the command that timed\nout.\n\nAs a result, shorter timeouts than a few seconds simply do not make\nsense, as the recovery would be longer than the timeout itself.\n\nAdd a BLK_MIN_SG_TIMEOUT to match the existign BLK_DEFAULT_SG_TIMEOUT.\n\nSuggested-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nAcked-by: Tejun Heo <tj@kernel.org>\nAcked-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Jeff Garzik <jeff@garzik.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ibwdt_set_heartbeat(int t)\n{\n\tint i;\n\n\tif ((t < 0) || (t > 30))\n\t\treturn -EINVAL;\n\n\tfor (i = 0x0F; i > -1; i--)\n\t\tif (wd_times[i] > t)\n\t\t\tbreak;\n\twd_margin = i;\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "[WATCHDOG] ib700wdt.c - fix buffer_underflow bug\n\nThis fixes Bug 11399:\nif ibwdt_set_heartbeat(int t) is called with value 30 then\nthe check \"if ((t < 0) || (t > 30))\" in ibwdt_set_heartbeat\nis not going to fail because t == 30, but in the loop, the\ncheck wd_times[i] > t is never going to be true because\nnone of the wd_times are greater than the value of t (i.e. 30).\nSo we are exiting the loop with i == -1 and therefore setting\nwd_margin to -1 which is wrong.\n\nReported-by: Zvonimir Rakamaric <zrakamar@cs.ubc.ca>\nSigned-off-by: Wim Van Sebroeck <wim@iguana.be>"}
{"func": "static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_warn(\"Received packet from invalid interface.\");\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_warn(\"Received invalid packet.\");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ARCOUNT) != 0) {\n            avahi_log_warn(\"Invalid query packet.\");\n            return;\n        }\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_warn(\"Invalid legacy unicast query packet.\");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_warn(\"Received response from host %s with invalid source port %u on interface '%s.%i'\", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_warn(\"Received response from host %s with invalid TTL %u on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_warn(\"Received non-local response from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_warn(\"Invalid response packet from host %s.\", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}", "target": 1, "cwe": ["CWE-399"], "message": "Don't get confused by UDP packets with a source port that is zero\n\nThis is a fix for rhbz 475394.\n\nProblem identified by Hugo Dias."}
{"func": "\twhile(1) {\n\t\t/* Add the Unix Domain Sockets to the list of read\n\t\t * descriptors.\n\t\t * rgerhards 2005-08-01: we must now check if there are\n\t\t * any local sockets to listen to at all. If the -o option\n\t\t * is given without -a, we do not need to listen at all..\n\t\t */\n\t        maxfds = 0;\n\t        FD_ZERO (&readfds);\n\n\t\t/* Add the UDP listen sockets to the list of read descriptors.\n\t\t */\n\t\tif(udpLstnSocks != NULL) {\n                        for (i = 0; i < *udpLstnSocks; i++) {\n                                if (udpLstnSocks[i+1] != -1) {\n\t\t\t\t\tif(Debug)\n\t\t\t\t\t\tnet.debugListenInfo(udpLstnSocks[i+1], \"UDP\");\n                                        FD_SET(udpLstnSocks[i+1], &readfds);\n\t\t\t\t\tif(udpLstnSocks[i+1]>maxfds) maxfds=udpLstnSocks[i+1];\n\t\t\t\t}\n                        }\n\t\t}\n\t\tif(Debug) {\n\t\t\tdbgprintf(\"--------imUDP calling select, active file descriptors (max %d): \", maxfds);\n\t\t\tfor (nfds = 0; nfds <= maxfds; ++nfds)\n\t\t\t\tif ( FD_ISSET(nfds, &readfds) )\n\t\t\t\t\tdbgprintf(\"%d \", nfds);\n\t\t\tdbgprintf(\"\\n\");\n\t\t}\n\n\t\t/* wait for io to become ready */\n\t\tnfds = select(maxfds+1, (fd_set *) &readfds, NULL, NULL, NULL);\n\n\t\tif(udpLstnSocks != NULL) {\n\t\t       for (i = 0; nfds && i < *udpLstnSocks; i++) {\n\t\t\t       if (FD_ISSET(udpLstnSocks[i+1], &readfds)) {\n\t\t\t\t       socklen = sizeof(frominet);\n\t\t\t\t       l = recvfrom(udpLstnSocks[i+1], (char*) pRcvBuf, MAXLINE - 1, 0,\n\t\t\t\t\t\t    (struct sockaddr *)&frominet, &socklen);\n\t\t\t\t       if (l > 0) {\n\t\t\t\t\t       if(net.cvthname(&frominet, fromHost, fromHostFQDN, fromHostIP) == RS_RET_OK) {\n\t\t\t\t\t\t       dbgprintf(\"Message from inetd socket: #%d, host: %s\\n\",\n\t\t\t\t\t\t\t       udpLstnSocks[i+1], fromHost);\n\t\t\t\t\t\t       /* Here we check if a host is permitted to send us\n\t\t\t\t\t\t\t* syslog messages. If it isn't, we do not further\n\t\t\t\t\t\t\t* process the message but log a warning (if we are\n\t\t\t\t\t\t\t* configured to do this).\n\t\t\t\t\t\t\t* rgerhards, 2005-09-26\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t       if(net.isAllowedSender((uchar*) \"UDP\",\n\t\t\t\t\t\t\t  (struct sockaddr *)&frominet, (char*)fromHostFQDN)) {\n\t\t\t\t\t\t\t       parseAndSubmitMessage(fromHost, fromHostIP, pRcvBuf, l,\n\t\t\t\t\t\t\t       MSG_PARSE_HOSTNAME, NOFLAG, eFLOWCTL_NO_DELAY);\n\t\t\t\t\t\t       } else {\n\t\t\t\t\t\t\t       dbgprintf(\"%s is not an allowed sender\\n\", (char*)fromHostFQDN);\n\t\t\t\t\t\t\t       if(glbl.GetOption_DisallowWarning) {\n\t\t\t\t\t\t\t\t       errmsg.LogError(0, NO_ERRCODE, \"UDP message from disallowed sender %s discarded\",\n\t\t\t\t\t\t\t\t\t\t  (char*)fromHost);\n\t\t\t\t\t\t\t       }\t\n\t\t\t\t\t\t       }\n\t\t\t\t\t       }\n\t\t\t\t       } else if (l < 0 && errno != EINTR && errno != EAGAIN) {\n\t\t\t\t\t\tchar errStr[1024];\n\t\t\t\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\t\t\t\tdbgprintf(\"INET socket error: %d = %s.\\n\", errno, errStr);\n\t\t\t\t\t\t       errmsg.LogError(errno, NO_ERRCODE, \"recvfrom inet\");\n\t\t\t\t\t\t       /* should be harmless */\n\t\t\t\t\t\t       sleep(1);\n\t\t\t\t\t       }\n\t\t\t\t\t--nfds; /* indicate we have processed one */\n\t\t\t\t}\n\t\t       }\n\t\t}\n\t}", "target": 1, "cwe": [], "message": "security fix: imudp emitted a message when a non-permitted sender...\n\n...tried to send a message to it. This behaviour is operator-configurable.\nIf enabled, a message was emitted each time. That way an attacker could\neffectively fill the disk via this facility. The message is now\nemitted only once in a minute (this currently is a hard-coded limit,\nif someone comes up with a good reason to make it configurable, we\nwill probably do that)."}
{"func": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1, "cwe": ["CWE-399"], "message": "[NET]: Add preemption point in qdisc_run\n\nThe qdisc_run loop is currently unbounded and runs entirely in a\nsoftirq.  This is bad as it may create an unbounded softirq run.\n\nThis patch fixes this by calling need_resched and breaking out if\nnecessary.\n\nIt also adds a break out if the jiffies value changes since that would\nindicate we've been transmitting for too long which starves other\nsoftirqs.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "sctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 1, "cwe": ["CWE-119"], "message": "sctp: Avoid memory overflow while FWD-TSN chunk is received with bad stream ID\n\nIf FWD-TSN chunk is received with bad stream ID, the sctp will not do the\nvalidity check, this may cause memory overflow when overwrite the TSN of\nthe stream ID.\n\nThe FORWARD-TSN chunk is like this:\n\nFORWARD-TSN chunk\n  Type                       = 192\n  Flags                      = 0\n  Length                     = 172\n  NewTSN                     = 99\n  Stream                     = 10000\n  StreamSequence             = 0xFFFF\n\nThis patch fix this problem by discard the chunk if stream ID is not\nless than MIS.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "sctp_disposition_t sctp_sf_eat_fwd_tsn(const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tSCTP_DEBUG_PRINTK(\"%s: TSN 0x%x.\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->autoclose) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}", "target": 1, "cwe": ["CWE-119"], "message": "sctp: Avoid memory overflow while FWD-TSN chunk is received with bad stream ID\n\nIf FWD-TSN chunk is received with bad stream ID, the sctp will not do the\nvalidity check, this may cause memory overflow when overwrite the TSN of\nthe stream ID.\n\nThe FORWARD-TSN chunk is like this:\n\nFORWARD-TSN chunk\n  Type                       = 192\n  Flags                      = 0\n  Length                     = 172\n  NewTSN                     = 99\n  Stream                     = 10000\n  StreamSequence             = 0xFFFF\n\nThis patch fix this problem by discard the chunk if stream ID is not\nless than MIS.\n\nSigned-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n\tint retval;\n\tstruct task_struct *p;\n\tint cgroup_callbacks_done = 0;\n\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretval = security_task_create(clone_flags);\n\tif (retval)\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current);\n\tif (!p)\n\t\tgoto fork_out;\n\n\trt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\tp->signal->rlim[RLIMIT_NPROC].rlim_cur) {\n\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n\t\t    p->real_cred->user != INIT_USER)\n\t\t\tgoto bad_fork_free;\n\t}\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (nr_threads >= max_threads)\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (!try_module_get(task_thread_info(p)->exec_domain->module))\n\t\tgoto bad_fork_cleanup_count;\n\n\tif (p->binfmt && !try_module_get(p->binfmt->module))\n\t\tgoto bad_fork_cleanup_put_domain;\n\n\tp->did_exec = 0;\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tcopy_flags(clone_flags, p);\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_flipctr_idx = 0;\n#endif /* #ifdef CONFIG_PREEMPT_RCU */\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tclear_tsk_thread_flag(p, TIF_SIGPENDING);\n\tinit_sigpending(&p->pending);\n\n\tp->utime = cputime_zero;\n\tp->stime = cputime_zero;\n\tp->gtime = cputime_zero;\n\tp->utimescaled = cputime_zero;\n\tp->stimescaled = cputime_zero;\n\tp->prev_utime = cputime_zero;\n\tp->prev_stime = cputime_zero;\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_DETECT_SOFTLOCKUP\n\tp->last_switch_count = 0;\n\tp->last_switch_timestamp = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cpu_timers_init(p);\n\n\tp->lock_depth = -1;\t\t/* -1 = no lock */\n\tdo_posix_clock_monotonic_gettime(&p->start_time);\n\tp->real_start_time = p->start_time;\n\tmonotonic_to_bootbased(&p->real_start_time);\n\tp->io_context = NULL;\n\tp->audit_context = NULL;\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_cgroup;\n \t}\n\tmpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tp->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n\tp->hardirqs_enabled = 1;\n#else\n\tp->hardirqs_enabled = 0;\n#endif\n\tp->hardirq_enable_ip = 0;\n\tp->hardirq_enable_event = 0;\n\tp->hardirq_disable_ip = _THIS_IP_;\n\tp->hardirq_disable_event = 0;\n\tp->softirqs_enabled = 1;\n\tp->softirq_enable_ip = _THIS_IP_;\n\tp->softirq_enable_event = 0;\n\tp->softirq_disable_ip = 0;\n\tp->softirq_disable_event = 0;\n\tp->hardirq_context = 0;\n\tp->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tp->lockdep_depth = 0; /* no locks held yet */\n\tp->curr_chain_key = 0;\n\tp->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n\tif (unlikely(current->ptrace))\n\t\tptrace_fork(p, clone_flags);\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tsched_fork(p, clone_flags);\n\n\tif ((retval = audit_alloc(p)))\n\t\tgoto bad_fork_cleanup_policy;\n\t/* copy all the process information */\n\tif ((retval = copy_semundo(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_audit;\n\tif ((retval = copy_files(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_semundo;\n\tif ((retval = copy_fs(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_files;\n\tif ((retval = copy_sighand(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_fs;\n\tif ((retval = copy_signal(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_sighand;\n\tif ((retval = copy_mm(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_signal;\n\tif ((retval = copy_namespaces(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_mm;\n\tif ((retval = copy_io(clone_flags, p)))\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tif (pid != &init_struct_pid) {\n\t\tretval = -ENOMEM;\n\t\tpid = alloc_pid(p->nsproxy->pid_ns);\n\t\tif (!pid)\n\t\t\tgoto bad_fork_cleanup_io;\n\n\t\tif (clone_flags & CLONE_NEWPID) {\n\t\t\tretval = pid_ns_prepare_proc(p->nsproxy->pid_ns);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t}\n\n\tftrace_graph_init_task(p);\n\n\tp->pid = pid_nr(pid);\n\tp->tgid = p->pid;\n\tif (clone_flags & CLONE_THREAD)\n\t\tp->tgid = current->tgid;\n\n\tif (current->nsproxy != p->nsproxy) {\n\t\tretval = ns_cgroup_clone(p, pid);\n\t\tif (retval)\n\t\t\tgoto bad_fork_free_graph;\n\t}\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;\n#ifdef CONFIG_FUTEX\n\tp->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n\tp->compat_robust_list = NULL;\n#endif\n\tINIT_LIST_HEAD(&p->pi_state_list);\n\tp->pi_state_cache = NULL;\n#endif\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tp->sas_ss_sp = p->sas_ss_size = 0;\n\n\t/*\n\t * Syscall tracing should be turned off in the child regardless\n\t * of CLONE_PTRACE.\n\t */\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_all_latency_tracing(p);\n\n\t/* Our parent execution domain becomes current domain\n\t   These must match for thread signalling to apply */\n\tp->parent_exec_id = p->self_exec_id;\n\n\t/* ok, now we should be set up.. */\n\tp->exit_signal = (clone_flags & CLONE_THREAD) ? -1 : (clone_flags & CSIGNAL);\n\tp->pdeath_signal = 0;\n\tp->exit_state = 0;\n\n\t/*\n\t * Ok, make it visible to the rest of the system.\n\t * We dont wake it up yet.\n\t */\n\tp->group_leader = p;\n\tINIT_LIST_HEAD(&p->thread_group);\n\n\t/* Now that the task is set up, run cgroup callbacks if\n\t * necessary. We need to run them before the task is visible\n\t * on the tasklist. */\n\tcgroup_fork_callbacks(p);\n\tcgroup_callbacks_done = 1;\n\n\t/* Need tasklist lock for parent etc handling! */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/*\n\t * The task hasn't been attached yet, so its cpus_allowed mask will\n\t * not be changed, nor will its assigned CPU.\n\t *\n\t * The cpus_allowed mask of the parent may have changed after it was\n\t * copied first time - so re-copy it here, then check the child's CPU\n\t * to ensure it is on a valid CPU (and if not, just force it back to\n\t * parent's CPU). This avoids alot of nasty races.\n\t */\n\tp->cpus_allowed = current->cpus_allowed;\n\tp->rt.nr_cpus_allowed = current->rt.nr_cpus_allowed;\n\tif (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||\n\t\t\t!cpu_online(task_cpu(p))))\n\t\tset_task_cpu(p, smp_processor_id());\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD))\n\t\tp->real_parent = current->real_parent;\n\telse\n\t\tp->real_parent = current;\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Process group and session signals need to be delivered to just the\n\t * parent before the fork or both the parent and the child after the\n\t * fork. Restart if a signal comes in before we add the new process to\n\t * it's process group.\n\t * A fatal signal pending means that current will exit, so the new\n\t * thread can't slip out of an OOM kill (or normal SIGKILL).\n \t */\n\trecalc_sigpending();\n\tif (signal_pending(current)) {\n\t\tspin_unlock(&current->sighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tretval = -ERESTARTNOINTR;\n\t\tgoto bad_fork_free_graph;\n\t}\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tlist_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n\t}\n\n\tif (likely(p->pid)) {\n\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\ttracehook_finish_clone(p, clone_flags, trace);\n\n\t\tif (thread_group_leader(p)) {\n\t\t\tif (clone_flags & CLONE_NEWPID)\n\t\t\t\tp->nsproxy->pid_ns->child_reaper = p;\n\n\t\t\tp->signal->leader_pid = pid;\n\t\t\ttty_kref_put(p->signal->tty);\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\tset_task_pgrp(p, task_pgrp_nr(current));\n\t\t\tset_task_session(p, task_session_nr(current));\n\t\t\tattach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tattach_pid(p, PIDTYPE_SID, task_session(current));\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\t__get_cpu_var(process_counts)++;\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID, pid);\n\t\tnr_threads++;\n\t}\n\n\ttotal_forks++;\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tproc_fork_connector(p);\n\tcgroup_post_fork(p);\n\treturn p;\n\nbad_fork_free_graph:\n\tftrace_graph_exit_task(p);\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_io:\n\tput_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm)\n\t\tmmput(p->mm);\nbad_fork_cleanup_signal:\n\tcleanup_signal(p);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_policy:\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n\tcgroup_exit(p, cgroup_callbacks_done);\n\tdelayacct_tsk_free(p);\n\tif (p->binfmt)\n\t\tmodule_put(p->binfmt->module);\nbad_fork_cleanup_put_domain:\n\tmodule_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\tput_cred(p->real_cred);\n\tput_cred(p->cred);\nbad_fork_free:\n\tfree_task(p);\nfork_out:\n\treturn ERR_PTR(retval);\n}", "target": 1, "cwe": ["CWE-264"], "message": "copy_process: fix CLONE_PARENT && parent_exec_id interaction\n\nCLONE_PARENT can fool the ->self_exec_id/parent_exec_id logic. If we\nre-use the old parent, we must also re-use ->parent_exec_id to make\nsure exit_notify() sees the right ->xxx_exec_id's when the CLONE_PARENT'ed\ntask exits.\n\nAlso, move down the \"p->parent_exec_id = p->self_exec_id\" thing, to place\ntwo different cases together.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Roland McGrath <roland@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: David Howells <dhowells@redhat.com>\nCc: Serge E. Hallyn <serge@hallyn.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "_AFmoduleinst _af_ms_adpcm_init_decompress (_Track *track, AFvirtualfile *fh,\n\tbool seekok, bool headerless, AFframecount *chunkframes)\n{\n\t_AFmoduleinst\tret = _AFnewmodinst(&ms_adpcm_decompress);\n\tms_adpcm_data\t*d;\n\tAUpvlist\tpv;\n\tlong\t\tl;\n\tvoid\t\t*v;\n\n\tassert(af_ftell(fh) == track->fpos_first_frame);\n\n\td = (ms_adpcm_data *) _af_malloc(sizeof (ms_adpcm_data));\n\n\td->track = track;\n\td->fh = fh;\n\n\td->track->frames2ignore = 0;\n\td->track->fpos_next_frame = d->track->fpos_first_frame;\n\n\tpv = d->track->f.compressionParams;\n\tif (_af_pv_getlong(pv, _AF_MS_ADPCM_NUM_COEFFICIENTS, &l))\n\t\td->numCoefficients = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"number of coefficients not set\");\n\n\tif (_af_pv_getptr(pv, _AF_MS_ADPCM_COEFFICIENTS, &v))\n\t\tmemcpy(d->coefficients, v, sizeof (int16_t) * 256 * 2);\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"coefficient array not set\");\n\n\tif (_af_pv_getlong(pv, _AF_SAMPLES_PER_BLOCK, &l))\n\t\td->samplesPerBlock = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"samples per block not set\");\n\n\tif (_af_pv_getlong(pv, _AF_BLOCK_SIZE, &l))\n\t\td->blockAlign = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"block size not set\");\n\n\t*chunkframes = d->samplesPerBlock / d->track->f.channelCount;\n\n\tret.modspec = d;\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ms_adpcm_run_pull (_AFmoduleinst *module)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) module->modspec;\n\tAFframecount\tframes2read = module->outc->nframes;\n\tAFframecount\tnframes = 0;\n\tint\t\ti, framesPerBlock, blockCount;\n\tssize_t\t\tblocksRead, bytesDecoded;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\tassert(module->outc->nframes % framesPerBlock == 0);\n\tblockCount = module->outc->nframes / framesPerBlock;\n\n\t/* Read the compressed frames. */\n\tblocksRead = af_fread(module->inc->buf, d->blockAlign, blockCount, d->fh);\n\n\t/* Decompress into module->outc. */\n\tfor (i=0; i<blockCount; i++)\n\t{\n\t\tbytesDecoded = ms_adpcm_decode_block(d,\n\t\t\t(uint8_t *) module->inc->buf + i * d->blockAlign,\n\t\t\t(int16_t *) module->outc->buf + i * d->samplesPerBlock);\n\n\t\tnframes += framesPerBlock;\n\t}\n\n\td->track->nextfframe += nframes;\n\n\tif (blocksRead > 0)\n\t\td->track->fpos_next_frame += blocksRead * d->blockAlign;\n\n\tassert(af_ftell(d->fh) == d->track->fpos_next_frame);\n\n\t/*\n\t\tIf we got EOF from read, then we return the actual amount read.\n\n\t\tComplain only if there should have been more frames in the file.\n\t*/\n\n\tif (d->track->totalfframes != -1 && nframes != frames2read)\n\t{\n\t\t/* Report error if we haven't already */\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, should be %d\",\n\t\t\t\td->track->nextfframe,\n\t\t\t\td->track->totalfframes);\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tmodule->outc->nframes = nframes;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ms_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ima_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "void _af_adpcm_decoder (uint8_t *indata, int16_t *outdata, int len,\n\tstruct adpcm_state *state)\n{\n    uint8_t *inp;\t\t/* Input buffer pointer */\n    int16_t *outp;\t\t/* output buffer pointer */\n    int sign;\t\t\t/* Current adpcm sign bit */\n    int delta;\t\t\t/* Current adpcm output value */\n    int step;\t\t\t/* Stepsize */\n    int valpred;\t\t/* Predicted value */\n    int vpdiff;\t\t\t/* Current change to valpred */\n    int index;\t\t\t/* Current step change index */\n    int inputbuffer;\t\t/* place to keep next 4-bit value */\n    int bufferstep;\t\t/* toggle between inputbuffer/input */\n\n    outp = outdata;\n    inp = indata;\n\n    valpred = state->valprev;\n    index = state->index;\n    step = stepsizeTable[index];\n\n    bufferstep = 0;\n    \n    for ( ; len > 0 ; len-- ) {\n\t\n\t/* Step 1 - get the delta value */\n\tif ( bufferstep ) {\n\t    delta = (inputbuffer >> 4) & 0xf;\n\t} else {\n\t    inputbuffer = *inp++;\n\t    delta = inputbuffer & 0xf;\n\t}\n\tbufferstep = !bufferstep;\n\n\t/* Step 2 - Find new index value (for later) */\n\tindex += indexTable[delta];\n\tif ( index < 0 ) index = 0;\n\tif ( index > 88 ) index = 88;\n\n\t/* Step 3 - Separate sign and magnitude */\n\tsign = delta & 8;\n\tdelta = delta & 7;\n\n\t/* Step 4 - Compute difference and new predicted value */\n\t/*\n\t** Computes 'vpdiff = (delta+0.5)*step/4', but see comment\n\t** in adpcm_coder.\n\t*/\n\tvpdiff = step >> 3;\n\tif ( delta & 4 ) vpdiff += step;\n\tif ( delta & 2 ) vpdiff += step>>1;\n\tif ( delta & 1 ) vpdiff += step>>2;\n\n\tif ( sign )\n\t  valpred -= vpdiff;\n\telse\n\t  valpred += vpdiff;\n\n\t/* Step 5 - clamp output value */\n\tif ( valpred > 32767 )\n\t  valpred = 32767;\n\telse if ( valpred < -32768 )\n\t  valpred = -32768;\n\n\t/* Step 6 - Update step value */\n\tstep = stepsizeTable[index];\n\n\t/* Step 7 - Output value */\n\t*outp++ = valpred;\n    }\n\n    state->valprev = valpred;\n    state->index = index;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static int ima_adpcm_decode_block (ima_adpcm_data *ima, uint8_t *encoded,\n\tint16_t *decoded)\n{\n\tint outputLength;\n\n\tstruct adpcm_state state;\n\n\toutputLength = ima->samplesPerBlock * sizeof (int16_t) *\n\t\tima->track->f.channelCount;\n\n\tstate.valprev = (encoded[1]<<8) | encoded[0];\n\tif (encoded[1] & 0x80)\n\t\tstate.valprev -= 0x10000;\n\n\tstate.index = encoded[2];\n\n\t*decoded++ = state.valprev;\n\n\tencoded += 4;\n\n\t_af_adpcm_decoder(encoded, decoded, ima->samplesPerBlock - 1, &state);\n\n\treturn outputLength;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "_AFmoduleinst _af_ima_adpcm_init_decompress (_Track *track, AFvirtualfile *fh,\n\tbool seekok, bool headerless, AFframecount *chunkframes)\n{\n\t_AFmoduleinst\tret = _AFnewmodinst(&ima_adpcm_decompress);\n\tima_adpcm_data\t*d;\n\tAUpvlist\tpv;\n\tlong\t\tl;\n\n\tassert(af_ftell(fh) == track->fpos_first_frame);\n\n\td = (ima_adpcm_data *) _af_malloc(sizeof (ima_adpcm_data));\n\n\td->track = track;\n\td->fh = fh;\n\n\td->track->frames2ignore = 0;\n\td->track->fpos_next_frame = d->track->fpos_first_frame;\n\n\tpv = d->track->f.compressionParams;\n\n\tif (_af_pv_getlong(pv, _AF_SAMPLES_PER_BLOCK, &l))\n\t\td->samplesPerBlock = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"samples per block not set\");\n\n\tif (_af_pv_getlong(pv, _AF_BLOCK_SIZE, &l))\n\t\td->blockAlign = l;\n\telse\n\t\t_af_error(AF_BAD_CODEC_CONFIG, \"block size not set\");\n\n\t*chunkframes = d->samplesPerBlock / d->track->f.channelCount;\n\n\tret.modspec = d;\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ima_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame / framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t/* postroll = frames2ignore */\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "void _af_adpcm_coder (int16_t *indata, uint8_t *outdata, int len,\n\tstruct adpcm_state *state)\n{\n    int16_t *inp;\t\t/* Input buffer pointer */\n    uint8_t *outp;\t\t/* Output buffer pointer */\n    int val;\t\t\t/* Current input sample value */\n    int sign;\t\t\t/* Current adpcm sign bit */\n    int delta;\t\t\t/* Current adpcm output value */\n    int diff;\t\t\t/* Difference between val and valprev */\n    int step;\t\t\t/* Stepsize */\n    int valpred;\t\t/* Predicted output value */\n    int vpdiff;\t\t\t/* Current change to valpred */\n    int index;\t\t\t/* Current step change index */\n    int outputbuffer;\t\t/* place to keep previous 4-bit value */\n    int bufferstep;\t\t/* toggle between outputbuffer/output */\n\n    outp = outdata;\n    inp = indata;\n\n    valpred = state->valprev;\n    index = state->index;\n    step = stepsizeTable[index];\n    \n    bufferstep = 1;\n\n    for ( ; len > 0 ; len-- ) {\n\tval = *inp++;\n\n\t/* Step 1 - compute difference with previous value */\n\tdiff = val - valpred;\n\tsign = (diff < 0) ? 8 : 0;\n\tif ( sign ) diff = (-diff);\n\n\t/* Step 2 - Divide and clamp */\n\t/* Note:\n\t** This code *approximately* computes:\n\t**    delta = diff*4/step;\n\t**    vpdiff = (delta+0.5)*step/4;\n\t** but in shift step bits are dropped. The net result of this is\n\t** that even if you have fast mul/div hardware you cannot put it to\n\t** good use since the fixup would be too expensive.\n\t*/\n\tdelta = 0;\n\tvpdiff = (step >> 3);\n\t\n\tif ( diff >= step ) {\n\t    delta = 4;\n\t    diff -= step;\n\t    vpdiff += step;\n\t}\n\tstep >>= 1;\n\tif ( diff >= step  ) {\n\t    delta |= 2;\n\t    diff -= step;\n\t    vpdiff += step;\n\t}\n\tstep >>= 1;\n\tif ( diff >= step ) {\n\t    delta |= 1;\n\t    vpdiff += step;\n\t}\n\n\t/* Step 3 - Update previous value */\n\tif ( sign )\n\t  valpred -= vpdiff;\n\telse\n\t  valpred += vpdiff;\n\n\t/* Step 4 - Clamp previous value to 16 bits */\n\tif ( valpred > 32767 )\n\t  valpred = 32767;\n\telse if ( valpred < -32768 )\n\t  valpred = -32768;\n\n\t/* Step 5 - Assemble value, update index and step values */\n\tdelta |= sign;\n\t\n\tindex += indexTable[delta];\n\tif ( index < 0 ) index = 0;\n\tif ( index > 88 ) index = 88;\n\tstep = stepsizeTable[index];\n\n\t/* Step 6 - Output value */\n\tif ( bufferstep ) {\n\t    outputbuffer = delta & 0x0f;\n\t} else {\n\t    *outp++ = ((delta << 4) & 0xf0) | outputbuffer;\n\t}\n\tbufferstep = !bufferstep;\n    }\n\n    /* Output last step, if needed */\n    if ( !bufferstep )\n      *outp++ = outputbuffer;\n    \n    state->valprev = valpred;\n    state->index = index;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ima_adpcm_run_pull (_AFmoduleinst *module)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) module->modspec;\n\tAFframecount\tframes2read = module->outc->nframes;\n\tAFframecount\tnframes = 0;\n\tint\t\ti, framesPerBlock, blockCount;\n\tssize_t\t\tblocksRead, bytesDecoded;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\tassert(module->outc->nframes % framesPerBlock == 0);\n\tblockCount = module->outc->nframes / framesPerBlock;\n\n\t/* Read the compressed frames. */\n\tblocksRead = af_fread(module->inc->buf, d->blockAlign, blockCount, d->fh);\n\n\t/* This condition would indicate that the file is bad. */\n\tif (blocksRead < 0)\n\t{\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ, \"file missing data\");\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tif (blocksRead < blockCount)\n\t\tblockCount = blocksRead;\n\n\t/* Decompress into module->outc. */\n\tfor (i=0; i<blockCount; i++)\n\t{\n\t\tbytesDecoded = ima_adpcm_decode_block(d,\n\t\t\t(uint8_t *) module->inc->buf + i * d->blockAlign,\n\t\t\t(int16_t *) module->outc->buf + i * d->samplesPerBlock);\n\n\t\tnframes += framesPerBlock;\n\t}\n\n\td->track->nextfframe += nframes;\n\n\tif (blocksRead > 0)\n\t\td->track->fpos_next_frame += blocksRead * d->blockAlign;\n\n\tassert(af_ftell(d->fh) == d->track->fpos_next_frame);\n\n\t/*\n\t\tIf we got EOF from read, then we return the actual amount read.\n\n\t\tComplain only if there should have been more frames in the file.\n\t*/\n\n\tif (d->track->totalfframes != -1 && nframes != frames2read)\n\t{\n\t\t/* Report error if we haven't already */\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, should be %d\",\n\t\t\t\td->track->nextfframe,\n\t\t\t\td->track->totalfframes);\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tmodule->outc->nframes = nframes;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static int ms_adpcm_decode_block (ms_adpcm_data *msadpcm, uint8_t *encoded,\n\tint16_t *decoded)\n{\n\tint\t\ti, outputLength, samplesRemaining;\n\tint\t\tchannelCount;\n\tint16_t\t\t*coefficient[2];\n\tms_adpcm_state\tdecoderState[2];\n\tms_adpcm_state\t*state[2];\n\n\t/* Calculate the number of bytes needed for decoded data. */\n\toutputLength = msadpcm->samplesPerBlock * sizeof (int16_t) *\n\t\tmsadpcm->track->f.channelCount;\n\n\tchannelCount = msadpcm->track->f.channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t/* Initialize predictor. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictor = *encoded++;\n\t\tassert(state[i]->predictor < msadpcm->numCoefficients);\n\t}\n\n\t/* Initialize delta. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t/* Initialize first two samples. */\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tcoefficient[0] = msadpcm->coefficients[state[0]->predictor];\n\tcoefficient[1] = msadpcm->coefficients[state[1]->predictor];\n\n\tfor (i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tsamplesRemaining = (msadpcm->samplesPerBlock - 2) *\n\t\tmsadpcm->track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = ms_adpcm_decode_sample(state[0], code,\n\t\t\tcoefficient[0]);\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = ms_adpcm_decode_sample(state[1], code,\n\t\t\tcoefficient[1]);\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static void ms_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame / framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t/* postroll = frames2ignore */\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "static status ParseFormat (AFfilehandle filehandle, AFvirtualfile *fp,\n\tuint32_t id, size_t size)\n{\n\t_Track\t\t*track;\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\t_WAVEInfo\t*wave;\n\n\tassert(filehandle != NULL);\n\tassert(fp != NULL);\n\tassert(!memcmp(&id, \"fmt \", 4));\n\n\ttrack = _af_filehandle_get_track(filehandle, AF_DEFAULT_TRACK);\n\n\tassert(filehandle->formatSpecific != NULL);\n\twave = (_WAVEInfo *) filehandle->formatSpecific;\n\n\taf_read_uint16_le(&formatTag, fp);\n\taf_read_uint16_le(&channelCount, fp);\n\taf_read_uint32_le(&sampleRate, fp);\n\taf_read_uint32_le(&averageBytesPerSecond, fp);\n\taf_read_uint16_le(&blockAlign, fp);\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t\tbitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\t\t\tint\t\ti;\n\t\t\tAUpvlist\tpv;\n\t\t\tlong\t\tl;\n\t\t\tvoid\t\t*v;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\t\t\taf_read_uint16_le(&extraByteCount, fp);\n\t\t\taf_read_uint16_le(&samplesPerBlock, fp);\n\t\t\taf_read_uint16_le(&numCoefficients, fp);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\n\t\t\tfor (i=0; i<numCoefficients; i++)\n\t\t\t{\n\t\t\t\tint16_t\ta0, a1;\n\n\t\t\t\taf_fread(&a0, 1, 2, fp);\n\t\t\t\taf_fread(&a1, 1, 2, fp);\n\n\t\t\t\ta0 = LENDIAN_TO_HOST_INT16(a0);\n\t\t\t\ta1 = LENDIAN_TO_HOST_INT16(a1);\n\n\t\t\t\twave->msadpcmCoefficients[i][0] = a0;\n\t\t\t\twave->msadpcmCoefficients[i][1] = a1;\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\t/* Create the parameter list. */\n\t\t\tpv = AUpvnew(4);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tl = numCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tv = wave->msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\tAUpvsetparam(pv, 2, _AF_SAMPLES_PER_BLOCK);\n\t\t\tAUpvsetvaltype(pv, 2, AU_PVTYPE_LONG);\n\t\t\tl = samplesPerBlock;\n\t\t\tAUpvsetval(pv, 2, &l);\n\n\t\t\tAUpvsetparam(pv, 3, _AF_BLOCK_SIZE);\n\t\t\tAUpvsetvaltype(pv, 3, AU_PVTYPE_LONG);\n\t\t\tl = blockAlign;\n\t\t\tAUpvsetval(pv, 3, &l);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tAUpvlist\tpv;\n\t\t\tlong\t\tl;\n\n\t\t\tuint16_t\tbitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock;\n\n\t\t\taf_read_uint16_le(&bitsPerSample, fp);\n\t\t\taf_read_uint16_le(&extraByteCount, fp);\n\t\t\taf_read_uint16_le(&samplesPerBlock, fp);\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\t/* Create the parameter list. */\n\t\t\tpv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_SAMPLES_PER_BLOCK);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tl = samplesPerBlock;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_BLOCK_SIZE);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_LONG);\n\t\t\tl = blockAlign;\n\t\t\tAUpvsetval(pv, 1, &l);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix decoding of multi-channel ADPCM audio files."}
{"func": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\n\n error:\n\treturn ret;\n\n} /* end keyctl_join_session_keyring() */", "target": 1, "cwe": ["CWE-399"], "message": "security: introduce missing kfree\n\nPlug this leak.\n\nAcked-by: David Howells <dhowells@redhat.com>\nCc: James Morris <jmorris@namei.org>\nCc: <stable@kernel.org>\nSigned-off-by: Vegard Nossum <vegard.nossum@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tunsigned int lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch(optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val==0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val=1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t\tif (len > sizeof(sk->sk_peercred))\n\t\t\tlen = sizeof(sk->sk_peercred);\n\t\tif (copy_to_user(optval, &sk->sk_peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "net: 4 bytes kernel memory disclosure in SO_BSDCOMPAT gsopt try #2\n\nIn function sock_getsockopt() located in net/core/sock.c, optval v.val\nis not correctly initialized and directly returned in userland in case\nwe have SO_BSDCOMPAT option set.\n\nThis dummy code should trigger the bug:\n\nint main(void)\n{\n\tunsigned char buf[4] = { 0, 0, 0, 0 };\n\tint len;\n\tint sock;\n\tsock = socket(33, 2, 2);\n\tgetsockopt(sock, 1, SO_BSDCOMPAT, &buf, &len);\n\tprintf(\"%x%x%x%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\tclose(sock);\n}\n\nHere is a patch that fix this bug by initalizing v.val just after its\ndeclaration.\n\nSigned-off-by: Cl\u00e9ment Lecigne <clement.lecigne@netasq.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tunsigned int lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tv.val = 0;\n\n\tswitch(optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val==0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv=sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val=1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t\tif (len > sizeof(sk->sk_peercred))\n\t\t\tlen = sizeof(sk->sk_peercred);\n\t\tif (copy_to_user(optval, &sk->sk_peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "net: amend the fix for SO_BSDCOMPAT gsopt infoleak\n\nThe fix for CVE-2009-0676 (upstream commit df0bca04) is incomplete. Note\nthat the same problem of leaking kernel memory will reappear if someone\non some architecture uses struct timeval with some internal padding (for\nexample tv_sec 64-bit and tv_usec 32-bit) --- then, you are going to\nleak the padded bytes to userspace.\n\nSigned-off-by: Eugene Teo <eugeneteo@kernel.sg>\nReported-by: Mikulas Patocka <mpatocka@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t/* Get the driver statistics */\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t/* Zero out the driver statistics */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t// switch\n\n\treturn status;\n}\t\t\t\t// skfp_ioctl", "target": 1, "cwe": ["CWE-264"], "message": "drivers/net/skfp: if !capable(CAP_NET_ADMIN): inverted logic\n\nFix inverted logic\n\nSigned-off-by: Roel Kluin <roel.kluin@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint num_grp_locked = 0;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, __func__, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext4_journal_start_sb(sb,\n\t\t\t\t       ext4_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tlock_super(sb);\n\tif (input->group != sbi->s_groups_count) {\n\t\text4_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n        /*\n         * We will only either add reserved group blocks to a backup group\n         * or remove reserved blocks for the first group in a new group block.\n         * Doing both would be mean more complex code, and sane people don't\n         * use non-sparse filesystems anymore.  This is already checked above.\n         */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext4_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext4_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n        /*\n         * OK, now we've set up the new group.  Time to make it active.\n         *\n         * Current kernels don't lock all allocations via lock_super(),\n         * so we have to be safe wrt. concurrent accesses the group\n         * data.  So we need to be careful to set all of the relevant\n         * group descriptor data etc. *before* we enable the group.\n         *\n         * The key field here is sbi->s_groups_count: as long as\n         * that retains its old value, nobody is going to access the new\n         * group.\n         *\n         * So first we update all the descriptor metadata for the new\n         * group; then we update the total disk blocks count; then we\n         * update the groups count to enable the group; then finally we\n         * update the free space counts so that the system can start\n         * using the new disk blocks.\n         */\n\n\tnum_grp_locked = ext4_mb_get_buddy_cache_lock(sb, input->group);\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n\t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n\n\text4_block_bitmap_set(sb, gdp, input->block_bitmap); /* LV FIXME */\n\text4_inode_bitmap_set(sb, gdp, input->inode_bitmap); /* LV FIXME */\n\text4_inode_table_set(sb, gdp, input->inode_table); /* LV FIXME */\n\text4_free_blks_set(sb, gdp, input->free_blocks_count);\n\text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n\tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n\n\t/*\n\t * We can allocate memory for mb_alloc based on the new group\n\t * descriptor\n\t */\n\terr = ext4_mb_add_groupinfo(sb, input->group, gdp);\n\tif (err) {\n\t\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\t\tgoto exit_journal;\n\t}\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\text4_blocks_count_set(es, ext4_blocks_count(es) +\n\t\tinput->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold lock_super\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold lock_super() over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n\n\text4_handle_dirty_metadata(handle, NULL, primary);\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n\t\tinput->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT4_INODES_PER_GROUP(sb));\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n\t\text4_group_t flex_group;\n\t\tflex_group = ext4_flex_group(sbi, input->group);\n\t\tsbi->s_flex_groups[flex_group].free_blocks +=\n\t\t\tinput->free_blocks_count;\n\t\tsbi->s_flex_groups[flex_group].free_inodes +=\n\t\t\tEXT4_INODES_PER_GROUP(sb);\n\t}\n\n\text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n\tsb->s_dirt = 1;\n\nexit_journal:\n\tunlock_super(sb);\n\tif ((err2 = ext4_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext4_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n} /* ext4_group_add */", "target": 1, "cwe": ["CWE-20"], "message": "ext4: Initialize the new group descriptor when resizing the filesystem\n\nMake sure all of the fields of the group descriptor are properly\ninitialized.  Previously, we allowed bg_flags field to be contain\nrandom garbage, which could trigger non-deterministic behavior,\nincluding a kernel OOPS.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12433\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org"}
{"func": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tlen = ((char *) root) + blocksize - (char *) de;\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}", "target": 1, "cwe": ["CWE-20"], "message": "ext4: Add sanity check to make_indexed_dir\n\nMake sure the rec_len field in the '..' entry is sane, lest we overrun\nthe directory block and cause a kernel oops on a purposefully\ncorrupted filesystem.\n\nThanks to Sami Liedes for reporting this bug.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12430\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org"}
{"func": "static int ext4_block_to_path(struct inode *inode,\n\t\t\text4_lblk_t i_block,\n\t\t\text4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < 0) {\n\t\text4_warning(inode->i_sb, \"ext4_block_to_path\", \"block < 0\");\n\t} else if (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"ext4_block_to_path\",\n\t\t\t\t\"block %lu > max\",\n\t\t\t\ti_block + direct_blocks +\n\t\t\t\tindirect_blocks + double_blocks);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}", "target": 1, "cwe": ["CWE-399"], "message": "ext4: only use i_size_high for regular files\n\nDirectories are not allowed to be bigger than 2GB, so don't use\ni_size_high for anything other than regular files.  E2fsck should\ncomplain about these inodes, but the simplest thing to do for the\nkernel is to only use i_size_high for regular files.\n\nThis prevents an intentially corrupted filesystem from causing the\nkernel to burn a huge amount of CPU and issuing error messages such\nas:\n\nEXT4-fs warning (device loop0): ext4_block_to_path: block 135090028 > max\n\nThanks to David Maciejak from Fortinet's FortiGuard Global Security\nResearch Team for reporting this issue.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12375\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org"}
{"func": "\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1, "cwe": ["CWE-399"], "message": "ext4: only use i_size_high for regular files\n\nDirectories are not allowed to be bigger than 2GB, so don't use\ni_size_high for anything other than regular files.  E2fsck should\ncomplain about these inodes, but the simplest thing to do for the\nkernel is to only use i_size_high for regular files.\n\nThis prevents an intentially corrupted filesystem from causing the\nkernel to burn a huge amount of CPU and issuing error messages such\nas:\n\nEXT4-fs warning (device loop0): ext4_block_to_path: block 135090028 > max\n\nThanks to David Maciejak from Fortinet's FortiGuard Global Security\nResearch Team for reporting this issue.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12375\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org"}
{"func": "\t\t\t\t__acquires(kernel_lock)\n\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tint db_count;\n\tint i;\n\tint needs_recovery, has_huge_files;\n\tint features;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to set blocksize\\n\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\tprintk(KERN_ERR \"EXT4-fs: unable to read superblock\\n\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_JOURNAL_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_ORDERED_DATA;\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tsbi->s_mount_opt |= EXT4_MOUNT_WRITEBACK_DATA;\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * turn on extents feature by default in ext4 filesystem\n\t * only if feature flag already set by mkfs or tune2fs.\n\t * Use -o noextents to turn it off\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS))\n\t\tset_opt(sbi->s_mount_opt, EXTENTS);\n\telse\n\t\text4_warning(sb, __func__,\n\t\t\t\"extents feature not enabled on this filesystem, \"\n\t\t\t\"use tune2fs.\");\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT4_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\tprintk(KERN_WARNING\n\t\t       \"EXT4-fs warning: feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\\n\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\tfeatures = EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP);\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x).\\n\", sb->s_id,\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\tgoto failed_mount;\n\t}\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tif (has_huge_files) {\n\t\t/*\n\t\t * Large file size enabled file system can only be\n\t\t * mount if kernel is build with CONFIG_LBD\n\t\t */\n\t\tif (sizeof(root->i_blocks) < sizeof(u64) &&\n\t\t\t\t!(sb->s_flags & MS_RDONLY)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: %s: Filesystem with huge \"\n\t\t\t\t\t\"files cannot be mounted read-write \"\n\t\t\t\t\t\"without CONFIG_LBD.\\n\", sb->s_id);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: Unsupported filesystem blocksize %d on %s.\\n\",\n\t\t       blocksize, sb->s_id);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: bad block size %d.\\n\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Can't read superblock on 2nd try.\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: Magic mismatch, very weird !\\n\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported inode size: %d\\n\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unsupported descriptor size %lu\\n\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #blocks per group too big: %lu\\n\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\tprintk(KERN_ERR\n\t\t       \"EXT4-fs: #inodes per group too big: %lu\\n\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_blocks_count(es) >\n\t\t    (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: filesystem on %s:\"\n\t\t\t\" too large to mount safely\\n\", sb->s_id);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: CONFIG_LBD not \"\n\t\t\t\t\t\"enabled\\n\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* ensure blocks_count calculation below doesn't sign-extend */\n\tif (ext4_blocks_count(es) + EXT4_BLOCKS_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_first_data_block) + 1) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: bad geometry: block count %llu, \"\n\t\t       \"first data block %u, blocks per group %lu\\n\",\n\t\t\text4_blocks_count(es),\n\t\t\tle32_to_cpu(es->s_first_data_block),\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tsbi->s_groups_count = blocks_count;\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: not enough memory\\n\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"inode_readahead_blks\", 0644, sbi->s_proc,\n\t\t\t\t &ext4_ui_proc_fops,\n\t\t\t\t &sbi->s_inode_readahead_blks);\n#endif\n\n\tbgl_lock_init(&sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: \"\n\t\t\t       \"can't read group descriptor %d\\n\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: group descriptors corrupted!\\n\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"EXT4-fs: unable to initialize \"\n\t\t\t       \"flex_bg meta info!\\n\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: insufficient memory\\n\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t\tif (!(sb->s_flags & MS_RDONLY) &&\n\t\t    EXT4_SB(sb)->s_journal->j_failed_commit) {\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): \"\n\t\t\t       \"ext4_fill_super: Journal transaction \"\n\t\t\t       \"%u is corrupt\\n\", sb->s_id,\n\t\t\t       EXT4_SB(sb)->s_journal->j_failed_commit);\n\t\t\tif (test_opt(sb, ERRORS_RO)) {\n\t\t\t\tprintk(KERN_CRIT\n\t\t\t\t       \"Mounting filesystem read-only\\n\");\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t}\n\t\t\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\t\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\t\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\t\t\text4_commit_super(sb, es, 1);\n\t\t\t\tgoto failed_mount4;\n\t\t\t}\n\t\t}\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\\n\");\n\t\tgoto failed_mount4;\n\t} else {\n\t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\tprintk(KERN_ERR \"ext4: Failed to set 64-bit journal feature\\n\");\n\t\tgoto failed_mount4;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\tprintk(KERN_ERR \"EXT4-fs: Journal does not support \"\n\t\t\t       \"requested data journaling mode\\n\");\n\t\t\tgoto failed_mount4;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\nno_journal:\n\n\tif (test_opt(sb, NOBH)) {\n\t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n\t\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring nobh option - \"\n\t\t\t\t\"its supported only with writeback mode\\n\");\n\t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n\t\t}\n\t}\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root inode failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\tprintk(KERN_ERR \"EXT4-fs: corrupt root inode, run e2fsck\\n\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\tprintk(KERN_ERR \"EXT4-fs: get root dentry failed\\n\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\tprintk(KERN_INFO \"EXT4-fs: required extra inode space not\"\n\t\t\t\"available.\\n\");\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk(KERN_WARNING \"EXT4-fs: Ignoring delalloc option - \"\n\t\t\t\t\"requested data journaling mode\\n\");\n\t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n\t} else if (test_opt(sb, DELALLOC))\n\t\tprintk(KERN_INFO \"EXT4-fs: delayed allocation enabled\\n\");\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to initalize mballoc (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * akpm: core read_super() calls in here with the superblock locked.\n\t * That deadlocks, because orphan cleanup needs to lock the superblock\n\t * in numerous places.  Here we just pop the lock - it's relatively\n\t * harmless, because we are now ready to accept write_super() requests,\n\t * and aviro says that's the only reason for hanging onto the\n\t * superblock lock.\n\t */\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\tprintk(KERN_INFO \"EXT4-fs: recovery complete.\\n\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tprintk(KERN_INFO \"EXT4-fs: mounted filesystem %s with%s\\n\",\n\t       sb->s_id, descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\tprintk(KERN_ERR \"VFS: Can't find ext4 filesystem on dev %s.\\n\",\n\t\t       sb->s_id);\n\tgoto failed_mount;\n\nfailed_mount4:\n\tprintk(KERN_ERR \"EXT4-fs (device %s): mount failed\\n\", sb->s_id);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(\"inode_readahead_blks\", sbi->s_proc);\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-20"], "message": "ext4: Add sanity checks for the superblock before mounting the filesystem\n\nThis avoids insane superblock configurations that could lead to kernel\noops due to null pointer derefences.\n\nhttp://bugzilla.kernel.org/show_bug.cgi?id=12371\n\nThanks to David Maciejak at Fortinet's FortiGuard Global Security\nResearch Team who discovered this bug independently (but at\napproximately the same time) as Thiemo Nagel, who submitted the patch.\n\nSigned-off-by: Thiemo Nagel <thiemo.nagel@ph.tum.de>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org"}
{"func": "int selinux_netlbl_inode_permission(struct inode *inode, int mask)\n{\n\tint rc;\n\tstruct sock *sk;\n\tstruct socket *sock;\n\tstruct sk_security_struct *sksec;\n\n\tif (!S_ISSOCK(inode->i_mode) ||\n\t    ((mask & (MAY_WRITE | MAY_APPEND)) == 0))\n\t\treturn 0;\n\n\tsock = SOCKET_I(inode);\n\tsk = sock->sk;\n\tsksec = sk->sk_security;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\tif (likely(sksec->nlbl_state == NLBL_REQUIRE))\n\t\trc = selinux_netlbl_sock_setsid(sk);\n\telse\n\t\trc = 0;\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}", "target": 1, "cwe": [], "message": "selinux: Fix a panic in selinux_netlbl_inode_permission()\n\nRick McNeal from LSI identified a panic in selinux_netlbl_inode_permission()\ncaused by a certain sequence of SUNRPC operations.  The problem appears to be\ndue to the lack of NULL pointer checking in the function; this patch adds the\npointer checks so the function will exit safely in the cases where the socket\nis not completely initialized.\n\nSigned-off-by: Paul Moore <paul.moore@hp.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const AvahiAddress *address, uint16_t port) {\n    assert(s);\n    assert(address);\n    assert(port > 0);\n\n    if (!s->config.enable_reflector)\n        return 0;\n\n    if (!avahi_address_is_local(s->monitor, address))\n        return 0;\n\n    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {\n        struct sockaddr_in lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin_port == port;\n\n    }\n\n    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {\n        struct sockaddr_in6 lsa;\n        socklen_t l = sizeof(lsa);\n\n        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin6_port == port;\n    }\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "CVE-2009-0758: Reflector creates packet storm on legacy unicast traffic\n\nFixes rhbz #488314."}
{"func": "static ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tsize_t event_size = sizeof (struct inotify_event);\n\tstruct inotify_device *dev;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT(wait);\n\n\tstart = buf;\n\tdev = file->private_data;\n\n\twhile (1) {\n\n\t\tprepare_to_wait(&dev->wq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tmutex_lock(&dev->ev_mutex);\n\t\tif (!list_empty(&dev->events)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&dev->ev_mutex);\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\tfinish_wait(&dev->wq, &wait);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tstruct inotify_kernel_event *kevent;\n\n\t\tret = buf - start;\n\t\tif (list_empty(&dev->events))\n\t\t\tbreak;\n\n\t\tkevent = inotify_dev_get_event(dev);\n\t\tif (event_size + kevent->event.len > count) {\n\t\t\tif (ret == 0 && count > 0) {\n\t\t\t\t/*\n\t\t\t\t * could not get a single event because we\n\t\t\t\t * didn't have enough buffer space.\n\t\t\t\t */\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tremove_kevent(dev, kevent);\n\n\t\t/*\n\t\t * Must perform the copy_to_user outside the mutex in order\n\t\t * to avoid a lock order reversal with mmap_sem.\n\t\t */\n\t\tmutex_unlock(&dev->ev_mutex);\n\n\t\tif (copy_to_user(buf, &kevent->event, event_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += event_size;\n\t\tcount -= event_size;\n\n\t\tif (kevent->name) {\n\t\t\tif (copy_to_user(buf, kevent->name, kevent->event.len)){\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += kevent->event.len;\n\t\t\tcount -= kevent->event.len;\n\t\t}\n\n\t\tfree_kevent(kevent);\n\n\t\tmutex_lock(&dev->ev_mutex);\n\t}\n\tmutex_unlock(&dev->ev_mutex);\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "inotify: clean up inotify_read and fix locking problems\n\nIf userspace supplies an invalid pointer to a read() of an inotify\ninstance, the inotify device's event list mutex is unlocked twice.\nThis causes an unbalance which effectively leaves the data structure\nunprotected, and we can trigger oopses by accessing the inotify\ninstance from different tasks concurrently.\n\nThe best fix (contributed largely by Linus) is a total rewrite\nof the function in question:\n\nOn Thu, Jan 22, 2009 at 7:05 AM, Linus Torvalds wrote:\n> The thing to notice is that:\n>\n>  - locking is done in just one place, and there is no question about it\n>   not having an unlock.\n>\n>  - that whole double-while(1)-loop thing is gone.\n>\n>  - use multiple functions to make nesting and error handling sane\n>\n>  - do error testing after doing the things you always need to do, ie do\n>   this:\n>\n>        mutex_lock(..)\n>        ret = function_call();\n>        mutex_unlock(..)\n>\n>        .. test ret here ..\n>\n>   instead of doing conditional exits with unlocking or freeing.\n>\n> So if the code is written in this way, it may still be buggy, but at least\n> it's not buggy because of subtle \"forgot to unlock\" or \"forgot to free\"\n> issues.\n>\n> This _always_ unlocks if it locked, and it always frees if it got a\n> non-error kevent.\n\nCc: John McCutchan <ttb@tentacle.dhs.org>\nCc: Robert Love <rlove@google.com>\nCc: <stable@kernel.org>\nSigned-off-by: Vegard Nossum <vegard.nossum@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n\tchar *virt;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released in this function */\n\tvirt = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,\n\t\t\t\t\t crypt_stat, ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,\n\t\t\t\t\t\t      crypt_stat, virt, size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,\n\t\t\t\t\t\t\t ecryptfs_dentry, virt);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_page((unsigned long)virt);\nout:\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-189"], "message": "eCryptfs: Allocate a variable number of pages for file headers\n\nWhen allocating the memory used to store the eCryptfs header contents, a\nsingle, zeroed page was being allocated with get_zeroed_page().\nHowever, the size of an eCryptfs header is either PAGE_CACHE_SIZE or\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is\nstored in the file's private_data->crypt_stat->num_header_bytes_at_front\nfield.\n\necryptfs_write_metadata_to_contents() was using\nnum_header_bytes_at_front to decide how many bytes should be written to\nthe lower filesystem for the file header.  Unfortunately, at least 8K\nwas being written from the page, despite the chance of the single,\nzeroed page being smaller than 8K.  This resulted in random areas of\nkernel memory being written between the 0x1000 and 0x1FFF bytes offsets\nin the eCryptfs file headers if PAGE_SIZE was 4K.\n\nThis patch allocates a variable number of pages, calculated with\nnum_header_bytes_at_front, and passes the number of allocated pages\nalong to ecryptfs_write_metadata_to_contents().\n\nThanks to Florian Streibelt for reporting the data leak and working with\nme to find the problem.  2.6.28 is the only kernel release with this\nvulnerability.  Corresponds to CVE-2009-0787\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nAcked-by: Dustin Kirkland <kirkland@canonical.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Eugene Teo <eugeneteo@kernel.sg>\nCc: Greg KH <greg@kroah.com>\nCc: dann frazier <dannf@dannf.org>\nCc: Serge E. Hallyn <serue@us.ibm.com>\nCc: Florian Streibelt <florian@f-streibelt.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-189"], "message": "eCryptfs: Allocate a variable number of pages for file headers\n\nWhen allocating the memory used to store the eCryptfs header contents, a\nsingle, zeroed page was being allocated with get_zeroed_page().\nHowever, the size of an eCryptfs header is either PAGE_CACHE_SIZE or\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is\nstored in the file's private_data->crypt_stat->num_header_bytes_at_front\nfield.\n\necryptfs_write_metadata_to_contents() was using\nnum_header_bytes_at_front to decide how many bytes should be written to\nthe lower filesystem for the file header.  Unfortunately, at least 8K\nwas being written from the page, despite the chance of the single,\nzeroed page being smaller than 8K.  This resulted in random areas of\nkernel memory being written between the 0x1000 and 0x1FFF bytes offsets\nin the eCryptfs file headers if PAGE_SIZE was 4K.\n\nThis patch allocates a variable number of pages, calculated with\nnum_header_bytes_at_front, and passes the number of allocated pages\nalong to ecryptfs_write_metadata_to_contents().\n\nThanks to Florian Streibelt for reporting the data leak and working with\nme to find the problem.  2.6.28 is the only kernel release with this\nvulnerability.  Corresponds to CVE-2009-0787\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nAcked-by: Dustin Kirkland <kirkland@canonical.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Eugene Teo <eugeneteo@kernel.sg>\nCc: Greg KH <greg@kroah.com>\nCc: dann frazier <dannf@dannf.org>\nCc: Serge E. Hallyn <serue@us.ibm.com>\nCc: Florian Streibelt <florian@f-streibelt.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-189"], "message": "eCryptfs: Allocate a variable number of pages for file headers\n\nWhen allocating the memory used to store the eCryptfs header contents, a\nsingle, zeroed page was being allocated with get_zeroed_page().\nHowever, the size of an eCryptfs header is either PAGE_CACHE_SIZE or\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is\nstored in the file's private_data->crypt_stat->num_header_bytes_at_front\nfield.\n\necryptfs_write_metadata_to_contents() was using\nnum_header_bytes_at_front to decide how many bytes should be written to\nthe lower filesystem for the file header.  Unfortunately, at least 8K\nwas being written from the page, despite the chance of the single,\nzeroed page being smaller than 8K.  This resulted in random areas of\nkernel memory being written between the 0x1000 and 0x1FFF bytes offsets\nin the eCryptfs file headers if PAGE_SIZE was 4K.\n\nThis patch allocates a variable number of pages, calculated with\nnum_header_bytes_at_front, and passes the number of allocated pages\nalong to ecryptfs_write_metadata_to_contents().\n\nThanks to Florian Streibelt for reporting the data leak and working with\nme to find the problem.  2.6.28 is the only kernel release with this\nvulnerability.  Corresponds to CVE-2009-0787\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nAcked-by: Dustin Kirkland <kirkland@canonical.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Eugene Teo <eugeneteo@kernel.sg>\nCc: Greg KH <greg@kroah.com>\nCc: dann frazier <dannf@dannf.org>\nCc: Serge E. Hallyn <serue@us.ibm.com>\nCc: Florian Streibelt <florian@f-streibelt.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty)\n{\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tint sel_mode, new_sel_start, new_sel_end, spc;\n\tchar *bp, *obp;\n\tint i, ps, pe, multiplier;\n\tu16 c;\n\tstruct kbd_struct *kbd = kbd_table + fg_console;\n\n\tpoke_blanked_console();\n\n\t{ unsigned short xs, ys, xe, ye;\n\n\t  if (!access_ok(VERIFY_READ, sel, sizeof(*sel)))\n\t\treturn -EFAULT;\n\t  __get_user(xs, &sel->xs);\n\t  __get_user(ys, &sel->ys);\n\t  __get_user(xe, &sel->xe);\n\t  __get_user(ye, &sel->ye);\n\t  __get_user(sel_mode, &sel->sel_mode);\n\t  xs--; ys--; xe--; ye--;\n\t  xs = limit(xs, vc->vc_cols - 1);\n\t  ys = limit(ys, vc->vc_rows - 1);\n\t  xe = limit(xe, vc->vc_cols - 1);\n\t  ye = limit(ye, vc->vc_rows - 1);\n\t  ps = ys * vc->vc_size_row + (xs << 1);\n\t  pe = ye * vc->vc_size_row + (xe << 1);\n\n\t  if (sel_mode == TIOCL_SELCLEAR) {\n\t      /* useful for screendump without selection highlights */\n\t      clear_selection();\n\t      return 0;\n\t  }\n\n\t  if (mouse_reporting() && (sel_mode & TIOCL_SELMOUSEREPORT)) {\n\t      mouse_report(tty, sel_mode & TIOCL_SELBUTTONMASK, xs, ys);\n\t      return 0;\n\t  }\n        }\n\n\tif (ps > pe)\t/* make sel_start <= sel_end */\n\t{\n\t\tint tmp = ps;\n\t\tps = pe;\n\t\tpe = tmp;\n\t}\n\n\tif (sel_cons != vc_cons[fg_console].d) {\n\t\tclear_selection();\n\t\tsel_cons = vc_cons[fg_console].d;\n\t}\n\tuse_unicode = kbd && kbd->kbdmode == VC_UNICODE;\n\n\tswitch (sel_mode)\n\t{\n\t\tcase TIOCL_SELCHAR:\t/* character-by-character selection */\n\t\t\tnew_sel_start = ps;\n\t\t\tnew_sel_end = pe;\n\t\t\tbreak;\n\t\tcase TIOCL_SELWORD:\t/* word-by-word selection */\n\t\t\tspc = isspace(sel_pos(ps));\n\t\t\tfor (new_sel_start = ps; ; ps -= 2)\n\t\t\t{\n\t\t\t\tif ((spc && !isspace(sel_pos(ps))) ||\n\t\t\t\t    (!spc && !inword(sel_pos(ps))))\n\t\t\t\t\tbreak;\n\t\t\t\tnew_sel_start = ps;\n\t\t\t\tif (!(ps % vc->vc_size_row))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspc = isspace(sel_pos(pe));\n\t\t\tfor (new_sel_end = pe; ; pe += 2)\n\t\t\t{\n\t\t\t\tif ((spc && !isspace(sel_pos(pe))) ||\n\t\t\t\t    (!spc && !inword(sel_pos(pe))))\n\t\t\t\t\tbreak;\n\t\t\t\tnew_sel_end = pe;\n\t\t\t\tif (!((pe + 2) % vc->vc_size_row))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIOCL_SELLINE:\t/* line-by-line selection */\n\t\t\tnew_sel_start = ps - ps % vc->vc_size_row;\n\t\t\tnew_sel_end = pe + vc->vc_size_row\n\t\t\t\t    - pe % vc->vc_size_row - 2;\n\t\t\tbreak;\n\t\tcase TIOCL_SELPOINTER:\n\t\t\thighlight_pointer(pe);\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* remove the pointer */\n\thighlight_pointer(-1);\n\n\t/* select to end of line if on trailing space */\n\tif (new_sel_end > new_sel_start &&\n\t\t!atedge(new_sel_end, vc->vc_size_row) &&\n\t\tisspace(sel_pos(new_sel_end))) {\n\t\tfor (pe = new_sel_end + 2; ; pe += 2)\n\t\t\tif (!isspace(sel_pos(pe)) ||\n\t\t\t    atedge(pe, vc->vc_size_row))\n\t\t\t\tbreak;\n\t\tif (isspace(sel_pos(pe)))\n\t\t\tnew_sel_end = pe;\n\t}\n\tif (sel_start == -1)\t/* no current selection */\n\t\thighlight(new_sel_start, new_sel_end);\n\telse if (new_sel_start == sel_start)\n\t{\n\t\tif (new_sel_end == sel_end)\t/* no action required */\n\t\t\treturn 0;\n\t\telse if (new_sel_end > sel_end)\t/* extend to right */\n\t\t\thighlight(sel_end + 2, new_sel_end);\n\t\telse\t\t\t\t/* contract from right */\n\t\t\thighlight(new_sel_end + 2, sel_end);\n\t}\n\telse if (new_sel_end == sel_end)\n\t{\n\t\tif (new_sel_start < sel_start)\t/* extend to left */\n\t\t\thighlight(new_sel_start, sel_start - 2);\n\t\telse\t\t\t\t/* contract from left */\n\t\t\thighlight(sel_start, new_sel_start - 2);\n\t}\n\telse\t/* some other case; start selection from scratch */\n\t{\n\t\tclear_selection();\n\t\thighlight(new_sel_start, new_sel_end);\n\t}\n\tsel_start = new_sel_start;\n\tsel_end = new_sel_end;\n\n\t/* Allocate a new buffer before freeing the old one ... */\n\tmultiplier = use_unicode ? 3 : 1;  /* chars can take up to 3 bytes */\n\tbp = kmalloc((sel_end-sel_start)/2*multiplier+1, GFP_KERNEL);\n\tif (!bp) {\n\t\tprintk(KERN_WARNING \"selection: kmalloc() failed\\n\");\n\t\tclear_selection();\n\t\treturn -ENOMEM;\n\t}\n\tkfree(sel_buffer);\n\tsel_buffer = bp;\n\n\tobp = bp;\n\tfor (i = sel_start; i <= sel_end; i += 2) {\n\t\tc = sel_pos(i);\n\t\tif (use_unicode)\n\t\t\tbp += store_utf8(c, bp);\n\t\telse\n\t\t\t*bp++ = c;\n\t\tif (!isspace(c))\n\t\t\tobp = bp;\n\t\tif (! ((i + 2) % vc->vc_size_row)) {\n\t\t\t/* strip trailing blanks from line and add newline,\n\t\t\t   unless non-space at end of line. */\n\t\t\tif (obp != bp) {\n\t\t\t\tbp = obp;\n\t\t\t\t*bp++ = '\\r';\n\t\t\t}\n\t\t\tobp = bp;\n\t\t}\n\t}\n\tsel_buffer_lth = bp - sel_buffer;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Fix memory corruption in console selection\n\nFix an off-by-two memory error in console selection.\n\nThe loop below goes from sel_start to sel_end (inclusive), so it writes\none more character.  This one more character was added to the allocated\nsize (+1), but it was not multiplied by an UTF-8 multiplier.\n\nThis patch fixes a memory corruption when UTF-8 console is used and the\nuser selects a few characters, all of them 3-byte in UTF-8 (for example\na frame line).\n\nWhen memory redzones are enabled, a redzone corruption is reported.\nWhen they are not enabled, trashing of random memory occurs.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *data,\n\t\t\t\t      const char *hostname,\n\t\t\t\t      const struct sockaddr_in *addr,\n\t\t\t\t      const char *mntpath,\n\t\t\t\t      const char *ip_addr,\n\t\t\t\t      rpc_authflavor_t authflavour,\n\t\t\t\t      struct nfs_fh *mntfh)\n{\n\tstruct nfs_fattr fattr;\n\tstruct nfs_server *server;\n\tint error;\n\n\tdprintk(\"--> nfs4_create_server()\\n\");\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Get a client record */\n\terror = nfs4_set_client(server, hostname, addr, ip_addr, authflavour,\n\t\t\tdata->proto, data->timeo, data->retrans);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* set up the general RPC client */\n\terror = nfs4_init_server(server, data, authflavour);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID */\n\terror = nfs4_path_walk(server, mntfh, mntpath);\n\tif (error < 0)\n\t\tgoto error;\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\tdprintk(\"Mount FH: %d\\n\", mntfh->size);\n\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\tdprintk(\"<-- nfs4_create_server() = %p\\n\", server);\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs4_create_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static struct dentry *nfs_readdir_lookup(nfs_readdir_descriptor_t *desc)\n{\n\tstruct dentry *parent = desc->file->f_path.dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_entry *entry = desc->entry;\n\tstruct dentry *dentry, *alias;\n\tstruct qstr name = {\n\t\t.name = entry->name,\n\t\t.len = entry->len,\n\t};\n\tstruct inode *inode;\n\n\tswitch (name.len) {\n\t\tcase 2:\n\t\t\tif (name.name[0] == '.' && name.name[1] == '.')\n\t\t\t\treturn dget_parent(parent);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (name.name[0] == '.')\n\t\t\t\treturn dget(parent);\n\t}\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry != NULL) {\n\t\t/* Is this a positive dentry that matches the readdir info? */\n\t\tif (dentry->d_inode != NULL &&\n\t\t\t\t(NFS_FILEID(dentry->d_inode) == entry->ino ||\n\t\t\t\td_mountpoint(dentry))) {\n\t\t\tif (!desc->plus || entry->fh->size == 0)\n\t\t\t\treturn dentry;\n\t\t\tif (nfs_compare_fh(NFS_FH(dentry->d_inode),\n\t\t\t\t\t\tentry->fh) == 0)\n\t\t\t\tgoto out_renew;\n\t\t}\n\t\t/* No, so d_drop to allow one to be created */\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tif (!desc->plus || !(entry->fattr->valid & NFS_ATTR_FATTR))\n\t\treturn NULL;\n\t/* Note: caller is already holding the dir->i_mutex! */\n\tdentry = d_alloc(parent, &name);\n\tif (dentry == NULL)\n\t\treturn NULL;\n\tdentry->d_op = NFS_PROTO(dir)->dentry_ops;\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr);\n\tif (IS_ERR(inode)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\talias = d_materialise_unique(dentry, inode);\n\tif (alias != NULL) {\n\t\tdput(dentry);\n\t\tif (IS_ERR(alias))\n\t\t\treturn NULL;\n\t\tdentry = alias;\n\t}\n\n\tnfs_renew_times(dentry);\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\treturn dentry;\nout_renew:\n\tnfs_renew_times(dentry);\n\tnfs_refresh_verifier(dentry, nfs_save_change_attribute(dir));\n\treturn dentry;\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int nfs4_path_walk(struct nfs_server *server,\n\t\t   struct nfs_fh *mntfh,\n\t\t   const char *path)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct nfs_fattr fattr;\n\tstruct nfs_fh lastfh;\n\tstruct qstr name;\n\tint ret;\n\n\tdprintk(\"--> nfs4_path_walk(,,%s)\\n\", path);\n\n\tfsinfo.fattr = &fattr;\n\tnfs_fattr_init(&fattr);\n\n\t/* Eat leading slashes */\n\twhile (*path == '/')\n\t\tpath++;\n\n\t/* Start by getting the root filehandle from the server */\n\tret = server->nfs_client->rpc_ops->getroot(server, mntfh, &fsinfo);\n\tif (ret < 0) {\n\t\tdprintk(\"nfs4_get_root: getroot error = %d\\n\", -ret);\n\t\treturn ret;\n\t}\n\n\tif (fattr.type != NFDIR) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" getroot encountered non-directory\\n\");\n\t\treturn -ENOTDIR;\n\t}\n\n\t/* FIXME: It is quite valid for the server to return a referral here */\n\tif (fattr.valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" getroot obtained referral\\n\");\n\t\treturn -EREMOTE;\n\t}\n\nnext_component:\n\tdprintk(\"Next: %s\\n\", path);\n\n\t/* extract the next bit of the path */\n\tif (!*path)\n\t\tgoto path_walk_complete;\n\n\tname.name = path;\n\twhile (*path && *path != '/')\n\t\tpath++;\n\tname.len = path - (const char *) name.name;\n\neat_dot_dir:\n\twhile (*path == '/')\n\t\tpath++;\n\n\tif (path[0] == '.' && (path[1] == '/' || !path[1])) {\n\t\tpath += 2;\n\t\tgoto eat_dot_dir;\n\t}\n\n\t/* FIXME: Why shouldn't the user be able to use \"..\" in the path? */\n\tif (path[0] == '.' && path[1] == '.' && (path[2] == '/' || !path[2])\n\t    ) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" Mount path contains reference to \\\"..\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* lookup the next FH in the sequence */\n\tmemcpy(&lastfh, mntfh, sizeof(lastfh));\n\n\tdprintk(\"LookupFH: %*.*s [%s]\\n\", name.len, name.len, name.name, path);\n\n\tret = server->nfs_client->rpc_ops->lookupfh(server, &lastfh, &name,\n\t\t\t\t\t\t    mntfh, &fattr);\n\tif (ret < 0) {\n\t\tdprintk(\"nfs4_get_root: getroot error = %d\\n\", -ret);\n\t\treturn ret;\n\t}\n\n\tif (fattr.type != NFDIR) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" lookupfh encountered non-directory\\n\");\n\t\treturn -ENOTDIR;\n\t}\n\n\t/* FIXME: Referrals are quite valid here too */\n\tif (fattr.valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tprintk(KERN_ERR \"nfs4_get_root:\"\n\t\t       \" lookupfh obtained referral\\n\");\n\t\treturn -EREMOTE;\n\t}\n\n\tgoto next_component;\n\npath_walk_complete:\n\tmemcpy(&server->fsid, &fattr.fsid, sizeof(server->fsid));\n\tdprintk(\"<-- nfs4_path_walk() = 0\\n\");\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,\n\t\t\t\t\t       struct nfs_fh *mntfh)\n{\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tdprintk(\"--> nfs4_create_referral_server()\\n\");\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(data->sb);\n\tparent_client = parent_server->nfs_client;\n\n\t/* Get a client representation.\n\t * Note: NFSv4 always uses TCP, */\n\terror = nfs4_set_client(server, data->hostname, data->addr,\n\t\t\tparent_client->cl_ipaddr,\n\t\t\tdata->authflavor,\n\t\t\tparent_server->client->cl_xprt->prot,\n\t\t\tparent_client->retrans_timeo,\n\t\t\tparent_client->retrans_count);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* Initialise the client representation from the parent server */\n\tnfs_server_copy_userdata(server, parent_server);\n\tserver->caps |= NFS_CAP_ATOMIC_OPEN;\n\n\terror = nfs_init_server_rpcclient(server, data->authflavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID and filehandle */\n\terror = nfs4_path_walk(server, mntfh, data->mnt_path);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* probe the filesystem info for this server filesystem */\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\n\tdprintk(\"Referral FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\n\tdprintk(\"<-- nfs_create_referral_server() = %p\\n\", server);\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs4_create_referral_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct nfs_server *nfs_clone_server(struct nfs_server *source,\n\t\t\t\t    struct nfs_fh *fh,\n\t\t\t\t    struct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_fattr fattr_fsinfo;\n\tint error;\n\n\tdprintk(\"--> nfs_clone_server(,%llx:%llx,)\\n\",\n\t\t(unsigned long long) fattr->fsid.major,\n\t\t(unsigned long long) fattr->fsid.minor);\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Copy data from the source */\n\tserver->nfs_client = source->nfs_client;\n\tatomic_inc(&server->nfs_client->cl_count);\n\tnfs_server_copy_userdata(server, source);\n\n\tserver->fsid = fattr->fsid;\n\n\terror = nfs_init_server_rpcclient(server, source->client->cl_auth->au_flavor);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\tif (!IS_ERR(source->client_acl))\n\t\tnfs_init_server_aclclient(server);\n\n\t/* probe the filesystem info for this server filesystem */\n\terror = nfs_probe_fsinfo(server, fh, &fattr_fsinfo);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tdprintk(\"Cloned FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto out_free_server;\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\n\tdprintk(\"<-- nfs_clone_server() = %p\\n\", server);\n\treturn server;\n\nout_free_server:\n\tnfs_free_server(server);\n\tdprintk(\"<-- nfs_clone_server() = error %d\\n\", error);\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct nfs_server *nfs_create_server(const struct nfs_mount_data *data,\n\t\t\t\t     struct nfs_fh *mntfh)\n{\n\tstruct nfs_server *server;\n\tstruct nfs_fattr fattr;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Get a client representation */\n\terror = nfs_init_server(server, data);\n\tif (error < 0)\n\t\tgoto error;\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\t/* Probe the root fh to retrieve its FSID */\n\terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n\tif (error < 0)\n\t\tgoto error;\n\tif (!(fattr.valid & NFS_ATTR_FATTR)) {\n\t\terror = server->nfs_client->rpc_ops->getattr(server, mntfh, &fattr);\n\t\tif (error < 0) {\n\t\t\tdprintk(\"nfs_create_server: getattr error = %d\\n\", -error);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmemcpy(&server->fsid, &fattr.fsid, sizeof(server->fsid));\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t(unsigned long long) server->fsid.major,\n\t\t(unsigned long long) server->fsid.minor);\n\n\tBUG_ON(!server->nfs_client);\n\tBUG_ON(!server->nfs_client->rpc_ops);\n\tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n\n\tspin_lock(&nfs_client_lock);\n\tlist_add_tail(&server->client_link, &server->nfs_client->cl_superblocks);\n\tlist_add_tail(&server->master_link, &nfs_volume_list);\n\tspin_unlock(&nfs_client_lock);\n\n\tserver->mount_time = jiffies;\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data)\n{\n\tstruct nfs_client *clp;\n\tint error, nfsvers = 2;\n\n\tdprintk(\"--> nfs_init_server()\\n\");\n\n#ifdef CONFIG_NFS_V3\n\tif (data->flags & NFS_MOUNT_VER3)\n\t\tnfsvers = 3;\n#endif\n\n\t/* Allocate or find a client reference we can use */\n\tclp = nfs_get_client(data->hostname, &data->addr, nfsvers);\n\tif (IS_ERR(clp)) {\n\t\tdprintk(\"<-- nfs_init_server() = error %ld\\n\", PTR_ERR(clp));\n\t\treturn PTR_ERR(clp);\n\t}\n\n\terror = nfs_init_client(clp, data);\n\tif (error < 0)\n\t\tgoto error;\n\n\tserver->nfs_client = clp;\n\n\t/* Initialise the client representation from the mount data */\n\tserver->flags = data->flags & NFS_MOUNT_FLAGMASK;\n\n\tif (data->rsize)\n\t\tserver->rsize = nfs_block_size(data->rsize, NULL);\n\tif (data->wsize)\n\t\tserver->wsize = nfs_block_size(data->wsize, NULL);\n\n\tserver->acregmin = data->acregmin * HZ;\n\tserver->acregmax = data->acregmax * HZ;\n\tserver->acdirmin = data->acdirmin * HZ;\n\tserver->acdirmax = data->acdirmax * HZ;\n\n\t/* Start lockd here, before we might error out */\n\terror = nfs_start_lockd(server);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs_init_server_rpcclient(server, data->pseudoflavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tserver->namelen  = data->namlen;\n\t/* Create a client RPC handle for the NFSv3 ACL management interface */\n\tnfs_init_server_aclclient(server);\n\tif (clp->cl_nfsversion == 3) {\n\t\tif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\n\t\t\tserver->namelen = NFS3_MAXNAMLEN;\n\t\tif (!(data->flags & NFS_MOUNT_NORDIRPLUS))\n\t\t\tserver->caps |= NFS_CAP_READDIRPLUS;\n\t} else {\n\t\tif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\n\t\t\tserver->namelen = NFS2_MAXNAMLEN;\n\t}\n\n\tdprintk(\"<-- nfs_init_server() = 0 [new %p]\\n\", clp);\n\treturn 0;\n\nerror:\n\tserver->nfs_client = NULL;\n\tnfs_put_client(clp);\n\tdprintk(\"<-- nfs_init_server() = xerror %d\\n\", error);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-20"], "message": "NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)\n{\n\tint err;\n\tconst int on = 1;\n\n\tif (udev_monitor->snl.nl_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);\n\t} else if (udev_monitor->sun.sun_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t/* enable receiving of the sender credentials */\n\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-346"], "message": "libudev: monitor - unify socket message handling"}
{"func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}", "target": 1, "cwe": ["CWE-346"], "message": "libudev: monitor - unify socket message handling"}
{"func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\t} else {\n\t\t/* no destination besides the muticast group, we will always get -1 ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\t}\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}", "target": 1, "cwe": ["CWE-346"], "message": "libudev: monitor - unify socket message handling"}
{"func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}", "target": 1, "cwe": ["CWE-346"], "message": "libudev: monitor - ignore messages from unusual sources\n\nFor added protection, ignore any unicast message received on the\nnetlink socket or any multicast message on the kernel group not\nreceived from the kernel.\n\nSigned-off-by: Scott James Remnant <scott@ubuntu.com>"}
{"func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0)\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -1;\n\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}", "target": 1, "cwe": ["CWE-346"], "message": "libudev: monitor - ignore messages from unusual sources\n\nFor added protection, ignore any unicast message received on the\nnetlink socket or any multicast message on the kernel group not\nreceived from the kernel.\n\nSigned-off-by: Scott James Remnant <scott@ubuntu.com>"}
{"func": "size_t util_path_encode(char *s, size_t len)\n{\n\tchar t[(len * 3)+1];\n\tsize_t i, j;\n\n\tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n\t\tif (s[i] == '/') {\n\t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n\t\t\tj += 4;\n\t\t} else if (s[i] == '\\\\') {\n\t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n\t\t\tj += 4;\n\t\t} else {\n\t\t\tt[j] = s[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (len == 0)\n\t\treturn j;\n\ti = (j < len - 1) ? j : len - 1;\n\tmemcpy(s, t, i);\n\ts[i] = '\\0';\n\treturn j;\n}", "target": 1, "cwe": ["CWE-120"], "message": "path_encode: fix max length calculation\n\nSebastian Krahmer wrote:\n> it should reserve 4 times not 3 times len :)"}
{"func": "void async_request(TALLOC_CTX *mem_ctx, struct winbindd_child *child,\n\t\t   struct winbindd_request *request,\n\t\t   struct winbindd_response *response,\n\t\t   void (*continuation)(void *private_data, BOOL success),\n\t\t   void *private_data)\n{\n\tstruct winbindd_async_request *state;\n\n\tSMB_ASSERT(continuation != NULL);\n\n\tstate = TALLOC_P(mem_ctx, struct winbindd_async_request);\n\n\tif (state == NULL) {\n\t\tDEBUG(0, (\"talloc failed\\n\"));\n\t\tcontinuation(private_data, False);\n\t\treturn;\n\t}\n\n\tstate->mem_ctx = mem_ctx;\n\tstate->child = child;\n\tstate->request = request;\n\tstate->response = response;\n\tstate->continuation = continuation;\n\tstate->private_data = private_data;\n\n\tDLIST_ADD_END(child->requests, state, struct winbindd_async_request *);\n\n\tschedule_async_request(child);\n\n\treturn;\n}", "target": 1, "cwe": [], "message": "Back-port of Volkers fix.\n\n    Fix a race condition in winbind leading to a crash\n\n    When SIGCHLD handling is delayed for some reason, sending a request to a child\n    can fail early because the child has died already. In this case\n    async_main_request_sent() directly called the continuation function without\n    properly removing the malfunctioning child process and the requests in the\n    queue. The next request would then crash in the DLIST_ADD_END() in\n    async_request() because the request pending for the child had been\n    talloc_free()'ed and yet still was referenced in the list.\n\n    This one is *old*...\n\n    Volker\n\nJeremy."}
{"func": "static void async_main_request_sent(void *private_data, BOOL success)\n{\n\tstruct winbindd_async_request *state =\n\t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n\n\tif (!success) {\n\t\tDEBUG(5, (\"Could not send async request\\n\"));\n\n\t\tstate->response->length = sizeof(struct winbindd_response);\n\t\tstate->response->result = WINBINDD_ERROR;\n\t\tstate->continuation(state->private_data, False);\n\t\treturn;\n\t}\n\n\tif (state->request->extra_len == 0) {\n\t\tasync_request_sent(private_data, True);\n\t\treturn;\n\t}\n\n\tsetup_async_write(&state->child->event, state->request->extra_data.data,\n\t\t\t  state->request->extra_len,\n\t\t\t  async_request_sent, state);\n}", "target": 1, "cwe": [], "message": "Back-port of Volkers fix.\n\n    Fix a race condition in winbind leading to a crash\n\n    When SIGCHLD handling is delayed for some reason, sending a request to a child\n    can fail early because the child has died already. In this case\n    async_main_request_sent() directly called the continuation function without\n    properly removing the malfunctioning child process and the requests in the\n    queue. The next request would then crash in the DLIST_ADD_END() in\n    async_request() because the request pending for the child had been\n    talloc_free()'ed and yet still was referenced in the list.\n\n    This one is *old*...\n\n    Volker\n\nJeremy."}
{"func": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\t/*\n\t\t * Just discard all writes to the performance counters; this\n\t\t * should keep both older linux and windows 64-bit guests\n\t\t * happy\n\t\t */\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Otherwise falls through to kvm_set_msr_common */\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-20"], "message": "KVM: VMX: Don't allow uninhibited access to EFER on i386\n\nvmx_set_msr() does not allow i386 guests to touch EFER, but they can still\ndo so through the default: label in the switch.  If they set EFER_LME, they\ncan oops the host.\n\nFix by having EFER access through the normal channel (which will check for\nEFER_LME) even on i386.\n\nReported-and-tested-by: Benjamin Gilbert <bgilbert@cs.cmu.edu>\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "static bool acl_group_override(connection_struct *conn,\n\t\t\t\tgid_t prim_gid,\n\t\t\t\tconst char *fname)\n{\n\tSMB_STRUCT_STAT sbuf;\n\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\n\t/* file primary group == user primary or supplementary group */\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(prim_gid)) {\n\t\treturn true;\n\t}\n\n\t/* user has writeable permission */\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, &sbuf)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Bug 6488: acl_group_override() call in posix acls references an uninitialized variable.\n(cherry picked from commit f92195e3a1baaddda47a5d496f9488c8445b41ad)"}
{"func": "static bool set_canon_ace_list(files_struct *fsp, canon_ace *the_ace, bool default_ace, gid_t prim_gid, bool *pacl_set_support)\n{\n\tconnection_struct *conn = fsp->conn;\n\tbool ret = False;\n\tSMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, (int)count_canon_ace_list(the_ace) + 1);\n\tcanon_ace *p_ace;\n\tint i;\n\tSMB_ACL_ENTRY_T mask_entry;\n\tbool got_mask_entry = False;\n\tSMB_ACL_PERMSET_T mask_permset;\n\tSMB_ACL_TYPE_T the_acl_type = (default_ace ? SMB_ACL_TYPE_DEFAULT : SMB_ACL_TYPE_ACCESS);\n\tbool needs_mask = False;\n\tmode_t mask_perms = 0;\n\n#if defined(POSIX_ACL_NEEDS_MASK)\n\t/* HP-UX always wants to have a mask (called \"class\" there). */\n\tneeds_mask = True;\n#endif\n\n\tif (the_acl == NULL) {\n\n\t\tif (!no_acl_syscall_error(errno)) {\n\t\t\t/*\n\t\t\t * Only print this error message if we have some kind of ACL\n\t\t\t * support that's not working. Otherwise we would always get this.\n\t\t\t */\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Unable to init %s ACL. (%s)\\n\",\n\t\t\t\tdefault_ace ? \"default\" : \"file\", strerror(errno) ));\n\t\t}\n\t\t*pacl_set_support = False;\n\t\treturn False;\n\t}\n\n\tif( DEBUGLVL( 10 )) {\n\t\tdbgtext(\"set_canon_ace_list: setting ACL:\\n\");\n\t\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\t\tprint_canon_ace( p_ace, i);\n\t\t}\n\t}\n\n\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\tSMB_ACL_ENTRY_T the_entry;\n\t\tSMB_ACL_PERMSET_T the_permset;\n\n\t\t/*\n\t\t * ACLs only \"need\" an ACL_MASK entry if there are any named user or\n\t\t * named group entries. But if there is an ACL_MASK entry, it applies\n\t\t * to ACL_USER, ACL_GROUP, and ACL_GROUP_OBJ entries. Set the mask\n\t\t * so that it doesn't deny (i.e., mask off) any permissions.\n\t\t */\n\n\t\tif (p_ace->type == SMB_ACL_USER || p_ace->type == SMB_ACL_GROUP) {\n\t\t\tneeds_mask = True;\n\t\t\tmask_perms |= p_ace->perms;\n\t\t} else if (p_ace->type == SMB_ACL_GROUP_OBJ) {\n\t\t\tmask_perms |= p_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Get the entry for this ACE.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (p_ace->type == SMB_ACL_MASK) {\n\t\t\tmask_entry = the_entry;\n\t\t\tgot_mask_entry = True;\n\t\t}\n\n\t\t/*\n\t\t * Ok - we now know the ACL calls should be working, don't\n\t\t * allow fallback to chmod.\n\t\t */\n\n\t\t*pacl_set_support = True;\n\n\t\t/*\n\t\t * Initialise the entry from the canon_ace.\n\t\t */\n\n\t\t/*\n\t\t * First tell the entry what type of ACE this is.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, p_ace->type) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Only set the qualifier (user or group id) if the entry is a user\n\t\t * or group id ACE.\n\t\t */\n\n\t\tif ((p_ace->type == SMB_ACL_USER) || (p_ace->type == SMB_ACL_GROUP)) {\n\t\t\tif (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&p_ace->unix_ug.uid) == -1) {\n\t\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set qualifier on entry %d. (%s)\\n\",\n\t\t\t\t\ti, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Convert the mode_t perms in the canon_ace to a POSIX permset.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, p_ace->perms, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create permset for mode (%u) on entry %d. (%s)\\n\",\n\t\t\t\t(unsigned int)p_ace->perms, i, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * ..and apply them to the entry.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif( DEBUGLVL( 10 ))\n\t\t\tprint_canon_ace( p_ace, i);\n\n\t}\n\n\tif (needs_mask && !got_mask_entry) {\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &mask_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask entry. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, mask_entry, SMB_ACL_MASK) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on mask entry. (%s)\\n\",strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, mask_entry, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, S_IRUSR|S_IWUSR|S_IXUSR, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, mask_entry, mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Finally apply it to the file or directory.\n\t */\n\n\tif(default_ace || fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif (SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file type %s failed for file %s (%s).\\n\",\n\t\t\t\t\t\tthe_acl_type == SMB_ACL_TYPE_DEFAULT ? \"directory default\" : \"file\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file failed for file %s (%s).\\n\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = True;\n\n  fail:\n\n\tif (the_acl != NULL) {\n\t\tSMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Bug 6488: acl_group_override() call in posix acls references an uninitialized variable.\n(cherry picked from commit f92195e3a1baaddda47a5d496f9488c8445b41ad)"}
{"func": "NTSTATUS set_nt_acl(files_struct *fsp, uint32 security_info_sent, SEC_DESC *psd)\n{\n\tconnection_struct *conn = fsp->conn;\n\tuid_t user = (uid_t)-1;\n\tgid_t grp = (gid_t)-1;\n\tSMB_STRUCT_STAT sbuf;\n\tDOM_SID file_owner_sid;\n\tDOM_SID file_grp_sid;\n\tcanon_ace *file_ace_list = NULL;\n\tcanon_ace *dir_ace_list = NULL;\n\tbool acl_perms = False;\n\tmode_t orig_mode = (mode_t)0;\n\tNTSTATUS status;\n\tbool set_acl_as_root = false;\n\tbool acl_set_support = false;\n\tbool ret = false;\n\n\tDEBUG(10,(\"set_nt_acl: called for file %s\\n\", fsp->fsp_name ));\n\n\tif (!CAN_WRITE(conn)) {\n\t\tDEBUG(10,(\"set acl rejected on read-only share\\n\"));\n\t\treturn NT_STATUS_MEDIA_WRITE_PROTECTED;\n\t}\n\n\t/*\n\t * Get the current state of the file.\n\t */\n\n\tif(fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif(SMB_VFS_STAT(fsp->conn,fsp->fsp_name, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t} else {\n\t\tif(SMB_VFS_FSTAT(fsp, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\t/* Save the original element we check against. */\n\torig_mode = sbuf.st_mode;\n\n\t/*\n\t * Unpack the user/group/world id's.\n\t */\n\n\tstatus = unpack_nt_owners( SNUM(conn), &user, &grp, security_info_sent, psd);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\n\t/*\n\t * Do we need to chown ? If so this must be done first as the incoming\n\t * CREATOR_OWNER acl will be relative to the *new* owner, not the old.\n\t * Noticed by Simo.\n\t */\n\n\tif (((user != (uid_t)-1) && (sbuf.st_uid != user)) || (( grp != (gid_t)-1) && (sbuf.st_gid != grp))) {\n\n\t\tDEBUG(3,(\"set_nt_acl: chown %s. uid = %u, gid = %u.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp ));\n\n\t\tif(try_chown( fsp->conn, fsp->fsp_name, user, grp) == -1) {\n\t\t\tDEBUG(3,(\"set_nt_acl: chown %s, %u, %u failed. Error = %s.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp, strerror(errno) ));\n\t\t\tif (errno == EPERM) {\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/*\n\t\t * Recheck the current state of the file, which may have changed.\n\t\t * (suid/sgid bits, for instance)\n\t\t */\n\n\t\tif(fsp->is_directory) {\n\t\t\tif(SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf) != 0) {\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\n\t\t\tint sret;\n\n\t\t\tif(fsp->fh->fd == -1)\n\t\t\t\tsret = SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf);\n\t\t\telse\n\t\t\t\tsret = SMB_VFS_FSTAT(fsp, &sbuf);\n\n\t\t\tif(sret != 0)\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/* Save the original element we check against. */\n\t\torig_mode = sbuf.st_mode;\n\n\t\t/* If we successfully chowned, we know we must\n \t\t * be able to set the acl, so do it as root.\n \t\t */\n\t\tset_acl_as_root = true;\n\t}\n\n\tcreate_file_sids(&sbuf, &file_owner_sid, &file_grp_sid);\n\n\tacl_perms = unpack_canon_ace( fsp, &sbuf, &file_owner_sid, &file_grp_sid,\n\t\t\t\t\t&file_ace_list, &dir_ace_list, security_info_sent, psd);\n\n\t/* Ignore W2K traverse DACL set. */\n\tif (!file_ace_list && !dir_ace_list) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tif (!acl_perms) {\n\t\tDEBUG(3,(\"set_nt_acl: cannot set permissions\\n\"));\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\t/*\n\t * Only change security if we got a DACL.\n\t */\n\n\tif(!(security_info_sent & DACL_SECURITY_INFORMATION) || (psd->dacl == NULL)) {\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Try using the POSIX ACL set first. Fall back to chmod if\n\t * we have no ACL support on this filesystem.\n\t */\n\n\tif (acl_perms && file_ace_list) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tret = set_canon_ace_list(fsp, file_ace_list, False, sbuf.st_gid, &acl_set_support);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t\tif (acl_set_support && ret == false) {\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to set file acl on file %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tif (acl_perms && acl_set_support && fsp->is_directory) {\n\t\tif (dir_ace_list) {\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tret = set_canon_ace_list(fsp, dir_ace_list, True, sbuf.st_gid, &acl_set_support);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (ret == false) {\n\t\t\t\tDEBUG(3,(\"set_nt_acl: failed to set default acl on directory %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\t\t\tint sret = -1;\n\n\t\t\t/*\n\t\t\t * No default ACL - delete one if it exists.\n\t\t\t */\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override delete_def_acl\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: sys_acl_delete_def_file failed (%s)\\n\", strerror(errno)));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (acl_set_support) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tstore_inheritance_attributes(fsp, file_ace_list, dir_ace_list,\n\t\t\t\t(psd->type & SE_DESC_DACL_PROTECTED) ? True : False);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t}\n\n\t/*\n\t * If we cannot set using POSIX ACLs we fall back to checking if we need to chmod.\n\t */\n\n\tif(!acl_set_support && acl_perms) {\n\t\tmode_t posix_perms;\n\n\t\tif (!convert_canon_ace_to_posix_perms( fsp, file_ace_list, &posix_perms)) {\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to convert file acl to posix permissions for file %s.\\n\",\n\t\t\t\tfsp->fsp_name ));\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\n\t\tif (orig_mode != posix_perms) {\n\t\t\tint sret = -1;\n\n\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s. perms = 0%o.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms ));\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif(sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override chmod\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s, 0%o failed. Error = %s.\\n\",\n\t\t\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms, strerror(errno) ));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_canon_ace_list(file_ace_list);\n\tfree_canon_ace_list(dir_ace_list);\n\treturn NT_STATUS_OK;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Bug 6488: acl_group_override() call in posix acls references an uninitialized variable.\n(cherry picked from commit f92195e3a1baaddda47a5d496f9488c8445b41ad)"}
{"func": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t\treturn POLLERR;\n\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\n\tpoll_wait(file, &tun->socket.wait, wait);\n\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1, "cwe": ["CWE-119"], "message": "tun/tap: Fix crashes if open() /dev/net/tun and then poll() it.\n\nFix NULL pointer dereference in tun_chr_pool() introduced by commit\n33dccbb050bbe35b88ca8cf1228dcf3e4d4b3554 (\"tun: Limit amount of queued\npackets per device\") and triggered by this code:\n\n\tint fd;\n\tstruct pollfd pfd;\n\tfd = open(\"/dev/net/tun\", O_RDWR);\n\tpfd.fd = fd;\n\tpfd.events = POLLIN | POLLOUT;\n\tpoll(&pfd, 1, 0);\n\nReported-by: Eugene Kapun <abacabadabacaba@gmail.com>\nSigned-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t/* Only pending external irq is handled here */\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"Set back pending irq %d\\n\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-476"], "message": "KVM: x86: check for cr3 validity in ioctl_set_sregs\n\nMatt T. Yourst notes that kvm_arch_vcpu_ioctl_set_sregs lacks validity\nchecking for the new cr3 value:\n\n\"Userspace callers of KVM_SET_SREGS can pass a bogus value of cr3 to\nthe kernel. This will trigger a NULL pointer access in gfn_to_rmap()\nwhen userspace next tries to call KVM_RUN on the affected VCPU and kvm\nattempts to activate the new non-existent page table root.\n\nThis happens since kvm only validates that cr3 points to a valid guest\nphysical memory page when code *inside* the guest sets cr3. However, kvm\ncurrently trusts the userspace caller (e.g. QEMU) on the host machine to\nalways supply a valid page table root, rather than properly validating\nit along with the rest of the reloaded guest state.\"\n\nhttp://sourceforge.net/tracker/?func=detail&atid=893831&aid=2687641&group_id=180599\n\nCheck for a valid cr3 address in kvm_arch_vcpu_ioctl_set_sregs, triple\nfault in case of failure.\n\nCc: stable@kernel.org\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "parse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-119"], "message": "eCryptfs: Check Tag 11 literal data buffer size\n\nTag 11 packets are stored in the metadata section of an eCryptfs file to\nstore the key signature(s) used to encrypt the file encryption key.\nAfter extracting the packet length field to determine the key signature\nlength, a check is not performed to see if the length would exceed the\nkey signature buffer size that was passed into parse_tag_11_packet().\n\nThanks to Ramon de Carvalho Valle for finding this bug using fsfuzzer.\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nCc: stable@kernel.org (2.6.27 and 30)\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "parse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t       (u16)data[(*packet_size)]);\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\tecryptfs_init_crypt_ctx(crypt_stat);\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-119"], "message": "eCryptfs: parse_tag_3_packet check tag 3 packet encrypted key size\n\nThe parse_tag_3_packet function does not check if the tag 3 packet contains a\nencrypted key size larger than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES.\n\nSigned-off-by: Ramon de Carvalho Valle <ramon@risesecurity.org>\n[tyhicks@linux.vnet.ibm.com: Added printk newline and changed goto to out_free]\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nCc: stable@kernel.org (2.6.27 and 30)\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int huft_build(b, n, s, d, e, t, m)\nunsigned *b;            /* code lengths in bits (all assumed <= BMAX) */\nunsigned n;             /* number of codes (assumed <= N_MAX) */\nunsigned s;             /* number of simple-valued codes (0..s-1) */\nush *d;                 /* list of base values for non-simple codes */\nush *e;                 /* list of extra bits for non-simple codes */\nstruct huft **t;        /* result: starting table */\nint *m;                 /* maximum lookup bits, returns actual */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return zero on success, one if\n   the given code set is incomplete (the tables are still built in this\n   case), two if the input is invalid (all zero length codes or an\n   oversubscribed set of lengths), and three if not enough memory. */\n{\n  unsigned a;                   /* counter for codes of length k */\n  unsigned c[BMAX+1];           /* bit length count table */\n  unsigned f;                   /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register unsigned i;          /* counter, current code */\n  register unsigned j;          /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  register unsigned *p;         /* pointer into c[], b[], or v[] */\n  register struct huft *q;      /* points to current table */\n  struct huft r;                /* table entry for structure assignment */\n  struct huft *u[BMAX];         /* table stack */\n  unsigned v[N_MAX];            /* values in order of bit length */\n  register int w;               /* bits before this table == (l * h) */\n  unsigned x[BMAX+1];           /* bit offsets, then code stack */\n  unsigned *xp;                 /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  unsigned z;                   /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  memzero(c, sizeof(c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? \"%c %d\\n\" : \"0x%x %d\\n\"),\n\t    n-i, *p));\n    c[*p]++;                    /* assume all entries <= BMAX */\n    p++;                      /* Can't combine with above line (Solaris bug) */\n  } while (--i);\n  if (c[0] == n)                /* null input--all zero length codes */\n  {\n    q = (struct huft *) malloc (2 * sizeof *q);\n    if (!q)\n      return 3;\n    hufts += 2;\n    q[0].v.t = (struct huft *) NULL;\n    q[1].e = 99;    /* invalid code marker */\n    q[1].b = 1;\n    *t = q + 1;\n    *m = 1;\n    return 0;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                        /* minimum code length */\n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                        /* maximum code length */\n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0)\n      return 2;                 /* bad input: more codes than bits */\n  if ((y -= c[i]) < 0)\n    return 2;\n  c[i] += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                   /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x[0] = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u[0] = (struct huft *)NULL;   /* just to keep compilers happy */\n  q = (struct huft *)NULL;      /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c[k];\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = (z = g - w) > (unsigned)l ? l : z;  /* upper limit on table size */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n\t  if (j < z)\n\t    while (++j < z)       /* try smaller tables up to z bits */\n\t    {\n\t      if ((f <<= 1) <= *++xp)\n\t\tbreak;            /* enough codes to use up j bits */\n\t      f -= *xp;           /* else deduct codes from patterns */\n\t    }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate and link in new table */\n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u[0]);\n          return 3;             /* not enough memory */\n        }\n        hufts += z + 1;         /* track memory usage */\n        *t = q + 1;             /* link to list for huft_free() */\n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u[h] = ++q;             /* table starts after link */\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x[h] = i;             /* save pattern for backing up */\n          r.b = (uch)l;         /* bits to dump before this table */\n          r.e = (uch)(16 + j);  /* bits in this table */\n          r.v.t = q;            /* pointer to this table */\n          j = i >> (w - l);     /* (get around Turbo C bug) */\n          u[h-1][j] = r;        /* connect to last table */\n        }\n      }\n\n      /* set up table entry in r */\n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;               /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);    /* 256 is end-of-block code */\n        r.v.n = (ush)(*p);             /* simple code is just the value */\n\tp++;                           /* one compiler does not like *p++ */\n      }\n      else\n      {\n        r.e = (uch)e[*p - s];   /* non-simple--look up in lists */\n        r.v.n = d[*p++ - s];\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n      /* backup over finished tables */\n      while ((i & ((1 << w) - 1)) != x[h])\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n      }\n    }\n  }\n\n\n  /* Return true (1) if we were given an incomplete table */\n  return y != 0 && g != 1;\n}", "target": 1, "cwe": ["CWE-20"], "message": "avoid creating an undersized buffer for the hufts table\n\nA malformed input file can cause gzip to crash with a segmentation\nviolation or hang in an endless loop.\nReported in <http://bugs.debian.org/507263>.\n* NEWS (Bug fixes): Mention it."}
{"func": "do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)\n{\n\tstack_t oss;\n\tint error;\n\n\tif (uoss) {\n\t\toss.ss_sp = (void __user *) current->sas_ss_sp;\n\t\toss.ss_size = current->sas_ss_size;\n\t\toss.ss_flags = sas_ss_flags(sp);\n\t}\n\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\t\tsize_t ss_size;\n\t\tint ss_flags;\n\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, uss, sizeof(*uss))\n\t\t    || __get_user(ss_sp, &uss->ss_sp)\n\t\t    || __get_user(ss_flags, &uss->ss_flags)\n\t\t    || __get_user(ss_size, &uss->ss_size))\n\t\t\tgoto out;\n\n\t\terror = -EPERM;\n\t\tif (on_sig_stack(sp))\n\t\t\tgoto out;\n\n\t\terror = -EINVAL;\n\t\t/*\n\t\t *\n\t\t * Note - this code used to test ss_flags incorrectly\n\t\t *  \t  old code may have been written using ss_flags==0\n\t\t *\t  to mean ss_flags==SS_ONSTACK (as this was the only\n\t\t *\t  way that worked) - this fix preserves that older\n\t\t *\t  mechanism\n\t\t */\n\t\tif (ss_flags != SS_DISABLE && ss_flags != SS_ONSTACK && ss_flags != 0)\n\t\t\tgoto out;\n\n\t\tif (ss_flags == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\terror = -ENOMEM;\n\t\t\tif (ss_size < MINSIGSTKSZ)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->sas_ss_sp = (unsigned long) ss_sp;\n\t\tcurrent->sas_ss_size = ss_size;\n\t}\n\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (copy_to_user(uoss, &oss, sizeof(oss)))\n\t\t\tgoto out;\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}", "target": 1, "cwe": [], "message": "do_sigaltstack: avoid copying 'stack_t' as a structure to user space\n\nUlrich Drepper correctly points out that there is generally padding in\nthe structure on 64-bit hosts, and that copying the structure from\nkernel to user space can leak information from the kernel stack in those\npadding bytes.\n\nAvoid the whole issue by just copying the three members one by one\ninstead, which also means that the function also can avoid the need for\na stack frame.  This also happens to match how we copy the new structure\nfrom user space, so it all even makes sense.\n\n[ The obvious solution of adding a memset() generates horrid code, gcc\n  does really stupid things. ]\n\nReported-by: Ulrich Drepper <drepper@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/* \n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags&MSG_OOB)\t/* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t \t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n \t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address. \n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in*)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->daddr;\n\t\tdport = inet->dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n  \t}\n\tipc.addr = inet->saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) || \n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (MULTICAST(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable*)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi fl = { .oif = ipc.oif,\n\t\t\t\t    .nl_u = { .ip4_u =\n\t\t\t\t\t      { .daddr = faddr,\n\t\t\t\t\t\t.saddr = saddr,\n\t\t\t\t\t\t.tos = tos } },\n\t\t\t\t    .proto = IPPROTO_UDP,\n\t\t\t\t    .uli_u = { .ports =\n\t\t\t\t\t       { .sport = inet->sport,\n\t\t\t\t\t\t .dport = dport } } };\n\t\tsecurity_sk_classify_flow(sk, &fl);\n\t\terr = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->u.dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tinet->cork.fl.fl4_dst = daddr;\n\tinet->cork.fl.fl_ip_dport = dport;\n\tinet->cork.fl.fl4_src = saddr;\n\tinet->cork.fl.fl_ip_sport = inet->sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen, \n\t\t\tsizeof(struct udphdr), &ipc, rt, \n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk, up);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->u.dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-476"], "message": "[UDP]: Fix MSG_PROBE crash\n\nUDP tracks corking status through the pending variable.  The\nIP layer also tracks it through the socket write queue.  It\nis possible for the two to get out of sync when MSG_PROBE is\nused.\n\nThis patch changes UDP to check the write queue to ensure\nthat the two stay in sync.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, \n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p = NULL, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi fl;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &np->daddr;\n\t} else \n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_type(daddr) == IPV6_ADDR_MAPPED) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_build_xmit\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\t\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl.fl_ip_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl.fl6_flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &np->daddr))\n\t\t\tdaddr = &np->daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    ipv6_addr_type(daddr)&IPV6_ADDR_LINKLOCAL)\n\t\t\tfl.oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl.fl_ip_dport = inet->dport;\n\t\tdaddr = &np->daddr;\n\t\tfl.fl6_flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl.oif)\n\t\tfl.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = datagram_send_ctl(msg, &fl, opt, &hlimit, &tclass);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl.fl6_flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl.fl6_flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl.proto = IPPROTO_UDP;\n\tipv6_addr_copy(&fl.fl6_dst, daddr);\n\tif (ipv6_addr_any(&fl.fl6_src) && !ipv6_addr_any(&np->saddr))\n\t\tipv6_addr_copy(&fl.fl6_src, &np->saddr);\n\tfl.fl_ip_sport = inet->sport;\n\t\n\t/* merge ip6_build_xmit from ip6_output */\n\tif (opt && opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) opt->srcrt;\n\t\tipv6_addr_copy(&final, &fl.fl6_dst);\n\t\tipv6_addr_copy(&fl.fl6_dst, rt0->addr);\n\t\tfinal_p = &final;\n\t\tconnected = 0;\n\t}\n\n\tif (!fl.oif && ipv6_addr_is_multicast(&fl.fl6_dst)) {\n\t\tfl.oif = np->mcast_oif;\n\t\tconnected = 0;\n\t}\n\n\tsecurity_sk_classify_flow(sk, &fl);\n\n\terr = ip6_sk_dst_lookup(sk, &dst, &fl);\n\tif (err)\n\t\tgoto out;\n\tif (final_p)\n\t\tipv6_addr_copy(&fl.fl6_dst, final_p);\n\n\tif ((err = xfrm_lookup(&dst, &fl, sk, 0)) < 0)\n\t\tgoto out;\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl.fl6_dst))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = dst_metric(dst, RTAX_HOPLIMIT);\n\t\tif (hlimit < 0)\n\t\t\thlimit = ipv6_get_hoplimit(dst->dev);\n\t}\n\n\tif (tclass < 0) {\n\t\ttclass = np->tclass;\n\t\tif (tclass < 0)\n\t\t\ttclass = 0;\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk, up);\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_dst, &np->daddr) ?\n\t\t\t\t      &np->daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl.fl6_src, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tfl6_sock_release(flowlabel);\n\tif (!err) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_OUTDATAGRAMS);\n\t\treturn len;\n\t}\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(UDP_MIB_SNDBUFERRORS);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-476"], "message": "[UDP]: Fix MSG_PROBE crash\n\nUDP tracks corking status through the pending variable.  The\nIP layer also tracks it through the socket write queue.  It\nis possible for the two to get out of sync when MSG_PROBE is\nused.\n\nThis patch changes UDP to check the write queue to ensure\nthat the two stay in sync.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "message": "NET: llc, zero sockaddr_llc struct\n\nsllc_arphrd member of sockaddr_llc might not be changed. Zero sllc\nbefore copying to the above layer's structure.\n\nSigned-off-by: Jiri Slaby <jirislaby@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int irda_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct sockaddr_irda saddr;\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->dtsap_sel;\n\t\tsaddr.sir_addr = self->daddr;\n\t} else {\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->stsap_sel;\n\t\tsaddr.sir_addr = self->saddr;\n\t}\n\n\tIRDA_DEBUG(1, \"%s(), tsap_sel = %#x\\n\", __func__, saddr.sir_lsap_sel);\n\tIRDA_DEBUG(1, \"%s(), addr = %08x\\n\", __func__, saddr.sir_addr);\n\n\t/* uaddr_len come to us uninitialised */\n\t*uaddr_len = sizeof (struct sockaddr_irda);\n\tmemcpy(uaddr, &saddr, *uaddr_len);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "irda: Fix irda_getname() leak\n\nirda_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "rose: Fix rose_getname() leak\n\nrose_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "appletalk: fix atalk_getname() leak\n\natalk_getname() can leak 8 bytes of kernel memory to user\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "econet: Fix econet_getname() leak\n\neconet_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "can: Fix raw_getname() leak\n\nraw_getname() can leak 10 bytes of kernel memory to user\n\n(two bytes hole between can_family and can_ifindex,\n8 bytes at the end of sockaddr_can structure)\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Oliver Hartkopp <oliver@hartkopp.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netrom: Fix nr_getname() leak\n\nnr_getname() can leak kernel memory to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-909"], "message": "tc: Fix unitialized kernel memory leak\n\nThree bytes of uninitialized kernel memory are currently leaked to user\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nReviewed-by: Jiri Pirko <jpirko@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing padding fields in dumped structures\n\nPlug holes with padding fields and initialized them to zero.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\n\tt->tcm_handle = f->handle;\n\n\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\n\trta->rta_len = skb->tail - b;\n\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing padding fields in dumped structures\n\nPlug holes with padding fields and initialized them to zero.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\t\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing padding fields in dumped structures\n\nPlug holes with padding fields and initialized them to zero.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int neightbl_fill_info(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndtmsg *ndtmsg;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tRTA_PUT_MSECS(skb, NDTA_GC_INTERVAL, tbl->gc_interval);\n\tRTA_PUT_U32(skb, NDTA_THRESH1, tbl->gc_thresh1);\n\tRTA_PUT_U32(skb, NDTA_THRESH2, tbl->gc_thresh2);\n\tRTA_PUT_U32(skb, NDTA_THRESH3, tbl->gc_thresh3);\n\n\t{\n\t\tunsigned long now = jiffies;\n\t\tunsigned int flush_delta = now - tbl->last_flush;\n\t\tunsigned int rand_delta = now - tbl->last_rand;\n\n\t\tstruct ndt_config ndc = {\n\t\t\t.ndtc_key_len\t\t= tbl->key_len,\n\t\t\t.ndtc_entry_size\t= tbl->entry_size,\n\t\t\t.ndtc_entries\t\t= atomic_read(&tbl->entries),\n\t\t\t.ndtc_last_flush\t= jiffies_to_msecs(flush_delta),\n\t\t\t.ndtc_last_rand\t\t= jiffies_to_msecs(rand_delta),\n\t\t\t.ndtc_hash_rnd\t\t= tbl->hash_rnd,\n\t\t\t.ndtc_hash_mask\t\t= tbl->hash_mask,\n\t\t\t.ndtc_hash_chain_gc\t= tbl->hash_chain_gc,\n\t\t\t.ndtc_proxy_qlen\t= tbl->proxy_queue.qlen,\n\t\t};\n\n\t\tRTA_PUT(skb, NDTA_CONFIG, sizeof(ndc), &ndc);\n\t}\n\n\t{\n\t\tint cpu;\n\t\tstruct ndt_stats ndst;\n\n\t\tmemset(&ndst, 0, sizeof(ndst));\n\n\t\tfor (cpu = 0; cpu < NR_CPUS; cpu++) {\n\t\t\tstruct neigh_statistics\t*st;\n\n\t\t\tif (!cpu_possible(cpu))\n\t\t\t\tcontinue;\n\n\t\t\tst = per_cpu_ptr(tbl->stats, cpu);\n\t\t\tndst.ndts_allocs\t\t+= st->allocs;\n\t\t\tndst.ndts_destroys\t\t+= st->destroys;\n\t\t\tndst.ndts_hash_grows\t\t+= st->hash_grows;\n\t\t\tndst.ndts_res_failed\t\t+= st->res_failed;\n\t\t\tndst.ndts_lookups\t\t+= st->lookups;\n\t\t\tndst.ndts_hits\t\t\t+= st->hits;\n\t\t\tndst.ndts_rcv_probes_mcast\t+= st->rcv_probes_mcast;\n\t\t\tndst.ndts_rcv_probes_ucast\t+= st->rcv_probes_ucast;\n\t\t\tndst.ndts_periodic_gc_runs\t+= st->periodic_gc_runs;\n\t\t\tndst.ndts_forced_gc_runs\t+= st->forced_gc_runs;\n\t\t}\n\n\t\tRTA_PUT(skb, NDTA_STATS, sizeof(ndst), &ndst);\n\t}\n\n\tBUG_ON(tbl->parms.dev);\n\tif (neightbl_fill_parms(skb, &tbl->parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n \nnlmsg_failure:\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&cache_resolve_queue_len);\n\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tkmem_cache_free(mrt_cachep, c);\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev, \n\t\t\t     u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tstruct net_device\t*dev = idev->dev;\n\t__s32\t\t\t*array = NULL;\n\tstruct ifinfomsg\t*r;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct rtattr\t\t*subattr;\n\t__u32\t\t\tmtu = dev->mtu;\n\tstruct ifla_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_INET6;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = 0;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (dev->addr_len)\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\n\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\tif (dev->ifindex != dev->iflink)\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(int), &dev->iflink);\n\t\t\t\n\tsubattr = (struct rtattr*)skb->tail;\n\n\tRTA_PUT(skb, IFLA_PROTINFO, 0, NULL);\n\n\t/* return the device flags */\n\tRTA_PUT(skb, IFLA_INET6_FLAGS, sizeof(__u32), &idev->if_flags);\n\n\t/* return interface cacheinfo */\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100\n\t\t    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);\n\tci.reachable_time = idev->nd_parms->reachable_time;\n\tci.retrans_time = idev->nd_parms->retrans_time;\n\tRTA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);\n\t\n\t/* return the device sysctl params */\n\tif ((array = kmalloc(DEVCONF_MAX * sizeof(*array), GFP_ATOMIC)) == NULL)\n\t\tgoto rtattr_failure;\n\tipv6_store_devconf(&idev->cnf, array, DEVCONF_MAX * sizeof(*array));\n\tRTA_PUT(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(*array), array);\n\n\t/* XXX - Statistics/MC not implemented */\n\tsubattr->rta_len = skb->tail - (u8*)subattr;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tkfree(array);\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (array)\n\t\tkfree(array);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tb = (unsigned char *)skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\t\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static __inline__ int cbq_dump_police(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_police opt;\n\n\tif (cl->police) {\n\t\topt.police = cl->police;\n\t\tRTA_PUT(skb, TCA_CBQ_POLICE, sizeof(opt), &opt);\n\t}\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int rtnetlink_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t int type, u32 pid, u32 seq, u32 change, \n\t\t\t\t unsigned int flags)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = change;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (1) {\n\t\tu32 txqlen = dev->tx_queue_len;\n\t\tRTA_PUT(skb, IFLA_TXQLEN, sizeof(txqlen), &txqlen);\n\t}\n\n\tif (1) {\n\t\tu32 weight = dev->weight;\n\t\tRTA_PUT(skb, IFLA_WEIGHT, sizeof(weight), &weight);\n\t}\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tRTA_PUT(skb, IFLA_MAP, sizeof(map), &map);\n\t}\n\n\tif (dev->addr_len) {\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\t\tRTA_PUT(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast);\n\t}\n\n\tif (1) {\n\t\tu32 mtu = dev->mtu;\n\t\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\t}\n\n\tif (dev->ifindex != dev->iflink) {\n\t\tu32 iflink = dev->iflink;\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(iflink), &iflink);\n\t}\n\n\tif (dev->qdisc_sleeping)\n\t\tRTA_PUT(skb, IFLA_QDISC,\n\t\t\tstrlen(dev->qdisc_sleeping->ops->id) + 1,\n\t\t\tdev->qdisc_sleeping->ops->id);\n\t\n\tif (dev->master) {\n\t\tu32 master = dev->master->ifindex;\n\t\tRTA_PUT(skb, IFLA_MASTER, sizeof(master), &master);\n\t}\n\n\tif (dev->get_stats) {\n\t\tunsigned long *stats = (unsigned long*)dev->get_stats(dev);\n\t\tif (stats) {\n\t\t\tstruct rtattr  *a;\n\t\t\t__u32\t       *s;\n\t\t\tint\t\ti;\n\t\t\tint\t\tn = sizeof(struct rtnl_link_stats)/4;\n\n\t\t\ta = __RTA_PUT(skb, IFLA_STATS, n*4);\n\t\t\ts = RTA_DATA(a);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t\ts[i] = stats[i];\n\t\t}\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t/* Wireless changes don't affect those flags */\n\n\t/* Add the wireless events in the netlink packet */\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n\nnlmsg_failure:\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\n\tb = (unsigned char *)skb->tail;\n\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8 *) x;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\n\treturn err;\n\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Missing initializations in dumped data\n\nMostly missing initialization of padding fields of 1 or 2 bytes length,\ntwo instances of uninitialized nlmsgerr->msg of 16 bytes length.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\treturn rta;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Clear padding in netlink messages\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Clear padding in netlink messages\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1, "cwe": ["CWE-200"], "message": "[NETLINK]: Clear padding in netlink messages\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void saveVCard (TNEFStruct *tnef, const gchar *tmpdir) {\n    gchar ifilename[512];\n    FILE *fptr;\n    variableLength *vl;\n    variableLength *pobox, *street, *city, *state, *zip, *country;\n    dtr thedate;\n    gint boolean, i;\n\n    if ((vl = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DISPLAY_NAME))) == MAPI_UNDEFINED) {\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COMPANY_NAME))) == MAPI_UNDEFINED) {\n            if (tnef->subject.size > 0) {\n                sprintf(ifilename, \"%s/%s.vcard\", tmpdir, tnef->subject.data);\n            } else {\n                sprintf(ifilename, \"%s/unknown.vcard\", tmpdir);\n            }\n        } else {\n            sprintf(ifilename, \"%s/%s.vcard\", tmpdir, vl->data);\n        }\n    } else {\n        sprintf(ifilename, \"%s/%s.vcard\", tmpdir, vl->data);\n    }\n    for (i=0; i<strlen (ifilename); i++)\n        if (ifilename[i] == ' ')\n            ifilename[i] = '_';\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCARD\\n\");\n        fprintf(fptr, \"VERSION:2.1\\n\");\n        if (vl != MAPI_UNDEFINED) {\n            fprintf(fptr, \"FN:%s\\n\", vl->data);\n        }\n        fprintProperty(tnef, fptr, PT_STRING8, PR_NICKNAME, \"NICKNAME:%s\\n\");\n        fprintUserProp(tnef, fptr, PT_STRING8, 0x8554, \"MAILER:Microsoft Outlook %s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_SPOUSE_NAME, \"X-EVOLUTION-SPOUSE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_MANAGER_NAME, \"X-EVOLUTION-MANAGER:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ASSISTANT, \"X-EVOLUTION-ASSISTANT:%s\\n\");\n\n        /* Organizational */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COMPANY_NAME))) != MAPI_UNDEFINED) {\n            if (vl->size > 0) {\n                if ((vl->size == 1) && (vl->data[0] == 0)) {\n                } else {\n                    fprintf(fptr,\"ORG:%s\", vl->data);\n                    if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DEPARTMENT_NAME))) != MAPI_UNDEFINED) {\n                        fprintf(fptr,\";%s\", vl->data);\n                    }\n                    fprintf(fptr, \"\\n\");\n                }\n            }\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_OFFICE_LOCATION, \"X-EVOLUTION-OFFICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TITLE, \"TITLE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PROFESSION, \"ROLE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BODY, \"NOTE:%s\\n\");\n        if (tnef->body.size > 0) {\n            fprintf(fptr, \"NOTE;QUOTED-PRINTABLE:\");\n            quotedfprint (fptr, &(tnef->body));\n            fprintf(fptr,\"\\n\");\n        }\n\n        /* Business Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_STREET_ADDRESS))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_LOCALITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;WORK:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n            if ((vl = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x801b))) != MAPI_UNDEFINED) {\n                fprintf(fptr, \"LABEL;QUOTED-PRINTABLE;WORK:\");\n                quotedfprint (fptr, vl);\n                fprintf(fptr,\"\\n\");\n            }\n        }\n\n        /* Home Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_STREET))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_CITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_HOME_ADDRESS_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;HOME:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n            if ((vl = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x801a))) != MAPI_UNDEFINED) {\n                fprintf(fptr, \"LABEL;QUOTED-PRINTABLE;WORK:\");\n                quotedfprint (fptr, vl);\n                fprintf(fptr,\"\\n\");\n            }\n        }\n\n        /* Other Address */\n        boolean = 0;\n        if ((pobox = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_POST_OFFICE_BOX))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((street = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_STREET))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((city = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_CITY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((state = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_STATE_OR_PROVINCE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((zip = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_POSTAL_CODE))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if ((country = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_OTHER_ADDRESS_COUNTRY))) != MAPI_UNDEFINED) {\n            boolean = 1;\n        }\n        if (boolean == 1) {\n            fprintf(fptr, \"ADR;QUOTED-PRINTABLE;OTHER:\");\n            if (pobox != MAPI_UNDEFINED) {\n                quotedfprint (fptr, pobox);\n            }\n            fprintf(fptr, \";;\");\n            if (street != MAPI_UNDEFINED) {\n                quotedfprint (fptr, street);\n            }\n            fprintf(fptr, \";\");\n            if (city != MAPI_UNDEFINED) {\n                quotedfprint (fptr, city);\n            }\n            fprintf(fptr, \";\");\n            if (state != MAPI_UNDEFINED) {\n                quotedfprint (fptr, state);\n            }\n            fprintf(fptr, \";\");\n            if (zip != MAPI_UNDEFINED) {\n                quotedfprint (fptr, zip);\n            }\n            fprintf(fptr, \";\");\n            if (country != MAPI_UNDEFINED) {\n                quotedfprint (fptr, country);\n            }\n            fprintf(fptr,\"\\n\");\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_CALLBACK_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-CALLBACK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PRIMARY_TELEPHONE_NUMBER, \"TEL;PREF:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_MOBILE_TELEPHONE_NUMBER, \"TEL;CELL:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_RADIO_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-RADIO:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_CAR_TELEPHONE_NUMBER, \"TEL;CAR:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_OTHER_TELEPHONE_NUMBER, \"TEL;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PAGER_TELEPHONE_NUMBER, \"TEL;PAGER:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TELEX_NUMBER, \"TEL;X-EVOLUTION-TELEX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ISDN_NUMBER, \"TEL;ISDN:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME2_TELEPHONE_NUMBER, \"TEL;HOME:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_TTYTDD_PHONE_NUMBER, \"TEL;X-EVOLUTION-TTYTDD:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME_TELEPHONE_NUMBER, \"TEL;HOME;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_ASSISTANT_TELEPHONE_NUMBER, \"TEL;X-EVOLUTION-ASSISTANT:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_COMPANY_MAIN_PHONE_NUMBER, \"TEL;WORK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_TELEPHONE_NUMBER, \"TEL;WORK:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS2_TELEPHONE_NUMBER, \"TEL;WORK;VOICE:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_PRIMARY_FAX_NUMBER, \"TEL;PREF;FAX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_FAX_NUMBER, \"TEL;WORK;FAX:%s\\n\");\n        fprintProperty(tnef, fptr, PT_STRING8, PR_HOME_FAX_NUMBER, \"TEL;HOME;FAX:%s\\n\");\n\n        /* Email addresses */\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8083))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8084));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8093))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x8094));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n        if ((vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x80a3))) == MAPI_UNDEFINED) {\n            vl=MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x80a4));\n        }\n        if (vl != MAPI_UNDEFINED) {\n            if (vl->size > 0)\n                fprintf(fptr, \"EMAIL:%s\\n\", vl->data);\n        }\n\n        fprintProperty(tnef, fptr, PT_STRING8, PR_BUSINESS_HOME_PAGE, \"URL:%s\\n\");\n        fprintUserProp(tnef, fptr, PT_STRING8, 0x80d8, \"FBURL:%s\\n\");\n\n        /* Birthday */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_SYSTIME, PR_BIRTHDAY))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"BDAY:\");\n            MAPISysTimetoDTR ((guchar *) vl->data, &thedate);\n            fprintf(fptr, \"%i-%02i-%02i\\n\", thedate.wYear, thedate.wMonth, thedate.wDay);\n        }\n\n        /* Anniversary */\n        if ((vl=MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_SYSTIME, PR_WEDDING_ANNIVERSARY))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"X-EVOLUTION-ANNIVERSARY:\");\n            MAPISysTimetoDTR ((guchar *) vl->data, &thedate);\n            fprintf(fptr, \"%i-%02i-%02i\\n\", thedate.wYear, thedate.wMonth, thedate.wDay);\n        }\n        fprintf(fptr, \"END:VCARD\\n\");\n        fclose (fptr);\n    }\n}", "target": 1, "cwe": [], "message": "bug #641069 - tnef plugin vulnerabilities\n\nResolves directory traversal and buffer overflow vulnerabilities."}
{"func": "void processTnef (TNEFStruct *tnef, const gchar *tmpdir) {\n    variableLength *filename;\n    variableLength *filedata;\n    Attachment *p;\n    gint RealAttachment;\n    gint object;\n    gchar ifilename[256];\n    gint i, count;\n    gint foundCal=0;\n\n    FILE *fptr;\n\n    /* First see if this requires special processing. */\n    /* ie: it's a Contact Card, Task, or Meeting request (vCal/vCard) */\n    if (tnef->messageClass[0] != 0)  {\n        if (strcmp(tnef->messageClass, \"IPM.Contact\") == 0) {\n            saveVCard (tnef, tmpdir);\n        }\n        if (strcmp(tnef->messageClass, \"IPM.Task\") == 0) {\n            saveVTask (tnef, tmpdir);\n        }\n        if (strcmp(tnef->messageClass, \"IPM.Appointment\") == 0) {\n            saveVCalendar (tnef, tmpdir);\n            foundCal = 1;\n        }\n    }\n\n    if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8,0x24))) != MAPI_UNDEFINED) {\n        if (strcmp(filename->data, \"IPM.Appointment\") == 0) {\n             /* If it's \"indicated\" twice, we don't want to save 2 calendar entries. */\n            if (foundCal == 0) {\n                saveVCalendar (tnef, tmpdir);\n            }\n        }\n    }\n\n    if (strcmp(tnef->messageClass, \"IPM.Microsoft Mail.Note\") == 0) {\n        if ((saveRTF == 1) && (tnef->subject.size > 0)) {\n            /*  Description */\n            if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n\t\t\t\t\t   PROP_TAG (PT_BINARY, PR_RTF_COMPRESSED)))\n                    != MAPI_UNDEFINED) {\n                variableLength buf;\n                if ((buf.data = (gchar *) DecompressRTF (filename, &buf.size)) != NULL) {\n                    sprintf(ifilename, \"%s/%s.rtf\", tmpdir, tnef->subject.data);\n                    for (i=0; i<strlen (ifilename); i++)\n                        if (ifilename[i] == ' ')\n                            ifilename[i] = '_';\n\n                    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n                        printf(\"ERROR: Error writing file to disk!\");\n                    } else {\n                        fwrite (buf.data,\n                                sizeof (BYTE),\n                                buf.size,\n                                fptr);\n                        fclose (fptr);\n                    }\n                    free (buf.data);\n                }\n            }\n\t}\n    }\n\n    /* Now process each attachment */\n    p = tnef->starting_attach.next;\n    count = 0;\n    while (p != NULL) {\n        count++;\n        /* Make sure it has a size. */\n        if (p->FileData.size > 0) {\n            object = 1;\n\n            /* See if the contents are stored as \"attached data\" */\n\t    /* Inside the MAPI blocks. */\n            if ((filedata = MAPIFindProperty (&(p->MAPI),\n                                    PROP_TAG (PT_OBJECT, PR_ATTACH_DATA_OBJ)))\n                    == MAPI_UNDEFINED) {\n                if ((filedata = MAPIFindProperty (&(p->MAPI),\n                                    PROP_TAG (PT_BINARY, PR_ATTACH_DATA_OBJ)))\n\t\t   == MAPI_UNDEFINED) {\n                    /* Nope, standard TNEF stuff. */\n                    filedata = &(p->FileData);\n                    object = 0;\n                }\n            }\n            /* See if this is an embedded TNEF stream. */\n            RealAttachment = 1;\n            if (object == 1) {\n                /*  This is an \"embedded object\", so skip the */\n                /* 16-byte identifier first. */\n                TNEFStruct emb_tnef;\n                DWORD signature;\n                memcpy (&signature, filedata->data+16, sizeof (DWORD));\n                if (TNEFCheckForSignature (signature) == 0) {\n                    /* Has a TNEF signature, so process it. */\n                    TNEFInitialize (&emb_tnef);\n                    emb_tnef.Debug = tnef->Debug;\n                    if (TNEFParseMemory ((guchar *) filedata->data+16,\n                             filedata->size-16, &emb_tnef) != -1) {\n                        processTnef (&emb_tnef, tmpdir);\n                        RealAttachment = 0;\n                    }\n                    TNEFFree (&emb_tnef);\n                }\n            } else {\n                TNEFStruct emb_tnef;\n                DWORD signature;\n                memcpy (&signature, filedata->data, sizeof (DWORD));\n                if (TNEFCheckForSignature (signature) == 0) {\n                    /* Has a TNEF signature, so process it. */\n                    TNEFInitialize (&emb_tnef);\n                    emb_tnef.Debug = tnef->Debug;\n                    if (TNEFParseMemory ((guchar *) filedata->data,\n                            filedata->size, &emb_tnef) != -1) {\n                        processTnef (&emb_tnef, tmpdir);\n                        RealAttachment = 0;\n                    }\n                    TNEFFree (&emb_tnef);\n                }\n            }\n            if ((RealAttachment == 1) || (saveintermediate == 1)) {\n\t\tgchar tmpname[20];\n                /* Ok, it's not an embedded stream, so now we */\n\t\t/* process it. */\n                if ((filename = MAPIFindProperty (&(p->MAPI),\n                                        PROP_TAG (PT_STRING8, PR_ATTACH_LONG_FILENAME)))\n                        == MAPI_UNDEFINED) {\n                    if ((filename = MAPIFindProperty (&(p->MAPI),\n                                        PROP_TAG (PT_STRING8, PR_DISPLAY_NAME)))\n                            == MAPI_UNDEFINED) {\n                        filename = &(p->Title);\n                    }\n                }\n                if (filename->size == 1) {\n                    filename->size = 20;\n                    sprintf(tmpname, \"file_%03i.dat\", count);\n                    filename->data = tmpname;\n                }\n                sprintf(ifilename, \"%s/%s\", tmpdir, filename->data);\n                for (i=0; i<strlen (ifilename); i++)\n                    if (ifilename[i] == ' ')\n                        ifilename[i] = '_';\n\n\t\tif ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n\t\t    printf(\"ERROR: Error writing file to disk!\");\n\t\t} else {\n\t\t    if (object == 1) {\n\t\t\tfwrite (filedata->data + 16,\n\t\t\t       sizeof (BYTE),\n\t\t\t       filedata->size - 16,\n\t\t\t       fptr);\n\t\t    } else {\n\t\t\tfwrite (filedata->data,\n\t\t\t       sizeof (BYTE),\n\t\t\t       filedata->size,\n\t\t\t       fptr);\n\t\t    }\n\t\t    fclose (fptr);\n\t\t}\n            }\n        } /* if size>0 */\n        p=p->next;\n    } /* while p!= null */\n}", "target": 1, "cwe": [], "message": "bug #641069 - tnef plugin vulnerabilities\n\nResolves directory traversal and buffer overflow vulnerabilities."}
{"func": "void saveVTask (TNEFStruct *tnef, const gchar *tmpdir) {\n    variableLength *vl;\n    variableLength *filename;\n    gint index,i;\n    gchar ifilename[256];\n    gchar *charptr, *charptr2;\n    dtr thedate;\n    FILE *fptr;\n    DWORD *dword_ptr;\n    DWORD dword_val;\n\n    vl = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_CONVERSATION_TOPIC));\n\n    if (vl == MAPI_UNDEFINED) {\n        return;\n    }\n\n    index = strlen (vl->data);\n    while (vl->data[index] == ' ')\n            vl->data[index--] = 0;\n\n    sprintf(ifilename, \"%s/%s.ics\", tmpdir, vl->data);\n    for (i=0; i<strlen (ifilename); i++)\n        if (ifilename[i] == ' ')\n            ifilename[i] = '_';\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCALENDAR\\n\");\n        fprintf(fptr, \"VERSION:2.0\\n\");\n        fprintf(fptr, \"METHOD:PUBLISH\\n\");\n        filename = NULL;\n\n        fprintf(fptr, \"BEGIN:VTODO\\n\");\n        if (tnef->messageID[0] != 0) {\n            fprintf(fptr,\"UID:%s\\n\", tnef->messageID);\n        }\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                        PROP_TAG (PT_STRING8, 0x8122));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"ORGANIZER:%s\\n\", filename->data);\n        }\n\n        if ((filename = MAPIFindProperty (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, PR_DISPLAY_TO))) != MAPI_UNDEFINED) {\n            filename = MAPIFindUserProp (&(tnef->MapiProperties), PROP_TAG (PT_STRING8, 0x811f));\n        }\n        if ((filename != MAPI_UNDEFINED) && (filename->size > 1)) {\n            charptr = filename->data-1;\n            while (charptr != NULL) {\n                charptr++;\n                charptr2 = strstr(charptr, \";\");\n                if (charptr2 != NULL) {\n                    *charptr2 = 0;\n                }\n                while (*charptr == ' ')\n                    charptr++;\n                fprintf(fptr, \"ATTENDEE;CN=%s;ROLE=REQ-PARTICIPANT:%s\\n\", charptr, charptr);\n                charptr = charptr2;\n            }\n        }\n\n        if (tnef->subject.size > 0) {\n            fprintf(fptr,\"SUMMARY:\");\n            cstylefprint (fptr,&(tnef->subject));\n            fprintf(fptr,\"\\n\");\n        }\n\n        if (tnef->body.size > 0) {\n            fprintf(fptr,\"DESCRIPTION:\");\n            cstylefprint (fptr,&(tnef->body));\n            fprintf(fptr,\"\\n\");\n        }\n\n        filename = MAPIFindProperty (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, PR_CREATION_TIME));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"DTSTAMP:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, 0x8517));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"DUE:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        filename = MAPIFindProperty (&(tnef->MapiProperties), \\\n                    PROP_TAG (PT_SYSTIME, PR_LAST_MODIFICATION_TIME));\n        if (filename != MAPI_UNDEFINED) {\n            fprintf(fptr, \"LAST-MODIFIED:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Class */\n        filename = MAPIFindUserProp (&(tnef->MapiProperties), \\\n                        PROP_TAG (PT_BOOLEAN, 0x8506));\n        if (filename != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            dword_val = SwapDWord ((BYTE*)dword_ptr);\n            fprintf(fptr, \"CLASS:\" );\n            if (*dword_ptr == 1) {\n                fprintf(fptr,\"PRIVATE\\n\");\n            } else {\n                fprintf(fptr,\"PUBLIC\\n\");\n            }\n        }\n        fprintf(fptr, \"END:VTODO\\n\");\n        fprintf(fptr, \"END:VCALENDAR\\n\");\n        fclose (fptr);\n    }\n\n}", "target": 1, "cwe": [], "message": "bug #641069 - tnef plugin vulnerabilities\n\nResolves directory traversal and buffer overflow vulnerabilities."}
{"func": "void saveVCalendar (TNEFStruct *tnef, const gchar *tmpdir) {\n    gchar ifilename[256];\n    variableLength *filename;\n    gchar *charptr, *charptr2;\n    FILE *fptr;\n    gint index;\n    DWORD *dword_ptr;\n    DWORD dword_val;\n    dtr thedate;\n\n    sprintf(ifilename, \"%s/calendar.ics\", tmpdir);\n    printf(\"%s\\n\", ifilename);\n\n    if ((fptr = fopen(ifilename, \"wb\"))==NULL) {\n            printf(\"Error writing file to disk!\");\n    } else {\n        fprintf(fptr, \"BEGIN:VCALENDAR\\n\");\n        if (tnef->messageClass[0] != 0) {\n            charptr2=tnef->messageClass;\n            charptr=charptr2;\n            while (*charptr != 0) {\n                if (*charptr == '.') {\n                    charptr2 = charptr;\n                }\n                charptr++;\n            }\n            if (strcmp(charptr2, \".MtgCncl\") == 0) {\n                fprintf(fptr, \"METHOD:CANCEL\\n\");\n            } else {\n                fprintf(fptr, \"METHOD:REQUEST\\n\");\n            }\n        } else {\n            fprintf(fptr, \"METHOD:REQUEST\\n\");\n        }\n        fprintf(fptr, \"VERSION:2.0\\n\");\n        fprintf(fptr, \"BEGIN:VEVENT\\n\");\n\n\t/* UID\n\t   After alot of comparisons, I'm reasonably sure this is totally\n\t   wrong.  But it's not really necessary. */\n\n\t/* I think it only exists to connect future modification entries to\n\t   this entry. so as long as it's incorrectly interpreted the same way\n\t   every time, it should be ok :) */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, 0x3))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_BINARY, 0x23))) == MAPI_UNDEFINED) {\n                filename = NULL;\n            }\n        }\n        if (filename!=NULL) {\n            fprintf(fptr, \"UID:\");\n            for (index=0;index<filename->size;index++) {\n                fprintf(fptr,\"%02X\", (guchar)filename->data[index]);\n            }\n            fprintf(fptr,\"\\n\");\n        }\n\n        /* Sequence */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_LONG, 0x8201))) != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            fprintf(fptr, \"SEQUENCE:%i\\n\", (gint) *dword_ptr);\n        }\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, PR_SENDER_SEARCH_KEY)))\n                != MAPI_UNDEFINED) {\n            charptr = filename->data;\n            charptr2 = strstr(charptr, \":\");\n            if (charptr2 == NULL)\n                charptr2 = charptr;\n            else\n                charptr2++;\n            fprintf(fptr, \"ORGANIZER;CN=\\\"%s\\\":MAILTO:%s\\n\",\n                    charptr2, charptr2);\n        }\n\n        /* Required Attendees */\n        if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x823b))) != MAPI_UNDEFINED) {\n\t    /* We have a list of required participants, so\n\t       write them out. */\n            if (filename->size > 1) {\n                charptr = filename->data-1;\n                while (charptr != NULL) {\n                    charptr++;\n                    charptr2 = strstr(charptr, \";\");\n                    if (charptr2 != NULL) {\n                        *charptr2 = 0;\n                    }\n                    while (*charptr == ' ')\n                        charptr++;\n                    fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                    fprintf(fptr, \"ROLE=REQ-PARTICIPANT;RSVP=TRUE;\");\n                    fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                    charptr = charptr2;\n                }\n            }\n            /* Optional attendees */\n            if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_STRING8, 0x823c))) != MAPI_UNDEFINED) {\n                    /* The list of optional participants */\n                if (filename->size > 1) {\n                    charptr = filename->data-1;\n                    while (charptr != NULL) {\n                        charptr++;\n                        charptr2 = strstr(charptr, \";\");\n                        if (charptr2 != NULL) {\n                            *charptr2 = 0;\n                        }\n                        while (*charptr == ' ')\n                            charptr++;\n                        fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                        fprintf(fptr, \"ROLE=OPT-PARTICIPANT;RSVP=TRUE;\");\n                        fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                        charptr = charptr2;\n                    }\n                }\n            }\n        } else if ((filename = MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x8238))) != MAPI_UNDEFINED) {\n            if (filename->size > 1) {\n                charptr = filename->data-1;\n                while (charptr != NULL) {\n                    charptr++;\n                    charptr2 = strstr(charptr, \";\");\n                    if (charptr2 != NULL) {\n                        *charptr2 = 0;\n                    }\n                    while (*charptr == ' ')\n                        charptr++;\n                    fprintf(fptr, \"ATTENDEE;PARTSTAT=NEEDS-ACTION;\");\n                    fprintf(fptr, \"ROLE=REQ-PARTICIPANT;RSVP=TRUE;\");\n                    fprintf(fptr, \"CN=\\\"%s\\\":MAILTO:%s\\n\",\n                                charptr, charptr);\n                    charptr = charptr2;\n                }\n            }\n\n        }\n        /* Summary */\n        filename = NULL;\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, PR_CONVERSATION_TOPIC)))\n                != MAPI_UNDEFINED) {\n            fprintf(fptr, \"SUMMARY:\");\n            cstylefprint (fptr, filename);\n            fprintf(fptr, \"\\n\");\n        }\n\n        /* Description */\n        if ((filename=MAPIFindProperty (&(tnef->MapiProperties),\n                                PROP_TAG (PT_BINARY, PR_RTF_COMPRESSED)))\n                != MAPI_UNDEFINED) {\n            variableLength buf;\n            if ((buf.data = (gchar *) DecompressRTF (filename, &buf.size)) != NULL) {\n                fprintf(fptr, \"DESCRIPTION:\");\n                printRtf (fptr, &buf);\n                free (buf.data);\n            }\n\n        }\n\n        /* Location */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_STRING8, 0x0002))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_STRING8, 0x8208))) == MAPI_UNDEFINED) {\n                filename = NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr,\"LOCATION: %s\\n\", filename->data);\n        }\n        /* Date Start */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x820d))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_SYSTIME, 0x8516))) == MAPI_UNDEFINED) {\n                filename=NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr, \"DTSTART:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Date End */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x820e))) == MAPI_UNDEFINED) {\n            if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                            PROP_TAG (PT_SYSTIME, 0x8517))) == MAPI_UNDEFINED) {\n                filename=NULL;\n            }\n        }\n        if (filename != NULL) {\n            fprintf(fptr, \"DTEND:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Date Stamp */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_SYSTIME, 0x8202))) != MAPI_UNDEFINED) {\n            fprintf(fptr, \"CREATED:\");\n            MAPISysTimetoDTR ((guchar *) filename->data, &thedate);\n            fprintf(fptr,\"%04i%02i%02iT%02i%02i%02iZ\\n\",\n                    thedate.wYear, thedate.wMonth, thedate.wDay,\n                    thedate.wHour, thedate.wMinute, thedate.wSecond);\n        }\n        /* Class */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BOOLEAN, 0x8506))) != MAPI_UNDEFINED) {\n            dword_ptr = (DWORD*)filename->data;\n            dword_val = SwapDWord ((BYTE*)dword_ptr);\n            fprintf(fptr, \"CLASS:\" );\n            if (*dword_ptr == 1) {\n                fprintf(fptr,\"PRIVATE\\n\");\n            } else {\n                fprintf(fptr,\"PUBLIC\\n\");\n            }\n        }\n        /* Recurrence */\n        filename = NULL;\n        if ((filename=MAPIFindUserProp (&(tnef->MapiProperties),\n                        PROP_TAG (PT_BINARY, 0x8216))) != MAPI_UNDEFINED) {\n            printRrule (fptr, filename->data, filename->size, tnef);\n        }\n\n        /* Wrap it up */\n        fprintf(fptr, \"END:VEVENT\\n\");\n        fprintf(fptr, \"END:VCALENDAR\\n\");\n        fclose (fptr);\n    }\n}", "target": 1, "cwe": [], "message": "bug #641069 - tnef plugin vulnerabilities\n\nResolves directory traversal and buffer overflow vulnerabilities."}
{"func": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netlink: fix typo in initialization\n\nCommit 9ef1d4c7c7aca1cd436612b6ca785b726ffb8ed8 (\"[NETLINK]: Missing\ninitializations in dumped data\") introduced a typo in\ninitialization. This patch fixes this.\n\nSigned-off-by: Jiri Pirko <jpirko@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "check_mountpoint(const char *progname, char *mountpoint)\n{\n\tint err;\n\tstruct stat statbuf;\n\n\t/* does mountpoint exist and is it a directory? */\n\terr = stat(mountpoint, &statbuf);\n\tif (err) {\n\t\tfprintf(stderr, \"%s: failed to stat %s: %s\\n\", progname,\n\t\t\t\tmountpoint, strerror(errno));\n\t\treturn EX_USAGE;\n\t}\n\n\tif (!S_ISDIR(statbuf.st_mode)) {\n\t\tfprintf(stderr, \"%s: %s is not a directory!\", progname,\n\t\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_LEGACY_SETUID_CHECK\n\t/* do extra checks on mountpoint for legacy setuid behavior */\n\tif (!getuid() || geteuid())\n\t\treturn 0;\n\n\tif (statbuf.st_uid != getuid()) {\n\t\tfprintf(stderr, \"%s: %s is not owned by user\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {\n\t\tfprintf(stderr, \"%s: invalid permissions on %s\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_LEGACY_SETUID_CHECK */\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-59"], "message": "mount.cifs: take extra care that mountpoint isn't changed during mount\n\nIt's possible to trick mount.cifs into mounting onto the wrong directory\nby replacing the mountpoint with a symlink to a directory. mount.cifs\nattempts to check the validity of the mountpoint, but there's still a\npossible race between those checks and the mount(2) syscall.\n\nTo guard against this, chdir to the mountpoint very early, and only deal\nwith it as \".\" from then on out.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif(resolved_path) {\n\t\t/* Note that if we can not canonicalize the name, we get\n\t\tanother chance to see if it is valid when we chdir to it */\n\t\tif (realpath(mountpoint, resolved_path)) {\n\t\t\tmountpoint = resolved_path; \n\t\t}\n\t}\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\tif (!fakemnt && mount(dev_name, mountpoint, cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}", "target": 1, "cwe": ["CWE-59"], "message": "mount.cifs: take extra care that mountpoint isn't changed during mount\n\nIt's possible to trick mount.cifs into mounting onto the wrong directory\nby replacing the mountpoint with a symlink to a directory. mount.cifs\nattempts to check the validity of the mountpoint, but there's still a\npossible race between those checks and the mount(2) syscall.\n\nTo guard against this, chdir to the mountpoint very early, and only deal\nwith it as \".\" from then on out.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}", "target": 1, "cwe": ["CWE-59"], "message": "mount.cifs: check for invalid characters in device name and mountpoint\n\nIt's apparently possible to corrupt the mtab if you pass embedded\nnewlines to addmntent. Apparently tabs are also a problem with certain\nearlier glibc versions. Backslashes are also a minor issue apparently,\nbut we can't reasonably filter those.\n\nMake sure that neither the devname or mountpoint contain any problematic\ncharacters before allowing the mount to proceed.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "int main(int argc, char ** argv)\n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\trc = check_mtab(thisprogram, dev_name, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}", "target": 1, "cwe": ["CWE-59"], "message": "mount.cifs: don't allow it to be run as setuid root program\n\nmount.cifs has been the subject of several \"security\" fire drills due to\ndistributions installing it as a setuid root program. This program has\nnot been properly audited for security and the Samba team highly\nrecommends that it not be installed as a setuid root program at this\ntime.\n\nTo make that abundantly clear, this patch forcibly disables the ability\nfor mount.cifs to run as a setuid root program. People are welcome to\ntrivially patch this out, but they do so at their own peril.\n\nA security audit and redesign of this program is in progress and we hope\nthat we'll be able to remove this in the near future.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "ReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Harden the BMP plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-1570. Fixes bug #600484."}
{"func": "read_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"}
{"func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"}
{"func": "read_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"}
{"func": "add_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)"}
{"func": "read_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GUINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GUINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GUINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GUINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}", "target": 1, "cwe": ["CWE-190"], "message": "Fix the PSD structs to use signed ints for bounding box coordinates.\n(cherry picked from commit 0e440cb6d4d6ee029667363d244aff61b154c33c)"}
{"func": "try_dlopen (lt_dlhandle *phandle, const char *filename, const char *ext,\n\t    lt_dladvise advise)\n{\n  const char *\tsaved_error\t= 0;\n  char *\tarchive_name\t= 0;\n  char *\tcanonical\t= 0;\n  char *\tbase_name\t= 0;\n  char *\tdir\t\t= 0;\n  char *\tname\t\t= 0;\n  char *        attempt\t\t= 0;\n  int\t\terrors\t\t= 0;\n  lt_dlhandle\tnewhandle;\n\n  assert (phandle);\n  assert (*phandle == 0);\n\n#ifdef LT_DEBUG_LOADERS\n  fprintf (stderr, \"try_dlopen (%s, %s)\\n\",\n\t   filename ? filename : \"(null)\",\n\t   ext ? ext : \"(null)\");\n#endif\n\n  LT__GETERROR (saved_error);\n\n  /* dlopen self? */\n  if (!filename)\n    {\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\treturn 1;\n\n      newhandle\t= *phandle;\n\n      /* lt_dlclose()ing yourself is very bad!  Disallow it.  */\n      newhandle->info.is_resident = 1;\n\n      if (tryall_dlopen (&newhandle, 0, advise, 0) != 0)\n\t{\n\t  FREE (*phandle);\n\t  return 1;\n\t}\n\n      goto register_handle;\n    }\n\n  assert (filename && *filename);\n\n  if (ext)\n    {\n      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);\n      if (!attempt)\n\treturn 1;\n\n      sprintf(attempt, \"%s%s\", filename, ext);\n    }\n  else\n    {\n      attempt = lt__strdup (filename);\n      if (!attempt)\n\treturn 1;\n    }\n\n  /* Doing this immediately allows internal functions to safely\n     assume only canonicalized paths are passed.  */\n  if (canonicalize_path (attempt, &canonical) != 0)\n    {\n      ++errors;\n      goto cleanup;\n    }\n\n  /* If the canonical module name is a path (relative or absolute)\n     then split it into a directory part and a name part.  */\n  base_name = strrchr (canonical, '/');\n  if (base_name)\n    {\n      size_t dirlen = (1+ base_name) - canonical;\n\n      dir = MALLOC (char, 1+ dirlen);\n      if (!dir)\n\t{\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      strncpy (dir, canonical, dirlen);\n      dir[dirlen] = LT_EOS_CHAR;\n\n      ++base_name;\n    }\n  else\n    MEMREASSIGN (base_name, canonical);\n\n  assert (base_name && *base_name);\n\n  ext = strrchr (base_name, '.');\n  if (!ext)\n    {\n      ext = base_name + LT_STRLEN (base_name);\n    }\n\n  /* extract the module name from the file name */\n  name = MALLOC (char, ext - base_name + 1);\n  if (!name)\n    {\n      ++errors;\n      goto cleanup;\n    }\n\n  /* canonicalize the module name */\n  {\n    int i;\n    for (i = 0; i < ext - base_name; ++i)\n      {\n\tif (isalnum ((unsigned char)(base_name[i])))\n\t  {\n\t    name[i] = base_name[i];\n\t  }\n\telse\n\t  {\n\t    name[i] = '_';\n\t  }\n      }\n    name[ext - base_name] = LT_EOS_CHAR;\n  }\n\n  /* Before trawling through the filesystem in search of a module,\n     check whether we are opening a preloaded module.  */\n  if (!dir)\n    {\n      const lt_dlvtable *vtable\t= lt_dlloader_find (\"lt_preopen\");\n\n      if (vtable)\n\t{\n\t  /* name + \".\" + libext + NULL */\n\t  archive_name = MALLOC (char, LT_STRLEN (name) + strlen (libext) + 2);\n\t  *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n\n\t  if ((*phandle == NULL) || (archive_name == NULL))\n\t    {\n\t      ++errors;\n\t      goto cleanup;\n\t    }\n\t  newhandle = *phandle;\n\n\t  /* Preloaded modules are always named according to their old\n\t     archive name.  */\n\t  sprintf (archive_name, \"%s.%s\", name, libext);\n\n\t  if (tryall_dlopen (&newhandle, archive_name, advise, vtable) == 0)\n\t    {\n\t      goto register_handle;\n\t    }\n\n\t  /* If we're still here, there was no matching preloaded module,\n\t     so put things back as we found them, and continue searching.  */\n\t  FREE (*phandle);\n\t  newhandle = NULL;\n\t}\n    }\n\n  /* If we are allowing only preloaded modules, and we didn't find\n     anything yet, give up on the search here.  */\n  if (advise && advise->try_preload_only)\n    {\n      goto cleanup;\n    }\n\n  /* Check whether we are opening a libtool module (.la extension).  */\n  if (ext && streq (ext, archive_ext))\n    {\n      /* this seems to be a libtool module */\n      FILE *\tfile\t = 0;\n      char *\tdlname\t = 0;\n      char *\told_name = 0;\n      char *\tlibdir\t = 0;\n      char *\tdeplibs\t = 0;\n\n      /* if we can't find the installed flag, it is probably an\n\t installed libtool archive, produced with an old version\n\t of libtool */\n      int\tinstalled = 1;\n\n      /* Now try to open the .la file.  If there is no directory name\n\t component, try to find it first in user_search_path and then other\n\t prescribed paths.  Otherwise (or in any case if the module was not\n\t yet found) try opening just the module name as passed.  */\n      if (!dir)\n\t{\n\t  const char *search_path = user_search_path;\n\n\t  if (search_path)\n\t    file = find_file (user_search_path, base_name, &dir);\n\n\t  if (!file)\n\t    {\n\t      search_path = getenv (LTDL_SEARCHPATH_VAR);\n\t      if (search_path)\n\t\tfile = find_file (search_path, base_name, &dir);\n\t    }\n\n#if defined(LT_MODULE_PATH_VAR)\n\t  if (!file)\n\t    {\n\t      search_path = getenv (LT_MODULE_PATH_VAR);\n\t      if (search_path)\n\t\tfile = find_file (search_path, base_name, &dir);\n\t    }\n#endif\n#if defined(LT_DLSEARCH_PATH)\n\t  if (!file && *sys_dlsearch_path)\n\t    {\n\t      file = find_file (sys_dlsearch_path, base_name, &dir);\n\t    }\n#endif\n\t}\n      if (!file)\n\t{\n\t  file = fopen (attempt, LT_READTEXT_MODE);\n\t}\n\n      /* If we didn't find the file by now, it really isn't there.  Set\n\t the status flag, and bail out.  */\n      if (!file)\n\t{\n\t  LT__SETERROR (FILE_NOT_FOUND);\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      /* read the .la file */\n      if (parse_dotla_file(file, &dlname, &libdir, &deplibs,\n\t    &old_name, &installed) != 0)\n\t++errors;\n\n      fclose (file);\n\n      /* allocate the handle */\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\t++errors;\n\n      if (errors)\n\t{\n\t  FREE (dlname);\n\t  FREE (old_name);\n\t  FREE (libdir);\n\t  FREE (deplibs);\n\t  FREE (*phandle);\n\t  goto cleanup;\n\t}\n\n      assert (*phandle);\n\n      if (load_deplibs (*phandle, deplibs) == 0)\n\t{\n\t  newhandle = *phandle;\n\t  /* find_module may replace newhandle */\n\t  if (find_module (&newhandle, dir, libdir, dlname, old_name,\n\t\t\t   installed, advise))\n\t    {\n\t      unload_deplibs (*phandle);\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  ++errors;\n\t}\n\n      FREE (dlname);\n      FREE (old_name);\n      FREE (libdir);\n      FREE (deplibs);\n\n      if (errors)\n\t{\n\t  FREE (*phandle);\n\t  goto cleanup;\n\t}\n\n      if (*phandle != newhandle)\n\t{\n\t  unload_deplibs (*phandle);\n\t}\n    }\n  else\n    {\n      /* not a libtool module */\n      *phandle = (lt_dlhandle) lt__zalloc (sizeof (struct lt__handle));\n      if (*phandle == 0)\n\t{\n\t  ++errors;\n\t  goto cleanup;\n\t}\n\n      newhandle = *phandle;\n\n      /* If the module has no directory name component, try to find it\n\t first in user_search_path and then other prescribed paths.\n\t Otherwise (or in any case if the module was not yet found) try\n\t opening just the module name as passed.  */\n      if ((dir || (!find_handle (user_search_path, base_name,\n\t\t\t\t &newhandle, advise)\n\t\t   && !find_handle (getenv (LTDL_SEARCHPATH_VAR), base_name,\n\t\t\t\t    &newhandle, advise)\n#if defined(LT_MODULE_PATH_VAR)\n\t\t   && !find_handle (getenv (LT_MODULE_PATH_VAR), base_name,\n\t\t\t\t    &newhandle, advise)\n#endif\n#if defined(LT_DLSEARCH_PATH)\n\t\t   && !find_handle (sys_dlsearch_path, base_name,\n\t\t\t\t    &newhandle, advise)\n#endif\n\t\t   )))\n\t{\n\t  if (tryall_dlopen (&newhandle, attempt, advise, 0) != 0)\n\t    {\n\t      newhandle = NULL;\n\t    }\n\t}\n\n      if (!newhandle)\n\t{\n\t  FREE (*phandle);\n\t  ++errors;\n\t  goto cleanup;\n\t}\n    }\n\n register_handle:\n  MEMREASSIGN (*phandle, newhandle);\n\n  if ((*phandle)->info.ref_count == 0)\n    {\n      (*phandle)->info.ref_count\t= 1;\n      MEMREASSIGN ((*phandle)->info.name, name);\n\n      (*phandle)->next\t= handles;\n      handles\t\t= *phandle;\n    }\n\n  LT__SETERRORSTR (saved_error);\n\n cleanup:\n  FREE (dir);\n  FREE (attempt);\n  FREE (name);\n  if (!canonical)\t\t/* was MEMREASSIGNed */\n    FREE (base_name);\n  FREE (canonical);\n  FREE (archive_name);\n\n  return errors;\n}", "target": 1, "cwe": [], "message": "Don't load module.la from current directory by default.\n\n* libltdl/ltdl.c (try_dlopen): Do not attempt to load an\nunqualified module.la file from the current directory (by\ndefault) since doing so is insecure and is not compliant with\nthe documentation.\n* tests/testsuite.at: Qualify access to module.la file in\ncurrent directory so that test passes."}
{"func": "find_module (lt_dlhandle *handle, const char *dir, const char *libdir,\n\t     const char *dlname,  const char *old_name, int installed,\n\t     lt_dladvise advise)\n{\n  /* Try to open the old library first; if it was dlpreopened,\n     we want the preopened version of it, even if a dlopenable\n     module is available.  */\n  if (old_name && tryall_dlopen (handle, old_name, advise, 0) == 0)\n    {\n      return 0;\n    }\n\n  /* Try to open the dynamic library.  */\n  if (dlname)\n    {\n      /* try to open the installed module */\n      if (installed && libdir)\n\t{\n\t  if (tryall_dlopen_module (handle, (const char *) 0,\n\t\t\t\t    libdir, dlname, advise) == 0)\n\t    return 0;\n\t}\n\n      /* try to open the not-installed module */\n      if (!installed)\n\t{\n\t  if (tryall_dlopen_module (handle, dir, objdir,\n\t\t\t\t    dlname, advise) == 0)\n\t    return 0;\n\t}\n\n      /* maybe it was moved to another directory */\n      {\n\t  if (dir && (tryall_dlopen_module (handle, (const char *) 0,\n\t\t\t\t\t    dir, dlname, advise) == 0))\n\t    return 0;\n      }\n    }\n\n  return 1;\n}", "target": 1, "cwe": [], "message": "Only use preopen loader to load preopened archives\n\n* libltdl/ltdl.c: Limit checking of .a to preopen loader.\n* tests/lt_dlopen_a.at: Add test.\n* Makefile.am: Add test."}
{"func": "x86_decode_insn(struct x86_emulate_ctxt *ctxt, struct x86_emulate_ops *ops)\n{\n\tstruct decode_cache *c = &ctxt->decode;\n\tint rc = 0;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, group;\n\n\t/* Shadow copy of register state. Committed on successful emulation. */\n\n\tmemset(c, 0, sizeof(struct decode_cache));\n\tc->eip = kvm_rip_read(ctxt->vcpu);\n\tctxt->cs_base = seg_base(ctxt, VCPU_SREG_CS);\n\tmemcpy(c->regs, ctxt->vcpu->arch.regs, sizeof c->regs);\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tc->op_bytes = def_op_bytes;\n\tc->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (c->b = insn_fetch(u8, 1, c->eip)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tc->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tc->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tc->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\tset_seg_override(c, (c->b >> 3) & 3);\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\tset_seg_override(c, c->b & 7);\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tc->rex_prefix = c->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tc->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\t\tc->rep_prefix = REPNE_PREFIX;\n\t\t\tbreak;\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tc->rep_prefix = REPE_PREFIX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tc->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (c->rex_prefix)\n\t\tif (c->rex_prefix & 8)\n\t\t\tc->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\tc->d = opcode_table[c->b];\n\tif (c->d == 0) {\n\t\t/* Two-byte opcode? */\n\t\tif (c->b == 0x0f) {\n\t\t\tc->twobyte = 1;\n\t\t\tc->b = insn_fetch(u8, 1, c->eip);\n\t\t\tc->d = twobyte_table[c->b];\n\t\t}\n\t}\n\n\tif (mode == X86EMUL_MODE_PROT64 && (c->d & No64)) {\n\t\tkvm_report_emulation_failure(ctxt->vcpu, \"invalid x86/64 instruction\");;\n\t\treturn -1;\n\t}\n\n\tif (c->d & Group) {\n\t\tgroup = c->d & GroupMask;\n\t\tc->modrm = insn_fetch(u8, 1, c->eip);\n\t\t--c->eip;\n\n\t\tgroup = (group << 3) + ((c->modrm >> 3) & 7);\n\t\tif ((c->d & GroupDual) && (c->modrm >> 6) == 3)\n\t\t\tc->d = group2_table[group];\n\t\telse\n\t\t\tc->d = group_table[group];\n\t}\n\n\t/* Unrecognised? */\n\tif (c->d == 0) {\n\t\tDPRINTF(\"Cannot emulate %02x\\n\", c->b);\n\t\treturn -1;\n\t}\n\n\tif (mode == X86EMUL_MODE_PROT64 && (c->d & Stack))\n\t\tc->op_bytes = 8;\n\n\t/* ModRM and SIB bytes. */\n\tif (c->d & ModRM)\n\t\trc = decode_modrm(ctxt, ops);\n\telse if (c->d & MemAbs)\n\t\trc = decode_abs(ctxt, ops);\n\tif (rc)\n\t\tgoto done;\n\n\tif (!c->has_seg_override)\n\t\tset_seg_override(c, VCPU_SREG_DS);\n\n\tif (!(!c->twobyte && c->b == 0x8d))\n\t\tc->modrm_ea += seg_override_base(ctxt, c);\n\n\tif (c->ad_bytes != 8)\n\t\tc->modrm_ea = (u32)c->modrm_ea;\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\tswitch (c->d & SrcMask) {\n\tcase SrcNone:\n\t\tbreak;\n\tcase SrcReg:\n\t\tdecode_register_operand(&c->src, c, 0);\n\t\tbreak;\n\tcase SrcMem16:\n\t\tc->src.bytes = 2;\n\t\tgoto srcmem_common;\n\tcase SrcMem32:\n\t\tc->src.bytes = 4;\n\t\tgoto srcmem_common;\n\tcase SrcMem:\n\t\tc->src.bytes = (c->d & ByteOp) ? 1 :\n\t\t\t\t\t\t\t   c->op_bytes;\n\t\t/* Don't fetch the address for invlpg: it could be unmapped. */\n\t\tif (c->twobyte && c->b == 0x01 && c->modrm_reg == 7)\n\t\t\tbreak;\n\tsrcmem_common:\n\t\t/*\n\t\t * For instructions with a ModR/M byte, switch to register\n\t\t * access if Mod = 3.\n\t\t */\n\t\tif ((c->d & ModRM) && c->modrm_mod == 3) {\n\t\t\tc->src.type = OP_REG;\n\t\t\tc->src.val = c->modrm_val;\n\t\t\tc->src.ptr = c->modrm_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tc->src.type = OP_MEM;\n\t\tbreak;\n\tcase SrcImm:\n\tcase SrcImmU:\n\t\tc->src.type = OP_IMM;\n\t\tc->src.ptr = (unsigned long *)c->eip;\n\t\tc->src.bytes = (c->d & ByteOp) ? 1 : c->op_bytes;\n\t\tif (c->src.bytes == 8)\n\t\t\tc->src.bytes = 4;\n\t\t/* NB. Immediates are sign-extended as necessary. */\n\t\tswitch (c->src.bytes) {\n\t\tcase 1:\n\t\t\tc->src.val = insn_fetch(s8, 1, c->eip);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc->src.val = insn_fetch(s16, 2, c->eip);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tc->src.val = insn_fetch(s32, 4, c->eip);\n\t\t\tbreak;\n\t\t}\n\t\tif ((c->d & SrcMask) == SrcImmU) {\n\t\t\tswitch (c->src.bytes) {\n\t\t\tcase 1:\n\t\t\t\tc->src.val &= 0xff;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->src.val &= 0xffff;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->src.val &= 0xffffffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SrcImmByte:\n\tcase SrcImmUByte:\n\t\tc->src.type = OP_IMM;\n\t\tc->src.ptr = (unsigned long *)c->eip;\n\t\tc->src.bytes = 1;\n\t\tif ((c->d & SrcMask) == SrcImmByte)\n\t\t\tc->src.val = insn_fetch(s8, 1, c->eip);\n\t\telse\n\t\t\tc->src.val = insn_fetch(u8, 1, c->eip);\n\t\tbreak;\n\tcase SrcOne:\n\t\tc->src.bytes = 1;\n\t\tc->src.val = 1;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\tswitch (c->d & Src2Mask) {\n\tcase Src2None:\n\t\tbreak;\n\tcase Src2CL:\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = c->regs[VCPU_REGS_RCX] & 0x8;\n\t\tbreak;\n\tcase Src2ImmByte:\n\t\tc->src2.type = OP_IMM;\n\t\tc->src2.ptr = (unsigned long *)c->eip;\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = insn_fetch(u8, 1, c->eip);\n\t\tbreak;\n\tcase Src2Imm16:\n\t\tc->src2.type = OP_IMM;\n\t\tc->src2.ptr = (unsigned long *)c->eip;\n\t\tc->src2.bytes = 2;\n\t\tc->src2.val = insn_fetch(u16, 2, c->eip);\n\t\tbreak;\n\tcase Src2One:\n\t\tc->src2.bytes = 1;\n\t\tc->src2.val = 1;\n\t\tbreak;\n\t}\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\tswitch (c->d & DstMask) {\n\tcase ImplicitOps:\n\t\t/* Special instructions do their own operand decoding. */\n\t\treturn 0;\n\tcase DstReg:\n\t\tdecode_register_operand(&c->dst, c,\n\t\t\t c->twobyte && (c->b == 0xb6 || c->b == 0xb7));\n\t\tbreak;\n\tcase DstMem:\n\t\tif ((c->d & ModRM) && c->modrm_mod == 3) {\n\t\t\tc->dst.bytes = (c->d & ByteOp) ? 1 : c->op_bytes;\n\t\t\tc->dst.type = OP_REG;\n\t\t\tc->dst.val = c->dst.orig_val = c->modrm_val;\n\t\t\tc->dst.ptr = c->modrm_ptr;\n\t\t\tbreak;\n\t\t}\n\t\tc->dst.type = OP_MEM;\n\t\tbreak;\n\tcase DstAcc:\n\t\tc->dst.type = OP_REG;\n\t\tc->dst.bytes = c->op_bytes;\n\t\tc->dst.ptr = &c->regs[VCPU_REGS_RAX];\n\t\tswitch (c->op_bytes) {\n\t\t\tcase 1:\n\t\t\t\tc->dst.val = *(u8 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->dst.val = *(u16 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->dst.val = *(u32 *)c->dst.ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tc->dst.orig_val = c->dst.val;\n\t\tbreak;\n\t}\n\n\tif (c->rip_relative)\n\t\tc->modrm_ea += c->eip;\n\ndone:\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? -1 : 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "KVM: x86 emulator: limit instructions to 15 bytes\n\nWhile we are never normally passed an instruction that exceeds 15 bytes,\nsmp games can cause us to attempt to interpret one, which will cause\nlarge latencies in non-preempt hosts.\n\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "KVM: x86 emulator: limit instructions to 15 bytes\n\nWhile we are never normally passed an instruction that exceeds 15 bytes,\nsmp games can cause us to attempt to interpret one, which will cause\nlarge latencies in non-preempt hosts.\n\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "nma_gconf_settings_new (void)\n{\n\treturn (NMAGConfSettings *) g_object_new (NMA_TYPE_GCONF_SETTINGS, NULL);\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "nm_connection_list_new (GType def_type)\n{\n\tNMConnectionList *list;\n\tDBusGConnection *dbus_connection;\n\tGError *error = NULL;\n\n\tlist = g_object_new (NM_TYPE_CONNECTION_LIST, NULL);\n\tif (!list)\n\t\treturn NULL;\n\n\t/* load GUI */\n\tlist->gui = glade_xml_new (GLADEDIR \"/nm-connection-editor.glade\", \"NMConnectionList\", NULL);\n\tif (!list->gui) {\n\t\tg_warning (\"Could not load Glade file for connection list\");\n\t\tgoto error;\n\t}\n\n\tgtk_window_set_default_icon_name (\"preferences-system-network\");\n\n\tlist->icon_theme = gtk_icon_theme_get_for_screen (gdk_screen_get_default ());\n\n\t/* Load icons */\n\tICON_LOAD(list->wired_icon, \"nm-device-wired\");\n\tICON_LOAD(list->wireless_icon, \"nm-device-wireless\");\n\tICON_LOAD(list->wwan_icon, \"nm-device-wwan\");\n\tICON_LOAD(list->vpn_icon, \"nm-vpn-standalone-lock\");\n\tICON_LOAD(list->unknown_icon, \"nm-no-connection\");\n\n\tlist->client = gconf_client_get_default ();\n\tif (!list->client)\n\t\tgoto error;\n\n\tdbus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n\tif (error) {\n\t\tg_warning (\"Could not connect to the system bus: %s\", error->message);\n\t\tg_error_free (error);\n\t\tgoto error;\n\t}\n\n\tlist->system_settings = nm_dbus_settings_system_new (dbus_connection);\n\tdbus_g_connection_unref (dbus_connection);\n\tg_signal_connect (list->system_settings, \"new-connection\",\n\t\t\t\t   G_CALLBACK (connection_added),\n\t\t\t\t   list);\n\n\tlist->gconf_settings = nma_gconf_settings_new ();\n\tg_signal_connect (list->gconf_settings, \"new-connection\",\n\t\t\t\t   G_CALLBACK (connection_added),\n\t\t\t\t   list);\n\n\tadd_connection_tabs (list, def_type);\n\n\tlist->editors = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_object_unref);\n\n\tlist->dialog = glade_xml_get_widget (list->gui, \"NMConnectionList\");\n\tif (!list->dialog)\n\t\tgoto error;\n\tg_signal_connect (G_OBJECT (list->dialog), \"response\", G_CALLBACK (dialog_response_cb), list);\n\n\tif (!vpn_get_plugins (&error)) {\n\t\tg_warning (\"%s: failed to load VPN plugins: %s\", __func__, error->message);\n\t\tg_error_free (error);\n\t}\n\n\treturn list;\n\nerror:\n\tg_object_unref (list);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "add_connection_real (NMAGConfSettings *self, NMAGConfConnection *connection)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);\n\n\tif (connection) {\n\t\tpriv->connections = g_slist_prepend (priv->connections, connection);\n\t\tg_signal_connect (connection, \"new-secrets-requested\",\n\t\t\t\t\t   G_CALLBACK (connection_new_secrets_requested_cb),\n\t\t\t\t\t   self);\n\n\t\tg_signal_connect (connection, \"removed\", G_CALLBACK (connection_removed), self);\n\t\tnm_settings_signal_new_connection (NM_SETTINGS (self),\n\t\t\t\t\t\t\t\t\tNM_EXPORTED_CONNECTION (connection));\n\t}\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "constructor (GType type,\n             guint n_props,\n             GObjectConstructParam *construct_props)\n{\n\tNMApplet *applet;\n\tAppletDBusManager *dbus_mgr;\n\tGList *server_caps, *iter;\n\n\tapplet = NM_APPLET (G_OBJECT_CLASS (nma_parent_class)->constructor (type, n_props, construct_props));\n\n\tg_set_application_name (_(\"NetworkManager Applet\"));\n\tgtk_window_set_default_icon_name (GTK_STOCK_NETWORK);\n\n\tapplet->glade_file = g_build_filename (GLADEDIR, \"applet.glade\", NULL);\n\tif (!applet->glade_file || !g_file_test (applet->glade_file, G_FILE_TEST_IS_REGULAR)) {\n\t\tGtkWidget *dialog;\n\t\tdialog = applet_warning_dialog_show (_(\"The NetworkManager Applet could not find some required resources (the glade file was not found).\"));\n\t\tgtk_dialog_run (GTK_DIALOG (dialog));\n\t\tgoto error;\n\t}\n\n\tapplet->info_dialog_xml = glade_xml_new (applet->glade_file, \"info_dialog\", NULL);\n\tif (!applet->info_dialog_xml)\n\t\tgoto error;\n\n\tapplet->gconf_client = gconf_client_get_default ();\n\tif (!applet->gconf_client)\n\t\tgoto error;\n\n\t/* Load pixmaps and create applet widgets */\n\tif (!setup_widgets (applet))\n\t\tgoto error;\n\tnma_icons_init (applet);\n\n\tif (!notify_is_initted ())\n\t\tnotify_init (\"NetworkManager\");\n\n\tserver_caps = notify_get_server_caps();\n\tapplet->notify_with_actions = FALSE;\n\tfor (iter = server_caps; iter; iter = g_list_next (iter)) {\n\t\tif (!strcmp ((const char *) iter->data, NOTIFY_CAPS_ACTIONS_KEY))\n\t\t\tapplet->notify_with_actions = TRUE;\n\t}\n\n\tg_list_foreach (server_caps, (GFunc) g_free, NULL);\n\tg_list_free (server_caps);\n\n\tdbus_mgr = applet_dbus_manager_get ();\n\tif (dbus_mgr == NULL) {\n\t\tnm_warning (\"Couldn't initialize the D-Bus manager.\");\n\t\tg_object_unref (applet);\n\t\treturn NULL;\n\t}\n\tg_signal_connect (G_OBJECT (dbus_mgr), \"exit-now\", G_CALLBACK (exit_cb), applet);\n\n\tapplet->dbus_settings = (NMDBusSettings *) nm_dbus_settings_system_new (applet_dbus_manager_get_connection (dbus_mgr));\n\n\tapplet->gconf_settings = nma_gconf_settings_new ();\n\tg_signal_connect (applet->gconf_settings, \"new-secrets-requested\",\n\t                  G_CALLBACK (applet_settings_new_secrets_requested_cb),\n\t                  applet);\n\n\tdbus_g_connection_register_g_object (applet_dbus_manager_get_connection (dbus_mgr),\n\t                                     NM_DBUS_PATH_SETTINGS,\n\t                                     G_OBJECT (applet->gconf_settings));\n\n\t/* Start our DBus service */\n\tif (!applet_dbus_manager_start_service (dbus_mgr)) {\n\t\tg_object_unref (applet);\n\t\treturn NULL;\n\t}\n\n\t/* Initialize device classes */\n\tapplet->wired_class = applet_device_wired_get_class (applet);\n\tg_assert (applet->wired_class);\n\n\tapplet->wifi_class = applet_device_wifi_get_class (applet);\n\tg_assert (applet->wifi_class);\n\n\tapplet->gsm_class = applet_device_gsm_get_class (applet);\n\tg_assert (applet->gsm_class);\n\n\tapplet->cdma_class = applet_device_cdma_get_class (applet);\n\tg_assert (applet->cdma_class);\n\n\tfoo_client_setup (applet);\n\n\t/* timeout to update connection timestamps every 5 minutes */\n\tapplet->update_timestamps_id = g_timeout_add_seconds (300,\n\t\t\t(GSourceFunc) periodic_update_active_connection_timestamps, applet);\n\n\tnm_gconf_set_pre_keyring_callback (applet_pre_keyring_callback, applet);\n\n\treturn G_OBJECT (applet);\n\nerror:\n\tg_object_unref (applet);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "connection_changes_done (gpointer data)\n{\n\tConnectionChangedInfo *info = (ConnectionChangedInfo *) data;\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);\n\tNMAGConfConnection *connection;\n\n\tconnection = nma_gconf_settings_get_by_path (info->settings, info->path);\n\tif (!connection) {\n\t\t/* New connection */\n\t\tconnection = nma_gconf_connection_new (priv->client, info->path);\n\t\tadd_connection_real (info->settings, connection);\n\t} else {\n\t\tif (gconf_client_dir_exists (priv->client, info->path, NULL)) {\n\t\t\t/* Updated connection */\n\t\t\tif (!nma_gconf_connection_changed (connection))\n\t\t\t\tpriv->connections = g_slist_remove (priv->connections, connection);\n\t\t}\n\t}\n\n\tg_hash_table_remove (priv->pending_changes, info->path);\n\n\treturn FALSE;\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "constructor (GType type,\n\t\t   guint n_construct_params,\n\t\t   GObjectConstructParam *construct_params)\n{\n\tGObject *object;\n\tNMAGConfConnectionPrivate *priv;\n\tNMConnection *connection;\n\tDBusGConnection *bus;\n\tGError *error = NULL;\n\n\tobject = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);\n\n\tif (!object)\n\t\treturn NULL;\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);\n\n\tif (!priv->client) {\n\t\tnm_warning (\"GConfClient not provided.\");\n\t\tgoto err;\n\t}\n\n\tif (!priv->dir) {\n\t\tnm_warning (\"GConf directory not provided.\");\n\t\tgoto err;\n\t}\n\n\tconnection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));\n\n\tutils_fill_connection_certs (connection);\n\tif (!nm_connection_verify (connection, &error)) {\n\t\tutils_clear_filled_connection_certs (connection);\n\t\tg_warning (\"Invalid connection: '%s' / '%s' invalid: %d\",\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\tutils_clear_filled_connection_certs (connection);\n\n\tfill_vpn_user_name (connection);\n\n\tbus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n\tif (!bus) {\n\t\tnm_warning (\"Could not get the system bus: %s\", error->message);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\n\tnm_exported_connection_register_object (NM_EXPORTED_CONNECTION (object),\n\t                                        NM_CONNECTION_SCOPE_USER,\n\t                                        bus);\n\tdbus_g_connection_unref (bus);\n\n\treturn object;\n\n err:\n\tg_object_unref (object);\n\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "read_connections (NMAGConfSettings *settings)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (settings);\n\tGSList *dir_list;\n\tGSList *iter;\n\n\tdir_list = nm_gconf_get_all_connections (priv->client);\n\tif (!dir_list)\n\t\treturn;\n\n\tfor (iter = dir_list; iter; iter = iter->next) {\n\t\tchar *dir = (char *) iter->data;\n\n\t\tadd_connection_real (settings, nma_gconf_connection_new (priv->client, dir));\n\t\tg_free (dir);\n\t}\n\n\tg_slist_free (dir_list);\n\tpriv->connections = g_slist_reverse (priv->connections);\n}", "target": 1, "cwe": ["CWE-200"], "message": "editor: prevent any registration of objects on the system bus\n\nD-Bus access-control is name-based; so requests for a specific name\nare allowed/denied based on the rules in /etc/dbus-1/system.d.  But\napparently apps still get a non-named service on the bus, and if we\nregister *any* object even though we don't have a named service,\ndbus and dbus-glib will happily proxy signals.  Since the connection\neditor shouldn't ever expose anything having to do with connections\non any bus, make sure that's the case."}
{"func": "dispose (GObject *object)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (object);\n\n\tif (priv->disposed)\n\t\treturn;\n\n\tpriv->disposed = TRUE;\n\n\tg_hash_table_destroy (priv->pending_changes);\n\n\tif (priv->read_connections_id) {\n\t\tg_source_remove (priv->read_connections_id);\n\t\tpriv->read_connections_id = 0;\n\t}\n\n\tgconf_client_notify_remove (priv->client, priv->conf_notify_id);\n\tgconf_client_remove_dir (priv->client, GCONF_PATH_CONNECTIONS, NULL);\n\n\tg_slist_foreach (priv->connections, (GFunc) g_object_unref, NULL);\n\tg_slist_free (priv->connections);\n\n\tg_object_unref (priv->client);\n\n\tG_OBJECT_CLASS (nma_gconf_settings_parent_class)->dispose (object);\n}", "target": 1, "cwe": ["CWE-200"], "message": "applet: fix dbus connection refcounting after 8627880e07c8345f69ed639325280c7f62a8f894"}
{"func": "add_connection_real (NMAGConfSettings *self, NMAGConfConnection *connection)\n{\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);\n\n\tg_return_if_fail (connection != NULL);\n\n\tpriv->connections = g_slist_prepend (priv->connections, connection);\n\tg_signal_connect (connection, \"new-secrets-requested\",\n\t\t\t\t   G_CALLBACK (connection_new_secrets_requested_cb),\n\t\t\t\t   self);\n\n\tg_signal_connect (connection, \"removed\", G_CALLBACK (connection_removed), self);\n\n\t/* Export the connection over dbus if requested */\n\tif (priv->bus) {\n\t\tnm_exported_connection_register_object (NM_EXPORTED_CONNECTION (connection),\n\t\t                                        NM_CONNECTION_SCOPE_USER,\n\t\t                                        priv->bus);\n\t\tdbus_g_connection_unref (priv->bus);\n\t}\n\n\tnm_settings_signal_new_connection (NM_SETTINGS (self), NM_EXPORTED_CONNECTION (connection));\n}", "target": 1, "cwe": ["CWE-200"], "message": "applet: fix dbus connection refcounting after 8627880e07c8345f69ed639325280c7f62a8f894"}
{"func": "nma_gconf_connection_new (GConfClient *client, const char *conf_dir)\n{\n\tNMConnection *connection;\n\tNMAGConfConnection *gconf_connection;\n\n\tg_return_val_if_fail (GCONF_IS_CLIENT (client), NULL);\n\tg_return_val_if_fail (conf_dir != NULL, NULL);\n\n\t/* retrieve GConf data */\n\tconnection = nm_gconf_read_connection (client, conf_dir);\n\tif (connection) {\n\t\tgconf_connection = nma_gconf_connection_new_from_connection (client, conf_dir, connection);\n\t\tg_object_unref (connection);\n\t} else {\n\t\tnm_warning (\"No connection read from GConf at %s.\", conf_dir);\n\t\tgconf_connection = NULL;\n\t}\n\t\n\treturn gconf_connection;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "nma_gconf_connection_changed (NMAGConfConnection *self)\n{\n\tNMAGConfConnectionPrivate *priv;\n\tGHashTable *settings;\n\tNMConnection *wrapped_connection;\n\tNMConnection *gconf_connection;\n\tGHashTable *new_settings;\n\tGError *error = NULL;\n\n\tg_return_val_if_fail (NMA_IS_GCONF_CONNECTION (self), FALSE);\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (self);\n\twrapped_connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (self));\n\n\tgconf_connection = nm_gconf_read_connection (priv->client, priv->dir);\n\tif (!gconf_connection) {\n\t\tg_warning (\"No connection read from GConf at %s.\", priv->dir);\n\t\tgoto invalid;\n\t}\n\n\tutils_fill_connection_certs (gconf_connection);\n\tif (!nm_connection_verify (gconf_connection, &error)) {\n\t\tutils_clear_filled_connection_certs (gconf_connection);\n\t\tg_warning (\"%s: Invalid connection %s: '%s' / '%s' invalid: %d\",\n\t\t           __func__, priv->dir,\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tgoto invalid;\n\t}\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\t/* Ignore the GConf update if nothing changed */\n\tif (   nm_connection_compare (wrapped_connection, gconf_connection, NM_SETTING_COMPARE_FLAG_EXACT)\n\t    && nm_gconf_compare_private_connection_values (wrapped_connection, gconf_connection))\n\t\treturn TRUE;\n\n\t/* Update private values to catch any certificate path changes */\n\tnm_gconf_copy_private_connection_values (wrapped_connection, gconf_connection);\n\n\tutils_fill_connection_certs (gconf_connection);\n\tnew_settings = nm_connection_to_hash (gconf_connection);\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\tif (!nm_connection_replace_settings (wrapped_connection, new_settings, &error)) {\n\t\tutils_clear_filled_connection_certs (wrapped_connection);\n\t\tg_hash_table_destroy (new_settings);\n\n\t\tg_warning (\"%s: '%s' / '%s' invalid: %d\",\n\t\t           __func__,\n\t\t           error ? g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)) : \"(none)\",\n\t\t           (error && error->message) ? error->message : \"(none)\",\n\t\t           error ? error->code : -1);\n\t\tgoto invalid;\n\t}\n\tg_object_unref (gconf_connection);\n\tg_hash_table_destroy (new_settings);\n\n\tfill_vpn_user_name (wrapped_connection);\n\n\tsettings = nm_connection_to_hash (wrapped_connection);\n\tutils_clear_filled_connection_certs (wrapped_connection);\n\n\tnm_exported_connection_signal_updated (NM_EXPORTED_CONNECTION (self), settings);\n\tg_hash_table_destroy (settings);\n\treturn TRUE;\n\ninvalid:\n\tg_clear_error (&error);\n\tnm_exported_connection_signal_removed (NM_EXPORTED_CONNECTION (self));\n\treturn FALSE;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "utils_fill_connection_certs (NMConnection *connection)\n{\n\tNMSetting8021x *s_8021x;\n\tconst char *filename;\n\tGError *error = NULL;\n\tgboolean need_client_cert = TRUE;\n\n\tg_return_if_fail (connection != NULL);\n\n\ts_8021x = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));\n\tif (!s_8021x)\n\t\treturn;\n\n\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CA_CERT_TAG);\n\tif (filename) {\n\t\tif (!nm_setting_802_1x_set_ca_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\tg_warning (\"%s: couldn't read CA certificate: %d %s\", __func__, error->code, error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* If the private key is PKCS#12, don't set the client cert */\n\tneed_client_cert = fill_one_private_key (connection,\n\t                                         NMA_PATH_PRIVATE_KEY_TAG,\n\t                                         NM_SETTING_802_1X_PRIVATE_KEY,\n\t                                         NM_SETTING_802_1X_CLIENT_CERT);\n\tif (need_client_cert) {\n\t\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CLIENT_CERT_TAG);\n\t\tif (filename) {\n\t\t\tif (!nm_setting_802_1x_set_client_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\t\tg_warning (\"%s: couldn't read client certificate: %d %s\", __func__, error->code, error->message);\n\t\t\tg_clear_error (&error);\n\t\t}\n\t}\n\n\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CA_CERT_TAG);\n\tif (filename) {\n\t\tif (!nm_setting_802_1x_set_phase2_ca_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\tg_warning (\"%s: couldn't read phase2 CA certificate: %d %s\", __func__, error->code, error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* If the private key is PKCS#12, don't set the client cert */\n\tneed_client_cert = fill_one_private_key (connection,\n\t                                         NMA_PATH_PHASE2_PRIVATE_KEY_TAG,\n\t                                         NM_SETTING_802_1X_PHASE2_PRIVATE_KEY,\n\t                                         NM_SETTING_802_1X_PHASE2_CLIENT_CERT);\n\tif (need_client_cert) {\n\t\tfilename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CLIENT_CERT_TAG);\n\t\tif (filename) {\n\t\t\tif (!nm_setting_802_1x_set_phase2_client_cert_from_file (s_8021x, filename, NULL, &error))\n\t\t\t\tg_warning (\"%s: couldn't read phase2 client certificate: %d %s\", __func__, error->code, error->message);\n\t\t\tg_clear_error (&error);\n\t\t}\n\t}\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "update_connection (NMConnectionList *list,\n                   NMConnectionEditor *editor,\n                   NMExportedConnection *original,\n                   NMConnection *modified,\n                   ConnectionUpdatedFn callback,\n                   gpointer user_data)\n{\n\tNMConnectionScope original_scope;\n\tConnectionUpdateInfo *info;\n\n\tinfo = g_slice_new0 (ConnectionUpdateInfo);\n\tinfo->list = list;\n\tinfo->editor = editor;\n\tinfo->original = g_object_ref (original);\n\tinfo->modified = g_object_ref (modified);\n\tinfo->callback = callback;\n\tinfo->user_data = user_data;\n\n\toriginal_scope = nm_connection_get_scope (nm_exported_connection_get_connection (original));\n\tif (nm_connection_get_scope (modified) == original_scope) {\n\t\t/* The easy part: Connection is updated */\n\t\tGHashTable *new_settings;\n\t\tGError *error = NULL;\n\t\tgboolean success;\n\t\tgboolean pending_auth = FALSE;\n\t\tGtkWindow *parent;\n\n\t\tutils_fill_connection_certs (modified);\n\t\tnew_settings = nm_connection_to_hash (modified);\n\n\t\t/* Hack; make sure that gconf private values are copied */\n\t\tnm_gconf_copy_private_connection_values (nm_exported_connection_get_connection (original),\n\t\t                                         modified);\n\n\t\tsuccess = nm_exported_connection_update (original, new_settings, &error);\n\t\tg_hash_table_destroy (new_settings);\n\t\tutils_clear_filled_connection_certs (modified);\n\n\t\tparent = nm_connection_editor_get_window (editor);\n\t\tif (!success) {\n\t\t\tif (pk_helper_is_permission_denied_error (error)) {\n\t\t\t\tGError *auth_error = NULL;\n\n\t\t\t\tpending_auth = pk_helper_obtain_auth (error, parent, update_connection_cb, info, &auth_error);\n\t\t\t\tif (auth_error) {\n\t\t\t\t\terror_dialog (parent,\n\t\t\t\t\t              _(\"Could not update connection\"),\n\t\t\t\t\t              \"%s\", auth_error->message);\n\t\t\t\t\tg_error_free (auth_error);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_dialog (parent,\n\t\t\t\t              _(\"Could not update connection\"),\n\t\t\t\t              \"%s\", error->message);\n\t\t\t}\n\n\t\t\tg_error_free (error);\n\t\t} else {\n\t\t\t/* Save user-connection vpn secrets */\n\t\t\tif (editor && (original_scope == NM_CONNECTION_SCOPE_USER))\n\t\t\t\tnm_connection_editor_save_vpn_secrets (editor);\n\t\t}\n\n\t\tif (!pending_auth)\n\t\t\tconnection_update_done (info, success);\n\t} else {\n\t\t/* The hard part: Connection scope changed:\n\t\t   Add the exported connection,\n\t\t   if it succeeds, remove the old one. */\n\t\tadd_connection (list, editor, modified, connection_update_add_done, info);\n\t}\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "add_connection (NMConnectionList *self,\n                NMConnectionEditor *editor,\n                NMConnection *connection,\n                ConnectionAddedFn callback,\n                gpointer user_data)\n{\n\tNMExportedConnection *exported = NULL;\n\tNMConnectionScope scope;\n\tgboolean success = FALSE;\n\n\tscope = nm_connection_get_scope (connection);\n\tif (scope == NM_CONNECTION_SCOPE_SYSTEM) {\n\t\tGError *error = NULL;\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_dbus_settings_system_add_connection (self->system_settings, connection, &error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (!success) {\n\t\t\tgboolean pending_auth = FALSE;\n\t\t\tGtkWindow *parent;\n\n\t\t\tparent = nm_connection_editor_get_window (editor);\n\t\t\tif (pk_helper_is_permission_denied_error (error)) {\n\t\t\t\tConnectionAddInfo *info;\n\t\t\t\tGError *auth_error = NULL;\n\n\t\t\t\tinfo = g_slice_new (ConnectionAddInfo);\n\t\t\t\tinfo->list = self;\n\t\t\t\tinfo->editor = editor;\n\t\t\t\tinfo->connection = g_object_ref (connection);\n\t\t\t\tinfo->callback = callback;\n\t\t\t\tinfo->user_data = user_data;\n\n\t\t\t\tpending_auth = pk_helper_obtain_auth (error, parent, add_connection_cb, info, &auth_error);\n\t\t\t\tif (auth_error) {\n\t\t\t\t\terror_dialog (parent,\n\t\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t\t              \"%s\", auth_error->message);\n\t\t\t\t\tg_error_free (auth_error);\n\t\t\t\t}\n\n\t\t\t\tif (!pending_auth) {\n\t\t\t\t\tg_object_unref (info->connection);\n\t\t\t\t\tg_slice_free (ConnectionAddInfo, info);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_dialog (parent,\n\t\t\t\t              _(\"Could not add connection\"),\n\t\t\t\t              \"%s\", error->message);\n\t\t\t}\n\n\t\t\tg_error_free (error);\n\n\t\t\tif (pending_auth)\n\t\t\t\treturn;\n\t\t}\n\t} else if (scope == NM_CONNECTION_SCOPE_USER) {\n\t\texported = (NMExportedConnection *) nma_gconf_settings_add_connection (self->gconf_settings, connection);\n\t\tsuccess = exported != NULL;\n\t\tif (success && editor)\n\t\t\tnm_connection_editor_save_vpn_secrets (editor);\n\t} else\n\t\tg_warning (\"%s: unhandled connection scope %d!\", __func__, scope);\n\n\tif (callback)\n\t\tcallback (exported, success, user_data);\n\n\tif (exported)\n\t\tg_object_unref (exported);\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "read_one_cert (ReadFromGConfInfo *info,\n               const char *setting_name,\n               const char *key)\n{\n\tchar *value = NULL;\n\n\tif (!nm_gconf_get_string_helper (info->client, info->dir, key, setting_name, &value))\n\t\treturn;\n\n\tg_object_set_data_full (G_OBJECT (info->connection),\n\t                        key, value,\n\t                        (GDestroyNotify) g_free);\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "read_applet_private_values_from_gconf (NMSetting *setting,\n                                       ReadFromGConfInfo *info)\n{\n\tif (NM_IS_SETTING_802_1X (setting)) {\n\t\tconst char *setting_name = nm_setting_get_name (setting);\n\t\tgboolean value;\n\n\t\tif (nm_gconf_get_bool_helper (info->client, info->dir,\n\t\t                              NMA_CA_CERT_IGNORE_TAG,\n\t\t                              setting_name, &value)) {\n\t\t\tg_object_set_data (G_OBJECT (info->connection),\n\t\t\t                   NMA_CA_CERT_IGNORE_TAG,\n\t\t\t                   GUINT_TO_POINTER (value));\n\t\t}\n\n\t\tif (nm_gconf_get_bool_helper (info->client, info->dir,\n\t\t                              NMA_PHASE2_CA_CERT_IGNORE_TAG,\n\t\t                              setting_name, &value)) {\n\t\t\tg_object_set_data (G_OBJECT (info->connection),\n\t\t\t                   NMA_PHASE2_CA_CERT_IGNORE_TAG,\n\t\t\t                   GUINT_TO_POINTER (value));\n\t\t}\n\n\t\t/* Binary certificate and key data doesn't get stored in GConf.  Instead,\n\t\t * the path to the certificate gets stored in a special key and the\n\t\t * certificate is read and stuffed into the setting right before\n\t\t * the connection is sent to NM\n\t\t */\n\t\tread_one_cert (info, setting_name, NMA_PATH_CA_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_CLIENT_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PRIVATE_KEY_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_CA_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_CLIENT_CERT_TAG);\n\t\tread_one_cert (info, setting_name, NMA_PATH_PHASE2_PRIVATE_KEY_TAG);\n\t}\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "get_8021x_secrets_cb (GtkDialog *dialog,\n\t\t\t\t\t  gint response,\n\t\t\t\t\t  gpointer user_data)\n{\n\tNM8021xInfo *info = user_data;\n\tNMAGConfConnection *gconf_connection;\n\tNMConnection *connection = NULL;\n\tNMSetting *setting;\n\tGHashTable *settings_hash;\n\tGHashTable *secrets;\n\tGError *err = NULL;\n\n\t/* Got a user response, clear the NMActiveConnection destroy handler for\n\t * this dialog since this function will now take over dialog destruction.\n\t */\n\tg_object_weak_unref (G_OBJECT (info->active_connection), destroy_8021x_dialog, info);\n\n\tif (response != GTK_RESPONSE_OK) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_SECRETS_REQUEST_CANCELED,\n\t\t             \"%s.%d (%s): canceled\",\n\t\t             __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tconnection = nma_wired_dialog_get_connection (info->dialog);\n\tif (!connection) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t             \"%s.%d (%s): couldn't get connection from wired dialog.\",\n\t\t             __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tsetting = nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X);\n\tif (!setting) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INVALID_CONNECTION,\n\t\t\t\t\t \"%s.%d (%s): requested setting '802-1x' didn't\"\n\t\t\t\t\t \" exist in the connection.\",\n\t\t\t\t\t __FILE__, __LINE__, __func__);\n\t\tgoto done;\n\t}\n\n\tutils_fill_connection_certs (NM_CONNECTION (connection));\n\tsecrets = nm_setting_to_hash (setting);\n\tutils_clear_filled_connection_certs (NM_CONNECTION (connection));\n\n\tif (!secrets) {\n\t\tg_set_error (&err, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t\t\t\t \"%s.%d (%s): failed to hash setting '%s'.\",\n\t\t\t\t\t __FILE__, __LINE__, __func__, nm_setting_get_name (setting));\n\t\tgoto done;\n\t}\n\n\t/* Returned secrets are a{sa{sv}}; this is the outer a{s...} hash that\n\t * will contain all the individual settings hashes.\n\t */\n\tsettings_hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t\t\t\t\t\t   g_free, (GDestroyNotify) g_hash_table_destroy);\n\n\tg_hash_table_insert (settings_hash, g_strdup (nm_setting_get_name (setting)), secrets);\n\tdbus_g_method_return (info->context, settings_hash);\n\tg_hash_table_destroy (settings_hash);\n\n\t/* Save the connection back to GConf _after_ hashing it, because\n\t * saving to GConf might trigger the GConf change notifiers, resulting\n\t * in the connection being read back in from GConf which clears secrets.\n\t */\n\tgconf_connection = nma_gconf_settings_get_by_connection (info->applet->gconf_settings, connection);\n\tif (gconf_connection)\n\t\tnma_gconf_connection_save (gconf_connection);\n\ndone:\n\tif (err) {\n\t\tg_warning (\"%s\", err->message);\n\t\tdbus_g_method_return_error (info->context, err);\n\t\tg_error_free (err);\n\t}\n\n\tif (connection)\n\t\tnm_connection_clear_secrets (connection);\n\n\tdestroy_8021x_dialog (info, NULL);\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "add_one_setting (GHashTable *settings,\n                 NMConnection *connection,\n                 NMSetting *setting,\n                 GError **error)\n{\n\tGHashTable *secrets;\n\n\tg_return_val_if_fail (settings != NULL, FALSE);\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\tg_return_val_if_fail (setting != NULL, FALSE);\n\tg_return_val_if_fail (error != NULL, FALSE);\n\tg_return_val_if_fail (*error == NULL, FALSE);\n\n\tutils_fill_connection_certs (connection);\n\tsecrets = nm_setting_to_hash (setting);\n\tutils_clear_filled_connection_certs (connection);\n\n\tif (secrets) {\n\t\tg_hash_table_insert (settings, g_strdup (nm_setting_get_name (setting)), secrets);\n\t} else {\n\t\tg_set_error (error, NM_SETTINGS_ERROR, NM_SETTINGS_ERROR_INTERNAL_ERROR,\n\t\t             \"%s.%d (%s): failed to hash setting '%s'.\",\n\t\t             __FILE__, __LINE__, __func__, nm_setting_get_name (setting));\n\t}\n\n\treturn secrets ? TRUE : FALSE;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "get_settings (NMExportedConnection *exported)\n{\n\tNMConnection *connection;\n\tGHashTable *settings;\n\n\tconnection = nm_exported_connection_get_connection (exported);\n\n\tutils_fill_connection_certs (connection);\n\tsettings = nm_connection_to_hash (connection);\n\tutils_clear_filled_connection_certs (connection);\n\n\treturn settings;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "constructor (GType type,\n\t\t   guint n_construct_params,\n\t\t   GObjectConstructParam *construct_params)\n{\n\tGObject *object;\n\tNMAGConfConnectionPrivate *priv;\n\tNMConnection *connection;\n\tGError *error = NULL;\n\n\tobject = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);\n\n\tif (!object)\n\t\treturn NULL;\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);\n\n\tif (!priv->client) {\n\t\tnm_warning (\"GConfClient not provided.\");\n\t\tgoto err;\n\t}\n\n\tif (!priv->dir) {\n\t\tnm_warning (\"GConf directory not provided.\");\n\t\tgoto err;\n\t}\n\n\tconnection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));\n\n\tutils_fill_connection_certs (connection);\n\tif (!nm_connection_verify (connection, &error)) {\n\t\tutils_clear_filled_connection_certs (connection);\n\t\tg_warning (\"Invalid connection: '%s' / '%s' invalid: %d\",\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tg_error_free (error);\n\t\tgoto err;\n\t}\n\tutils_clear_filled_connection_certs (connection);\n\n\tfill_vpn_user_name (connection);\n\n\treturn object;\n\n err:\n\tg_object_unref (object);\n\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "nm_gconf_read_connection (GConfClient *client,\n                          const char *dir)\n{\n\tReadFromGConfInfo info;\n\tGSList *list;\n\tGError *err = NULL;\n\n\tlist = gconf_client_all_dirs (client, dir, &err);\n\tif (err) {\n\t\tg_warning (\"Error while reading connection: %s\", err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\n\tif (!list) {\n\t\tg_warning (\"Invalid connection (empty)\");\n\t\treturn NULL;\n\t}\n\n\tinfo.connection = nm_connection_new ();\n\tinfo.client = client;\n\tinfo.dir = dir;\n\tinfo.dir_len = strlen (dir);\n\n\tg_slist_foreach (list, read_one_setting, &info);\n\tg_slist_free (list);\n\n\treturn info.connection;\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "edit_done_cb (NMConnectionEditor *editor, gint response, GError *error, gpointer user_data)\n{\n\tEditConnectionInfo *info = (EditConnectionInfo *) user_data;\n\tconst char *message = _(\"An unknown error ocurred.\");\n\n\tg_hash_table_remove (info->list->editors, info->original_connection);\n\n\tif (response == GTK_RESPONSE_NONE) {\n\t\tif (error && error->message)\n\t\t\tmessage = error->message;\n\t\terror_dialog (GTK_WINDOW (editor->window), _(\"Error initializing editor\"), \"%s\", message);\n\t} else if (response == GTK_RESPONSE_OK) {\n\t\tNMConnection *connection;\n\t\tGError *edit_error = NULL;\n\t\tgboolean success;\n\n\t\tconnection = nm_connection_editor_get_connection (editor);\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_connection_verify (connection, &edit_error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (success) {\n\t\t\tupdate_connection (info->list, editor, info->original_connection,\n\t\t\t                   connection, connection_updated_cb, info);\n\t\t} else {\n\t\t\tg_warning (\"%s: invalid connection after update: bug in the \"\n\t\t\t           \"'%s' / '%s' invalid: %d\",\n\t\t\t           __func__,\n\t\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (edit_error->domain)),\n\t\t\t           edit_error->message, edit_error->code);\n\t\t\tg_error_free (edit_error);\n\t\t\tconnection_updated_cb (info->list, FALSE, user_data);\n\t\t}\n\t}\n}", "target": 1, "cwe": ["CWE-310"], "message": "core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)\n\nIf a connection was created with a CA certificate, but the user later\nmoved or deleted that CA certificate, the applet would simply provide the\nconnection to NetworkManager without any CA certificate.  This could cause\nNM to connect to the original network (or a network spoofing the original\nnetwork) without verifying the identity of the network as the user\nexpects.\n\nIn the future we can/should do better here by (1) alerting the user that\nsome connection is now no longer complete by flagging it in the connection\neditor or notifying the user somehow, and (2) by using a freaking' cert\nstore already (not that Linux has one yet)."}
{"func": "static int ohci_queue_iso_receive_dualbuffer(struct fw_iso_context *base,\n\t\t\t\t\t     struct fw_iso_packet *packet,\n\t\t\t\t\t     struct fw_iso_buffer *buffer,\n\t\t\t\t\t     unsigned long payload)\n{\n\tstruct iso_context *ctx = container_of(base, struct iso_context, base);\n\tstruct db_descriptor *db = NULL;\n\tstruct descriptor *d;\n\tstruct fw_iso_packet *p;\n\tdma_addr_t d_bus, page_bus;\n\tu32 z, header_z, length, rest;\n\tint page, offset, packet_count, header_size;\n\n\t/*\n\t * FIXME: Cycle lost behavior should be configurable: lose\n\t * packet, retransmit or terminate..\n\t */\n\n\tp = packet;\n\tz = 2;\n\n\t/*\n\t * The OHCI controller puts the isochronous header and trailer in the\n\t * buffer, so we need at least 8 bytes.\n\t */\n\tpacket_count = p->header_length / ctx->base.header_size;\n\theader_size = packet_count * max(ctx->base.header_size, (size_t)8);\n\n\t/* Get header size in number of descriptors. */\n\theader_z = DIV_ROUND_UP(header_size, sizeof(*d));\n\tpage     = payload >> PAGE_SHIFT;\n\toffset   = payload & ~PAGE_MASK;\n\trest     = p->payload_length;\n\n\t/* FIXME: make packet-per-buffer/dual-buffer a context option */\n\twhile (rest > 0) {\n\t\td = context_get_descriptors(&ctx->context,\n\t\t\t\t\t    z + header_z, &d_bus);\n\t\tif (d == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tdb = (struct db_descriptor *) d;\n\t\tdb->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t  DESCRIPTOR_BRANCH_ALWAYS);\n\t\tdb->first_size =\n\t\t    cpu_to_le16(max(ctx->base.header_size, (size_t)8));\n\t\tif (p->skip && rest == p->payload_length) {\n\t\t\tdb->control |= cpu_to_le16(DESCRIPTOR_WAIT);\n\t\t\tdb->first_req_count = db->first_size;\n\t\t} else {\n\t\t\tdb->first_req_count = cpu_to_le16(header_size);\n\t\t}\n\t\tdb->first_res_count = db->first_req_count;\n\t\tdb->first_buffer = cpu_to_le32(d_bus + sizeof(*db));\n\n\t\tif (p->skip && rest == p->payload_length)\n\t\t\tlength = 4;\n\t\telse if (offset + rest < PAGE_SIZE)\n\t\t\tlength = rest;\n\t\telse\n\t\t\tlength = PAGE_SIZE - offset;\n\n\t\tdb->second_req_count = cpu_to_le16(length);\n\t\tdb->second_res_count = db->second_req_count;\n\t\tpage_bus = page_private(buffer->pages[page]);\n\t\tdb->second_buffer = cpu_to_le32(page_bus + offset);\n\n\t\tif (p->interrupt && length == rest)\n\t\t\tdb->control |= cpu_to_le16(DESCRIPTOR_IRQ_ALWAYS);\n\n\t\tcontext_append(&ctx->context, d, z, header_z);\n\t\toffset = (offset + length) & ~PAGE_MASK;\n\t\trest -= length;\n\t\tif (offset == 0)\n\t\t\tpage++;\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "firewire: ohci: handle receive packets with a data length of zero\n\nQueueing to receive an ISO packet with a payload length of zero\nsilently does nothing in dualbuffer mode, and crashes the kernel in\npacket-per-buffer mode.  Return an error in dualbuffer mode, because\nthe DMA controller won't let us do what we want, and work correctly in\npacket-per-buffer mode.\n\nSigned-off-by: Jay Fenlason <fenlason@redhat.com>\nSigned-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>\nCc: stable@kernel.org"}
{"func": "static int ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,\n\t\t\t\t\tstruct fw_iso_packet *packet,\n\t\t\t\t\tstruct fw_iso_buffer *buffer,\n\t\t\t\t\tunsigned long payload)\n{\n\tstruct iso_context *ctx = container_of(base, struct iso_context, base);\n\tstruct descriptor *d = NULL, *pd = NULL;\n\tstruct fw_iso_packet *p = packet;\n\tdma_addr_t d_bus, page_bus;\n\tu32 z, header_z, rest;\n\tint i, j, length;\n\tint page, offset, packet_count, header_size, payload_per_buffer;\n\n\t/*\n\t * The OHCI controller puts the isochronous header and trailer in the\n\t * buffer, so we need at least 8 bytes.\n\t */\n\tpacket_count = p->header_length / ctx->base.header_size;\n\theader_size  = max(ctx->base.header_size, (size_t)8);\n\n\t/* Get header size in number of descriptors. */\n\theader_z = DIV_ROUND_UP(header_size, sizeof(*d));\n\tpage     = payload >> PAGE_SHIFT;\n\toffset   = payload & ~PAGE_MASK;\n\tpayload_per_buffer = p->payload_length / packet_count;\n\n\tfor (i = 0; i < packet_count; i++) {\n\t\t/* d points to the header descriptor */\n\t\tz = DIV_ROUND_UP(payload_per_buffer + offset, PAGE_SIZE) + 1;\n\t\td = context_get_descriptors(&ctx->context,\n\t\t\t\tz + header_z, &d_bus);\n\t\tif (d == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\td->control      = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t      DESCRIPTOR_INPUT_MORE);\n\t\tif (p->skip && i == 0)\n\t\t\td->control |= cpu_to_le16(DESCRIPTOR_WAIT);\n\t\td->req_count    = cpu_to_le16(header_size);\n\t\td->res_count    = d->req_count;\n\t\td->transfer_status = 0;\n\t\td->data_address = cpu_to_le32(d_bus + (z * sizeof(*d)));\n\n\t\trest = payload_per_buffer;\n\t\tfor (j = 1; j < z; j++) {\n\t\t\tpd = d + j;\n\t\t\tpd->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t\t  DESCRIPTOR_INPUT_MORE);\n\n\t\t\tif (offset + rest < PAGE_SIZE)\n\t\t\t\tlength = rest;\n\t\t\telse\n\t\t\t\tlength = PAGE_SIZE - offset;\n\t\t\tpd->req_count = cpu_to_le16(length);\n\t\t\tpd->res_count = pd->req_count;\n\t\t\tpd->transfer_status = 0;\n\n\t\t\tpage_bus = page_private(buffer->pages[page]);\n\t\t\tpd->data_address = cpu_to_le32(page_bus + offset);\n\n\t\t\toffset = (offset + length) & ~PAGE_MASK;\n\t\t\trest -= length;\n\t\t\tif (offset == 0)\n\t\t\t\tpage++;\n\t\t}\n\t\tpd->control = cpu_to_le16(DESCRIPTOR_STATUS |\n\t\t\t\t\t  DESCRIPTOR_INPUT_LAST |\n\t\t\t\t\t  DESCRIPTOR_BRANCH_ALWAYS);\n\t\tif (p->interrupt && i == packet_count - 1)\n\t\t\tpd->control |= cpu_to_le16(DESCRIPTOR_IRQ_ALWAYS);\n\n\t\tcontext_append(&ctx->context, d, z, header_z);\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "firewire: ohci: handle receive packets with a data length of zero\n\nQueueing to receive an ISO packet with a payload length of zero\nsilently does nothing in dualbuffer mode, and crashes the kernel in\npacket-per-buffer mode.  Return an error in dualbuffer mode, because\nthe DMA controller won't let us do what we want, and work correctly in\npacket-per-buffer mode.\n\nSigned-off-by: Jay Fenlason <fenlason@redhat.com>\nSigned-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>\nCc: stable@kernel.org"}
{"func": "activate_parameters_install_free (ActivateParametersInstall *parameters_install)\n{\n\tif (parameters_install->slot_info) {\n\t\tg_object_remove_weak_pointer (G_OBJECT (parameters_install->slot_info), (gpointer *)&parameters_install->slot_info);\n\t}\n\tif (parameters_install->parent_window) {\n\t\tg_object_remove_weak_pointer (G_OBJECT (parameters_install->parent_window), (gpointer *)&parameters_install->parent_window);\n\t}\n\tnautilus_file_list_free (parameters_install->files);\n\tg_free (parameters_install->activation_directory);\n\tg_free (parameters_install);\n}", "target": 1, "cwe": [], "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003"}
{"func": "link_info_done (NautilusDirectory *directory,\n\t\tNautilusFile *file,\n\t\tconst char *uri,\n\t\tconst char *name, \n\t\tconst char *icon,\n\t\tgboolean is_launcher,\n\t\tgboolean is_foreign)\n{\n\tfile->details->link_info_is_up_to_date = TRUE;\n\n\tnautilus_file_set_display_name (file, name, name, TRUE);\n\t\n\tfile->details->got_link_info = TRUE;\n\tg_free (file->details->custom_icon);\n\tif (uri) {\n\t\tif (file->details->activation_location) {\n\t\t\tg_object_unref (file->details->activation_location);\n\t\t\tfile->details->activation_location = NULL;\n\t\t}\n\t\tfile->details->got_custom_activation_location = TRUE;\n\t\tfile->details->activation_location = g_file_new_for_uri (uri);\n\t}\n\tfile->details->custom_icon = g_strdup (icon);\n\tfile->details->is_launcher = is_launcher;\n\tfile->details->is_foreign_link = is_foreign;\n\t\n\tnautilus_directory_async_state_changed (directory);\n}", "target": 1, "cwe": [], "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003"}
{"func": "nautilus_file_set_display_name (NautilusFile *file,\n\t\t\t\tconst char *display_name,\n\t\t\t\tconst char *edit_name,\n\t\t\t\tgboolean custom)\n{\n\tgboolean changed;\n\n\tif (display_name == NULL || *display_name == 0) {\n\t\treturn FALSE;\n\t}\n\t\n\tif (!custom && file->details->got_custom_display_name) {\n\t\treturn FALSE;\n\t}\n\n\tif (custom && display_name == NULL) {\n\t\t/* We're re-setting a custom display name, invalidate it if\n\t\t   we already set it so that the old one is re-read */\n\t\tif (file->details->got_custom_display_name) {\n\t\t\tfile->details->got_custom_display_name = FALSE;\n\t\t\tnautilus_file_invalidate_attributes (file,\n\t\t\t\t\t\t\t     NAUTILUS_FILE_ATTRIBUTE_INFO);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tif (edit_name == NULL) {\n\t\tedit_name = display_name;\n\t}\n\t    \n\tchanged = FALSE;\n\t\n\tif (eel_strcmp (eel_ref_str_peek (file->details->display_name), display_name) != 0) {\n\t\tchanged = TRUE;\n\t\t\n\t\teel_ref_str_unref (file->details->display_name);\n\t\t\n\t\tif (eel_strcmp (eel_ref_str_peek (file->details->name), display_name) == 0) {\n\t\t\tfile->details->display_name = eel_ref_str_ref (file->details->name);\n\t\t} else {\n\t\t\tfile->details->display_name = eel_ref_str_new (display_name);\n\t\t}\n\t\t\n\t\tg_free (file->details->display_name_collation_key);\n\t\tfile->details->display_name_collation_key = g_utf8_collate_key_for_filename (display_name, -1);\n\t}\n\n\tif (eel_strcmp (eel_ref_str_peek (file->details->edit_name), edit_name) != 0) {\n\t\tchanged = TRUE;\n\t\t\n\t\teel_ref_str_unref (file->details->edit_name);\n\t\tif (eel_strcmp (eel_ref_str_peek (file->details->display_name), edit_name) == 0) {\n\t\t\tfile->details->edit_name = eel_ref_str_ref (file->details->display_name);\n\t\t} else {\n\t\t\tfile->details->edit_name = eel_ref_str_new (edit_name);\n\t\t}\n\t}\n\t\n\tfile->details->got_custom_display_name = custom;\n\treturn changed;\n}", "target": 1, "cwe": [], "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003"}
{"func": "activate_files (ActivateParameters *parameters)\n{\n\tNautilusWindowInfo *window_info;\n\tNautilusWindowOpenFlags flags;\n\tNautilusFile *file;\n\tGList *launch_desktop_files;\n\tGList *launch_files;\n\tGList *launch_in_terminal_files;\n\tGList *open_in_app_files;\n\tGList *open_in_app_parameters;\n\tGList *unhandled_open_in_app_files;\n\tApplicationLaunchParameters *one_parameters;\n\tGList *open_in_view_files;\n\tGList *l;\n\tint count;\n\tchar *uri;\n\tchar *executable_path, *quoted_path, *name;\n\tchar *old_working_dir;\n\tActivationAction action;\n\tGdkScreen *screen;\n\t\n\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n\tlaunch_desktop_files = NULL;\n\tlaunch_files = NULL;\n\tlaunch_in_terminal_files = NULL;\n\topen_in_app_files = NULL;\n\topen_in_view_files = NULL;\n\n\tfor (l = parameters->files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\tif (file_was_cancelled (file)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taction = get_activation_action (file);\n\t\tif (action == ACTIVATION_ACTION_ASK) {\n\t\t\t/* Special case for executable text files, since it might be\n\t\t\t * dangerous & unexpected to launch these.\n\t\t\t */\n\t\t\tpause_activation_timed_cancel (parameters);\n\t\t\taction = get_executable_text_file_action (parameters->parent_window, file);\n\t\t\tunpause_activation_timed_cancel (parameters);\n\t\t}\n\n\t\tswitch (action) {\n\t\tcase ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE :\n\t\t\tlaunch_desktop_files = g_list_prepend (launch_desktop_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_LAUNCH :\n\t\t\tlaunch_files = g_list_prepend (launch_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_LAUNCH_IN_TERMINAL :\n\t\t\tlaunch_in_terminal_files = g_list_prepend (launch_in_terminal_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_OPEN_IN_VIEW :\n\t\t\topen_in_view_files = g_list_prepend (open_in_view_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_OPEN_IN_APPLICATION :\n\t\t\topen_in_app_files = g_list_prepend (open_in_app_files, file);\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_DO_NOTHING :\n\t\t\tbreak;\n\t\tcase ACTIVATION_ACTION_ASK :\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlaunch_desktop_files = g_list_reverse (launch_desktop_files);\n\tfor (l = launch_desktop_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\t\t\n\t\turi = nautilus_file_get_uri (file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t}\n\n\told_working_dir = NULL;\n\tif (parameters->activation_directory &&\n\t    (launch_files != NULL || launch_in_terminal_files != NULL)) {\n\t\told_working_dir = g_get_current_dir ();\n\t\tg_chdir (parameters->activation_directory);\n\t\t\n\t}\n\n\tlaunch_files = g_list_reverse (launch_files);\n\tfor (l = launch_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\turi = nautilus_file_get_activation_uri (file);\n\t\texecutable_path = g_filename_from_uri (uri, NULL, NULL);\n\t\tquoted_path = g_shell_quote (executable_path);\n\t\tname = nautilus_file_get_name (file);\n\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, quoted_path);\n\n\t\tnautilus_launch_application_from_command (screen, name, quoted_path, FALSE, NULL);\n\t\tg_free (name);\n\t\tg_free (quoted_path);\n\t\tg_free (executable_path);\n\t\tg_free (uri);\n\t\t\t\n\t}\n\n\tlaunch_in_terminal_files = g_list_reverse (launch_in_terminal_files);\n\tfor (l = launch_in_terminal_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\turi = nautilus_file_get_activation_uri (file);\n\t\texecutable_path = g_filename_from_uri (uri, NULL, NULL);\n\t\tquoted_path = g_shell_quote (executable_path);\n\t\tname = nautilus_file_get_name (file);\n\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_in_terminal window=%p: %s\",\n\t\t\t\t    parameters->parent_window, quoted_path);\n\n\t\tnautilus_launch_application_from_command (screen, name, quoted_path, TRUE, NULL);\n\t\tg_free (name);\n\t\tg_free (quoted_path);\n\t\tg_free (executable_path);\n\t\tg_free (uri);\n\t}\n\n\tif (old_working_dir != NULL) {\n\t\tg_chdir (old_working_dir);\n\t\tg_free (old_working_dir);\n\t}\n\n\topen_in_view_files = g_list_reverse (open_in_view_files);\n\tcount = g_list_length (open_in_view_files);\n\n\tflags = parameters->flags;\n\tif (count > 1) {\n\t\tif (eel_preferences_get_boolean (NAUTILUS_PREFERENCES_ENABLE_TABS) &&\n\t\t    (parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW) == 0) {\n\t\t\tflags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB;\n\t\t} else {\n\t\t\tflags |= NAUTILUS_WINDOW_OPEN_FLAG_NEW_WINDOW;\n\t\t}\n\t}\n\n\tif (parameters->slot_info != NULL &&\n\t    (!parameters->user_confirmation ||\n\t     confirm_multiple_windows (parameters->parent_window, count,\n\t\t\t\t       (flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0))) {\n\n\t\tif ((flags & NAUTILUS_WINDOW_OPEN_FLAG_NEW_TAB) != 0 &&\n\t\t    eel_preferences_get_enum (NAUTILUS_PREFERENCES_NEW_TAB_POSITION) ==\n\t\t    NAUTILUS_NEW_TAB_POSITION_AFTER_CURRENT_TAB) {\n\t\t\t/* When inserting N tabs after the current one,\n\t\t\t * we first open tab N, then tab N-1, ..., then tab 0.\n\t\t\t * Each of them is appended to the current tab, i.e.\n\t\t\t * prepended to the list of tabs to open.\n\t\t\t */\n\t\t\topen_in_view_files = g_list_reverse (open_in_view_files);\n\t\t}\n\n\n\t\tfor (l = open_in_view_files; l != NULL; l = l->next) {\n\t\t\tGFile *f;\n\t\t\t/* The ui should ask for navigation or object windows\n\t\t\t * depending on what the current one is */\n\t\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\t\turi = nautilus_file_get_activation_uri (file);\n\t\t\tf = g_file_new_for_uri (uri);\n\t\t\tnautilus_window_slot_info_open_location (parameters->slot_info,\n\t\t\t\t\t\t\t\t f, parameters->mode, flags, NULL);\n\t\t\tg_object_unref (f);\n\t\t\tg_free (uri);\n\t\t}\n\t}\n\n\topen_in_app_parameters = NULL;\n\tunhandled_open_in_app_files = NULL;\n\n\tif (open_in_app_files != NULL) {\n\t\topen_in_app_files = g_list_reverse (open_in_app_files);\n\n\t\topen_in_app_parameters = fm_directory_view_make_activation_parameters\n\t\t\t(open_in_app_files, &unhandled_open_in_app_files);\n\t}\n\n\tfor (l = open_in_app_parameters; l != NULL; l = l->next) {\n\t\tone_parameters = l->data;\n\n\t\tnautilus_launch_application (one_parameters->application,\n\t\t\t\t\t     one_parameters->files,\n\t\t\t\t\t     parameters->parent_window);\n\t\tapplication_launch_parameters_free (one_parameters);\n\t}\n\n\tfor (l = unhandled_open_in_app_files; l != NULL; l = l->next) {\n\t\tfile = NAUTILUS_FILE (l->data);\n\n\t\t/* this does not block */\n\t\tapplication_unhandled_file (parameters, file);\n\t}\n\n\twindow_info = NULL;\n\tif (parameters->slot_info != NULL) {\n\t\twindow_info = nautilus_window_slot_info_get_window (parameters->slot_info);\n\t}\n\n\tif (open_in_app_parameters != NULL ||\n\t    unhandled_open_in_app_files != NULL) {\n\t\tif ((parameters->flags & NAUTILUS_WINDOW_OPEN_FLAG_CLOSE_BEHIND) != 0 &&\n\t\t    window_info != NULL && \n\t\t     nautilus_window_info_get_window_type (window_info) == NAUTILUS_WINDOW_SPATIAL) {\n\t\t\tnautilus_window_info_close (window_info);\n\t\t}\n\t}\n\n\tg_list_free (launch_desktop_files);\n\tg_list_free (launch_files);\n\tg_list_free (launch_in_terminal_files);\n\tg_list_free (open_in_view_files);\n\tg_list_free (open_in_app_files);\n\tg_list_free (open_in_app_parameters);\n\tg_list_free (unhandled_open_in_app_files);\n\t\n\tactivation_parameters_free (parameters);\n}", "target": 1, "cwe": [], "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003"}
{"func": "nautilus_file_clear_info (NautilusFile *file)\n{\n\tfile->details->got_file_info = FALSE;\n\tif (file->details->get_info_error) {\n\t\tg_error_free (file->details->get_info_error);\n\t\tfile->details->get_info_error = NULL;\n\t}\n\t/* Reset to default type, which might be other than unknown for\n\t   special kinds of files like the desktop or a search directory */\n\tfile->details->type = NAUTILUS_FILE_GET_CLASS (file)->default_file_type;\n\n\tif (!file->details->got_custom_display_name) {\n\t\tnautilus_file_clear_display_name (file);\n\t}\n\n\tif (!file->details->got_custom_activation_location &&\n\t    file->details->activation_location != NULL) {\n\t\tg_object_unref (file->details->activation_location);\n\t\tfile->details->activation_location = NULL;\n\t}\n\t\n\tif (file->details->icon != NULL) {\n\t\tg_object_unref (file->details->icon);\n\t\tfile->details->icon = NULL;\n\t}\n\n\tg_free (file->details->thumbnail_path);\n\tfile->details->thumbnail_path = NULL;\n\tfile->details->thumbnailing_failed = FALSE;\n\t\n\tfile->details->is_launcher = FALSE;\n\tfile->details->is_foreign_link = FALSE;\n\tfile->details->is_symlink = FALSE;\n\tfile->details->is_hidden = FALSE;\n\tfile->details->is_backup = FALSE;\n\tfile->details->is_mountpoint = FALSE;\n\tfile->details->uid = -1;\n\tfile->details->gid = -1;\n\tfile->details->can_read = TRUE;\n\tfile->details->can_write = TRUE;\n\tfile->details->can_execute = TRUE;\n\tfile->details->can_delete = TRUE;\n\tfile->details->can_trash = TRUE;\n\tfile->details->can_rename = TRUE;\n\tfile->details->can_mount = FALSE;\n\tfile->details->can_unmount = FALSE;\n\tfile->details->can_eject = FALSE;\n\tfile->details->has_permissions = FALSE;\n\tfile->details->permissions = 0;\n\tfile->details->size = -1;\n\tfile->details->sort_order = 0;\n\tfile->details->mtime = 0;\n\tfile->details->atime = 0;\n\tfile->details->ctime = 0;\n\tg_free (file->details->symlink_name);\n\tfile->details->symlink_name = NULL;\n\teel_ref_str_unref (file->details->mime_type);\n\tfile->details->mime_type = NULL;\n\tg_free (file->details->selinux_context);\n\tfile->details->selinux_context = NULL;\n\tg_free (file->details->description);\n\tfile->details->description = NULL;\n\n\teel_ref_str_unref (file->details->filesystem_id);\n\tfile->details->filesystem_id = NULL;\n}", "target": 1, "cwe": [], "message": "Check for trusted desktop file launchers.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-directory-async.c:\n\tCheck for trusted desktop file launchers.\n\n        * libnautilus-private/nautilus-file-private.h:\n        * libnautilus-private/nautilus-file.c:\n        * libnautilus-private/nautilus-file.h:\n        Add nautilus_file_is_trusted_link.\n\tAllow unsetting of custom display name.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tDisplay dialog when trying to launch a non-trusted desktop file.\n\n\n\nsvn path=/trunk/; revision=15003"}
{"func": "mark_trusted_callback (NautilusFile  *file,\n\t\t       GFile         *result_location,\n\t\t       GError        *error,\n\t\t       gpointer       callback_data)\n{\n\tActivateParametersDesktop *parameters;\n\n\tparameters = callback_data;\n\tif (error) {\n\t\teel_show_error_dialog (_(\"Unable to mark launcher trusted (executable)\"),\n\t\t\t\t       error->message,\n\t\t\t\t       parameters->parent_window);\n\t}\n\t\n\tactivate_parameters_desktop_free (parameters);\n}", "target": 1, "cwe": [], "message": "Add nautilus_file_mark_desktop_file_trusted(), this now adds a #! line if\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n\tAdd nautilus_file_mark_desktop_file_trusted(), this now\n\tadds a #! line if there is none as well as makes the file\n\texecutable.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tUse nautilus_file_mark_desktop_file_trusted() instead of\n\tjust setting the permissions.\n\n\n\nsvn path=/trunk/; revision=15006"}
{"func": "untrusted_launcher_response_callback (GtkDialog *dialog,\n\t\t\t\t      int response_id,\n\t\t\t\t      ActivateParametersDesktop *parameters)\n{\n\tGdkScreen *screen;\n\tchar *uri;\n\tgboolean free_params;\n\t\n\tfree_params = TRUE;\n\tswitch (response_id) {\n\tcase RESPONSE_RUN:\n\t\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\t\turi = nautilus_file_get_uri (parameters->file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t\tbreak;\n\tcase RESPONSE_MARK_TRUSTED:\n\t\tnautilus_file_set_permissions (parameters->file, \n\t\t\t\t\t       nautilus_file_get_permissions (parameters->file) | S_IXGRP | S_IXUSR | S_IXOTH,\n\t\t\t\t\t       mark_trusted_callback,\n\t\t\t\t\t       parameters);\n\t\tfree_params = FALSE;\n\t\tbreak;\n\tdefault:\n\t\t/* Just destroy dialog */\n\t\tbreak;\n\t}\n\t\n\tgtk_widget_destroy (GTK_WIDGET (dialog));\n\tif (free_params) {\n\t\tactivate_parameters_desktop_free (parameters);\n\t}\n}", "target": 1, "cwe": [], "message": "Add nautilus_file_mark_desktop_file_trusted(), this now adds a #! line if\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n\tAdd nautilus_file_mark_desktop_file_trusted(), this now\n\tadds a #! line if there is none as well as makes the file\n\texecutable.\n\n        * libnautilus-private/nautilus-mime-actions.c:\n\tUse nautilus_file_mark_desktop_file_trusted() instead of\n\tjust setting the permissions.\n\n\n\nsvn path=/trunk/; revision=15006"}
{"func": "finish_startup (NautilusApplication *application)\n{\n\tGList *drives;\n\n\t/* initialize nautilus modules */\n\tnautilus_module_setup ();\n\n\t/* attach menu-provider module callback */\n\tmenu_provider_init_callback ();\n\t\n\t/* Initialize the desktop link monitor singleton */\n\tnautilus_desktop_link_monitor_get ();\n\n\t/* Watch for mounts so we can restore open windows This used\n\t * to be for showing new window on mount, but is not used\n\t * anymore */\n\n\t/* Watch for unmounts so we can close open windows */\n\t/* TODO-gio: This should be using the UNMOUNTED feature of GFileMonitor instead */\n\tapplication->volume_monitor = g_volume_monitor_get ();\n\tg_signal_connect_object (application->volume_monitor, \"mount_removed\",\n\t\t\t\t G_CALLBACK (mount_removed_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"mount_pre_unmount\",\n\t\t\t\t G_CALLBACK (mount_removed_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"mount_added\",\n\t\t\t\t G_CALLBACK (mount_added_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"volume_added\",\n\t\t\t\t G_CALLBACK (volume_added_callback), application, 0);\n\tg_signal_connect_object (application->volume_monitor, \"drive_connected\",\n\t\t\t\t G_CALLBACK (drive_connected_callback), application, 0);\n\n\t/* listen for eject button presses */\n\tdrives = g_volume_monitor_get_connected_drives (application->volume_monitor);\n\tg_list_foreach (drives, (GFunc) drive_listen_for_eject_button, application);\n\tg_list_foreach (drives, (GFunc) g_object_unref, NULL);\n\tg_list_free (drives);\n\n\tapplication->automount_idle_id = \n\t\tg_idle_add_full (G_PRIORITY_LOW,\n\t\t\t\t automount_all_volumes_idle_cb,\n\t\t\t\t application, NULL);\n}", "target": 1, "cwe": [], "message": "Add \"interactive\" argument to nautilus_file_mark_desktop_file_trusted.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n        * libnautilus-private/nautilus-mime-actions.c:\n        Add \"interactive\" argument to\n\tnautilus_file_mark_desktop_file_trusted.\n\n        * src/nautilus-application.c:\n\tMark all desktopfiles on the desktop trusted on first\n\trun.\n\n\n\nsvn path=/trunk/; revision=15009"}
{"func": "mark_trusted_job (GIOSchedulerJob *io_job,\n\t\t  GCancellable *cancellable,\n\t\t  gpointer user_data)\n{\n\tMarkTrustedJob *job = user_data;\n\tCommonJob *common;\n\tchar *contents, *new_contents;\n\tgsize length, new_length;\n\tGError *error;\n\tguint32 current;\n\tint response;\n\tGFileInfo *info;\n\t\n\tcommon = (CommonJob *)job;\n\tcommon->io_job = io_job;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\n retry:\n\terror = NULL;\n\tif (!g_file_load_contents (job->file,\n\t\t\t\t  cancellable,\n\t\t\t\t  &contents, &length,\n\t\t\t\t  NULL, &error)) {\n\t\tresponse = run_error (common,\n\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t      error->message,\n\t\t\t\t      NULL,\n\t\t\t\t      FALSE,\n\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t      NULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!g_str_has_prefix (contents, \"#!\")) {\n\t\tnew_length = length + strlen (TRUSTED_SHEBANG);\n\t\tnew_contents = g_malloc (new_length);\n\t\t\n\t\tstrcpy (new_contents, TRUSTED_SHEBANG);\n\t\tmemcpy (new_contents + strlen (TRUSTED_SHEBANG),\n\t\t\tcontents, length);\n\t\t\n\t\tif (!g_file_replace_contents (job->file,\n\t\t\t\t\t      new_contents,\n\t\t\t\t\t      new_length,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE, 0,\n\t\t\t\t\t      NULL, cancellable, &error)) {\n\t\t\tg_free (contents);\n\t\t\tg_free (new_contents);\n\t\t\t\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t\t\n\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\tabort_job (common);\n\t\t\t} else if (response == 1) {\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tg_free (new_contents);\n\t\t\n\t}\n\tg_free (contents);\n\t\n\tinfo = g_file_query_info (job->file,\n\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_TYPE\",\"\n\t\t\t\t  G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t  common->cancellable,\n\t\t\t\t  &error);\n\n\tif (info == NULL) {\n\t\tresponse = run_error (common,\n\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t      error->message,\n\t\t\t\t      NULL,\n\t\t\t\t      FALSE,\n\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t      NULL);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\t\n\t\tgoto out;\n\t}\n\t\n\t\n\tif (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE)) {\n\t\tcurrent = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\t\tcurrent = current | S_IXGRP | S_IXUSR | S_IXOTH;\n\n\t\tif (!g_file_set_attribute_uint32 (job->file, G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t\t\t  current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t  common->cancellable, &error))\n\t\t\t{\n\t\t\t\tg_object_unref (info);\n\t\t\t\t\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (common);\n\t\t\t\t} else if (response == 1) {\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgoto out;\n\t\t\t}\n\t} \n\tg_object_unref (info);\n\nout:\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   mark_trusted_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}", "target": 1, "cwe": [], "message": "Add \"interactive\" argument to nautilus_file_mark_desktop_file_trusted.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n        * libnautilus-private/nautilus-mime-actions.c:\n        Add \"interactive\" argument to\n\tnautilus_file_mark_desktop_file_trusted.\n\n        * src/nautilus-application.c:\n\tMark all desktopfiles on the desktop trusted on first\n\trun.\n\n\n\nsvn path=/trunk/; revision=15009"}
{"func": "untrusted_launcher_response_callback (GtkDialog *dialog,\n\t\t\t\t      int response_id,\n\t\t\t\t      ActivateParametersDesktop *parameters)\n{\n\tGdkScreen *screen;\n\tchar *uri;\n\tGFile *file;\n\t\n\tswitch (response_id) {\n\tcase RESPONSE_RUN:\n\t\tscreen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\t\turi = nautilus_file_get_uri (parameters->file);\n\t\tnautilus_debug_log (FALSE, NAUTILUS_DEBUG_LOG_DOMAIN_USER,\n\t\t\t\t    \"directory view activate_callback launch_desktop_file window=%p: %s\",\n\t\t\t\t    parameters->parent_window, uri);\n\t\tnautilus_launch_desktop_file (screen, uri, NULL,\n\t\t\t\t\t      parameters->parent_window);\n\t\tg_free (uri);\n\t\tbreak;\n\tcase RESPONSE_MARK_TRUSTED:\n\t\tfile = nautilus_file_get_location (parameters->file);\n\t\tnautilus_file_mark_desktop_file_trusted (file,\n\t\t\t\t\t\t\t parameters->parent_window,\n\t\t\t\t\t\t\t NULL, NULL);\n\t\tg_object_unref (file);\n\t\tbreak;\n\tdefault:\n\t\t/* Just destroy dialog */\n\t\tbreak;\n\t}\n\t\n\tgtk_widget_destroy (GTK_WIDGET (dialog));\n\tactivate_parameters_desktop_free (parameters);\n}", "target": 1, "cwe": [], "message": "Add \"interactive\" argument to nautilus_file_mark_desktop_file_trusted.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n        * libnautilus-private/nautilus-mime-actions.c:\n        Add \"interactive\" argument to\n\tnautilus_file_mark_desktop_file_trusted.\n\n        * src/nautilus-application.c:\n\tMark all desktopfiles on the desktop trusted on first\n\trun.\n\n\n\nsvn path=/trunk/; revision=15009"}
{"func": "nautilus_application_startup (NautilusApplication *application,\n\t\t\t      gboolean kill_shell,\n\t\t\t      gboolean no_default_window,\n\t\t\t      gboolean no_desktop,\n\t\t\t      gboolean browser_window,\n\t\t\t      const char *geometry,\n\t\t\t      char **urls)\n{\n\tUniqueMessageData *message;\n\t\n\t/* Check the user's ~/.nautilus directories and post warnings\n\t * if there are problems.\n\t */\n\tif (!kill_shell && !check_required_directories (application)) {\n\t\treturn;\n\t}\n\n\tif (kill_shell) {\n\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t UNIQUE_CLOSE, NULL);\n\t\t\t\n\t\t}\n\t} else {\n\t\t/* If KDE desktop is running, then force no_desktop */\n\t\tif (is_kdesktop_present ()) {\n\t\t\tno_desktop = TRUE;\n\t\t}\n\t\t\n\t\tif (!no_desktop && eel_preferences_get_boolean (NAUTILUS_PREFERENCES_SHOW_DESKTOP)) {\n\t\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t COMMAND_START_DESKTOP, NULL);\n\t\t\t} else {\n\t\t\t\tnautilus_application_open_desktop (application);\n\t\t\t}\n\t\t}\n\n\t\tif (!unique_app_is_running (application->unique_app)) {\n\t\t\tfinish_startup (application);\n\t\t\tg_signal_connect (application->unique_app, \"message-received\", G_CALLBACK (message_received_cb), application);\t\t\t\n\t\t}\n\t\t\n\t\t/* Monitor the preference to show or hide the desktop */\n\t\teel_preferences_add_callback_while_alive (NAUTILUS_PREFERENCES_SHOW_DESKTOP,\n\t\t\t\t\t\t\t  desktop_changed_callback,\n\t\t\t\t\t\t\t  application,\n\t\t\t\t\t\t\t  G_OBJECT (application));\n\n\t\t/* Monitor the preference to have the desktop */\n\t\t/* point to the Unix home folder */\n\t\teel_preferences_add_callback_while_alive (NAUTILUS_PREFERENCES_DESKTOP_IS_HOME_DIR,\n\t\t\t\t\t\t\t  desktop_location_changed_callback,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  G_OBJECT (application));\n\n\t  \t/* Create the other windows. */\n\t\tif (urls != NULL || !no_default_window) {\n\t\t\tif (unique_app_is_running (application->unique_app)) {\n\t\t\t\tmessage = unique_message_data_new ();\n\t\t\t\t_unique_message_data_set_geometry_and_uris (message, geometry, urls);\n\t\t\t\tif (browser_window) {\n\t\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t\t COMMAND_OPEN_BROWSER, message);\n\t\t\t\t} else {\n\t\t\t\t\tunique_app_send_message (application->unique_app,\n\t\t\t\t\t\t\t\t UNIQUE_OPEN, message);\n\t\t\t\t}\n\t\t\t\tunique_message_data_free (message);\t\t\t\t\n\t\t\t} else {\n\t\t\t\topen_windows (application, NULL,\n\t\t\t\t\t      urls,\n\t\t\t\t\t      geometry,\n\t\t\t\t\t      browser_window);\n\t\t\t}\n\t\t}\n\n\t\t/* Load session info if availible */\n\t\tnautilus_application_load_session (application);\n\t}\n}", "target": 1, "cwe": [], "message": "Add \"interactive\" argument to nautilus_file_mark_desktop_file_trusted.\n\n2009-02-24  Alexander Larsson  <alexl@redhat.com>\n\n        * libnautilus-private/nautilus-file-operations.c:\n        * libnautilus-private/nautilus-file-operations.h:\n        * libnautilus-private/nautilus-mime-actions.c:\n        Add \"interactive\" argument to\n\tnautilus_file_mark_desktop_file_trusted.\n\n        * src/nautilus-application.c:\n\tMark all desktopfiles on the desktop trusted on first\n\trun.\n\n\n\nsvn path=/trunk/; revision=15009"}
{"func": "copy_job_done (gpointer user_data)\n{\n\tCopyMoveJob *job;\n\n\tjob = user_data;\n\tif (job->done_callback) {\n\t\tjob->done_callback (job->debuting_files, job->done_callback_data);\n\t}\n\n\teel_g_object_list_free (job->files);\n\tif (job->destination) {\n\t\tg_object_unref (job->destination);\n\t}\n\tg_hash_table_unref (job->debuting_files);\n\tg_free (job->icon_positions);\n\t\n\tfinalize_common ((CommonJob *)job);\n\n\tnautilus_file_changes_consume_changes (TRUE);\n\treturn FALSE;\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "mark_desktop_files_trusted (void)\n{\n\tchar *user_dir, *do_once_file;\n\tGFile *f, *c;\n\tGFileEnumerator *e;\n\tGFileInfo *info;\n\tconst char *name;\n\tint fd;\n\t\n\tuser_dir = nautilus_get_user_directory ();\n\tdo_once_file = g_build_filename (user_dir, \"converted-launchers\", NULL);\n\tg_free (user_dir);\n\n\tif (g_file_test (do_once_file, G_FILE_TEST_EXISTS)) {\n\t\tgoto out;\n\t}\n\n\tf = nautilus_get_desktop_location ();\n\te = g_file_enumerate_children (f,\n\t\t\t\t       G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n\t\t\t\t       G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t       G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE\n\t\t\t\t       ,\n\t\t\t\t       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t       NULL, NULL);\n\tif (e == NULL) {\n\t\tgoto out2;\n\t}\n\t\n\twhile ((info = g_file_enumerator_next_file (e, NULL, NULL)) != NULL) {\n\t\tname = g_file_info_get_name (info);\n\t\t\n\t\tif (g_str_has_suffix (name, \".desktop\") &&\n\t\t    !g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE)) {\n\t\t\tc = g_file_get_child (f, name);\n\t\t\tnautilus_file_mark_desktop_file_trusted (c,\n\t\t\t\t\t\t\t\t NULL, FALSE,\n\t\t\t\t\t\t\t\t NULL, NULL);\n\t\t\tg_object_unref (c);\n\t\t}\n\t\tg_object_unref (info);\n\t}\n\t\n\tg_object_unref (e);\n out2:\n\tfd = g_creat (do_once_file, 0666);\n\tclose (fd);\n\t\n\tg_object_unref (f);\n out:\t\n\tg_free (do_once_file);\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "nautilus_file_operations_copy (GList *files,\n\t\t\t       GArray *relative_item_points,\n\t\t\t       GFile *target_dir,\n\t\t\t       GtkWindow *parent_window,\n\t\t\t       NautilusCopyCallback  done_callback,\n\t\t\t       gpointer done_callback_data)\n{\n\tCopyMoveJob *job;\n\n\tjob = op_job_new (CopyMoveJob, parent_window);\n\tjob->done_callback = done_callback;\n\tjob->done_callback_data = done_callback_data;\n\tjob->files = eel_g_object_list_copy (files);\n\tjob->destination = g_object_ref (target_dir);\n\tif (relative_item_points != NULL &&\n\t    relative_item_points->len > 0) {\n\t\tjob->icon_positions =\n\t\t\tg_memdup (relative_item_points->data,\n\t\t\t\t  sizeof (GdkPoint) * relative_item_points->len);\n\t\tjob->n_icon_positions = relative_item_points->len;\n\t}\n\tjob->debuting_files = g_hash_table_new_full (g_file_hash, (GEqualFunc)g_file_equal, g_object_unref, NULL);\n\n\tg_io_scheduler_push_job (copy_job,\n\t\t\t   job,\n\t\t\t   NULL, /* destroy notify */\n\t\t\t   0,\n\t\t\t   job->common.cancellable);\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "mark_trusted_job (GIOSchedulerJob *io_job,\n\t\t  GCancellable *cancellable,\n\t\t  gpointer user_data)\n{\n\tMarkTrustedJob *job = user_data;\n\tCommonJob *common;\n\tchar *contents, *new_contents;\n\tgsize length, new_length;\n\tGError *error;\n\tguint32 current;\n\tint response;\n\tGFileInfo *info;\n\t\n\tcommon = (CommonJob *)job;\n\tcommon->io_job = io_job;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\n retry:\n\terror = NULL;\n\tif (!g_file_load_contents (job->file,\n\t\t\t\t  cancellable,\n\t\t\t\t  &contents, &length,\n\t\t\t\t  NULL, &error)) {\n\t\tif (job->interactive) {\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tresponse = 0;\n\t\t}\n\t\t\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!g_str_has_prefix (contents, \"#!\")) {\n\t\tnew_length = length + strlen (TRUSTED_SHEBANG);\n\t\tnew_contents = g_malloc (new_length);\n\t\t\n\t\tstrcpy (new_contents, TRUSTED_SHEBANG);\n\t\tmemcpy (new_contents + strlen (TRUSTED_SHEBANG),\n\t\t\tcontents, length);\n\t\t\n\t\tif (!g_file_replace_contents (job->file,\n\t\t\t\t\t      new_contents,\n\t\t\t\t\t      new_length,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE, 0,\n\t\t\t\t\t      NULL, cancellable, &error)) {\n\t\t\tg_free (contents);\n\t\t\tg_free (new_contents);\n\t\t\t\n\t\t\tif (job->interactive) {\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t} else {\n\t\t\t\tresponse = 0;\n\t\t\t}\n\n\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\tabort_job (common);\n\t\t\t} else if (response == 1) {\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tg_free (new_contents);\n\t\t\n\t}\n\tg_free (contents);\n\t\n\tinfo = g_file_query_info (job->file,\n\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_TYPE\",\"\n\t\t\t\t  G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t  common->cancellable,\n\t\t\t\t  &error);\n\n\tif (info == NULL) {\n\t\tif (job->interactive) {\n\t\t\tresponse = run_error (common,\n\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t      error->message,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      FALSE,\n\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tresponse = 0;\n\t\t}\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (common);\n\t\t} else if (response == 1) {\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\t\n\t\tgoto out;\n\t}\n\t\n\t\n\tif (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE)) {\n\t\tcurrent = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n\t\tcurrent = current | S_IXGRP | S_IXUSR | S_IXOTH;\n\n\t\tif (!g_file_set_attribute_uint32 (job->file, G_FILE_ATTRIBUTE_UNIX_MODE,\n\t\t\t\t\t\t  current, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t  common->cancellable, &error))\n\t\t\t{\n\t\t\t\tg_object_unref (info);\n\t\t\t\t\n\t\t\t\tresponse = run_error (common,\n\t\t\t\t\t\t      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n\t\t\t\t\t\t      error->message,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      FALSE,\n\t\t\t\t\t\t      GTK_STOCK_CANCEL, RETRY,\n\t\t\t\t\t\t      NULL);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (common);\n\t\t\t\t} else if (response == 1) {\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tgoto out;\n\t\t\t}\n\t} \n\tg_object_unref (info);\n\nout:\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   mark_trusted_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "copy_move_file (CopyMoveJob *copy_job,\n\t\tGFile *src,\n\t\tGFile *dest_dir,\n\t\tgboolean same_fs,\n\t\tgboolean unique_names,\n\t\tchar **dest_fs_type,\n\t\tSourceInfo *source_info,\n\t\tTransferInfo *transfer_info,\n\t\tGHashTable *debuting_files,\n\t\tGdkPoint *position,\n\t\tgboolean overwrite,\n\t\tgboolean *skipped_file,\n\t\tgboolean readonly_source_fs)\n{\n\tGFile *dest, *new_dest;\n\tGError *error;\n\tGFileCopyFlags flags;\n\tchar *primary, *secondary, *details;\n\tint response;\n\tProgressData pdata;\n\tgboolean would_recurse, is_merge;\n\tCommonJob *job;\n\tgboolean res;\n\tint unique_name_nr;\n\tgboolean handled_invalid_filename;\n\n\tjob = (CommonJob *)copy_job;\n\t\n\tif (should_skip_file (job, src)) {\n\t\t*skipped_file = TRUE;\n\t\treturn;\n\t}\n\n\tunique_name_nr = 1;\n\n\t/* another file in the same directory might have handled the invalid\n\t * filename condition for us\n\t */\n\thandled_invalid_filename = *dest_fs_type != NULL;\n\n\tif (unique_names) {\n\t\tdest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n\t} else {\n\t\tdest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\t}\n\n\n\t/* Don't allow recursive move/copy into itself.  \n\t * (We would get a file system error if we proceeded but it is nicer to \n\t * detect and report it at this level) */\n\tif (test_dir_is_parent (dest_dir, src)) {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\t/*  the run_warning() frees all strings passed in automatically  */\n\t\tprimary = copy_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n\t\t\t\t\t    : g_strdup (_(\"You cannot copy a folder into itself.\"));\n\t\tsecondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t/* Don't allow copying over the source or one of the parents of the source.\n\t */\n\tif (test_dir_is_parent (src, dest)) {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\t/*  the run_warning() frees all strings passed in automatically  */\n\t\tprimary = copy_job->is_move ? g_strdup (_(\"You cannot move a file over itself.\"))\n\t\t\t\t\t    : g_strdup (_(\"You cannot copy a file over itself.\"));\n\t\tsecondary = g_strdup (_(\"The source file would be overwritten by the destination.\"));\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t\n retry:\n\t\n\terror = NULL;\n\tflags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n\tif (overwrite) {\n\t\tflags |= G_FILE_COPY_OVERWRITE;\n\t}\n\tif (readonly_source_fs) {\n\t\tflags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;\n\t}\n\n\tpdata.job = copy_job;\n\tpdata.last_size = 0;\n\tpdata.source_info = source_info;\n\tpdata.transfer_info = transfer_info;\n\n\tif (copy_job->is_move) {\n\t\tres = g_file_move (src, dest,\n\t\t\t\t   flags,\n\t\t\t\t   job->cancellable,\n\t\t\t\t   copy_file_progress_callback,\n\t\t\t\t   &pdata,\n\t\t\t\t   &error);\n\t} else {\n\t\tres = g_file_copy (src, dest,\n\t\t\t\t   flags,\n\t\t\t\t   job->cancellable,\n\t\t\t\t   copy_file_progress_callback,\n\t\t\t\t   &pdata,\n\t\t\t\t   &error);\n\t}\n\t\n\tif (res) {\n\t\ttransfer_info->num_files ++;\n\t\treport_copy_progress (copy_job, source_info, transfer_info);\n\n\t\tif (debuting_files) {\n\t\t\tif (copy_job->is_move) {\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_move (src, dest);\n\t\t\t} else {\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_copy (src, dest);\n\t\t\t}\n\t\t\tif (position) {\n\t\t\t\tnautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n\t\t\t} else {\n\t\t\t\tnautilus_file_changes_queue_schedule_position_remove (dest);\n\t\t\t}\n\t\t\t\n\t\t\tg_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n\t\t}\n\t\tif (copy_job->is_move) {\n\t\t\tnautilus_file_changes_queue_file_moved (src, dest);\n\t\t} else {\n\t\t\tnautilus_file_changes_queue_file_added (dest);\n\t\t}\n\t\tg_object_unref (dest);\n\t\treturn;\n\t}\n\n\tif (!handled_invalid_filename &&\n\t    IS_IO_ERROR (error, INVALID_FILENAME)) {\n\t\thandled_invalid_filename = TRUE;\n\n\t\tg_assert (*dest_fs_type == NULL);\n\t\t*dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n\t\tif (unique_names) {\n\t\t\tnew_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);\n\t\t} else {\n\t\t\tnew_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n\t\t}\n\n\t\tif (!g_file_equal (dest, new_dest)) {\n\t\t\tg_object_unref (dest);\n\t\t\tdest = new_dest;\n\n\t\t\tg_error_free (error);\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_object_unref (new_dest);\n\t\t}\n\t}\n\n\t/* Conflict */\n\tif (!overwrite &&\n\t    IS_IO_ERROR (error, EXISTS)) {\n\t\tgboolean is_merge;\n\n\t\tif (unique_names) {\n\t\t\tg_object_unref (dest);\n\t\t\tdest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n\t\t\tg_error_free (error);\n\t\t\tgoto retry;\n\t\t}\n\t\t\n\t\tis_merge = FALSE;\n\t\tif (is_dir (dest)) {\n\t\t\tif (is_dir (src)) {\n\t\t\t\tis_merge = TRUE;\n\t\t\t\tprimary = f (_(\"A folder named \\\"%B\\\" already exists.  Do you want to merge the source folder?\"), \n\t\t\t\t\t     dest);\n\t\t\t\tsecondary = f (_(\"The source folder already exists in \\\"%B\\\".  \"\n\t\t\t\t\t\t \"Merging will ask for confirmation before replacing any files in the folder that conflict with the files being copied.\"), \n\t\t\t\t\t       dest_dir);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tprimary = f (_(\"A folder named \\\"%B\\\" already exists.  Do you want to replace it?\"), \n\t\t\t\t\t\t\t    dest);\n\t\t\t\tsecondary = f (_(\"The folder already exists in \\\"%F\\\".  \"\n\t\t\t\t\t\t \"Replacing it will remove all files in the folder.\"), \n\t\t\t\t\t       dest_dir);\n\t\t\t}\n\t\t} else {\n\t\t\tprimary = f (_(\"A file named \\\"%B\\\" already exists.  Do you want to replace it?\"), \n\t\t\t\t     dest);\n\t\t\tsecondary = f (_(\"The file already exists in \\\"%F\\\".  \"\n\t\t\t\t\t \"Replacing it will overwrite its content.\"), \n\t\t\t\t       dest_dir);\n\t\t}\n\n\t\tif ((is_merge && job->merge_all) ||\n\t\t    (!is_merge && job->replace_all)) {\n\t\t\tg_free (primary);\n\t\t\tg_free (secondary);\n\t\t\tg_error_free (error);\n\t\t\t\n\t\t\toverwrite = TRUE;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (job->skip_all_conflict) {\n\t\t\tg_free (primary);\n\t\t\tg_free (secondary);\n\t\t\tg_error_free (error);\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tNULL,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL,\n\t\t\t\t\tSKIP_ALL,\n\t\t\t\t\tis_merge?MERGE_ALL:REPLACE_ALL,\n\t\t\t\t\tSKIP,\n\t\t\t\t\tis_merge?MERGE:REPLACE,\n\t\t\t\t\tNULL);\n\t\t\n\t\tg_error_free (error);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1 || response == 3) { /* skip all / skip */\n\t\t\tif (response == 1) {\n\t\t\t\tjob->skip_all_conflict = TRUE;\n\t\t\t}\n\t\t} else if (response == 2 || response == 4) { /* merge/replace all  / merge/replace*/\n\t\t\tif (response == 2) {\n\t\t\t\tif (is_merge) {\n\t\t\t\t\tjob->merge_all = TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tjob->replace_all = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\toverwrite = TRUE;\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\telse if (overwrite &&\n\t\t IS_IO_ERROR (error, IS_DIRECTORY)) {\n\n\t\tg_error_free (error);\n\t\t\n\t\tif (remove_target_recursively (job, src, dest, dest)) {\n\t\t\tgoto retry;\n\t\t}\n\t}\n\t\n\t/* Needs to recurse */\n\telse if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n\t\t IS_IO_ERROR (error, WOULD_MERGE)) {\n\t\tis_merge = error->code == G_IO_ERROR_WOULD_MERGE;\n\t\twould_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;\n\t\tg_error_free (error);\n\n\t\tif (overwrite && would_recurse) {\n\t\t\terror = NULL;\n\t\t\t\n\t\t\t/* Copying a dir onto file, first remove the file */\n\t\t\tif (!g_file_delete (dest, job->cancellable, &error) &&\n\t\t\t    !IS_IO_ERROR (error, NOT_FOUND)) {\n\t\t\t\tif (job->skip_all_error) {\n\t\t\t\t\tg_error_free (error);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (copy_job->is_move) {\n\t\t\t\t\tprimary = f (_(\"Error while moving \\\"%B\\\".\"), src);\n\t\t\t\t} else {\n\t\t\t\t\tprimary = f (_(\"Error while copying \\\"%B\\\".\"), src);\n\t\t\t\t}\n\t\t\t\tsecondary = f (_(\"Could not remove the already existing file with the same name in %F.\"), dest_dir);\n\t\t\t\tdetails = error->message;\n\n\t\t\t\t/* setting TRUE on show_all here, as we could have\n\t\t\t\t * another error on the same file later.\n\t\t\t\t */\n\t\t\t\tresponse = run_warning (job,\n\t\t\t\t\t\t\tprimary,\n\t\t\t\t\t\t\tsecondary,\n\t\t\t\t\t\t\tdetails,\n\t\t\t\t\t\t\tTRUE,\n\t\t\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\t\t\tNULL);\n\t\t\t\t\n\t\t\t\tg_error_free (error);\n\t\t\t\t\n\t\t\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\t\t\tabort_job (job);\n\t\t\t\t} else if (response == 1) { /* skip all */\n\t\t\t\t\tjob->skip_all_error = TRUE;\n\t\t\t\t} else if (response == 2) { /* skip */\n\t\t\t\t\t/* do nothing */\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tg_error_free (error);\n\t\t\t\terror = NULL;\n\t\t\t}\n\t\t\tif (debuting_files) { /* Only remove metadata for toplevel items */\n\t\t\t\tnautilus_file_changes_queue_schedule_metadata_remove (dest);\n\t\t\t}\n\t\t\tnautilus_file_changes_queue_file_removed (dest);\n\t\t}\n\n\t\tif (is_merge) {\n\t\t\t/* On merge we now write in the target directory, which may not\n\t\t\t   be in the same directory as the source, even if the parent is\n\t\t\t   (if the merged directory is a mountpoint). This could cause\n\t\t\t   problems as we then don't transcode filenames.\n\t\t\t   We just set same_fs to FALSE which is safe but a bit slower. */\n\t\t\tsame_fs = FALSE;\n\t\t}\n\t\t\n\t\tif (!copy_move_directory (copy_job, src, &dest, same_fs,\n\t\t\t\t\t  would_recurse, dest_fs_type,\n\t\t\t\t\t  source_info, transfer_info,\n\t\t\t\t\t  debuting_files, skipped_file,\n\t\t\t\t\t  readonly_source_fs)) {\n\t\t\t/* destination changed, since it was an invalid file name */\n\t\t\tg_assert (*dest_fs_type != NULL);\n\t\t\thandled_invalid_filename = TRUE;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tg_object_unref (dest);\n\t\treturn;\n\t}\n\t\n\telse if (IS_IO_ERROR (error, CANCELLED)) {\n\t\tg_error_free (error);\n\t}\n\t\n\t/* Other error */\n\telse {\n\t\tif (job->skip_all_error) {\n\t\t\tg_error_free (error);\n\t\t\tgoto out;\n\t\t}\n\t\tprimary = f (_(\"Error while copying \\\"%B\\\".\"), src);\n\t\tsecondary = f (_(\"There was an error copying the file into %F.\"), dest_dir);\n\t\tdetails = error->message;\n\t\t\n\t\tresponse = run_warning (job,\n\t\t\t\t\tprimary,\n\t\t\t\t\tsecondary,\n\t\t\t\t\tdetails,\n\t\t\t\t\t(source_info->num_files - transfer_info->num_files) > 1,\n\t\t\t\t\tGTK_STOCK_CANCEL, SKIP_ALL, SKIP,\n\t\t\t\t\tNULL);\n\n\t\tg_error_free (error);\n\t\t\n\t\tif (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) {\n\t\t\tabort_job (job);\n\t\t} else if (response == 1) { /* skip all */\n\t\t\tjob->skip_all_error = TRUE;\n\t\t} else if (response == 2) { /* skip */\n\t\t\t/* do nothing */\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n out:\n\t*skipped_file = TRUE; /* Or aborted, but same-same */\n\tg_object_unref (dest);\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "copy_job (GIOSchedulerJob *io_job,\n\t  GCancellable *cancellable,\n\t  gpointer user_data)\n{\n\tCopyMoveJob *job;\n\tCommonJob *common;\n\tSourceInfo source_info;\n\tTransferInfo transfer_info;\n\tchar *dest_fs_id;\n\tGFile *dest;\n\n\tjob = user_data;\n\tcommon = &job->common;\n\tcommon->io_job = io_job;\n\n\tdest_fs_id = NULL;\n\t\n\tnautilus_progress_info_start (job->common.progress);\n\t\n\tscan_sources (job->files,\n\t\t      &source_info,\n\t\t      common,\n\t\t      OP_KIND_COPY);\n\tif (job_aborted (common)) {\n\t\tgoto aborted;\n\t}\n\n\tif (job->destination) {\n\t\tdest = g_object_ref (job->destination);\n\t} else {\n\t\t/* Duplication, no dest,\n\t\t * use source for free size, etc\n\t\t */\n\t\tdest = g_file_get_parent (job->files->data);\n\t}\n\t\n\tverify_destination (&job->common,\n\t\t\t    dest,\n\t\t\t    &dest_fs_id,\n\t\t\t    source_info.num_bytes);\n\tg_object_unref (dest);\n\tif (job_aborted (common)) {\n\t\tgoto aborted;\n\t}\n\n\tg_timer_start (job->common.time);\n\t\n\tmemset (&transfer_info, 0, sizeof (transfer_info));\n\tcopy_files (job,\n\t\t    dest_fs_id,\n\t\t    &source_info, &transfer_info);\n\t\n aborted:\n\t\n\tg_free (dest_fs_id);\n\t\n\tg_io_scheduler_job_send_to_mainloop_async (io_job,\n\t\t\t\t\t\t   copy_job_done,\n\t\t\t\t\t\t   job,\n\t\t\t\t\t\t   NULL);\n\n\treturn FALSE;\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "is_link_trusted (NautilusFile *file,\n\t\t gboolean is_launcher)\n{\n\tgboolean res;\n\t\n\tif (!is_launcher) {\n\t\treturn TRUE;\n\t}\n\t\n\tif (nautilus_file_can_execute (file)) {\n\t\treturn TRUE;\n\t}\n\n\tres = FALSE;\n\t\n\tif (nautilus_file_is_local (file)) {\n\t\tconst char * const * data_dirs; \n\t\tchar *uri, *path;\n\t\tint i;\n\t\t\t\n\t\tdata_dirs = g_get_system_data_dirs ();\n\t\t\n\t\tpath = NULL;\n\t\turi = nautilus_file_get_uri (file);\n\t\tif (uri) {\n\t\t\tpath = g_filename_from_uri (uri, NULL, NULL);\n\t\t\tg_free (uri);\n\t\t}\n\n\t\tfor (i = 0; path != NULL && data_dirs[i] != NULL; i++) {\n\t\t\tif (g_str_has_prefix (path, data_dirs[i])) {\n\t\t\t\tres = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tg_free (path);\n\t}\n\t\n\t\n\treturn res;\n}", "target": 1, "cwe": [], "message": "Use $XDG_DATA_HOME/.converted-launchers as marker for one-time desktop\n\n2009-02-25  Alexander Larsson  <alexl@redhat.com>\n\n        * src/nautilus-application.c:\n\tUse $XDG_DATA_HOME/.converted-launchers as marker for\n\tone-time desktop file trust operation.\n\n        * libnautilus-private/nautilus-file-utilities.[ch]:\n\tAdd nautilus_is_in_system_dir() to check if path is in\n\tXDG_DATA_DIR or in ~/.gnome2.\n\n        * libnautilus-private/nautilus-directory-async.c:\n        (is_link_trusted):\n\tUse new nautilus_is_in_system_dir() instead of open coding it.\n\n        * libnautilus-private/nautilus-file-operations.c:\n\tWhen copying a desktop file from a trusted location to the desktop,\n\tmark it as trusted.\n\n\nsvn path=/trunk/; revision=15018"}
{"func": "nautilus_link_get_link_info_given_file_contents (const char  *file_contents,\n\t\t\t\t\t\t int          link_file_size,\n\t\t\t\t\t\t const char  *file_uri,\n\t\t\t\t\t\t char       **uri,\n\t\t\t\t\t\t char       **name,\n\t\t\t\t\t\t char       **icon,\n\t\t\t\t\t\t gboolean    *is_launcher,\n\t\t\t\t\t\t gboolean    *is_foreign)\n{\n\tGKeyFile *key_file;\n\tchar *type;\n\tchar **only_show_in;\n\tchar **not_show_in;\n\n\tif (!is_link_data (file_contents, link_file_size)) {\n\t\treturn;\n\t}\n\n\tkey_file = g_key_file_new ();\n\tif (!g_key_file_load_from_data (key_file,\n\t\t\t\t\tfile_contents,\n\t\t\t\t\tlink_file_size,\n\t\t\t\t\tG_KEY_FILE_NONE,\n\t\t\t\t\tNULL)) {\n\t\tg_key_file_free (key_file);\n\t\treturn; \n\t}\n\n\t*uri = nautilus_link_get_link_uri_from_desktop (key_file, file_uri);\n\t*name = nautilus_link_get_link_name_from_desktop (key_file);\n\t*icon = nautilus_link_get_link_icon_from_desktop (key_file);\n\n\t*is_launcher = FALSE;\n\ttype = g_key_file_get_string (key_file, MAIN_GROUP, \"Type\", NULL);\n\tif (g_strcmp0 (type, \"Application\") == 0 &&\n\t    g_key_file_has_key (key_file, MAIN_GROUP, \"Exec\", NULL)) {\n\t\t*is_launcher = TRUE;\n\t}\n\tg_free (type);\n\n\t*is_foreign = FALSE;\n\tonly_show_in = g_key_file_get_string_list (key_file, MAIN_GROUP,\n\t\t\t\t\t\t   \"OnlyShowIn\", NULL, NULL);\n\tif (only_show_in && !string_array_contains (only_show_in, \"GNOME\")) {\n\t\t*is_foreign = TRUE;\n\t}\n\tg_strfreev (only_show_in);\n\n\tnot_show_in = g_key_file_get_string_list (key_file, MAIN_GROUP,\n\t\t\t\t\t\t  \"NotShowIn\", NULL, NULL);\n\tif (not_show_in && string_array_contains (not_show_in, \"GNOME\")) {\n\t\t*is_foreign = TRUE;\n\t}\n\tg_strfreev (not_show_in);\n\n\tg_key_file_free (key_file);\n}", "target": 1, "cwe": [], "message": "Bug 573991 \u2013 Nautilus does not recognize some .desktop files as\n\n2009-03-04  Alexander Larsson  <alexl@redhat.com>\n\n\tBug 573991 \u2013 Nautilus does not recognize some .desktop files as launchers\n\n        * libnautilus-private/nautilus-link.c:\n        (nautilus_link_get_link_info_given_file_contents):\n\tDon't try to sniff the contents, we'll handle that when parsing anyway.\n\tAnd sniffing breaks if there are too much comments before the first group in\n\tthe desktop file.\n\n\n\nsvn path=/trunk/; revision=15052"}
{"func": "is_link_data (const char *file_contents, int file_size)\n{\n\tchar *mimetype;\n\tgboolean res;\n\n\tmimetype = g_content_type_guess (NULL, file_contents, file_size, NULL);\n\tres =  is_link_mime_type (mimetype);\n\tg_free (mimetype);\n\treturn res;\n}", "target": 1, "cwe": [], "message": "Bug 573991 \u2013 Nautilus does not recognize some .desktop files as\n\n2009-03-04  Alexander Larsson  <alexl@redhat.com>\n\n\tBug 573991 \u2013 Nautilus does not recognize some .desktop files as launchers\n\n        * libnautilus-private/nautilus-link.c:\n        (nautilus_link_get_link_info_given_file_contents):\n\tDon't try to sniff the contents, we'll handle that when parsing anyway.\n\tAnd sniffing breaks if there are too much comments before the first group in\n\tthe desktop file.\n\n\n\nsvn path=/trunk/; revision=15052"}
{"func": "static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr, *map;\n\n\t\tkaddr = map = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(map);\n\t}\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "fuse: fix kunmap in fuse_ioctl_copy_user\n\nLooks like another victim of the confusing kmap() vs kmap_atomic() API\ndifferences.\n\nReported-by: Todor Gyumyushev <yodor1@gmail.com>\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCc: Tejun Heo <tj@kernel.org>\nCc: stable@kernel.org"}
{"func": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tchar *line;\n\n\tprogname = basename(argv[0]);\n\n#if POSIXLY_CORRECT\n\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#else\n\tif (getenv(POSIXLY_CORRECT_STR))\n\t\tposixly_correct = 1;\n\tif (!posixly_correct)\n\t\tcmd_line_options = CMD_LINE_OPTIONS;\n\telse\n\t\tcmd_line_options = POSIXLY_CMD_LINE_OPTIONS;\n#endif\n\n\tsetlocale(LC_CTYPE, \"\");\n\tsetlocale(LC_MESSAGES, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\n\t/* Align `#effective:' comments to column 40 for tty's */\n\tif (!posixly_correct && isatty(fileno(stdout)))\n\t\tprint_options |= TEXT_SMART_INDENT;\n\n\twhile ((opt = getopt_long(argc, argv, cmd_line_options,\n\t\t                 long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\t\tcase 'a':  /* acl only */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_print_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd':  /* default acl only */\n\t\t\t\topt_print_default_acl = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':  /* no comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_comments = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 'e':  /* all #effective comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options |= TEXT_ALL_EFFECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'E':  /* no #effective comments */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\tprint_options &= ~(TEXT_SOME_EFFECTIVE |\n\t\t\t\t                   TEXT_ALL_EFFECTIVE);\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':  /* recursive */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_RECURSIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'L':  /* follow all symlinks */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_LOGICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_PHYSICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 'P':  /* skip all symlinks */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\twalk_flags |= WALK_TREE_PHYSICAL;\n\t\t\t\twalk_flags &= ~WALK_TREE_LOGICAL;\n\t\t\t\tbreak;\n\n\t\t\tcase 's':  /* skip files with only base entries */\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_skip_base = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_strip_leading_slash = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tif (posixly_correct)\n\t\t\t\t\tgoto synopsis;\n\t\t\t\topt_tabular = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':  /* numeric */\n\t\t\t\topt_numeric = 1;\n\t\t\t\tprint_options |= TEXT_NUMERIC_IDS;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':  /* print version */\n\t\t\t\tprintf(\"%s \" VERSION \"\\n\", progname);\n\t\t\t\treturn 0;\n\n\t\t\tcase 'h':  /* help */\n\t\t\t\thelp();\n\t\t\t\treturn 0;\n\n\t\t\tcase ':':  /* option missing */\n\t\t\tcase '?':  /* unknown option */\n\t\t\tdefault:\n\t\t\t\tgoto synopsis;\n\t\t}\n\t}\n\n\tif (!(opt_print_acl || opt_print_default_acl)) {\n\t\topt_print_acl = 1;\n\t\tif (!posixly_correct)\n\t\t\topt_print_default_acl = 1;\n\t}\n\t\t\n\tif ((optind == argc) && !posixly_correct)\n\t\tgoto synopsis;\n\n\tdo {\n\t\tif (optind == argc ||\n\t\t    strcmp(argv[optind], \"-\") == 0) {\n\t\t\twhile ((line = next_line(stdin)) != NULL) {\n\t\t\t\tif (*line == '\\0')\n\t\t\t\t\tcontinue;\n\n\t\t\t\thad_errors += walk_tree(line, walk_flags, 0,\n\t\t\t\t\t\t\tdo_print, NULL);\n\t\t\t}\n\t\t\tif (!feof(stdin)) {\n\t\t\t\tfprintf(stderr, _(\"%s: Standard input: %s\\n\"),\n\t\t\t\t        progname, strerror(errno));\n\t\t\t\thad_errors++;\n\t\t\t}\n\t\t} else\n\t\t\thad_errors += walk_tree(argv[optind], walk_flags, 0,\n\t\t\t\t\t\tdo_print, NULL);\n\t\toptind++;\n\t} while (optind < argc);\n\n\treturn had_errors ? 1 : 0;\n\nsynopsis:\n\tfprintf(stderr, _(\"Usage: %s [-%s] file ...\\n\"),\n\t        progname, cmd_line_options);\n\tfprintf(stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t\tprogname);\n\treturn 2;\n}", "target": 1, "cwe": [], "message": "Make sure that getfacl -R only calls stat(2) on symlinks when it needs to\n\nThis fixes http://oss.sgi.com/bugzilla/show_bug.cgi?id=790\n\"getfacl follows symlinks, even without -L\"."}
{"func": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\te = insize-(o = (posbits>>3));\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}", "target": 1, "cwe": ["CWE-189"], "message": "gzip -d: do not clobber stack for valid input on x86_64\n\n* unlzw.c (unlzw): Avoid integer overflow.\nAki Helin reported the segfault along with an input to trigger the bug.\n* NEWS (Bug fixes): Mention it."}
{"func": "_hb_ot_layout_init (hb_face_t *face)\n{\n  hb_ot_layout_t *layout = &face->ot_layout;\n\n  layout->gdef_blob = Sanitizer<GDEF>::sanitize (hb_face_get_table (face, HB_OT_TAG_GDEF));\n  layout->gdef = &Sanitizer<GDEF>::lock_instance (layout->gdef_blob);\n\n  layout->gsub_blob = Sanitizer<GSUB>::sanitize (hb_face_get_table (face, HB_OT_TAG_GSUB));\n  layout->gsub = &Sanitizer<GSUB>::lock_instance (layout->gsub_blob);\n\n  layout->gpos_blob = Sanitizer<GPOS>::sanitize (hb_face_get_table (face, HB_OT_TAG_GPOS));\n  layout->gpos = &Sanitizer<GPOS>::lock_instance (layout->gpos_blob);\n}", "target": 1, "cwe": ["CWE-119"], "message": "[HB/GDEF] Fix bug in building synthetic GDEF table"}
{"func": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n\n  hb_ot_layout_t *layout = &face->ot_layout;\n\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1, "cwe": ["CWE-119"], "message": "[HB/GDEF] Fix bug in building synthetic GDEF table"}
{"func": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n\n    /* \n     * Process certain standard device requests.\n     * These are infrequent and are processed synchronously.\n     */\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n\n    /* The rest are asynchronous */\n\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n\n    /* \n     * Setup ctrl transfer.\n     *\n     * s->ctrl is layed out such that data buffer immediately follows\n     * 'req' struct which is exactly what usbdevfs expects.\n     */ \n    urb = &aurb->urb;\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = 8 + s->ctrl.len;\n\n    urb->usercontext = s;\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}", "target": 1, "cwe": ["CWE-119"], "message": "usb-linux.c: fix buffer overflow\n\nIn usb-linux.c:usb_host_handle_control, we pass a 1024-byte buffer and\nlength to the kernel.  However, the length was provided by the caller\nof dev->handle_packet, and is not checked, so the kernel might provide\ntoo much data and overflow our buffer.\n\nFor example, hw/usb-uhci.c could set the length to 2047.\nhw/usb-ohci.c looks like it might go up to 4096 or 8192.\n\nThis causes a qemu crash, as reported here:\n  http://www.mail-archive.com/kvm@vger.kernel.org/msg18447.html\n\nThis patch increases the usb-linux.c buffer size to 2048 to fix the\nspecific device reported, and adds a check to avoid the overflow in\nany case.\n\nSigned-off-by: Jim Paris <jim@jtan.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>"}
{"func": "gs_manager_create_window_for_monitor (GSManager *manager,\n                                      GdkScreen *screen,\n                                      int        monitor)\n{\n        GSWindow    *window;\n        GdkRectangle rect;\n\n        gdk_screen_get_monitor_geometry (screen, monitor, &rect);\n\n        gs_debug (\"Creating window for monitor %d [%d,%d] (%dx%d)\",\n                  monitor, rect.x, rect.y, rect.width, rect.height);\n\n        window = gs_window_new (screen, monitor, manager->priv->lock_active);\n\n        gs_window_set_user_switch_enabled (window, manager->priv->user_switch_enabled);\n        gs_window_set_logout_enabled (window, manager->priv->logout_enabled);\n        gs_window_set_logout_timeout (window, manager->priv->logout_timeout);\n        gs_window_set_logout_command (window, manager->priv->logout_command);\n        gs_window_set_keyboard_enabled (window, manager->priv->keyboard_enabled);\n        gs_window_set_keyboard_command (window, manager->priv->keyboard_command);\n        gs_window_set_status_message (window, manager->priv->status_message);\n\n        connect_window_signals (manager, window);\n\n        manager->priv->windows = g_slist_append (manager->priv->windows, window);\n}", "target": 1, "cwe": [], "message": "Fix adding monitors\n\nMake sure to show windows that are added.  And fix an off by one bug."}
{"func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i - 1);\n                }\n        } else {\n                /* remove the extra windows */\n                for (l = manager->priv->windows; l != NULL; l = l->next) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                }\n        }\n}", "target": 1, "cwe": [], "message": "Fix adding monitors\n\nMake sure to show windows that are added.  And fix an off by one bug."}
{"func": "gs_manager_finalize (GObject *object)\n{\n        GSManager *manager;\n\n        g_return_if_fail (object != NULL);\n        g_return_if_fail (GS_IS_MANAGER (object));\n\n        manager = GS_MANAGER (object);\n\n        g_return_if_fail (manager->priv != NULL);\n\n        if (manager->priv->bg_notify_id != 0) {\n                gconf_client_remove_dir (manager->priv->client,\n                                         GNOME_BG_KEY_DIR,\n                                         NULL);\n                gconf_client_notify_remove (manager->priv->client,\n                                            manager->priv->bg_notify_id);\n                manager->priv->bg_notify_id = 0;\n        }\n        if (manager->priv->bg != NULL) {\n                g_object_unref (manager->priv->bg);\n        }\n        if (manager->priv->client != NULL) {\n                g_object_unref (manager->priv->client);\n        }\n\n        free_themes (manager);\n        g_free (manager->priv->logout_command);\n        g_free (manager->priv->keyboard_command);\n        g_free (manager->priv->away_message);\n\n        remove_unfade_idle (manager);\n        remove_timers (manager);\n\n        gs_grab_release (manager->priv->grab);\n\n        manager_stop_jobs (manager);\n\n        gs_manager_destroy_windows (manager);\n\n        manager->priv->active = FALSE;\n        manager->priv->activate_time = 0;\n        manager->priv->lock_enabled = FALSE;\n\n        g_object_unref (manager->priv->fade);\n        g_object_unref (manager->priv->grab);\n        g_object_unref (manager->priv->theme_manager);\n\n        G_OBJECT_CLASS (gs_manager_parent_class)->finalize (object);\n}", "target": 1, "cwe": [], "message": "Create or remove windows as number of monitors changes due to randr 1.2\n\n2008-08-20  William Jon McCann  <jmccann@redhat.com>\n\n\t* src/gs-manager.c (gs_manager_create_window_for_monitor),\n\t(on_screen_monitors_changed), (gs_manager_destroy_windows),\n\t(gs_manager_finalize), (gs_manager_create_windows_for_screen):\n\tCreate or remove windows as number of monitors changes\n\tdue to randr 1.2 goodness.\n\n\nsvn path=/trunk/; revision=1483"}
{"func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  gdk_screen_get_n_monitors (screen));\n}", "target": 1, "cwe": [], "message": "Create or remove windows as number of monitors changes due to randr 1.2\n\n2008-08-20  William Jon McCann  <jmccann@redhat.com>\n\n\t* src/gs-manager.c (gs_manager_create_window_for_monitor),\n\t(on_screen_monitors_changed), (gs_manager_destroy_windows),\n\t(gs_manager_finalize), (gs_manager_create_windows_for_screen):\n\tCreate or remove windows as number of monitors changes\n\tdue to randr 1.2 goodness.\n\n\nsvn path=/trunk/; revision=1483"}
{"func": "gs_manager_create_windows_for_screen (GSManager *manager,\n                                      GdkScreen *screen)\n{\n        GSWindow *window;\n        int       n_monitors;\n        int       i;\n\n        g_return_if_fail (manager != NULL);\n        g_return_if_fail (GS_IS_MANAGER (manager));\n        g_return_if_fail (GDK_IS_SCREEN (screen));\n\n        g_object_ref (manager);\n        g_object_ref (screen);\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n\n        gs_debug (\"Creating %d windows for screen %d\", n_monitors, gdk_screen_get_number (screen));\n\n        for (i = 0; i < n_monitors; i++) {\n                window = gs_window_new (screen, i, manager->priv->lock_active);\n\n                gs_window_set_user_switch_enabled (window, manager->priv->user_switch_enabled);\n                gs_window_set_logout_enabled (window, manager->priv->logout_enabled);\n                gs_window_set_logout_timeout (window, manager->priv->logout_timeout);\n                gs_window_set_logout_command (window, manager->priv->logout_command);\n                gs_window_set_keyboard_enabled (window, manager->priv->keyboard_enabled);\n                gs_window_set_keyboard_command (window, manager->priv->keyboard_command);\n                gs_window_set_away_message (window, manager->priv->away_message);\n\n                connect_window_signals (manager, window);\n\n                manager->priv->windows = g_slist_append (manager->priv->windows, window);\n        }\n\n        g_object_unref (screen);\n        g_object_unref (manager);\n}", "target": 1, "cwe": [], "message": "Create or remove windows as number of monitors changes due to randr 1.2\n\n2008-08-20  William Jon McCann  <jmccann@redhat.com>\n\n\t* src/gs-manager.c (gs_manager_create_window_for_monitor),\n\t(on_screen_monitors_changed), (gs_manager_destroy_windows),\n\t(gs_manager_finalize), (gs_manager_create_windows_for_screen):\n\tCreate or remove windows as number of monitors changes\n\tdue to randr 1.2 goodness.\n\n\nsvn path=/trunk/; revision=1483"}
{"func": "gs_manager_destroy_windows (GSManager *manager)\n{\n        GdkDisplay  *display;\n        GSList      *l;\n        int          n_screens;\n        int          i;\n\n        g_return_if_fail (manager != NULL);\n        g_return_if_fail (GS_IS_MANAGER (manager));\n\n        if (manager->priv->windows == NULL) {\n                return;\n        }\n\n        display = gdk_display_get_default ();\n\n        n_screens = gdk_display_get_n_screens (display);\n\n        for (i = 0; i < n_screens; i++) {\n                g_signal_handlers_disconnect_by_func (gdk_display_get_screen (display, i),\n                                                      on_screen_monitors_changed,\n                                                      manager);\n        }\n\n        for (l = manager->priv->windows; l; l = l->next) {\n                gs_window_destroy (l->data);\n        }\n        g_slist_free (manager->priv->windows);\n        manager->priv->windows = NULL;\n}", "target": 1, "cwe": [], "message": "Create or remove windows as number of monitors changes due to randr 1.2\n\n2008-08-20  William Jon McCann  <jmccann@redhat.com>\n\n\t* src/gs-manager.c (gs_manager_create_window_for_monitor),\n\t(on_screen_monitors_changed), (gs_manager_destroy_windows),\n\t(gs_manager_finalize), (gs_manager_create_windows_for_screen):\n\tCreate or remove windows as number of monitors changes\n\tdue to randr 1.2 goodness.\n\n\nsvn path=/trunk/; revision=1483"}
{"func": "auto_configure_outputs (GsdXrandrManager *manager, guint32 timestamp)\n{\n        /* FMQ: implement */\n}", "target": 1, "cwe": [], "message": "Implement autoconfiguration of the outputs\n\nThis is similar in spirit to 'xrandr --auto', but we disfavor selecting clone modes.\nInstead, we lay out the outputs left-to-right.\n\nSigned-off-by: Federico Mena Quintero <federico@novell.com>"}
{"func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i);\n                }\n        } else {\n                /* remove the extra windows */\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n                        GSList    *next = l->next;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                g_hash_table_remove (manager->priv->jobs, l->data);\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                        l = next;\n                }\n        }\n}", "target": 1, "cwe": [], "message": "Ensure keyboard grab and unlock dialog exist after monitor removal\n\ngnome-screensaver currently doesn't deal with monitors getting\nremoved properly.  If the unlock dialog is on the removed monitor\nthen the unlock dialog and its associated keyboard grab are not\nmoved to an existing monitor when the monitor removal is processed.\n\nThis means that users can gain access to the locked system by placing\nthe mouse pointer on an external monitor and then disconnect the\nexternal monitor.\n\nCVE-2010-0414\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609337"}
{"func": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}", "target": 1, "cwe": [], "message": "Ensure keyboard grab and unlock dialog exist after monitor removal\n\ngnome-screensaver currently doesn't deal with monitors getting\nremoved properly.  If the unlock dialog is on the removed monitor\nthen the unlock dialog and its associated keyboard grab are not\nmoved to an existing monitor when the monitor removal is processed.\n\nThis means that users can gain access to the locked system by placing\nthe mouse pointer on an external monitor and then disconnect the\nexternal monitor.\n\nCVE-2010-0414\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609337"}
{"func": "static NTSTATUS smb_set_file_unix_link(connection_struct *conn,\n\t\t\t\t       struct smb_request *req,\n\t\t\t\t       const char *pdata,\n\t\t\t\t       int total_data,\n\t\t\t\t       const struct smb_filename *smb_fname)\n{\n\tchar *link_target = NULL;\n\tconst char *newname = smb_fname->base_name;\n\tNTSTATUS status = NT_STATUS_OK;\n\tTALLOC_CTX *ctx = talloc_tos();\n\n\t/* Set a symbolic link. */\n\t/* Don't allow this if follow links is false. */\n\n\tif (total_data == 0) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\tif (!lp_symlinks(SNUM(conn))) {\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\tsrvstr_pull_talloc(ctx, pdata, req->flags2, &link_target, pdata,\n\t\t    total_data, STR_TERMINATE);\n\n\tif (!link_target) {\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\t/* !widelinks forces the target path to be within the share. */\n\t/* This means we can interpret the target as a pathname. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\tchar *rel_name = NULL;\n\t\tchar *last_dirp = NULL;\n\n\t\tif (*link_target == '/') {\n\t\t\t/* No absolute paths allowed. */\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\t\trel_name = talloc_strdup(ctx,newname);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tlast_dirp = strrchr_m(rel_name, '/');\n\t\tif (last_dirp) {\n\t\t\tlast_dirp[1] = '\\0';\n\t\t} else {\n\t\t\trel_name = talloc_strdup(ctx,\"./\");\n\t\t\tif (!rel_name) {\n\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t}\n\t\t}\n\t\trel_name = talloc_asprintf_append(rel_name,\n\t\t\t\t\"%s\",\n\t\t\t\tlink_target);\n\t\tif (!rel_name) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\n\t\tstatus = check_name(conn, rel_name);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tDEBUG(10,(\"smb_set_file_unix_link: SMB_SET_FILE_UNIX_LINK doing symlink %s -> %s\\n\",\n\t\t\tnewname, link_target ));\n\n\tif (SMB_VFS_SYMLINK(conn,link_target,newname) != 0) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\treturn NT_STATUS_OK;\n}", "target": 1, "cwe": ["CWE-22"], "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."}
{"func": "connection_struct *make_connection_snum(struct smbd_server_connection *sconn,\n\t\t\t\t\tint snum, user_struct *vuser,\n\t\t\t\t\tDATA_BLOB password,\n\t\t\t\t\tconst char *pdev,\n\t\t\t\t\tNTSTATUS *pstatus)\n{\n\tconnection_struct *conn;\n\tstruct smb_filename *smb_fname_cpath = NULL;\n\tfstring dev;\n\tint ret;\n\tchar addr[INET6_ADDRSTRLEN];\n\tbool on_err_call_dis_hook = false;\n\tNTSTATUS status;\n\n\tfstrcpy(dev, pdev);\n\n\tif (NT_STATUS_IS_ERR(*pstatus = share_sanity_checks(snum, dev))) {\n\t\treturn NULL;\n\t}\t\n\n\tconn = conn_new(sconn);\n\tif (!conn) {\n\t\tDEBUG(0,(\"Couldn't find free connection.\\n\"));\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}\n\n\tconn->params->service = snum;\n\n\tstatus = create_connection_server_info(sconn,\n\t\tconn, snum, vuser ? vuser->server_info : NULL, password,\n\t\t&conn->server_info);\n\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tDEBUG(1, (\"create_connection_server_info failed: %s\\n\",\n\t\t\t  nt_errstr(status)));\n\t\t*pstatus = status;\n\t\tconn_free(conn);\n\t\treturn NULL;\n\t}\n\n\tif ((lp_guest_only(snum)) || (lp_security() == SEC_SHARE)) {\n\t\tconn->force_user = true;\n\t}\n\n\tadd_session_user(sconn, conn->server_info->unix_name);\n\n\tsafe_strcpy(conn->client_address,\n\t\t\tclient_addr(get_client_fd(),addr,sizeof(addr)), \n\t\t\tsizeof(conn->client_address)-1);\n\tconn->num_files_open = 0;\n\tconn->lastused = conn->lastused_count = time(NULL);\n\tconn->used = True;\n\tconn->printer = (strncmp(dev,\"LPT\",3) == 0);\n\tconn->ipc = ( (strncmp(dev,\"IPC\",3) == 0) ||\n\t\t      ( lp_enable_asu_support() && strequal(dev,\"ADMIN$\")) );\n\n\t/* Case options for the share. */\n\tif (lp_casesensitive(snum) == Auto) {\n\t\t/* We will be setting this per packet. Set to be case\n\t\t * insensitive for now. */\n\t\tconn->case_sensitive = False;\n\t} else {\n\t\tconn->case_sensitive = (bool)lp_casesensitive(snum);\n\t}\n\n\tconn->case_preserve = lp_preservecase(snum);\n\tconn->short_case_preserve = lp_shortpreservecase(snum);\n\n\tconn->encrypt_level = lp_smb_encrypt(snum);\n\n\tconn->veto_list = NULL;\n\tconn->hide_list = NULL;\n\tconn->veto_oplock_list = NULL;\n\tconn->aio_write_behind_list = NULL;\n\n\tconn->read_only = lp_readonly(SNUM(conn));\n\tconn->admin_user = False;\n\n\tif (*lp_force_user(snum)) {\n\n\t\t/*\n\t\t * Replace conn->server_info with a completely faked up one\n\t\t * from the username we are forced into :-)\n\t\t */\n\n\t\tchar *fuser;\n\t\tstruct auth_serversupplied_info *forced_serverinfo;\n\n\t\tfuser = talloc_string_sub(conn, lp_force_user(snum), \"%S\",\n\t\t\t\t\t  lp_servicename(snum));\n\t\tif (fuser == NULL) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstatus = make_serverinfo_from_username(\n\t\t\tconn, fuser, conn->server_info->guest,\n\t\t\t&forced_serverinfo);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tTALLOC_FREE(conn->server_info);\n\t\tconn->server_info = forced_serverinfo;\n\n\t\tconn->force_user = True;\n\t\tDEBUG(3,(\"Forced user %s\\n\", fuser));\n\t}\n\n\t/*\n\t * If force group is true, then override\n\t * any groupid stored for the connecting user.\n\t */\n\n\tif (*lp_force_group(snum)) {\n\n\t\tstatus = find_forced_group(\n\t\t\tconn->force_user, snum, conn->server_info->unix_name,\n\t\t\t&conn->server_info->ptok->user_sids[1],\n\t\t\t&conn->server_info->utok.gid);\n\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = status;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * We need to cache this gid, to use within\n \t\t * change_to_user() separately from the conn->server_info\n \t\t * struct. We only use conn->server_info directly if\n \t\t * \"force_user\" was set.\n \t\t */\n\t\tconn->force_group_gid = conn->server_info->utok.gid;\n\t}\n\n\tconn->vuid = (vuser != NULL) ? vuser->vuid : UID_FIELD_INVALID;\n\n\t{\n\t\tchar *s = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_pathname(snum));\n\t\tif (!s) {\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\tTALLOC_FREE(s);\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_NO_MEMORY;\n\t\t\treturn NULL;\n\t\t}\n\t\tDEBUG(3,(\"Connect path is '%s' for service [%s]\\n\",s,\n\t\t\t lp_servicename(snum)));\n\t\tTALLOC_FREE(s);\n\t}\n\n\t/*\n\t * New code to check if there's a share security descripter\n\t * added from NT server manager. This is done after the\n\t * smb.conf checks are done as we need a uid and token. JRA.\n\t *\n\t */\n\n\t{\n\t\tbool can_write = False;\n\n\t\tcan_write = share_access_check(conn->server_info->ptok,\n\t\t\t\t\t       lp_servicename(snum),\n\t\t\t\t\t       FILE_WRITE_DATA);\n\n\t\tif (!can_write) {\n\t\t\tif (!share_access_check(conn->server_info->ptok,\n\t\t\t\t\t\tlp_servicename(snum),\n\t\t\t\t\t\tFILE_READ_DATA)) {\n\t\t\t\t/* No access, read or write. */\n\t\t\t\tDEBUG(0,(\"make_connection: connection to %s \"\n\t\t\t\t\t \"denied due to security \"\n\t\t\t\t\t \"descriptor.\\n\",\n\t\t\t\t\t  lp_servicename(snum)));\n\t\t\t\tconn_free(conn);\n\t\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\tconn->read_only = True;\n\t\t\t}\n\t\t}\n\t}\n\t/* Initialise VFS function pointers */\n\n\tif (!smbd_vfs_init(conn)) {\n\t\tDEBUG(0, (\"vfs_init failed for service %s\\n\",\n\t\t\t  lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If widelinks are disallowed we need to canonicalise the connect\n\t * path here to ensure we don't have any symlinks in the\n\t * connectpath. We will be checking all paths on this connection are\n\t * below this directory. We must do this after the VFS init as we\n\t * depend on the realpath() pointer in the vfs table. JRA.\n\t */\n\tif (!lp_widelinks(snum)) {\n\t\tif (!canonicalize_connect_path(conn)) {\n\t\t\tDEBUG(0, (\"canonicalize_connect_path failed \"\n\t\t\t\"for service %s, path %s\\n\",\n\t\t\t\tlp_servicename(snum),\n\t\t\t\tconn->connectpath));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif ((!conn->printer) && (!conn->ipc)) {\n\t\tconn->notify_ctx = notify_init(conn, server_id_self(),\n\t\t\t\t\t       smbd_messaging_context(),\n\t\t\t\t\t       smbd_event_context(),\n\t\t\t\t\t       conn);\n\t}\n\n/* ROOT Activities: */\t\n\t/*\n\t * Enforce the max connections parameter.\n\t */\n\n\tif ((lp_max_connections(snum) > 0)\n\t    && (count_current_connections(lp_servicename(SNUM(conn)), True) >=\n\t\tlp_max_connections(snum))) {\n\n\t\tDEBUG(1, (\"Max connections (%d) exceeded for %s\\n\",\n\t\t\t  lp_max_connections(snum), lp_servicename(snum)));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INSUFFICIENT_RESOURCES;\n\t\treturn NULL;\n\t}  \n\n\t/*\n\t * Get us an entry in the connections db\n\t */\n\tif (!claim_connection(conn, lp_servicename(snum), 0)) {\n\t\tDEBUG(1, (\"Could not store connections entry\\n\"));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_INTERNAL_DB_ERROR;\n\t\treturn NULL;\n\t}  \n\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\t/* execute any \"root preexec = \" line */\n\tif (*lp_rootpreexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_rootpreexec(snum));\n\t\tDEBUG(5,(\"cmd=%s\\n\",cmd));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_rootpreexec_close(snum)) {\n\t\t\tDEBUG(1,(\"root preexec gave %d - failing \"\n\t\t\t\t \"connection\\n\", ret));\n\t\t\tyield_connection(conn, lp_servicename(snum));\n\t\t\tconn_free(conn);\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n/* USER Activites: */\n\tif (!change_to_user(conn, conn->vuid)) {\n\t\t/* No point continuing if they fail the basic checks */\n\t\tDEBUG(0,(\"Can't become connected user!\\n\"));\n\t\tyield_connection(conn, lp_servicename(snum));\n\t\tconn_free(conn);\n\t\t*pstatus = NT_STATUS_LOGON_FAILURE;\n\t\treturn NULL;\n\t}\n\n\t/* Remember that a different vuid can connect later without these\n\t * checks... */\n\t\n\t/* Preexecs are done here as they might make the dir we are to ChDir\n\t * to below */\n\n\t/* execute any \"preexec = \" line */\n\tif (*lp_preexec(snum)) {\n\t\tchar *cmd = talloc_sub_advanced(talloc_tos(),\n\t\t\t\t\tlp_servicename(SNUM(conn)),\n\t\t\t\t\tconn->server_info->unix_name,\n\t\t\t\t\tconn->connectpath,\n\t\t\t\t\tconn->server_info->utok.gid,\n\t\t\t\t\tconn->server_info->sanitized_username,\n\t\t\t\t\tpdb_get_domain(conn->server_info->sam_account),\n\t\t\t\t\tlp_preexec(snum));\n\t\tret = smbrun(cmd,NULL);\n\t\tTALLOC_FREE(cmd);\n\t\tif (ret != 0 && lp_preexec_close(snum)) {\n\t\t\tDEBUG(1,(\"preexec gave %d - failing connection\\n\",\n\t\t\t\t ret));\n\t\t\t*pstatus = NT_STATUS_ACCESS_DENIED;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t}\n\n#ifdef WITH_FAKE_KASERVER\n\tif (lp_afs_share(snum)) {\n\t\tafs_login(conn);\n\t}\n#endif\n\t\n\t/* Add veto/hide lists */\n\tif (!IS_IPC(conn) && !IS_PRINT(conn)) {\n\t\tset_namearray( &conn->veto_list, lp_veto_files(snum));\n\t\tset_namearray( &conn->hide_list, lp_hide_files(snum));\n\t\tset_namearray( &conn->veto_oplock_list, lp_veto_oplocks(snum));\n\t\tset_namearray( &conn->aio_write_behind_list,\n\t\t\t\tlp_aio_write_behind(snum));\n\t}\n\t\n\t/* Invoke VFS make connection hook - do this before the VFS_STAT call\n\t   to allow any filesystems needing user credentials to initialize\n\t   themselves. */\n\n\tif (SMB_VFS_CONNECT(conn, lp_servicename(snum),\n\t\t\t    conn->server_info->unix_name) < 0) {\n\t\tDEBUG(0,(\"make_connection: VFS make connection failed!\\n\"));\n\t\t*pstatus = NT_STATUS_UNSUCCESSFUL;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* Any error exit after here needs to call the disconnect hook. */\n\ton_err_call_dis_hook = true;\n\n\tstatus = create_synthetic_smb_fname(talloc_tos(), conn->connectpath,\n\t\t\t\t\t    NULL, NULL, &smb_fname_cpath);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\t*pstatus = status;\n\t\tgoto err_root_exit;\n\t}\n\n\t/* win2000 does not check the permissions on the directory\n\t   during the tree connect, instead relying on permission\n\t   check during individual operations. To match this behaviour\n\t   I have disabled this chdir check (tridge) */\n\t/* the alternative is just to check the directory exists */\n\tif ((ret = SMB_VFS_STAT(conn, smb_fname_cpath)) != 0 ||\n\t    !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\tif (ret == 0 && !S_ISDIR(smb_fname_cpath->st.st_ex_mode)) {\n\t\t\tDEBUG(0,(\"'%s' is not a directory, when connecting to \"\n\t\t\t\t \"[%s]\\n\", conn->connectpath,\n\t\t\t\t lp_servicename(snum)));\n\t\t} else {\n\t\t\tDEBUG(0,(\"'%s' does not exist or permission denied \"\n\t\t\t\t \"when connecting to [%s] Error was %s\\n\",\n\t\t\t\t conn->connectpath, lp_servicename(snum),\n\t\t\t\t strerror(errno) ));\n\t\t}\n\t\t*pstatus = NT_STATUS_BAD_NETWORK_NAME;\n\t\tgoto err_root_exit;\n\t}\n\n\tstring_set(&conn->origpath,conn->connectpath);\n\n#if SOFTLINK_OPTIMISATION\n\t/* resolve any soft links early if possible */\n\tif (vfs_ChDir(conn,conn->connectpath) == 0) {\n\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\tchar *s = vfs_GetWd(ctx,s);\n\t\tif (!s) {\n\t\t\t*status = map_nt_error_from_unix(errno);\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tif (!set_conn_connectpath(conn,s)) {\n\t\t\t*status = NT_STATUS_NO_MEMORY;\n\t\t\tgoto err_root_exit;\n\t\t}\n\t\tvfs_ChDir(conn,conn->connectpath);\n\t}\n#endif\n\n\t/* Figure out the characteristics of the underlying filesystem. This\n\t * assumes that all the filesystem mounted withing a share path have\n\t * the same characteristics, which is likely but not guaranteed.\n\t */\n\n\tconn->fs_capabilities = SMB_VFS_FS_CAPABILITIES(conn, &conn->ts_res);\n\n\t/*\n\t * Print out the 'connected as' stuff here as we need\n\t * to know the effective uid and gid we will be using\n\t * (at least initially).\n\t */\n\n\tif( DEBUGLVL( IS_IPC(conn) ? 3 : 1 ) ) {\n\t\tdbgtext( \"%s (%s) \", get_remote_machine_name(),\n\t\t\t conn->client_address );\n\t\tdbgtext( \"%s\", srv_is_signing_active(smbd_server_conn) ? \"signed \" : \"\");\n\t\tdbgtext( \"connect to service %s \", lp_servicename(snum) );\n\t\tdbgtext( \"initially as user %s \",\n\t\t\t conn->server_info->unix_name );\n\t\tdbgtext( \"(uid=%d, gid=%d) \", (int)geteuid(), (int)getegid() );\n\t\tdbgtext( \"(pid %d)\\n\", (int)sys_getpid() );\n\t}\n\n\t/* we've finished with the user stuff - go back to root */\n\tchange_to_root_user();\n\treturn(conn);\n\n  err_root_exit:\n\tTALLOC_FREE(smb_fname_cpath);\n\tchange_to_root_user();\n\tif (on_err_call_dis_hook) {\n\t\t/* Call VFS disconnect hook */\n\t\tSMB_VFS_DISCONNECT(conn);\n\t}\n\tyield_connection(conn, lp_servicename(snum));\n\tconn_free(conn);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-22"], "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."}
{"func": "NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)\n{\n#ifdef REALPATH_TAKES_NULL\n\tbool free_resolved_name = True;\n#else\n        char resolved_name_buf[PATH_MAX+1];\n\tbool free_resolved_name = False;\n#endif\n\tchar *resolved_name = NULL;\n\tchar *p = NULL;\n\n\tDEBUG(3,(\"check_reduced_name [%s] [%s]\\n\", fname, conn->connectpath));\n\n#ifdef REALPATH_TAKES_NULL\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,NULL);\n#else\n\tresolved_name = SMB_VFS_REALPATH(conn,fname,resolved_name_buf);\n#endif\n\n\tif (!resolved_name) {\n\t\tswitch (errno) {\n\t\t\tcase ENOTDIR:\n\t\t\t\tDEBUG(3,(\"check_reduced_name: Component not a \"\n\t\t\t\t\t \"directory in getting realpath for \"\n\t\t\t\t\t \"%s\\n\", fname));\n\t\t\t\treturn NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\tcase ENOENT:\n\t\t\t{\n\t\t\t\tTALLOC_CTX *ctx = talloc_tos();\n\t\t\t\tchar *tmp_fname = NULL;\n\t\t\t\tchar *last_component = NULL;\n\t\t\t\t/* Last component didn't exist. Remove it and try and canonicalise the directory. */\n\n\t\t\t\ttmp_fname = talloc_strdup(ctx, fname);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tp = strrchr_m(tmp_fname, '/');\n\t\t\t\tif (p) {\n\t\t\t\t\t*p++ = '\\0';\n\t\t\t\t\tlast_component = p;\n\t\t\t\t} else {\n\t\t\t\t\tlast_component = tmp_fname;\n\t\t\t\t\ttmp_fname = talloc_strdup(ctx,\n\t\t\t\t\t\t\t\".\");\n\t\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,NULL);\n#else\n\t\t\t\tresolved_name = SMB_VFS_REALPATH(conn,tmp_fname,resolved_name_buf);\n#endif\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tNTSTATUS status = map_nt_error_from_unix(errno);\n\n\t\t\t\t\tif (errno == ENOENT || errno == ENOTDIR) {\n\t\t\t\t\t\tstatus = NT_STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t\t\t}\n\n\t\t\t\t\tDEBUG(3,(\"check_reduce_named: \"\n\t\t\t\t\t\t \"couldn't get realpath for \"\n\t\t\t\t\t\t \"%s (%s)\\n\",\n\t\t\t\t\t\tfname,\n\t\t\t\t\t\tnt_errstr(status)));\n\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t\ttmp_fname = talloc_asprintf(ctx,\n\t\t\t\t\t\t\"%s/%s\",\n\t\t\t\t\t\tresolved_name,\n\t\t\t\t\t\tlast_component);\n\t\t\t\tif (!tmp_fname) {\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#ifdef REALPATH_TAKES_NULL\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t\tresolved_name = SMB_STRDUP(tmp_fname);\n\t\t\t\tif (!resolved_name) {\n\t\t\t\t\tDEBUG(0, (\"check_reduced_name: malloc \"\n\t\t\t\t\t\t  \"fail for %s\\n\", tmp_fname));\n\t\t\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t\t\t}\n#else\n\t\t\t\tsafe_strcpy(resolved_name_buf, tmp_fname, PATH_MAX);\n\t\t\t\tresolved_name = resolved_name_buf;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tDEBUG(1,(\"check_reduced_name: couldn't get \"\n\t\t\t\t\t \"realpath for %s\\n\", fname));\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tDEBUG(10,(\"check_reduced_name realpath [%s] -> [%s]\\n\", fname,\n\t\t  resolved_name));\n\n\tif (*resolved_name != '/') {\n\t\tDEBUG(0,(\"check_reduced_name: realpath doesn't return \"\n\t\t\t \"absolute paths !\\n\"));\n\t\tif (free_resolved_name) {\n\t\t\tSAFE_FREE(resolved_name);\n\t\t}\n\t\treturn NT_STATUS_OBJECT_NAME_INVALID;\n\t}\n\n\t/* Check for widelinks allowed. */\n\tif (!lp_widelinks(SNUM(conn))) {\n\t\t    const char *conn_rootdir;\n\n\t\t    conn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);\n\t\t    if (conn_rootdir == NULL) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Could not get \"\n\t\t\t\t      \"conn_rootdir\\n\"));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\n\t\t    if (strncmp(conn_rootdir, resolved_name,\n\t\t\t\tstrlen(conn_rootdir)) != 0) {\n\t\t\t    DEBUG(2, (\"check_reduced_name: Bad access \"\n\t\t\t\t      \"attempt: %s is a symlink outside the \"\n\t\t\t\t      \"share path\", fname));\n\t\t\t    if (free_resolved_name) {\n\t\t\t\t    SAFE_FREE(resolved_name);\n\t\t\t    }\n\t\t\t    return NT_STATUS_ACCESS_DENIED;\n\t\t    }\n\t}\n\n        /* Check if we are allowing users to follow symlinks */\n        /* Patch from David Clerc <David.Clerc@cui.unige.ch>\n                University of Geneva */\n\n#ifdef S_ISLNK\n        if (!lp_symlinks(SNUM(conn))) {\n\t\tstruct smb_filename *smb_fname = NULL;\n\t\tNTSTATUS status;\n\n\t\tstatus = create_synthetic_smb_fname(talloc_tos(), fname, NULL,\n\t\t\t\t\t\t    NULL, &smb_fname);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        return status;\n\t\t}\n\n\t\tif ( (SMB_VFS_LSTAT(conn, smb_fname) != -1) &&\n                                (S_ISLNK(smb_fname->st.st_ex_mode)) ) {\n\t\t\tif (free_resolved_name) {\n\t\t\t\tSAFE_FREE(resolved_name);\n\t\t\t}\n                        DEBUG(3,(\"check_reduced_name: denied: file path name \"\n\t\t\t\t \"%s is a symlink\\n\",resolved_name));\n\t\t\tTALLOC_FREE(smb_fname);\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n                }\n\t\tTALLOC_FREE(smb_fname);\n        }\n#endif\n\n\tDEBUG(3,(\"check_reduced_name: %s reduced to %s\\n\", fname,\n\t\t resolved_name));\n\tif (free_resolved_name) {\n\t\tSAFE_FREE(resolved_name);\n\t}\n\treturn NT_STATUS_OK;\n}", "target": 1, "cwe": ["CWE-22"], "message": "Fix bug 7104 - \"wide links\" and \"unix extensions\" are incompatible.\n\nChange parameter \"wide links\" to default to \"no\".\nEnsure \"wide links = no\" if \"unix extensions = yes\" on a share.\nFix man pages to refect this.\n\nRemove \"within share\" checks for a UNIX symlink set - even if\nwidelinks = no. The server will not follow that link anyway.\n\nCorrect DEBUG message in check_reduced_name() to add missing \"\\n\"\nso it's really clear when a path is being denied as it's outside\nthe enclosing share path.\n\nJeremy."}
{"func": "on_screen_monitors_changed (GdkScreen *screen,\n                            GSManager *manager)\n{\n        GSList *l;\n        int     n_monitors;\n        int     n_windows;\n        int     i;\n\n        n_monitors = gdk_screen_get_n_monitors (screen);\n        n_windows = g_slist_length (manager->priv->windows);\n\n        gs_debug (\"Monitors changed for screen %d: num=%d\",\n                  gdk_screen_get_number (screen),\n                  n_monitors);\n\n        if (n_monitors > n_windows) {\n                /* add more windows */\n                for (i = n_windows; i < n_monitors; i++) {\n                        gs_manager_create_window_for_monitor (manager, screen, i);\n                }\n        } else {\n\n                gdk_x11_grab_server ();\n\n                /* remove the extra windows */\n                l = manager->priv->windows;\n                while (l != NULL) {\n                        GdkScreen *this_screen;\n                        int        this_monitor;\n                        GSList    *next = l->next;\n\n                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));\n                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));\n                        if (this_screen == screen && this_monitor >= n_monitors) {\n                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));\n                                g_hash_table_remove (manager->priv->jobs, l->data);\n                                gs_window_destroy (GS_WINDOW (l->data));\n                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);\n                        }\n                        l = next;\n                }\n\n                /* make sure there is a lock dialog on a connected monitor,\n                 * and that the keyboard is still properly grabbed after all\n                 * the windows above got destroyed*/\n                if (n_windows > n_monitors) {\n                        gs_manager_request_unlock (manager);\n                }\n\n                gdk_flush ();\n                gdk_x11_ungrab_server ();\n        }\n}", "target": 1, "cwe": [], "message": "Update which monitor the unlock dialog is on when layout changes\n\nBefore we were moving the grabs but not the unlock dialog.\nEverything needs to be in lock step, otherwise:\n\n1) The unlock dialog won't get focus and will fail to work generally\n2) Assumptions in the code about the two being in lock-step will\nprove incorrect leading to the grabs getting dropped entirely.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789\nCVE-2010-0422"}
{"func": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_pid > 0) {\n                gs_window_dialog_finish (window);\n        }\n\n        remove_popup_dialog_idle (window);\n        remove_command_watches (window);\n        remove_watchdog_timer (window);\n\n        if (window->priv->lock_box != NULL) {\n                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));\n                window->priv->lock_box = NULL;\n\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n        }\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}", "target": 1, "cwe": [], "message": "Make gs_window_cancel_unlock_request synchronous\n\nThis way we know the cancel has finished before moving\non in the code.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "gs_window_cancel_unlock_request (GSWindow  *window)\n{\n        /* FIXME: This is a bit of a hammer approach...\n\t * Maybe we should send a delete-event to\n\t * the plug?\n\t */\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_socket == NULL) {\n                return;\n        }\n\n        if (window->priv->lock_pid > 0) {\n                kill (window->priv->lock_pid, SIGTERM);\n        }\n}", "target": 1, "cwe": [], "message": "Make gs_window_cancel_unlock_request synchronous\n\nThis way we know the cancel has finished before moving\non in the code.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "gs_grab_get_mouse (GSGrab    *grab,\n                   GdkWindow *window,\n                   GdkScreen *screen,\n                   gboolean   hide_cursor)\n{\n        GdkGrabStatus status;\n        GdkCursor    *cursor;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        cursor = get_cursor ();\n\n        gs_debug (\"Grabbing mouse widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_pointer_grab (window, TRUE, 0, NULL,\n                                   (hide_cursor ? cursor : NULL),\n                                   GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->mouse_grab_window = window;\n                grab->priv->mouse_grab_screen = screen;\n                grab->priv->mouse_hide_cursor = hide_cursor;\n        }\n\n        gdk_cursor_unref (cursor);\n\n        return status;\n}", "target": 1, "cwe": [], "message": "Nullify grab window variables when windows are destroyed\n\nIf we don't do this then there is a time period where the\ngrab window variables contain dangling pointers which can\ncause crashes.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "gs_grab_keyboard_reset (GSGrab *grab)\n{\n        grab->priv->keyboard_grab_window = NULL;\n        grab->priv->keyboard_grab_screen = NULL;\n}", "target": 1, "cwe": [], "message": "Nullify grab window variables when windows are destroyed\n\nIf we don't do this then there is a time period where the\ngrab window variables contain dangling pointers which can\ncause crashes.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "gs_grab_get_keyboard (GSGrab    *grab,\n                      GdkWindow *window,\n                      GdkScreen *screen)\n{\n        GdkGrabStatus status;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        gs_debug (\"Grabbing keyboard widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->keyboard_grab_window = window;\n                grab->priv->keyboard_grab_screen = screen;\n        } else {\n                gs_debug (\"Couldn't grab keyboard!  (%s)\", grab_string (status));\n        }\n\n        return status;\n}", "target": 1, "cwe": [], "message": "Nullify grab window variables when windows are destroyed\n\nIf we don't do this then there is a time period where the\ngrab window variables contain dangling pointers which can\ncause crashes.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "gs_grab_mouse_reset (GSGrab *grab)\n{\n        grab->priv->mouse_grab_window = NULL;\n        grab->priv->mouse_grab_screen = NULL;\n}", "target": 1, "cwe": [], "message": "Nullify grab window variables when windows are destroyed\n\nIf we don't do this then there is a time period where the\ngrab window variables contain dangling pointers which can\ncause crashes.\n\nPart of fix for\nhttps://bugzilla.gnome.org/show_bug.cgi?id=609789"}
{"func": "listener_ref_entry_has_connection (gpointer key,\n                                   gpointer value,\n                                   gpointer user_data)\n{\n        GSListenerRefEntry *entry;\n        const char         *connection;\n        gboolean            matches;\n\n        entry = (GSListenerRefEntry *)value;\n        connection = (const char *) user_data;\n\n        matches = FALSE;\n        if (connection != NULL && entry->connection != NULL) {\n                matches = (strcmp (connection, entry->connection) == 0);\n                if (matches) {\n                        gs_debug (\"removing %s from %s for reason '%s' on connection %s\",\n                                  get_name_for_entry_type (entry->entry_type),\n                                  entry->application,\n                                  entry->reason,\n                                  entry->connection);\n                }\n        }\n\n        return matches;\n}", "target": 1, "cwe": [], "message": "Remove session inhibitors if the originator falls of the bus\n\nThis fixes a problem where totem leaves inhibitors behind, see\nbug 600488."}
{"func": "listener_ref_entry_remove_for_connection (GSListener  *listener,\n                                          int          entry_type,\n                                          const char  *connection)\n{\n        gboolean    removed;\n        guint       n_removed;\n        GHashTable *hash;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        removed = FALSE;\n        n_removed = g_hash_table_foreach_remove (hash, listener_ref_entry_has_connection, (gpointer)connection);\n\n        removed = (n_removed > 0);\n\n        return removed;\n}", "target": 1, "cwe": [], "message": "Remove session inhibitors if the originator falls of the bus\n\nThis fixes a problem where totem leaves inhibitors behind, see\nbug 600488."}
{"func": "lock_command_watch (GIOChannel   *source,\n                    GIOCondition  condition,\n                    GSWindow     *window)\n{\n        gboolean finished = FALSE;\n\n        g_return_val_if_fail (GS_IS_WINDOW (window), FALSE);\n\n        if (condition & G_IO_IN) {\n                GIOStatus status;\n                GError   *error = NULL;\n                char     *line;\n\n                line = NULL;\n                status = g_io_channel_read_line (source, &line, NULL, NULL, &error);\n\n                switch (status) {\n                case G_IO_STATUS_NORMAL:\n                        gs_debug (\"command output: %s\", line);\n\n                        if (strstr (line, \"WINDOW ID=\") != NULL) {\n                                guint32 id;\n                                char    c;\n                                if (1 == sscanf (line, \" WINDOW ID= %\" G_GUINT32_FORMAT \" %c\", &id, &c)) {\n                                        create_lock_socket (window, id);\n                                }\n                        } else if (strstr (line, \"NOTICE=\") != NULL) {\n                                if (strstr (line, \"NOTICE=AUTH FAILED\") != NULL) {\n                                        shake_dialog (window);\n                                }\n                        } else if (strstr (line, \"RESPONSE=\") != NULL) {\n                                if (strstr (line, \"RESPONSE=OK\") != NULL) {\n                                        gs_debug (\"Got OK response\");\n                                        window->priv->dialog_response = DIALOG_RESPONSE_OK;\n                                } else {\n                                        gs_debug (\"Got CANCEL response\");\n                                        window->priv->dialog_response = DIALOG_RESPONSE_CANCEL;\n                                }\n                                finished = TRUE;\n                        }\n                        break;\n                case G_IO_STATUS_EOF:\n                        finished = TRUE;\n                        break;\n                case G_IO_STATUS_ERROR:\n                        finished = TRUE;\n                        gs_debug (\"Error reading from child: %s\\n\", error->message);\n                        g_error_free (error);\n                        return FALSE;\n                case G_IO_STATUS_AGAIN:\n                default:\n                        break;\n                }\n\n                g_free (line);\n        } else if (condition & G_IO_HUP) {\n                finished = TRUE;\n        }\n\n        if (finished) {\n                gs_window_dialog_finish (window);\n\n                if (window->priv->dialog_response == DIALOG_RESPONSE_OK) {\n                        add_emit_deactivated_idle (window);\n                }\n\n                gtk_widget_show (window->priv->drawing_area);\n\n                gs_window_clear (window);\n                set_invisible_cursor (GTK_WIDGET (window)->window, TRUE);\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n\n                /* reset the pointer positions */\n                window->priv->last_x = -1;\n                window->priv->last_y = -1;\n\n                window->priv->lock_watch_id = 0;\n\n                return FALSE;\n        }\n\n        return TRUE;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Work around x errors by asking dialog to die on cancel\n\nBasically, what is happening is that gnome-screensaver-dialog exits after the\n5th failed attempt at unlocking the screen, but before the shake animation\nfinishes. If the timing is slightly unlucky, this results in gnome-screensaver\naccessing X resources that have already been destroyed (I ran it through\nxtrace, and that showed this happening)\n\nMy patch fixes this by making gnome-screensaver-dialog request to\ngnome-screensaver that it be terminated after the 5th failed attempt (rather\nthan exitting straight away, although there is a fallback timeout too).\ngnome-screensaver then terminates the dialog after it is finished with the\nshake animation, to avoid the race condition that is currently making it crash."}
{"func": "popup_dialog_idle (GSWindow *window)\n{\n        gboolean  result;\n        char     *tmp;\n        GString  *command;\n\n        gs_debug (\"Popping up dialog\");\n\n        tmp = g_build_filename (LIBEXECDIR, \"gnome-screensaver-dialog\", NULL);\n        command = g_string_new (tmp);\n        g_free (tmp);\n\n        if (is_logout_enabled (window)) {\n                command = g_string_append (command, \" --enable-logout\");\n                g_string_append_printf (command, \" --logout-command='%s'\", window->priv->logout_command);\n        }\n\n        if (window->priv->status_message) {\n                char *quoted;\n\n                quoted = g_shell_quote (window->priv->status_message);\n                g_string_append_printf (command, \" --status-message=%s\", quoted);\n                g_free (quoted);\n        }\n\n        if (is_user_switch_enabled (window)) {\n                command = g_string_append (command, \" --enable-switch\");\n        }\n\n        if (gs_debug_enabled ()) {\n                command = g_string_append (command, \" --verbose\");\n        }\n\n        gtk_widget_hide (window->priv->drawing_area);\n\n        gs_window_clear_to_background_pixmap (window);\n\n        set_invisible_cursor (GTK_WIDGET (window)->window, FALSE);\n\n        result = spawn_on_window (window,\n                                  command->str,\n                                  &window->priv->lock_pid,\n                                  (GIOFunc)lock_command_watch,\n                                  window,\n                                  &window->priv->lock_watch_id);\n        if (! result) {\n                gs_debug (\"Could not start command: %s\", command->str);\n        }\n\n        g_string_free (command, TRUE);\n\n        window->priv->popup_dialog_idle_id = 0;\n\n        return FALSE;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Work around x errors by asking dialog to die on cancel\n\nBasically, what is happening is that gnome-screensaver-dialog exits after the\n5th failed attempt at unlocking the screen, but before the shake animation\nfinishes. If the timing is slightly unlucky, this results in gnome-screensaver\naccessing X resources that have already been destroyed (I ran it through\nxtrace, and that showed this happening)\n\nMy patch fixes this by making gnome-screensaver-dialog request to\ngnome-screensaver that it be terminated after the 5th failed attempt (rather\nthan exitting straight away, although there is a fallback timeout too).\ngnome-screensaver then terminates the dialog after it is finished with the\nshake animation, to avoid the race condition that is currently making it crash."}
{"func": "shake_dialog (GSWindow *window)\n{\n        int   i;\n        guint left;\n        guint right;\n\n        for (i = 0; i < 9; i++) {\n                if (i % 2 == 0) {\n                        left = 30;\n                        right = 0;\n                } else {\n                        left = 0;\n                        right = 30;\n                }\n\n                if (! window->priv->lock_box) {\n                        break;\n                }\n\n                gtk_alignment_set_padding (GTK_ALIGNMENT (window->priv->lock_box),\n                                           0, 0,\n                                           left,\n                                           right);\n\n                while (gtk_events_pending ()) {\n                        gtk_main_iteration ();\n                }\n\n                g_usleep (10000);\n        }\n}", "target": 1, "cwe": ["CWE-362"], "message": "Work around x errors by asking dialog to die on cancel\n\nBasically, what is happening is that gnome-screensaver-dialog exits after the\n5th failed attempt at unlocking the screen, but before the shake animation\nfinishes. If the timing is slightly unlucky, this results in gnome-screensaver\naccessing X resources that have already been destroyed (I ran it through\nxtrace, and that showed this happening)\n\nMy patch fixes this by making gnome-screensaver-dialog request to\ngnome-screensaver that it be terminated after the 5th failed attempt (rather\nthan exitting straight away, although there is a fallback timeout too).\ngnome-screensaver then terminates the dialog after it is finished with the\nshake animation, to avoid the race condition that is currently making it crash."}
{"func": "auth_check_idle (GSLockPlug *plug)\n{\n        gboolean     res;\n        gboolean     again;\n        static guint loop_counter = 0;\n\n        again = TRUE;\n        res = do_auth_check (plug);\n\n        if (res) {\n                again = FALSE;\n                g_idle_add ((GSourceFunc)quit_response_ok, NULL);\n        } else {\n                loop_counter++;\n\n                if (loop_counter < MAX_FAILURES) {\n                        gs_debug (\"Authentication failed, retrying (%u)\", loop_counter);\n                        g_timeout_add (3000, (GSourceFunc)reset_idle_cb, plug);\n                } else {\n                        gs_debug (\"Authentication failed, quitting (max failures)\");\n                        again = FALSE;\n                        gtk_main_quit ();\n                }\n        }\n\n        return again;\n}", "target": 1, "cwe": ["CWE-362"], "message": "Work around x errors by asking dialog to die on cancel\n\nBasically, what is happening is that gnome-screensaver-dialog exits after the\n5th failed attempt at unlocking the screen, but before the shake animation\nfinishes. If the timing is slightly unlucky, this results in gnome-screensaver\naccessing X resources that have already been destroyed (I ran it through\nxtrace, and that showed this happening)\n\nMy patch fixes this by making gnome-screensaver-dialog request to\ngnome-screensaver that it be terminated after the 5th failed attempt (rather\nthan exitting straight away, although there is a fallback timeout too).\ngnome-screensaver then terminates the dialog after it is finished with the\nshake animation, to avoid the race condition that is currently making it crash."}
{"func": "static int futex_lock_pi(u32 __user *uaddr, int fshared,\n\t\t\t int detect, ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\n\tq.pi_state = NULL;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\nretry:\n\tq.key = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr, fshared, &q.key);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Task is exiting and we just wait for the\n\t\t\t * exit to complete.\n\t\t\t */\n\t\t\tqueue_unlock(&q, hb);\n\t\t\tput_futex_key(fshared, &q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\tqueue_me(&q, hb);\n\n\tWARN_ON(!q.pi_state);\n\t/*\n\t * Block on the PI mutex:\n\t */\n\tif (!trylock)\n\t\tret = rt_mutex_timed_lock(&q.pi_state->pi_mutex, to, 1);\n\telse {\n\t\tret = rt_mutex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t}\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, fshared, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current))\n\t\trt_mutex_unlock(&q.pi_state->pi_mutex);\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tgoto out;\n\nout_unlock_put_key:\n\tqueue_unlock(&q, hb);\n\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to)\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(&q, hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!fshared)\n\t\tgoto retry_private;\n\n\tput_futex_key(fshared, &q.key);\n\tgoto retry;\n}", "target": 1, "cwe": [], "message": "futex_lock_pi() key refcnt fix\n\nThis fixes a futex key reference count bug in futex_lock_pi(),\nwhere a key's reference count is incremented twice but decremented\nonly once, causing the backing object to not be released.\n\nIf the futex is created in a temporary file in an ext3 file system,\nthis bug causes the file's inode to become an \"undead\" orphan,\nwhich causes an oops from a BUG_ON() in ext3_put_super() when the\nfile system is unmounted. glibc's test suite is known to trigger this,\nsee <http://bugzilla.kernel.org/show_bug.cgi?id=14256>.\n\nThe bug is a regression from 2.6.28-git3, namely Peter Zijlstra's\n38d47c1b7075bd7ec3881141bb3629da58f88dab \"[PATCH] futex: rely on\nget_user_pages() for shared futexes\". That commit made get_futex_key()\nalso increment the reference count of the futex key, and updated its\ncallers to decrement the key's reference count before returning.\nUnfortunately the normal exit path in futex_lock_pi() wasn't corrected:\nthe reference count is incremented by get_futex_key() and queue_lock(),\nbut the normal exit path only decrements once, via unqueue_me_pi().\nThe fix is to put_futex_key() after unqueue_me_pi(), since 2.6.31\nthis is easily done by 'goto out_put_key' rather than 'goto out'.\n\nSigned-off-by: Mikael Pettersson <mikpe@it.uu.se>\nAcked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nAcked-by: Darren Hart <dvhltc@us.ibm.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: <stable@kernel.org>"}
{"func": "static int encode_to_private_key_info(gnutls_x509_privkey_t pkey,\n\t\t\t\t      gnutls_datum_t * der,\n\t\t\t\t      ASN1_TYPE * pkey_info)\n{\n    int result;\n    size_t size;\n    opaque *data = NULL;\n    opaque null = 0;\n\n    if (pkey->pk_algorithm != GNUTLS_PK_RSA) {\n\tgnutls_assert();\n\treturn GNUTLS_E_UNIMPLEMENTED_FEATURE;\n    }\n\n    if ((result =\n\t asn1_create_element(_gnutls_get_pkix(),\n\t\t\t     \"PKIX1.pkcs-8-PrivateKeyInfo\",\n\t\t\t     pkey_info)) != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Write the version.\n     */\n    result = asn1_write_value(*pkey_info, \"version\", &null, 1);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* write the privateKeyAlgorithm\n     * fields. (OID+NULL data)\n     */\n    result =\n\tasn1_write_value(*pkey_info, \"privateKeyAlgorithm.algorithm\",\n\t\t\t PKIX1_RSA_OID, 1);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    result =\n\tasn1_write_value(*pkey_info, \"privateKeyAlgorithm.parameters\",\n\t\t\t NULL, 0);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Write the raw private key\n     */\n    size = 0;\n    result =\n\tgnutls_x509_privkey_export(pkey, GNUTLS_X509_FMT_DER, NULL, &size);\n    if (result != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n\tgnutls_assert();\n\tgoto error;\n    }\n\n    data = gnutls_alloca(size);\n    if (data == NULL) {\n\tgnutls_assert();\n\tresult = GNUTLS_E_MEMORY_ERROR;\n\tgoto error;\n    }\n\n\n    result =\n\tgnutls_x509_privkey_export(pkey, GNUTLS_X509_FMT_DER, data, &size);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto error;\n    }\n\n    result = asn1_write_value(*pkey_info, \"privateKey\", data, size);\n\n    gnutls_afree(data);\n    data = NULL;\n\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* Append an empty Attributes field.\n     */\n    result = asn1_write_value(*pkey_info, \"attributes\", NULL, 0);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* DER Encode the generated private key info.\n     */\n    size = 0;\n    result = asn1_der_coding(*pkey_info, \"\", NULL, &size, NULL);\n    if (result != ASN1_MEM_ERROR) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    /* allocate data for the der\n     */\n    der->size = size;\n    der->data = gnutls_malloc(size);\n    if (der->data == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_MEMORY_ERROR;\n    }\n\n    result = asn1_der_coding(*pkey_info, \"\", der->data, &size, NULL);\n    if (result != ASN1_SUCCESS) {\n\tgnutls_assert();\n\tresult = _gnutls_asn2err(result);\n\tgoto error;\n    }\n\n    return 0;\n\n  error:\n    asn1_delete_structure(pkey_info);\n    if (data != NULL) {\n\tgnutls_afree(data);\n    }\n    return result;\n\n}", "target": 1, "cwe": [], "message": "some changes for 64bit machines."}
{"func": "int gnutls_x509_crt_get_serial(gnutls_x509_crt_t cert, void *result,\n\t\t\t       size_t * result_size)\n{\n    int ret;\n\n    if (cert == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INVALID_REQUEST;\n    }\n\n    if ((ret =\n\t asn1_read_value(cert->cert, \"tbsCertificate.serialNumber\", result,\n\t\t\t result_size)) < 0) {\n\tgnutls_assert();\n\treturn _gnutls_asn2err(ret);\n    }\n\n    return 0;\n}", "target": 1, "cwe": [], "message": "some changes for 64bit machines."}
{"func": "_gnutls_asn1_get_structure_xml(ASN1_TYPE structure,\n\t\t\t       gnutls_datum_t * res, int detail)\n{\n    node_asn *p, *root;\n    int k, indent = 0, len, len2, len3;\n    opaque tmp[1024];\n    char nname[256];\n    int ret;\n    gnutls_string str;\n\n    if (res == NULL || structure == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INVALID_REQUEST;\n    }\n\n    _gnutls_string_init(&str, malloc, realloc, free);\n\n    STR_APPEND(XML_HEADER);\n    indent = 1;\n\n    root = _asn1_find_node(structure, \"\");\n\n    if (root == NULL) {\n\tgnutls_assert();\n\t_gnutls_string_clear(&str);\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (detail == GNUTLS_XML_SHOW_ALL)\n\tret = asn1_expand_any_defined_by(_gnutls_get_pkix(), &structure);\n    /* we don't need to check the error value\n     * here.\n     */\n\n    if (detail == GNUTLS_XML_SHOW_ALL) {\n\tret = _gnutls_x509_expand_extensions(&structure);\n\tif (ret < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n    }\n\n    p = root;\n    while (p) {\n\tif (is_node_printable(p)) {\n\t    for (k = 0; k < indent; k++)\n\t\tAPPEND(\" \", 1);\n\n\t    if ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t_gnutls_string_clear(&str);\n\t\tgnutls_assert();\n\t\treturn ret;\n\t    }\n\n\t    APPEND(\"<\", 1);\n\t    STR_APPEND(nname);\n\t}\n\n\tif (is_node_printable(p)) {\n\t    switch (type_field(p->type)) {\n\t    case TYPE_DEFAULT:\n\t\tSTR_APPEND(\" type=\\\"DEFAULT\\\"\");\n\t\tbreak;\n\t    case TYPE_NULL:\n\t\tSTR_APPEND(\" type=\\\"NULL\\\"\");\n\t\tbreak;\n\t    case TYPE_IDENTIFIER:\n\t\tSTR_APPEND(\" type=\\\"IDENTIFIER\\\"\");\n\t\tbreak;\n\t    case TYPE_INTEGER:\n\t\tSTR_APPEND(\" type=\\\"INTEGER\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_ENUMERATED:\n\t\tSTR_APPEND(\" type=\\\"ENUMERATED\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_TIME:\n\t\tSTR_APPEND(\" type=\\\"TIME\\\"\");\n\t\tbreak;\n\t    case TYPE_BOOLEAN:\n\t\tSTR_APPEND(\" type=\\\"BOOLEAN\\\"\");\n\t\tbreak;\n\t    case TYPE_SEQUENCE:\n\t\tSTR_APPEND(\" type=\\\"SEQUENCE\\\"\");\n\t\tbreak;\n\t    case TYPE_BIT_STRING:\n\t\tSTR_APPEND(\" type=\\\"BIT STRING\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_OCTET_STRING:\n\t\tSTR_APPEND(\" type=\\\"OCTET STRING\\\"\");\n\t\tSTR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_SEQUENCE_OF:\n\t\tSTR_APPEND(\" type=\\\"SEQUENCE OF\\\"\");\n\t\tbreak;\n\t    case TYPE_OBJECT_ID:\n\t\tSTR_APPEND(\" type=\\\"OBJECT ID\\\"\");\n\t\tbreak;\n\t    case TYPE_ANY:\n\t\tSTR_APPEND(\" type=\\\"ANY\\\"\");\n\t\tif (!p->down)\n\t\t    STR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\tbreak;\n\t    case TYPE_CONSTANT:{\n\t\t    ASN1_TYPE up = _asn1_find_up(p);\n\n\t\t    if (up && type_field(up->type) == TYPE_ANY &&\n\t\t\tup->left && up->left->value &&\n\t\t\tup->type & CONST_DEFINED_BY &&\n\t\t\ttype_field(up->left->type) == TYPE_OBJECT_ID) {\n\n\t\t\tif (_gnutls_x509_oid_data_printable\n\t\t\t    (up->left->value) == 0) {\n\t\t\t    STR_APPEND(\" encoding=\\\"HEX\\\"\");\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_SET:\n\t\tSTR_APPEND(\" type=\\\"SET\\\"\");\n\t\tbreak;\n\t    case TYPE_SET_OF:\n\t\tSTR_APPEND(\" type=\\\"SET OF\\\"\");\n\t\tbreak;\n\t    case TYPE_CHOICE:\n\t\tSTR_APPEND(\" type=\\\"CHOICE\\\"\");\n\t\tbreak;\n\t    case TYPE_DEFINITIONS:\n\t\tSTR_APPEND(\" type=\\\"DEFINITIONS\\\"\");\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n\n\n\tif (p->type == TYPE_BIT_STRING) {\n\t    len2 = -1;\n\t    len = _asn1_get_length_der(p->value, &len2);\n\t    snprintf(tmp, sizeof(tmp), \" length=\\\"%i\\\"\",\n\t\t     (len - 1) * 8 - (p->value[len2]));\n\t    STR_APPEND(tmp);\n\t}\n\n\tif (is_node_printable(p))\n\t    STR_APPEND(\">\");\n\n\tif (is_node_printable(p)) {\n\t    const unsigned char *value;\n\n\t    if (p->value == NULL)\n\t\tvalue = find_default_value(p);\n\t    else\n\t\tvalue = p->value;\n\n\t    switch (type_field(p->type)) {\n\n\t    case TYPE_DEFAULT:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_IDENTIFIER:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_INTEGER:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\n\t\t}\n\t\tbreak;\n\t    case TYPE_ENUMERATED:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_TIME:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_BOOLEAN:\n\t\tif (value) {\n\t\t    if (value[0] == 'T') {\n\t\t\tSTR_APPEND(\"TRUE\");\n\t\t    } else if (value[0] == 'F') {\n\t\t\tSTR_APPEND(\"FALSE\");\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_BIT_STRING:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\n\t\t    for (k = 1; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_OCTET_STRING:\n\t\tif (value) {\n\t\t    len2 = -1;\n\t\t    len = _asn1_get_length_der(value, &len2);\n\t\t    for (k = 0; k < len; k++) {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t \"%02X\", (value)[k + len2]);\n\t\t\tSTR_APPEND(tmp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_OBJECT_ID:\n\t\tif (value)\n\t\t    STR_APPEND(value);\n\t\tbreak;\n\t    case TYPE_ANY:\n\t\tif (!p->down) {\n\t\t    if (value) {\n\t\t\tlen3 = -1;\n\t\t\tlen2 = _asn1_get_length_der(value, &len3);\n\t\t\tfor (k = 0; k < len2; k++) {\n\t\t\t    snprintf(tmp, sizeof(tmp),\n\t\t\t\t     \"%02X\", (value)[k + len3]);\n\t\t\t    STR_APPEND(tmp);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    case TYPE_CONSTANT:{\n\t\t    ASN1_TYPE up = _asn1_find_up(p);\n\n\t\t    if (up && type_field(up->type) == TYPE_ANY &&\n\t\t\tup->left && up->left->value &&\n\t\t\tup->type & CONST_DEFINED_BY &&\n\t\t\ttype_field(up->left->type) == TYPE_OBJECT_ID) {\n\n\t\t\tlen2 = _asn1_get_length_der(up->value, &len3);\n\n\t\t\tif (len2 > 0 && strcmp(p->name, \"type\") == 0) {\n\t\t\t    int len = sizeof(tmp);\n\t\t\t    ret =\n\t\t\t\t_gnutls_x509_oid_data2string(up->left->\n\t\t\t\t\t\t\t     value,\n\t\t\t\t\t\t\t     up->value +\n\t\t\t\t\t\t\t     len3, len2,\n\t\t\t\t\t\t\t     tmp, &len);\n\n\t\t\t    if (ret >= 0) {\n\t\t\t\tSTR_APPEND(tmp);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    for (k = 0; k < len2; k++) {\n\t\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t\t \"%02X\", (up->value)[k + len3]);\n\t\t\t\tSTR_APPEND(tmp);\n\t\t\t    }\n\n\t\t\t}\n\t\t    } else {\n\t\t\tif (value)\n\t\t\t    STR_APPEND(value);\n\t\t    }\n\n\t\t}\n\t\tbreak;\n\t    case TYPE_SET:\n\t    case TYPE_SET_OF:\n\t    case TYPE_CHOICE:\n\t    case TYPE_DEFINITIONS:\n\t    case TYPE_SEQUENCE_OF:\n\t    case TYPE_SEQUENCE:\n\t    case TYPE_NULL:\n\t\tbreak;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n\n\tif (p->down && is_node_printable(p)) {\n\t    ASN1_TYPE x;\n\t    p = p->down;\n\t    indent += 2;\n\t    x = p;\n\t    do {\n\t\tif (is_node_printable(x)) {\n\t\t    STR_APPEND(\"\\n\");\n\t\t    break;\n\t\t}\n\t\tx = x->right;\n\t    } while (x != NULL);\n\t} else if (p == root) {\n\t    if (is_node_printable(p)) {\n\t\tif ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t    _gnutls_string_clear(&str);\n\t\t    gnutls_assert();\n\t\t    return ret;\n\t\t}\n\n\t\tAPPEND(\"</\", 2);\n\t\tSTR_APPEND(nname);\n\t\tAPPEND(\">\\n\", 2);\n\t    }\n\t    p = NULL;\n\t    break;\n\t} else {\n\t    if (is_node_printable(p)) {\n\t\tif ((ret = normalize_name(p, nname, sizeof(nname))) < 0) {\n\t\t    _gnutls_string_clear(&str);\n\t\t    gnutls_assert();\n\t\t    return ret;\n\t\t}\n\n\t\tAPPEND(\"</\", 2);\n\t\tSTR_APPEND(nname);\n\t\tAPPEND(\">\\n\", 2);\n\t    }\n\t    if (p->right)\n\t\tp = p->right;\n\t    else {\n\t\twhile (1) {\n\t\t    ASN1_TYPE old_p;\n\n\t\t    old_p = p;\n\n\t\t    p = _asn1_find_up(p);\n\t\t    indent -= 2;\n\t\t    if (is_node_printable(p)) {\n\t\t\tif (!is_leaf(p))\t/* XXX */\n\t\t\t    for (k = 0; k < indent; k++)\n\t\t\t\tSTR_APPEND(\" \");\n\n\t\t\tif ((ret =\n\t\t\t     normalize_name(p, nname,\n\t\t\t\t\t    sizeof(nname))) < 0) {\n\t\t\t    _gnutls_string_clear(&str);\n\t\t\t    gnutls_assert();\n\t\t\t    return ret;\n\t\t\t}\n\n\t\t\tAPPEND(\"</\", 2);\n\t\t\tSTR_APPEND(nname);\n\t\t\tAPPEND(\">\\n\", 2);\n\t\t    }\n\t\t    if (p == root) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    if (p->right) {\n\t\t\tp = p->right;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    STR_APPEND(XML_FOOTER);\n    APPEND(\"\\n\\0\", 2);\n\n    *res = _gnutls_string2datum(&str);\n    res->size -= 1;\t\t/* null is not included in size */\n\n    return 0;\n}", "target": 1, "cwe": [], "message": "some changes for 64bit machines."}
{"func": "int mszip_decompress(struct mszip_stream *zip, off_t out_bytes) {\n  /* for the bit buffer */\n  register unsigned int bit_buffer;\n  register int bits_left;\n  unsigned char *i_ptr, *i_end;\n\n  int i, ret, state, error;\n\n  /* easy answers */\n  if (!zip || (out_bytes < 0)) return CL_ENULLARG;\n  if (zip->error) return zip->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = zip->o_end - zip->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  while (out_bytes > 0) {\n    /* unpack another block */\n    MSZIP_RESTORE_BITS;\n\n    /* skip to next read 'CK' header */\n    i = bits_left & 7; MSZIP_REMOVE_BITS(i); /* align to bytestream */\n    state = 0;\n    do {\n      MSZIP_READ_BITS(i, 8);\n      if (i == 'C') state = 1;\n      else if ((state == 1) && (i == 'K')) state = 2;\n      else state = 0;\n    } while (state != 2);\n\n    /* inflate a block, repair and realign if necessary */\n    zip->window_posn = 0;\n    zip->bytes_output = 0;\n    MSZIP_STORE_BITS;\n    if ((error = mszip_inflate(zip))) {\n      cli_dbgmsg(\"mszip_decompress: inflate error %d\\n\", error);\n      if (zip->repair_mode) {\n\tcli_dbgmsg(\"mszip_decompress: MSZIP error, %u bytes of data lost\\n\",\n\t\t\t  MSZIP_FRAME_SIZE - zip->bytes_output);\n\tfor (i = zip->bytes_output; i < MSZIP_FRAME_SIZE; i++) {\n\t  zip->window[i] = '\\0';\n\t}\n\tzip->bytes_output = MSZIP_FRAME_SIZE;\n      }\n      else {\n\treturn zip->error = (error > 0) ? error : CL_EFORMAT;\n      }\n    }\n    zip->o_ptr = &zip->window[0];\n    zip->o_end = &zip->o_ptr[zip->bytes_output];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)zip->bytes_output) ?\n      (int)out_bytes : zip->bytes_output;\n    if (zip->wflag && (ret = mspack_write(zip->ofd, zip->o_ptr, i, zip->file)) != CL_SUCCESS) {\n      return zip->error = ret;\n    }\n\n    /* mspack errors (i.e. read errors) are fatal and can't be recovered */\n    if ((error > 0) && zip->repair_mode) return error;\n\n    zip->o_ptr  += i;\n    out_bytes   -= i;\n  }\n\n  if (out_bytes) {\n    cli_dbgmsg(\"mszip_decompress: bytes left to output\\n\");\n    return zip->error = CL_EFORMAT;\n  }\n  return CL_SUCCESS;\n}", "target": 1, "cwe": [], "message": "libclamav/mspack.c: improve unpacking of malformed cabinets (bb#1826)"}
{"func": "int lzx_decompress(struct lzx_stream *lzx, off_t out_bytes) {\n  /* bitstream reading and huffman variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  register unsigned short sym;\n  unsigned char *i_ptr, *i_end;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j, ret;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return CL_ENULLARG;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->wflag && (ret = mspack_write(lzx->ofd, lzx->o_ptr, i, lzx->file)) != CL_SUCCESS) {\n      return lzx->error = ret;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  LZX_RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tcli_dbgmsg(\"lzx_decompress: %d bytes remaining at reset interval\\n\", lzx->block_remaining);\n\treturn lzx->error = CL_EFORMAT;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzx_reset_state(lzx);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; LZX_READ_BITS(i, 1); if (i) { LZX_READ_BITS(i, 16); LZX_READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  if (i_ptr == i_end) {\n\t    if (lzx_read_input(lzx)) return lzx->error;\n\t    i_ptr = lzx->i_ptr;\n\t    i_end = lzx->i_end;\n\t  }\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tLZX_READ_BITS(lzx->block_type, 3);\n\tLZX_READ_BITS(i, 16); LZX_READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { LZX_READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  LZX_BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  LZX_READ_LENGTHS(MAINTREE, 0, 256);\n\t  LZX_READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + (lzx->posn_slots << 3));\n\t  LZX_BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  LZX_READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  LZX_BUILD_TABLE(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  LZX_ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    if (i_ptr == i_end) {\n\t      if (lzx_read_input(lzx)) return lzx->error;\n\t      i_ptr = lzx->i_ptr;\n\t      i_end = lzx->i_end;\n\t    }\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  cli_dbgmsg(\"lzx_decompress: bad block type (0x%x)\\n\", lzx->block_type);\n\t  return lzx->error = CL_EFORMAT;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  LZX_READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      LZX_READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\t  \n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = lzx->extra_bits[match_offset];\n\t      LZX_READ_BITS(verbatim_bits, extra);\n\t      match_offset = lzx->position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      cli_dbgmsg(\"lzx_decompress: match ran over window wrap\\n\");\n\t      return lzx->error = CL_EFORMAT;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t        cli_dbgmsg(\"lzx_decompress: match offset beyond window boundaries\\n\");\n\t\treturn lzx->error = CL_EFORMAT;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      if(i > (int) (lzx->window_size - window_posn))\n\t        i = lzx->window_size - window_posn;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  LZX_READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      LZX_READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = lzx->extra_bits[match_offset];\n\t      match_offset = lzx->position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tLZX_READ_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tLZX_READ_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tLZX_READ_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tLZX_READ_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      cli_dbgmsg(\"lzx_decompress: match ran over window wrap\\n\");\n\t      return lzx->error = CL_EFORMAT;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t        cli_dbgmsg(\"lzx_decompress: match offset beyond window boundaries\\n\");\n\t\treturn lzx->error = CL_EFORMAT;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr)) {\n\t    if (i > this_run) i = this_run;\n\t    memcpy(rundest, i_ptr, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t  else {\n\t    if (lzx_read_input(lzx)) return lzx->error;\n\t    i_ptr = lzx->i_ptr;\n\t    i_end = lzx->i_end;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = CL_EFORMAT; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  cli_dbgmsg(\"lzx_decompress: overrun went past end of block by %d (%d remaining)\\n\", -this_run, lzx->block_remaining);\n\t  return lzx->error = CL_EFORMAT;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      cli_dbgmsg(\"lzx_decompress: decode beyond output frame limits! %d != %d\\n\", window_posn - lzx->frame_posn, frame_size);\n      return lzx->error = CL_EFORMAT;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) LZX_ENSURE_BITS(16);\n    if (bits_left & 15) LZX_REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      cli_dbgmsg(\"lzx_decompress: %ld avail bytes, new %d frame\\n\", lzx->o_end-lzx->o_ptr, frame_size);\n      return lzx->error = CL_EFORMAT;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      memcpy(data, &lzx->window[lzx->frame_posn], frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->wflag && (ret = mspack_write(lzx->ofd, lzx->o_ptr, i, lzx->file)) != CL_SUCCESS) {\n      return lzx->error = ret;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    cli_dbgmsg(\"lzx_decompress: bytes left to output\\n\");\n    return lzx->error = CL_EFORMAT;\n  }\n\n  /* store local state */\n  LZX_STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return CL_SUCCESS;\n}", "target": 1, "cwe": [], "message": "libclamav/mspack.c: improve unpacking of malformed cabinets (bb#1826)"}
{"func": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}", "target": 1, "cwe": ["CWE-20"], "message": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)"}
{"func": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match */\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n\n error:\n\treturn keyring;\n\n} /* end find_keyring_by_name() */", "target": 1, "cwe": ["CWE-362"], "message": "KEYS: find_keyring_by_name() can gain access to a freed keyring\n\nfind_keyring_by_name() can gain access to a keyring that has had its reference\ncount reduced to zero, and is thus ready to be freed.  This then allows the\ndead keyring to be brought back into use whilst it is being destroyed.\n\nThe following timeline illustrates the process:\n\n|(cleaner)                           (user)\n|\n| free_user(user)                    sys_keyctl()\n|  |                                  |\n|  key_put(user->session_keyring)     keyctl_get_keyring_ID()\n|  ||\t//=> keyring->usage = 0        |\n|  |schedule_work(&key_cleanup_task)   lookup_user_key()\n|  ||                                   |\n|  kmem_cache_free(,user)               |\n|  .                                    |[KEY_SPEC_USER_KEYRING]\n|  .                                    install_user_keyrings()\n|  .                                    ||\n| key_cleanup() [<= worker_thread()]    ||\n|  |                                    ||\n|  [spin_lock(&key_serial_lock)]        |[mutex_lock(&key_user_keyr..mutex)]\n|  |                                    ||\n|  atomic_read() == 0                   ||\n|  |{ rb_ease(&key->serial_node,) }     ||\n|  |                                    ||\n|  [spin_unlock(&key_serial_lock)]      |find_keyring_by_name()\n|  |                                    |||\n|  keyring_destroy(keyring)             ||[read_lock(&keyring_name_lock)]\n|  ||                                   |||\n|  |[write_lock(&keyring_name_lock)]    ||atomic_inc(&keyring->usage)\n|  |.                                   ||| *** GET freeing keyring ***\n|  |.                                   ||[read_unlock(&keyring_name_lock)]\n|  ||                                   ||\n|  |list_del()                          |[mutex_unlock(&key_user_k..mutex)]\n|  ||                                   |\n|  |[write_unlock(&keyring_name_lock)]  ** INVALID keyring is returned **\n|  |                                    .\n|  kmem_cache_free(,keyring)            .\n|                                       .\n|                                       atomic_dec(&keyring->usage)\nv                                         *** DESTROYED ***\nTIME\n\nIf CONFIG_SLUB_DEBUG=y then we may see the following message generated:\n\n\t=============================================================================\n\tBUG key_jar: Poison overwritten\n\t-----------------------------------------------------------------------------\n\n\tINFO: 0xffff880197a7e200-0xffff880197a7e200. First byte 0x6a instead of 0x6b\n\tINFO: Allocated in key_alloc+0x10b/0x35f age=25 cpu=1 pid=5086\n\tINFO: Freed in key_cleanup+0xd0/0xd5 age=12 cpu=1 pid=10\n\tINFO: Slab 0xffffea000592cb90 objects=16 used=2 fp=0xffff880197a7e200 flags=0x200000000000c3\n\tINFO: Object 0xffff880197a7e200 @offset=512 fp=0xffff880197a7e300\n\n\tBytes b4 0xffff880197a7e1f0:  5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZZZZZ\n\t  Object 0xffff880197a7e200:  6a 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b jkkkkkkkkkkkkkkk\n\nAlternatively, we may see a system panic happen, such as:\n\n\tBUG: unable to handle kernel NULL pointer dereference at 0000000000000001\n\tIP: [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9\n\tPGD 6b2b4067 PUD 6a80d067 PMD 0\n\tOops: 0000 [#1] SMP\n\tlast sysfs file: /sys/kernel/kexec_crash_loaded\n\tCPU 1\n\t...\n\tPid: 31245, comm: su Not tainted 2.6.34-rc5-nofixed-nodebug #2 D2089/PRIMERGY\n\tRIP: 0010:[<ffffffff810e61a3>]  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9\n\tRSP: 0018:ffff88006af3bd98  EFLAGS: 00010002\n\tRAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88007d19900b\n\tRDX: 0000000100000000 RSI: 00000000000080d0 RDI: ffffffff81828430\n\tRBP: ffffffff81828430 R08: ffff88000a293750 R09: 0000000000000000\n\tR10: 0000000000000001 R11: 0000000000100000 R12: 00000000000080d0\n\tR13: 00000000000080d0 R14: 0000000000000296 R15: ffffffff810f20ce\n\tFS:  00007f97116bc700(0000) GS:ffff88000a280000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n\tCR2: 0000000000000001 CR3: 000000006a91c000 CR4: 00000000000006e0\n\tDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n\tDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n\tProcess su (pid: 31245, threadinfo ffff88006af3a000, task ffff8800374414c0)\n\tStack:\n\t 0000000512e0958e 0000000000008000 ffff880037f8d180 0000000000000001\n\t 0000000000000000 0000000000008001 ffff88007d199000 ffffffff810f20ce\n\t 0000000000008000 ffff88006af3be48 0000000000000024 ffffffff810face3\n\tCall Trace:\n\t [<ffffffff810f20ce>] ? get_empty_filp+0x70/0x12f\n\t [<ffffffff810face3>] ? do_filp_open+0x145/0x590\n\t [<ffffffff810ce208>] ? tlb_finish_mmu+0x2a/0x33\n\t [<ffffffff810ce43c>] ? unmap_region+0xd3/0xe2\n\t [<ffffffff810e4393>] ? virt_to_head_page+0x9/0x2d\n\t [<ffffffff81103916>] ? alloc_fd+0x69/0x10e\n\t [<ffffffff810ef4ed>] ? do_sys_open+0x56/0xfc\n\t [<ffffffff81008a02>] ? system_call_fastpath+0x16/0x1b\n\tCode: 0f 1f 44 00 00 49 89 c6 fa 66 0f 1f 44 00 00 65 4c 8b 04 25 60 e8 00 00 48 8b 45 00 49 01 c0 49 8b 18 48 85 db 74 0d 48 63 45 18 <48> 8b 04 03 49 89 00 eb 14 4c 89 f9 83 ca ff 44 89 e6 48 89 ef\n\tRIP  [<ffffffff810e61a3>] kmem_cache_alloc+0x5b/0xe9\n\nThis problem is that find_keyring_by_name does not confirm that the keyring is\nvalid before accepting it.\n\nSkipping keyrings that have been reduced to a zero count seems the way to go.\nTo this end, use atomic_inc_not_zero() to increment the usage count and skip\nthe candidate keyring if that returns false.\n\nThe following script _may_ cause the bug to happen, but there's no guarantee\nas the window of opportunity is small:\n\n\t#!/bin/sh\n\tLOOP=100000\n\tUSER=dummy_user\n\t/bin/su -c \"exit;\" $USER || { /usr/sbin/adduser -m $USER; add=1; }\n\tfor ((i=0; i<LOOP; i++))\n\tdo\n\t\t/bin/su -c \"echo '$i' > /dev/null\" $USER\n\tdone\n\t(( add == 1 )) && /usr/sbin/userdel -r $USER\n\texit\n\nNote that the nominated user must not be in use.\n\nAn alternative way of testing this may be:\n\n\tfor ((i=0; i<100000; i++))\n\tdo\n\t\tkeyctl session foo /bin/true || break\n\tdone >&/dev/null\n\nas that uses a keyring named \"foo\" rather than relying on the user and\nuser-session named keyrings.\n\nReported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "static int do_sync(unsigned int num_qd, struct gfs2_quota_data **qda)\n{\n\tstruct gfs2_sbd *sdp = (*qda)->qd_gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_quota_inode);\n\tunsigned int data_blocks, ind_blocks;\n\tstruct gfs2_holder *ghs, i_gh;\n\tunsigned int qx, x;\n\tstruct gfs2_quota_data *qd;\n\tloff_t offset;\n\tunsigned int nalloc = 0, blocks;\n\tstruct gfs2_alloc *al = NULL;\n\tint error;\n\n\tgfs2_write_calc_reserv(ip, sizeof(struct gfs2_quota),\n\t\t\t      &data_blocks, &ind_blocks);\n\n\tghs = kcalloc(num_qd, sizeof(struct gfs2_holder), GFP_NOFS);\n\tif (!ghs)\n\t\treturn -ENOMEM;\n\n\tsort(qda, num_qd, sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\tmutex_lock_nested(&ip->i_inode.i_mutex, I_MUTEX_QUOTA);\n\tfor (qx = 0; qx < num_qd; qx++) {\n\t\terror = gfs2_glock_nq_init(qda[qx]->qd_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &ghs[qx]);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &i_gh);\n\tif (error)\n\t\tgoto out;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tint alloc_required;\n\n\t\toffset = qd2offset(qda[x]);\n\t\terror = gfs2_write_alloc_required(ip, offset,\n\t\t\t\t\t\t  sizeof(struct gfs2_quota),\n\t\t\t\t\t\t  &alloc_required);\n\t\tif (error)\n\t\t\tgoto out_gunlock;\n\t\tif (alloc_required)\n\t\t\tnalloc++;\n\t}\n\n\tal = gfs2_alloc_get(ip);\n\tif (!al) {\n\t\terror = -ENOMEM;\n\t\tgoto out_gunlock;\n\t}\n\t/* \n\t * 1 blk for unstuffing inode if stuffed. We add this extra\n\t * block to the reservation unconditionally. If the inode\n\t * doesn't need unstuffing, the block will be released to the \n\t * rgrp since it won't be allocated during the transaction\n\t */\n\tal->al_requested = 1;\n\t/* +1 in the end for block requested above for unstuffing */\n\tblocks = num_qd * data_blocks + RES_DINODE + num_qd + 1;\n\n\tif (nalloc)\n\t\tal->al_requested += nalloc * (data_blocks + ind_blocks);\t\t\n\terror = gfs2_inplace_reserve(ip);\n\tif (error)\n\t\tgoto out_alloc;\n\n\tif (nalloc)\n\t\tblocks += al->al_rgd->rd_length + nalloc * ind_blocks + RES_STATFS;\n\n\terror = gfs2_trans_begin(sdp, blocks, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\tfor (x = 0; x < num_qd; x++) {\n\t\tqd = qda[x];\n\t\toffset = qd2offset(qd);\n\t\terror = gfs2_adjust_quota(ip, offset, qd->qd_change_sync, qd, NULL);\n\t\tif (error)\n\t\t\tgoto out_end_trans;\n\n\t\tdo_qc(qd, -qd->qd_change_sync);\n\t}\n\n\terror = 0;\n\nout_end_trans:\n\tgfs2_trans_end(sdp);\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_alloc:\n\tgfs2_alloc_put(ip);\nout_gunlock:\n\tgfs2_glock_dq_uninit(&i_gh);\nout:\n\twhile (qx--)\n\t\tgfs2_glock_dq_uninit(&ghs[qx]);\n\tmutex_unlock(&ip->i_inode.i_mutex);\n\tkfree(ghs);\n\tgfs2_log_flush(ip->i_gl->gl_sbd, ip->i_gl);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-399"], "message": "GFS2: Fix writing to non-page aligned gfs2_quota structures\n\nThis is the upstream fix for this bug. This patch differs\nfrom the RHEL5 fix (Red Hat bz #555754) which simply writes to the 8-byte\nvalue field of the quota. In upstream quota code, we're\nrequired to write the entire quota (88 bytes) which can be split\nacross a page boundary. We check for such quotas, and read/write\nthe two parts from/to the corresponding pages holding these parts.\n\nWith this patch, I don't see the bug anymore using the reproducer\nin Red Hat bz 555754. I successfully ran a couple of simple tests/mounts/\numounts and it doesn't seem like this patch breaks anything else.\n\nSigned-off-by: Abhi Das <adas@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>"}
{"func": "static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct fs_disk_quota *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh, *dibh;\n\tstruct page *page;\n\tvoid *kaddr;\n\tstruct gfs2_quota *qp;\n\ts64 value;\n\tint err = -EIO;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip))\n\t\tgfs2_unstuff_dinode(ip, NULL);\n\t\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tgfs2_trans_add_bh(ip->i_gl, bh, 0);\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tqp = kaddr + offset;\n\tvalue = (s64)be64_to_cpu(qp->qu_value) + change;\n\tqp->qu_value = cpu_to_be64(value);\n\tqd->qd_qb.qb_value = qp->qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & FS_DQ_BSOFT) {\n\t\t\tqp->qu_warn = cpu_to_be64(fdq->d_blk_softlimit);\n\t\t\tqd->qd_qb.qb_warn = qp->qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & FS_DQ_BHARD) {\n\t\t\tqp->qu_limit = cpu_to_be64(fdq->d_blk_hardlimit);\n\t\t\tqd->qd_qb.qb_limit = qp->qu_limit;\n\t\t}\n\t}\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\terr = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (err)\n\t\tgoto unlock;\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size) {\n\t\tip->i_disksize = size;\n\t\ti_size_write(inode, size);\n\t}\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\tmark_inode_dirty(inode);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-399"], "message": "GFS2: Fix writing to non-page aligned gfs2_quota structures\n\nThis is the upstream fix for this bug. This patch differs\nfrom the RHEL5 fix (Red Hat bz #555754) which simply writes to the 8-byte\nvalue field of the quota. In upstream quota code, we're\nrequired to write the entire quota (88 bytes) which can be split\nacross a page boundary. We check for such quotas, and read/write\nthe two parts from/to the corresponding pages holding these parts.\n\nWith this patch, I don't see the bug anymore using the reproducer\nin Red Hat bz 555754. I successfully ran a couple of simple tests/mounts/\numounts and it doesn't seem like this patch breaks anything else.\n\nSigned-off-by: Abhi Das <adas@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>"}
{"func": "void chain_reply(struct smb_request *req)\n{\n\tsize_t smblen = smb_len(req->inbuf);\n\tsize_t already_used, length_needed;\n\tuint8_t chain_cmd;\n\tuint32_t chain_offset;\t/* uint32_t to avoid overflow */\n\n\tuint8_t wct;\n\tuint16_t *vwv;\n\tuint16_t buflen;\n\tuint8_t *buf;\n\n\tif (IVAL(req->outbuf, smb_rcls) != 0) {\n\t\tfixup_chain_error_packet(req);\n\t}\n\n\t/*\n\t * Any of the AndX requests and replies have at least a wct of\n\t * 2. vwv[0] is the next command, vwv[1] is the offset from the\n\t * beginning of the SMB header to the next wct field.\n\t *\n\t * None of the AndX requests put anything valuable in vwv[0] and [1],\n\t * so we can overwrite it here to form the chain.\n\t */\n\n\tif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Here we assume that this is the end of the chain. For that we need\n\t * to set \"next command\" to 0xff and the offset to 0. If we later find\n\t * more commands in the chain, this will be overwritten again.\n\t */\n\n\tSCVAL(req->outbuf, smb_vwv0, 0xff);\n\tSCVAL(req->outbuf, smb_vwv0+1, 0);\n\tSSVAL(req->outbuf, smb_vwv1, 0);\n\n\tif (req->chain_outbuf == NULL) {\n\t\t/*\n\t\t * In req->chain_outbuf we collect all the replies. Start the\n\t\t * chain by copying in the first reply.\n\t\t *\n\t\t * We do the realloc because later on we depend on\n\t\t * talloc_get_size to determine the length of\n\t\t * chain_outbuf. The reply_xxx routines might have\n\t\t * over-allocated (reply_pipe_read_and_X used to be such an\n\t\t * example).\n\t\t */\n\t\treq->chain_outbuf = TALLOC_REALLOC_ARRAY(\n\t\t\treq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\n\t\tif (req->chain_outbuf == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\treq->outbuf = NULL;\n\t} else {\n\t\t/*\n\t\t * Update smb headers where subsequent chained commands\n\t\t * may have updated them.\n\t\t */\n\t\tSCVAL(req->chain_outbuf, smb_tid, CVAL(req->outbuf, smb_tid));\n\t\tSCVAL(req->chain_outbuf, smb_uid, CVAL(req->outbuf, smb_uid));\n\n\t\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tTALLOC_FREE(req->outbuf);\n\t}\n\n\t/*\n\t * We use the old request's vwv field to grab the next chained command\n\t * and offset into the chained fields.\n\t */\n\n\tchain_cmd = CVAL(req->vwv+0, 0);\n\tchain_offset = SVAL(req->vwv+1, 0);\n\n\tif (chain_cmd == 0xff) {\n\t\t/*\n\t\t * End of chain, no more requests from the client. So ship the\n\t\t * replies.\n\t\t */\n\t\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\t\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t\t  true, req->seqnum+1,\n\t\t\t\t  IS_CONN_ENCRYPTED(req->conn)\n\t\t\t\t  ||req->encrypted,\n\t\t\t\t  &req->pcd)) {\n\t\t\texit_server_cleanly(\"chain_reply: srv_send_smb \"\n\t\t\t\t\t    \"failed.\");\n\t\t}\n\t\tTALLOC_FREE(req->chain_outbuf);\n\t\treq->done = true;\n\t\treturn;\n\t}\n\n\t/* add a new perfcounter for this element of chain */\n\tSMB_PERFCOUNT_ADD(&req->pcd);\n\tSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\n\tSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\n\n\t/*\n\t * Check if the client tries to fool us. The request so far uses the\n\t * space to the end of the byte buffer in the request just\n\t * processed. The chain_offset can't point into that area. If that was\n\t * the case, we could end up with an endless processing of the chain,\n\t * we would always handle the same request.\n\t */\n\n\talready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\n\tif (chain_offset < already_used) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Next check: Make sure the chain offset does not point beyond the\n\t * overall smb request length.\n\t */\n\n\tlength_needed = chain_offset+1;\t/* wct */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Now comes the pointer magic. Goal here is to set up req->vwv and\n\t * req->buf correctly again to be able to call the subsequent\n\t * switch_message(). The chain offset (the former vwv[1]) points at\n\t * the new wct field.\n\t */\n\n\twct = CVAL(smb_base(req->inbuf), chain_offset);\n\n\t/*\n\t * Next consistency check: Make the new vwv array fits in the overall\n\t * smb request.\n\t */\n\n\tlength_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\n\n\t/*\n\t * Now grab the new byte buffer....\n\t */\n\n\tbuflen = SVAL(vwv+wct, 0);\n\n\t/*\n\t * .. and check that it fits.\n\t */\n\n\tlength_needed += buflen;\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tbuf = (uint8_t *)(vwv+wct+1);\n\n\treq->cmd = chain_cmd;\n\treq->wct = wct;\n\treq->vwv = vwv;\n\treq->buflen = buflen;\n\treq->buf = buf;\n\n\tswitch_message(chain_cmd, req, smblen);\n\n\tif (req->outbuf == NULL) {\n\t\t/*\n\t\t * This happens if the chained command has suspended itself or\n\t\t * if it has called srv_send_smb() itself.\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t * We end up here if the chained command was not itself chained or\n\t * suspended, but for example a close() command. We now need to splice\n\t * the chained commands' outbuf into the already built up chain_outbuf\n\t * and ship the result.\n\t */\n\tgoto done;\n\n error:\n\t/*\n\t * We end up here if there's any error in the chain syntax. Report a\n\t * DOS error, just like Windows does.\n\t */\n\treply_force_doserror(req, ERRSRV, ERRerror);\n\tfixup_chain_error_packet(req);\n\n done:\n\t/*\n\t * This scary statement intends to set the\n\t * FLAGS2_32_BIT_ERROR_CODES flg2 field in req->chain_outbuf\n\t * to the value req->outbuf carries\n\t */\n\tSSVAL(req->chain_outbuf, smb_flg2,\n\t      (SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)\n\t      | (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));\n\n\t/*\n\t * Transfer the error codes from the subrequest to the main one\n\t */\n\tSSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));\n\tSSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));\n\n\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\texit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n\t}\n\tTALLOC_FREE(req->outbuf);\n\n\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\tshow_msg((char *)(req->chain_outbuf));\n\n\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t  true, req->seqnum+1,\n\t\t\t  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n\t\t\t  &req->pcd)) {\n\t\texit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n\t}\n\tTALLOC_FREE(req->chain_outbuf);\n\treq->done = true;\n}", "target": 1, "cwe": [], "message": "s3: Fix a NULL pointer dereference\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>.\n\nThanks!\n\nVolker"}
{"func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n\tfile_save(\"negotiate.dat\", blob1.data, blob1.length);\n#endif\n\n\tp2 = (char *)req->buf + data_blob_len;\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}", "target": 1, "cwe": ["CWE-119"], "message": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash)."}
{"func": "void chain_reply(struct smb_request *req)\n{\n\tsize_t smblen = smb_len(req->inbuf);\n\tsize_t already_used, length_needed;\n\tuint8_t chain_cmd;\n\tuint32_t chain_offset;\t/* uint32_t to avoid overflow */\n\n\tuint8_t wct;\n\tuint16_t *vwv;\n\tuint16_t buflen;\n\tuint8_t *buf;\n\n\tif (IVAL(req->outbuf, smb_rcls) != 0) {\n\t\tfixup_chain_error_packet(req);\n\t}\n\n\t/*\n\t * Any of the AndX requests and replies have at least a wct of\n\t * 2. vwv[0] is the next command, vwv[1] is the offset from the\n\t * beginning of the SMB header to the next wct field.\n\t *\n\t * None of the AndX requests put anything valuable in vwv[0] and [1],\n\t * so we can overwrite it here to form the chain.\n\t */\n\n\tif ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Here we assume that this is the end of the chain. For that we need\n\t * to set \"next command\" to 0xff and the offset to 0. If we later find\n\t * more commands in the chain, this will be overwritten again.\n\t */\n\n\tSCVAL(req->outbuf, smb_vwv0, 0xff);\n\tSCVAL(req->outbuf, smb_vwv0+1, 0);\n\tSSVAL(req->outbuf, smb_vwv1, 0);\n\n\tif (req->chain_outbuf == NULL) {\n\t\t/*\n\t\t * In req->chain_outbuf we collect all the replies. Start the\n\t\t * chain by copying in the first reply.\n\t\t *\n\t\t * We do the realloc because later on we depend on\n\t\t * talloc_get_size to determine the length of\n\t\t * chain_outbuf. The reply_xxx routines might have\n\t\t * over-allocated (reply_pipe_read_and_X used to be such an\n\t\t * example).\n\t\t */\n\t\treq->chain_outbuf = TALLOC_REALLOC_ARRAY(\n\t\t\treq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);\n\t\tif (req->chain_outbuf == NULL) {\n\t\t\tgoto error;\n\t\t}\n\t\treq->outbuf = NULL;\n\t} else {\n\t\t/*\n\t\t * Update smb headers where subsequent chained commands\n\t\t * may have updated them.\n\t\t */\n\t\tSCVAL(req->chain_outbuf, smb_tid, CVAL(req->outbuf, smb_tid));\n\t\tSCVAL(req->chain_outbuf, smb_uid, CVAL(req->outbuf, smb_uid));\n\n\t\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tTALLOC_FREE(req->outbuf);\n\t}\n\n\t/*\n\t * We use the old request's vwv field to grab the next chained command\n\t * and offset into the chained fields.\n\t */\n\n\tchain_cmd = CVAL(req->vwv+0, 0);\n\tchain_offset = SVAL(req->vwv+1, 0);\n\n\tif (chain_cmd == 0xff) {\n\t\t/*\n\t\t * End of chain, no more requests from the client. So ship the\n\t\t * replies.\n\t\t */\n\t\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\t\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t\t  true, req->seqnum+1,\n\t\t\t\t  IS_CONN_ENCRYPTED(req->conn)\n\t\t\t\t  ||req->encrypted,\n\t\t\t\t  &req->pcd)) {\n\t\t\texit_server_cleanly(\"chain_reply: srv_send_smb \"\n\t\t\t\t\t    \"failed.\");\n\t\t}\n\t\tTALLOC_FREE(req);\n\n\t\treturn;\n\t}\n\n\t/* add a new perfcounter for this element of chain */\n\tSMB_PERFCOUNT_ADD(&req->pcd);\n\tSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);\n\tSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);\n\n\t/*\n\t * Check if the client tries to fool us. The request so far uses the\n\t * space to the end of the byte buffer in the request just\n\t * processed. The chain_offset can't point into that area. If that was\n\t * the case, we could end up with an endless processing of the chain,\n\t * we would always handle the same request.\n\t */\n\n\talready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));\n\tif (chain_offset < already_used) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Next check: Make sure the chain offset does not point beyond the\n\t * overall smb request length.\n\t */\n\n\tlength_needed = chain_offset+1;\t/* wct */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Now comes the pointer magic. Goal here is to set up req->vwv and\n\t * req->buf correctly again to be able to call the subsequent\n\t * switch_message(). The chain offset (the former vwv[1]) points at\n\t * the new wct field.\n\t */\n\n\twct = CVAL(smb_base(req->inbuf), chain_offset);\n\n\t/*\n\t * Next consistency check: Make the new vwv array fits in the overall\n\t * smb request.\n\t */\n\n\tlength_needed += (wct+1)*sizeof(uint16_t); /* vwv+buflen */\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);\n\n\t/*\n\t * Now grab the new byte buffer....\n\t */\n\n\tbuflen = SVAL(vwv+wct, 0);\n\n\t/*\n\t * .. and check that it fits.\n\t */\n\n\tlength_needed += buflen;\n\tif (length_needed > smblen) {\n\t\tgoto error;\n\t}\n\tbuf = (uint8_t *)(vwv+wct+1);\n\n\treq->cmd = chain_cmd;\n\treq->wct = wct;\n\treq->vwv = vwv;\n\treq->buflen = buflen;\n\treq->buf = buf;\n\n\tswitch_message(chain_cmd, req, smblen);\n\n\tif (req->outbuf == NULL) {\n\t\t/*\n\t\t * This happens if the chained command has suspended itself or\n\t\t * if it has called srv_send_smb() itself.\n\t\t */\n\t\treturn;\n\t}\n\n\t/*\n\t * We end up here if the chained command was not itself chained or\n\t * suspended, but for example a close() command. We now need to splice\n\t * the chained commands' outbuf into the already built up chain_outbuf\n\t * and ship the result.\n\t */\n\tgoto done;\n\n error:\n\t/*\n\t * We end up here if there's any error in the chain syntax. Report a\n\t * DOS error, just like Windows does.\n\t */\n\treply_nterror(req, NT_STATUS_DOS(ERRSRV, ERRerror));\n\tfixup_chain_error_packet(req);\n\n done:\n\tif (!smb_splice_chain(&req->chain_outbuf,\n\t\t\t      CVAL(req->outbuf, smb_com),\n\t\t\t      CVAL(req->outbuf, smb_wct),\n\t\t\t      (uint16_t *)(req->outbuf + smb_vwv),\n\t\t\t      0, smb_buflen(req->outbuf),\n\t\t\t      (uint8_t *)smb_buf(req->outbuf))) {\n\t\texit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");\n\t}\n\tTALLOC_FREE(req->outbuf);\n\n\tsmb_setlen((char *)(req->chain_outbuf),\n\t\t   talloc_get_size(req->chain_outbuf) - 4);\n\n\tshow_msg((char *)(req->chain_outbuf));\n\n\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,\n\t\t\t  true, req->seqnum+1,\n\t\t\t  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,\n\t\t\t  &req->pcd)) {\n\t\texit_server_cleanly(\"construct_reply: srv_send_smb failed.\");\n\t}\n\tTALLOC_FREE(req);\n}", "target": 1, "cwe": [], "message": "In chain_reply, copy the subrequests' error to the main request"}
{"func": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "(_gnutls_x509_oid2mac_algorithm): Don't crash trying to strcmp the\nNULL OID value in the hash_algorithms array, which happens when the\ninput OID doesn't match our OIDs for SHA1, MD5, MD2 or RIPEMD160.\nReported by satyakumar <satyam_kkd@hyd.hellosoft.com>."}
{"func": "cli_pdf(const char *dir, cli_ctx *ctx, off_t offset)\n{\n\toff_t size;\t/* total number of bytes in the file */\n\toff_t bytesleft, trailerlength;\n\tchar *buf;\t/* start of memory mapped area */\n\tconst char *p, *q, *trailerstart;\n\tconst char *xrefstart;\t/* cross reference table */\n\t/*size_t xreflength;*/\n\tint printed_predictor_message, printed_embedded_font_message, rc;\n\tunsigned int files;\n\tfmap_t *map = *ctx->fmap;\n\tint opt_failed = 0;\n\n\tcli_dbgmsg(\"in cli_pdf(%s)\\n\", dir);\n\tsize = map->len - offset;\n\n\tif(size <= 7)\t/* doesn't even include the file header */\n\t\treturn CL_CLEAN;\n\n\tp = buf = fmap_need_off_once(map, 0, size); /* FIXME: really port to fmap */\n\tif(!buf) {\n\t\tcli_errmsg(\"cli_pdf: mmap() failed\\n\");\n\t\treturn CL_EMAP;\n\t}\n\n\tcli_dbgmsg(\"cli_pdf: scanning %lu bytes\\n\", (unsigned long)size);\n\n\t/* Lines are terminated by \\r, \\n or both */\n\n\t/* File Header */\n\tbytesleft = size - 5;\n\tfor(q = p; bytesleft; bytesleft--, q++) {\n\t    if(!strncasecmp(q, \"%PDF-\", 5)) {\n\t\tbytesleft = size - (off_t) (q - p);\n\t\tp = q;\n\t\tbreak;\n\t    }\n\t}\n\n\tif(!bytesleft) {\n\t    cli_dbgmsg(\"cli_pdf: file header not found\\n\");\n\t    return CL_CLEAN;\n\t}\n\n\t/* Find the file trailer */\n\tfor(q = &p[bytesleft - 5]; q > p; --q)\n\t\tif(strncasecmp(q, \"%%EOF\", 5) == 0)\n\t\t\tbreak;\n\n\tif(q <= p) {\n\t\tcli_dbgmsg(\"cli_pdf: trailer not found\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\tfor(trailerstart = &q[-7]; trailerstart > p; --trailerstart)\n\t\tif(memcmp(trailerstart, \"trailer\", 7) == 0)\n\t\t\tbreak;\n\n\t/*\n\t * q points to the end of the trailer section\n\t */\n\ttrailerlength = (long)(q - trailerstart);\n\tif(cli_memstr(trailerstart, trailerlength, \"Encrypt\", 7)) {\n\t\t/*\n\t\t * This tends to mean that the file is, in effect, read-only\n\t\t * http://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt\n\t\t * http://www.adobe.com/devnet/pdf/\n\t\t */\n\t\tcli_dbgmsg(\"cli_pdf: Encrypted PDF files not yet supported\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\t/*\n\t * not true, since edits may put data after the trailer\n\tbytesleft -= trailerlength;\n\t */\n\n\t/*\n\t * FIXME: Handle more than one xref section in the xref table\n\t */\n\tfor(xrefstart = trailerstart; xrefstart > p; --xrefstart)\n\t\tif(memcmp(xrefstart, \"xref\", 4) == 0)\n\t\t\t/*\n\t\t\t * Make sure it's the start of the line, not a startxref\n\t\t\t * token\n\t\t\t */\n\t\t\tif((xrefstart[-1] == '\\n') || (xrefstart[-1] == '\\r'))\n\t\t\t\tbreak;\n\n\tif(xrefstart == p) {\n\t\tcli_dbgmsg(\"cli_pdf: xref not found\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\n\tprinted_predictor_message = printed_embedded_font_message = 0;\n\n\t/*\n\t * not true, since edits may put data after the trailer\n\txreflength = (size_t)(trailerstart - xrefstart);\n\tbytesleft -= xreflength;\n\t */\n\n\tfiles = 0;\n\n\trc = CL_CLEAN;\n\n\t/*\n\t * The body section consists of a sequence of indirect objects\n\t */\n\twhile((p < xrefstart) && (cli_checklimits(\"cli_pdf\", ctx, 0, 0, 0)==CL_CLEAN) &&\n\t      ((q = pdf_nextobject(p, bytesleft)) != NULL)) {\n\t\tint is_ascii85decode, is_flatedecode, fout, len, has_cr;\n\t\t/*int object_number, generation_number;*/\n\t\tconst char *objstart, *objend, *streamstart, *streamend;\n\t\tunsigned long length, objlen, real_streamlen, calculated_streamlen;\n\t\tint is_embedded_font, predictor;\n\t\tchar fullname[NAME_MAX + 1];\n\n\t\trc = CL_CLEAN;\n\t\tif(q == xrefstart)\n\t\t\tbreak;\n\t\tif(memcmp(q, \"xref\", 4) == 0)\n\t\t\tbreak;\n\n\t\t/*object_number = atoi(q);*/\n\t\tbytesleft -= (off_t)(q - p);\n\t\tp = q;\n\n\t\tif(memcmp(q, \"endobj\", 6) == 0)\n\t\t\tcontinue;\n\t\tif(!isdigit(*q)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Object number missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tq = pdf_nextobject(p, bytesleft);\n\t\tif((q == NULL) || !isdigit(*q)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Generation number missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t/*generation_number = atoi(q);*/\n\t\tbytesleft -= (off_t)(q - p);\n\t\tp = q;\n\n\t\tq = pdf_nextobject(p, bytesleft);\n\t\tif((q == NULL) || (memcmp(q, \"obj\", 3) != 0)) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Indirect object missing \\\"obj\\\"\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbytesleft -= (off_t)((q - p) + 3);\n\t\tobjstart = p = &q[3];\n\t\tobjend = cli_memstr(p, bytesleft, \"endobj\", 6);\n\t\tif(objend == NULL) {\n\t\t\tcli_dbgmsg(\"cli_pdf: No matching endobj\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbytesleft -= (off_t)((objend - p) + 6);\n\t\tp = &objend[6];\n\t\tobjlen = (unsigned long)(objend - objstart);\n\n\t\t/* Is this object a stream? */\n\t\tstreamstart = cli_memstr(objstart, objlen, \"stream\", 6);\n\t\tif(streamstart == NULL)\n\t\t\tcontinue;\n\n\t\tis_embedded_font = length = is_ascii85decode =\n\t\t\tis_flatedecode = 0;\n\t\tpredictor = 1;\n\n\t\t/*\n\t\t * TODO: handle F and FFilter?\n\t\t */\n\t\tq = objstart;\n\t\twhile(q < streamstart) {\n\t\t\tif(*q == '/') {\t/* name object */\n\t\t\t\t/*cli_dbgmsg(\"Name object %8.8s\\n\", q+1, q+1);*/\n\t\t\t\tif(strncmp(++q, \"Length \", 7) == 0) {\n\t\t\t\t\tq += 7;\n\t\t\t\t\tlength = atoi(q);\n\t\t\t\t\twhile(isdigit(*q))\n\t\t\t\t\t\tq++;\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: incremental updates are not\n\t\t\t\t\t *\tsupported\n\t\t\t\t\t */\n\t\t\t\t\tif((bytesleft > 11) && strncmp(q, \" 0 R\", 4) == 0) {\n\t\t\t\t\t\tconst char *r, *nq;\n\t\t\t\t\t\tchar b[14];\n\n\t\t\t\t\t\tq += 4;\n\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: Length is in indirect obj %lu\\n\",\n\t\t\t\t\t\t\tlength);\n\t\t\t\t\t\tsnprintf(b, sizeof(b),\n\t\t\t\t\t\t\t\"%lu 0 obj\", length);\n\t\t\t\t\t\tlength = (unsigned long)strlen(b);\n\t\t\t\t\t\t/* optimization: assume objects\n\t\t\t\t\t\t * are sequential */\n\t\t\t\t\t\tif(!opt_failed) {\n\t\t\t\t\t\t    nq = q;\n\t\t\t\t\t\t    len = buf + size - q;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t    nq = buf;\n\t\t\t\t\t\t    len = q - buf;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tr = cli_memstr(nq, len, b, length);\n\t\t\t\t\t\t\tif (r > nq) {\n\t\t\t\t\t\t\t\tconst char x = *(r-1);\n\t\t\t\t\t\t\t\tif (x == '\\n' || x=='\\r') {\n\t\t\t\t\t\t\t\t\t--r;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\t\tlen -= r + length - nq;\n\t\t\t\t\t\t\t\tnq = r + length;\n\t\t\t\t\t\t\t} else if (!opt_failed) {\n\t\t\t\t\t\t\t\t/* we failed optimized match,\n\t\t\t\t\t\t\t\t * try matching from the beginning\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tlen = q - buf;\n\t\t\t\t\t\t\t\tr = nq = buf;\n\t\t\t\t\t\t\t\t/* prevent\n\t\t\t\t\t\t\t\t * infloop */\n\t\t\t\t\t\t\t\topt_failed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (r);\n\t\t\t\t\t\tif(r) {\n\t\t\t\t\t\t\tr += length - 1;\n\t\t\t\t\t\t\tr = pdf_nextobject(r, bytesleft - (r - q));\n\t\t\t\t\t\t\tif(r) {\n\t\t\t\t\t\t\t\tlength = atoi(r);\n\t\t\t\t\t\t\t\twhile(isdigit(*r))\n\t\t\t\t\t\t\t\t\tr++;\n\t\t\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: length in '%s' %lu\\n\",\n\t\t\t\t\t\t\t\t\t&b[1],\n\t\t\t\t\t\t\t\t\tlength);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcli_dbgmsg(\"cli_pdf: Couldn't find '%s'\\n\",\n\t\t\t\t\t\t\t\t&b[1]);\n\t\t\t\t\t}\n\t\t\t\t\tq--;\n\t\t\t\t} else if(strncmp(q, \"Length2 \", 8) == 0)\n\t\t\t\t\tis_embedded_font = 1;\n\t\t\t\telse if(strncmp(q, \"Predictor \", 10) == 0) {\n\t\t\t\t\tq += 10;\n\t\t\t\t\tpredictor = atoi(q);\n\t\t\t\t\twhile(isdigit(*q))\n\t\t\t\t\t\tq++;\n\t\t\t\t\tq--;\n\t\t\t\t} else if(strncmp(q, \"FlateDecode\", 11) == 0) {\n\t\t\t\t\tis_flatedecode = 1;\n\t\t\t\t\tq += 11;\n\t\t\t\t} else if(strncmp(q, \"ASCII85Decode\", 13) == 0) {\n\t\t\t\t\tis_ascii85decode = 1;\n\t\t\t\t\tq += 13;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = pdf_nextobject(q, (size_t)(streamstart - q));\n\t\t\tif(q == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(is_embedded_font) {\n\t\t\t/*\n\t\t\t * Need some documentation, the only I can find a\n\t\t\t * reference to is not free, if some kind soul wishes\n\t\t\t * to donate a copy, please contact me!\n\t\t\t * (http://safari.adobepress.com/0321304748)\n\t\t\t */\n\t\t\tif(!printed_embedded_font_message) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: Embedded fonts not yet supported\\n\");\n\t\t\t\tprinted_embedded_font_message = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(predictor > 1) {\n\t\t\t/*\n\t\t\t * Needs some thought\n\t\t\t */\n\t\t\tif(!printed_predictor_message) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: Predictor %d not honoured for embedded image\\n\",\n\t\t\t\t\tpredictor);\n\t\t\t\tprinted_predictor_message = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* objend points to the end of the object (start of \"endobj\") */\n\t\tstreamstart += 6;\t/* go past the word \"stream\" */\n\t\tlen = (int)(objend - streamstart);\n\t\tq = pdf_nextlinestart(streamstart, len);\n\t\tif(q == NULL)\n\t\t\tbreak;\n\t\tlen -= (int)(q - streamstart);\n\t\tstreamstart = q;\n\t\tstreamend = cli_memstr(streamstart, len, \"endstream\\n\", 10);\n\t\tif(streamend == NULL) {\n\t\t\tstreamend = cli_memstr(streamstart, len, \"endstream\\r\", 10);\n\t\t\tif(streamend == NULL) {\n\t\t\t\tcli_dbgmsg(\"cli_pdf: No endstream\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thas_cr = 1;\n\t\t} else\n\t\t\thas_cr = 0;\n\t\tsnprintf(fullname, sizeof(fullname), \"%s\"PATHSEP\"pdf%02u\", dir, files);\n\t\tfout = open(fullname, O_RDWR|O_CREAT|O_EXCL|O_TRUNC|O_BINARY, 0600);\n\t\tif(fout < 0) {\n\t\t\tchar err[128];\n\t\t\tcli_errmsg(\"cli_pdf: can't create temporary file %s: %s\\n\", fullname, cli_strerror(errno, err, sizeof(err)));\n\t\t\trc = CL_ETMPFILE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Calculate the length ourself, the Length parameter is often\n\t\t * wrong\n\t\t */\n\t\tif((*--streamend != '\\n') && (*streamend != '\\r'))\n\t\t\tstreamend++;\n\t\telse if(has_cr && (*--streamend != '\\r'))\n\t\t\tstreamend++;\n\n\t\tif(streamend <= streamstart) {\n\t\t\tclose(fout);\n\t\t\tcli_dbgmsg(\"cli_pdf: Empty stream\\n\");\n\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\trc = CL_EUNLINK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tcalculated_streamlen = (int)(streamend - streamstart);\n\t\treal_streamlen = length;\n\n\t\tcli_dbgmsg(\"cli_pdf: length %lu, calculated_streamlen %lu isFlate %d isASCII85 %d\\n\",\n\t\t\tlength, calculated_streamlen,\n\t\t\tis_flatedecode, is_ascii85decode);\n\n\t\tif(calculated_streamlen != real_streamlen) {\n\t\t\tcli_dbgmsg(\"cli_pdf: Incorrect Length field in file attempting to recover\\n\");\n\t\t\tif(real_streamlen > calculated_streamlen)\n\t\t\t\treal_streamlen = calculated_streamlen;\n\t\t}\n#if\t0\n\t\t/* FIXME: this isn't right... */\n\t\tif(length)\n\t\t\t/*streamlen = (is_flatedecode) ? length : MIN(length, streamlen);*/\n\t\t\tstreamlen = MIN(length, streamlen);\n#endif\n\n\t\tif(is_ascii85decode) {\n\t\t\tunsigned char *tmpbuf;\n\t\t\tint ret = cli_checklimits(\"cli_pdf\", ctx, calculated_streamlen * 5, calculated_streamlen, real_streamlen);\n\n\t\t\tif(ret != CL_CLEAN) {\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttmpbuf = cli_malloc(calculated_streamlen * 5);\n\n\t\t\tif(tmpbuf == NULL) {\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ascii85decode(streamstart, calculated_streamlen, tmpbuf);\n\n\t\t\tif(ret == -1) {\n\t\t\t\tfree(tmpbuf);\n\t\t\t\tclose(fout);\n\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(ret) {\n\t\t\t\tunsigned char *t;\n\n\t\t\t\treal_streamlen = ret;\n\t\t\t\t/* free unused trailing bytes */\n\t\t\t\tt = (unsigned char *)cli_realloc(tmpbuf,calculated_streamlen);\n\t\t\t\tif(t == NULL) {\n\t\t\t\t\tfree(tmpbuf);\n\t\t\t\t\tclose(fout);\n\t\t\t\t\tif (cli_unlink(fullname)) {\n\t\t\t\t\t\trc = CL_EUNLINK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmpbuf = t;\n\t\t\t\t/*\n\t\t\t\t * Note that it will probably be both\n\t\t\t\t * ascii85encoded and flateencoded\n\t\t\t\t */\n\n\t\t\t\tif(is_flatedecode)\n\t\t\t\t\trc = try_flatedecode((unsigned char *)tmpbuf, real_streamlen, real_streamlen, fout, ctx);\n\t\t\t\telse\n\t\t\t\t  rc = (unsigned long)cli_writen(fout, (const char *)streamstart, real_streamlen)==real_streamlen ? CL_CLEAN : CL_EWRITE;\n\t\t\t}\n\t\t\tfree(tmpbuf);\n\t\t} else if(is_flatedecode) {\n\t\t\trc = try_flatedecode((unsigned char *)streamstart, real_streamlen, calculated_streamlen, fout, ctx);\n\n\t\t} else {\n\t\t\tcli_dbgmsg(\"cli_pdf: writing %lu bytes from the stream\\n\",\n\t\t\t\t(unsigned long)real_streamlen);\n\t\t\tif((rc = cli_checklimits(\"cli_pdf\", ctx, real_streamlen, 0, 0))==CL_CLEAN)\n\t\t\t\trc = (unsigned long)cli_writen(fout, (const char *)streamstart, real_streamlen) == real_streamlen ? CL_CLEAN : CL_EWRITE;\n\t\t}\n\n\t\tif (rc == CL_CLEAN) {\n\t\t\tcli_dbgmsg(\"cli_pdf: extracted file %u to %s\\n\", files, fullname);\n\t\t\tfiles++;\n\t\n\t\t\tlseek(fout, 0, SEEK_SET);\n\t\t\trc = cli_magic_scandesc(fout, ctx);\n\t\t}\n\t\tclose(fout);\n\t\tif(!ctx->engine->keeptmp)\n\t\t\tif (cli_unlink(fullname)) rc = CL_EUNLINK;\n\t\tif(rc != CL_CLEAN) break;\n\t}\n\n\n\tcli_dbgmsg(\"cli_pdf: returning %d\\n\", rc);\n\treturn rc;\n}", "target": 1, "cwe": [], "message": "bb #2016."}
{"func": "int cli_pdf(const char *dir, cli_ctx *ctx, off_t offset)\n{\n    struct pdf_struct pdf;\n    fmap_t *map = *ctx->fmap;\n    size_t size = map->len - offset;\n    off_t versize = size > 1032 ? 1032 : size;\n    off_t map_off, bytesleft;\n    long xref;\n    const char *pdfver, *start, *eofmap, *q, *eof;\n    int rc;\n    unsigned i;\n\n    cli_dbgmsg(\"in cli_pdf(%s)\\n\", dir);\n    memset(&pdf, 0, sizeof(pdf));\n    pdf.ctx = ctx;\n    pdf.dir = dir;\n\n    pdfver = start = fmap_need_off_once(map, offset, versize);\n\n    /* Check PDF version */\n    if (!pdfver) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (1)\\n\");\n\treturn CL_EMAP;\n    }\n    /* offset is 0 when coming from filetype2 */\n    pdfver = cli_memstr(pdfver, versize, \"%PDF-\", 5);\n    if (!pdfver) {\n\tcli_dbgmsg(\"cli_pdf: no PDF- header found\\n\");\n\treturn CL_SUCCESS;\n    }\n    /* Check for PDF-1.[0-9]. Although 1.7 is highest now, allow for future\n     * versions */\n    if (pdfver[5] != '1' || pdfver[6] != '.' ||\n\tpdfver[7] < '1' || pdfver[7] > '9') {\n\tpdf.flags |= 1 << BAD_PDF_VERSION;\n\tcli_dbgmsg(\"cli_pdf: bad pdf version: %.8s\\n\", pdfver);\n    }\n    if (pdfver != start || offset) {\n\tpdf.flags |= 1 << BAD_PDF_HEADERPOS;\n\tcli_dbgmsg(\"cli_pdf: PDF header is not at position 0: %ld\\n\",pdfver-start+offset);\n    }\n    offset += pdfver - start;\n\n    /* find trailer and xref, don't fail if not found */\n    map_off = map->len - 2048;\n    if (map_off < 0)\n\tmap_off = 0;\n    bytesleft = map->len - map_off;\n    eofmap = fmap_need_off_once(map, map_off, bytesleft);\n    if (!eofmap) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (2)\\n\");\n\treturn CL_EMAP;\n    }\n    eof = eofmap + bytesleft;\n    for (q=&eofmap[bytesleft-5]; q > eofmap; q--) {\n\tif (memcmp(q, \"%%EOF\", 5) == 0)\n\t    break;\n    }\n    if (q <= eofmap) {\n\tpdf.flags |= 1 << BAD_PDF_TRAILER;\n\tcli_dbgmsg(\"cli_pdf: %%%%EOF not found\\n\");\n    } else {\n\tsize = q - eofmap + map_off;\n\tfor (;q > eofmap;q--) {\n\t    if (memcmp(q, \"startxref\", 9) == 0)\n\t\tbreak;\n\t}\n\tif (q <= eofmap) {\n\t    pdf.flags |= 1 << BAD_PDF_TRAILER;\n\t    cli_dbgmsg(\"cli_pdf: startxref not found\\n\");\n\t}\n\tq += 9;\n\twhile (q < eof && (*q == ' ' || *q == '\\n' || *q == '\\r')) { q++; }\n\txref = atol(q);\n\tbytesleft = map->len - offset - xref;\n\tif (bytesleft > 4096)\n\t    bytesleft = 4096;\n\tq = fmap_need_off_once(map, offset + xref, bytesleft);\n\tif (!q || xrefCheck(q, q+bytesleft) == -1) {\n\t    cli_dbgmsg(\"cli_pdf: did not find valid xref\\n\");\n\t    pdf.flags |= 1 << BAD_PDF_TRAILER;\n\t}\n    }\n    size -= offset;\n\n    pdf.size = size;\n    pdf.map = fmap_need_off_once(map, offset, size);\n    if (!pdf.map) {\n\tcli_errmsg(\"cli_pdf: mmap() failed (3)\\n\");\n\treturn CL_EMAP;\n    }\n    /* parse PDF and find obj offsets */\n    while ((rc = pdf_findobj(&pdf)) > 0) {\n\tstruct pdf_obj *obj = &pdf.objs[pdf.nobjs-1];\n\tcli_dbgmsg(\"found %d %d obj @%ld\\n\", obj->id >> 8, obj->id&0xff, obj->start + offset);\n\tpdf_parseobj(&pdf, obj);\n    }\n    if (rc == -1)\n\tpdf.flags |= 1 << BAD_PDF_TOOMANYOBJS;\n\n    /* extract PDF objs */\n    for (i=0;i<pdf.nobjs;i++) {\n\tstruct pdf_obj *obj = &pdf.objs[i];\n\trc = pdf_extract_obj(&pdf, obj);\n\tif (rc != CL_SUCCESS)\n\t    break;\n    }\n\n    if (pdf.flags) {\n\tcli_dbgmsg(\"cli_pdf: flags 0x%02x\\n\", pdf.flags);\n\tif (pdf.flags & (1 << ESCAPED_COMMON_PDFNAME)) {\n\t    /* for example /Fl#61te#44#65#63#6f#64#65 instead of /FlateDecode */\n\t    *ctx->virname = \"Heuristics.PDF.ObfuscatedNameObject\";\n\t    rc = CL_VIRUS;\n\t}\n    }\n    cli_dbgmsg(\"cli_pdf: returning %d\\n\", rc);\n    free(pdf.objs);\n    return rc;\n}", "target": 1, "cwe": [], "message": "bb #2016."}
{"func": "retrieve_url (struct url * orig_parsed, const char *origurl, char **file,\n              char **newloc, const char *refurl, int *dt, bool recursive,\n              struct iri *iri, bool register_status)\n{\n  uerr_t result;\n  char *url;\n  bool location_changed;\n  bool iri_fallbacked = 0;\n  int dummy;\n  char *mynewloc, *proxy;\n  struct url *u = orig_parsed, *proxy_url;\n  int up_error_code;            /* url parse error code */\n  char *local_file;\n  int redirection_count = 0;\n\n  bool post_data_suspended = false;\n  char *saved_post_data = NULL;\n  char *saved_post_file_name = NULL;\n\n  /* If dt is NULL, use local storage.  */\n  if (!dt)\n    {\n      dt = &dummy;\n      dummy = 0;\n    }\n  url = xstrdup (origurl);\n  if (newloc)\n    *newloc = NULL;\n  if (file)\n    *file = NULL;\n\n  if (!refurl)\n    refurl = opt.referer;\n\n redirected:\n  /* (also for IRI fallbacking) */\n\n  result = NOCONERROR;\n  mynewloc = NULL;\n  local_file = NULL;\n  proxy_url = NULL;\n\n  proxy = getproxy (u);\n  if (proxy)\n    {\n      struct iri *pi = iri_new ();\n      set_uri_encoding (pi, opt.locale, true);\n      pi->utf8_encode = false;\n\n      /* Parse the proxy URL.  */\n      proxy_url = url_parse (proxy, &up_error_code, NULL, true);\n      if (!proxy_url)\n        {\n          char *error = url_error (proxy, up_error_code);\n          logprintf (LOG_NOTQUIET, _(\"Error parsing proxy URL %s: %s.\\n\"),\n                     proxy, error);\n          xfree (url);\n          xfree (error);\n          RESTORE_POST_DATA;\n          result = PROXERR;\n          goto bail;\n        }\n      if (proxy_url->scheme != SCHEME_HTTP && proxy_url->scheme != u->scheme)\n        {\n          logprintf (LOG_NOTQUIET, _(\"Error in proxy URL %s: Must be HTTP.\\n\"), proxy);\n          url_free (proxy_url);\n          xfree (url);\n          RESTORE_POST_DATA;\n          result = PROXERR;\n          goto bail;\n        }\n    }\n\n  if (u->scheme == SCHEME_HTTP\n#ifdef HAVE_SSL\n      || u->scheme == SCHEME_HTTPS\n#endif\n      || (proxy_url && proxy_url->scheme == SCHEME_HTTP))\n    {\n      result = http_loop (u, &mynewloc, &local_file, refurl, dt, proxy_url, iri);\n    }\n  else if (u->scheme == SCHEME_FTP)\n    {\n      /* If this is a redirection, temporarily turn off opt.ftp_glob\n         and opt.recursive, both being undesirable when following\n         redirects.  */\n      bool oldrec = recursive, glob = opt.ftp_glob;\n      if (redirection_count)\n        oldrec = glob = false;\n\n      result = ftp_loop (u, &local_file, dt, proxy_url, recursive, glob);\n      recursive = oldrec;\n\n      /* There is a possibility of having HTTP being redirected to\n         FTP.  In these cases we must decide whether the text is HTML\n         according to the suffix.  The HTML suffixes are `.html',\n         `.htm' and a few others, case-insensitive.  */\n      if (redirection_count && local_file && u->scheme == SCHEME_FTP)\n        {\n          if (has_html_suffix_p (local_file))\n            *dt |= TEXTHTML;\n        }\n    }\n\n  if (proxy_url)\n    {\n      url_free (proxy_url);\n      proxy_url = NULL;\n    }\n\n  location_changed = (result == NEWLOCATION);\n  if (location_changed)\n    {\n      char *construced_newloc;\n      struct url *newloc_parsed;\n\n      assert (mynewloc != NULL);\n\n      if (local_file)\n        xfree (local_file);\n\n      /* The HTTP specs only allow absolute URLs to appear in\n         redirects, but a ton of boneheaded webservers and CGIs out\n         there break the rules and use relative URLs, and popular\n         browsers are lenient about this, so wget should be too. */\n      construced_newloc = uri_merge (url, mynewloc);\n      xfree (mynewloc);\n      mynewloc = construced_newloc;\n\n      /* Reset UTF-8 encoding state, keep the URI encoding and reset\n         the content encoding. */\n      iri->utf8_encode = opt.enable_iri;\n      set_content_encoding (iri, NULL);\n      xfree_null (iri->orig_url);\n\n      /* Now, see if this new location makes sense. */\n      newloc_parsed = url_parse (mynewloc, &up_error_code, iri, true);\n      if (!newloc_parsed)\n        {\n          char *error = url_error (mynewloc, up_error_code);\n          logprintf (LOG_NOTQUIET, \"%s: %s.\\n\", escnonprint_uri (mynewloc),\n                     error);\n          if (orig_parsed != u)\n            {\n              url_free (u);\n            }\n          xfree (url);\n          xfree (mynewloc);\n          xfree (error);\n          RESTORE_POST_DATA;\n          goto bail;\n        }\n\n      /* Now mynewloc will become newloc_parsed->url, because if the\n         Location contained relative paths like .././something, we\n         don't want that propagating as url.  */\n      xfree (mynewloc);\n      mynewloc = xstrdup (newloc_parsed->url);\n\n      /* Check for max. number of redirections.  */\n      if (++redirection_count > opt.max_redirect)\n        {\n          logprintf (LOG_NOTQUIET, _(\"%d redirections exceeded.\\n\"),\n                     opt.max_redirect);\n          url_free (newloc_parsed);\n          if (orig_parsed != u)\n            {\n              url_free (u);\n            }\n          xfree (url);\n          xfree (mynewloc);\n          RESTORE_POST_DATA;\n          result = WRONGCODE;\n          goto bail;\n        }\n\n      xfree (url);\n      url = mynewloc;\n      if (orig_parsed != u)\n        {\n          url_free (u);\n        }\n      u = newloc_parsed;\n\n      /* If we're being redirected from POST, we don't want to POST\n         again.  Many requests answer POST with a redirection to an\n         index page; that redirection is clearly a GET.  We \"suspend\"\n         POST data for the duration of the redirections, and restore\n         it when we're done. */\n      if (!post_data_suspended)\n        SUSPEND_POST_DATA;\n\n      goto redirected;\n    }\n\n  /* Try to not encode in UTF-8 if fetching failed */\n  if (!(*dt & RETROKF) && iri->utf8_encode)\n    {\n      iri->utf8_encode = false;\n      if (orig_parsed != u)\n        {\n          url_free (u);\n        }\n      u = url_parse (origurl, NULL, iri, true);\n      if (u)\n        {\n          DEBUGP ((\"[IRI fallbacking to non-utf8 for %s\\n\", quote (url)));\n          url = xstrdup (u->url);\n          iri_fallbacked = 1;\n          goto redirected;\n        }\n      else\n          DEBUGP ((\"[Couldn't fallback to non-utf8 for %s\\n\", quote (url)));\n    }\n\n  if (local_file && *dt & RETROKF)\n    {\n      register_download (u->url, local_file);\n      if (redirection_count && 0 != strcmp (origurl, u->url))\n        register_redirection (origurl, u->url);\n      if (*dt & TEXTHTML)\n        register_html (u->url, local_file);\n      if (*dt & RETROKF)\n        {\n          register_download (u->url, local_file);\n          if (redirection_count && 0 != strcmp (origurl, u->url))\n            register_redirection (origurl, u->url);\n          if (*dt & TEXTHTML)\n            register_html (u->url, local_file);\n          if (*dt & TEXTCSS)\n            register_css (u->url, local_file);\n        }\n    }\n\n  if (file)\n    *file = local_file ? local_file : NULL;\n  else\n    xfree_null (local_file);\n\n  if (orig_parsed != u)\n    {\n      url_free (u);\n    }\n\n  if (redirection_count || iri_fallbacked)\n    {\n      if (newloc)\n        *newloc = url;\n      else\n        xfree (url);\n    }\n  else\n    {\n      if (newloc)\n        *newloc = NULL;\n      xfree (url);\n    }\n\n  RESTORE_POST_DATA;\n\nbail:\n  if (register_status)\n    inform_exit_status (result);\n  return result;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Introduce --trust-server-names.  Close CVE-2010-2252."}
{"func": "print_help (void)\n{\n  /* We split the help text this way to ease translation of individual\n     entries.  */\n  static const char *help[] = {\n    \"\\n\",\n    N_(\"\\\nMandatory arguments to long options are mandatory for short options too.\\n\\n\"),\n    N_(\"\\\nStartup:\\n\"),\n    N_(\"\\\n  -V,  --version           display the version of Wget and exit.\\n\"),\n    N_(\"\\\n  -h,  --help              print this help.\\n\"),\n    N_(\"\\\n  -b,  --background        go to background after startup.\\n\"),\n    N_(\"\\\n  -e,  --execute=COMMAND   execute a `.wgetrc'-style command.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nLogging and input file:\\n\"),\n    N_(\"\\\n  -o,  --output-file=FILE    log messages to FILE.\\n\"),\n    N_(\"\\\n  -a,  --append-output=FILE  append messages to FILE.\\n\"),\n#ifdef ENABLE_DEBUG\n    N_(\"\\\n  -d,  --debug               print lots of debugging information.\\n\"),\n#endif\n#ifdef USE_WATT32\n    N_(\"\\\n       --wdebug              print Watt-32 debug output.\\n\"),\n#endif\n    N_(\"\\\n  -q,  --quiet               quiet (no output).\\n\"),\n    N_(\"\\\n  -v,  --verbose             be verbose (this is the default).\\n\"),\n    N_(\"\\\n  -nv, --no-verbose          turn off verboseness, without being quiet.\\n\"),\n    N_(\"\\\n  -i,  --input-file=FILE     download URLs found in local or external FILE.\\n\"),\n    N_(\"\\\n  -F,  --force-html          treat input file as HTML.\\n\"),\n    N_(\"\\\n  -B,  --base=URL            resolves HTML input-file links (-i -F)\\n\\\n                             relative to URL.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nDownload:\\n\"),\n    N_(\"\\\n  -t,  --tries=NUMBER            set number of retries to NUMBER (0 unlimits).\\n\"),\n    N_(\"\\\n       --retry-connrefused       retry even if connection is refused.\\n\"),\n    N_(\"\\\n  -O,  --output-document=FILE    write documents to FILE.\\n\"),\n    N_(\"\\\n  -nc, --no-clobber              skip downloads that would download to\\n\\\n                                 existing files.\\n\"),\n    N_(\"\\\n  -c,  --continue                resume getting a partially-downloaded file.\\n\"),\n    N_(\"\\\n       --progress=TYPE           select progress gauge type.\\n\"),\n    N_(\"\\\n  -N,  --timestamping            don't re-retrieve files unless newer than\\n\\\n                                 local.\\n\"),\n    N_(\"\\\n  --no-use-server-timestamps     don't set the local file's timestamp by\\n\\\n                                 the one on the server.\\n\"),\n    N_(\"\\\n  -S,  --server-response         print server response.\\n\"),\n    N_(\"\\\n       --spider                  don't download anything.\\n\"),\n    N_(\"\\\n  -T,  --timeout=SECONDS         set all timeout values to SECONDS.\\n\"),\n    N_(\"\\\n       --dns-timeout=SECS        set the DNS lookup timeout to SECS.\\n\"),\n    N_(\"\\\n       --connect-timeout=SECS    set the connect timeout to SECS.\\n\"),\n    N_(\"\\\n       --read-timeout=SECS       set the read timeout to SECS.\\n\"),\n    N_(\"\\\n  -w,  --wait=SECONDS            wait SECONDS between retrievals.\\n\"),\n    N_(\"\\\n       --waitretry=SECONDS       wait 1..SECONDS between retries of a retrieval.\\n\"),\n    N_(\"\\\n       --random-wait             wait from 0.5*WAIT...1.5*WAIT secs between retrievals.\\n\"),\n    N_(\"\\\n       --no-proxy                explicitly turn off proxy.\\n\"),\n    N_(\"\\\n  -Q,  --quota=NUMBER            set retrieval quota to NUMBER.\\n\"),\n    N_(\"\\\n       --bind-address=ADDRESS    bind to ADDRESS (hostname or IP) on local host.\\n\"),\n    N_(\"\\\n       --limit-rate=RATE         limit download rate to RATE.\\n\"),\n    N_(\"\\\n       --no-dns-cache            disable caching DNS lookups.\\n\"),\n    N_(\"\\\n       --restrict-file-names=OS  restrict chars in file names to ones OS allows.\\n\"),\n    N_(\"\\\n       --ignore-case             ignore case when matching files/directories.\\n\"),\n#ifdef ENABLE_IPV6\n    N_(\"\\\n  -4,  --inet4-only              connect only to IPv4 addresses.\\n\"),\n    N_(\"\\\n  -6,  --inet6-only              connect only to IPv6 addresses.\\n\"),\n    N_(\"\\\n       --prefer-family=FAMILY    connect first to addresses of specified family,\\n\\\n                                 one of IPv6, IPv4, or none.\\n\"),\n#endif\n    N_(\"\\\n       --user=USER               set both ftp and http user to USER.\\n\"),\n    N_(\"\\\n       --password=PASS           set both ftp and http password to PASS.\\n\"),\n    N_(\"\\\n       --ask-password            prompt for passwords.\\n\"),\n    N_(\"\\\n       --no-iri                  turn off IRI support.\\n\"),\n    N_(\"\\\n       --local-encoding=ENC      use ENC as the local encoding for IRIs.\\n\"),\n    N_(\"\\\n       --remote-encoding=ENC     use ENC as the default remote encoding.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nDirectories:\\n\"),\n    N_(\"\\\n  -nd, --no-directories           don't create directories.\\n\"),\n    N_(\"\\\n  -x,  --force-directories        force creation of directories.\\n\"),\n    N_(\"\\\n  -nH, --no-host-directories      don't create host directories.\\n\"),\n    N_(\"\\\n       --protocol-directories     use protocol name in directories.\\n\"),\n    N_(\"\\\n  -P,  --directory-prefix=PREFIX  save files to PREFIX/...\\n\"),\n    N_(\"\\\n       --cut-dirs=NUMBER          ignore NUMBER remote directory components.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nHTTP options:\\n\"),\n    N_(\"\\\n       --http-user=USER        set http user to USER.\\n\"),\n    N_(\"\\\n       --http-password=PASS    set http password to PASS.\\n\"),\n    N_(\"\\\n       --no-cache              disallow server-cached data.\\n\"),\n    N_ (\"\\\n       --default-page=NAME     Change the default page name (normally\\n\\\n                               this is `index.html'.).\\n\"),\n    N_(\"\\\n  -E,  --adjust-extension      save HTML/CSS documents with proper extensions.\\n\"),\n    N_(\"\\\n       --ignore-length         ignore `Content-Length' header field.\\n\"),\n    N_(\"\\\n       --header=STRING         insert STRING among the headers.\\n\"),\n    N_(\"\\\n       --max-redirect          maximum redirections allowed per page.\\n\"),\n    N_(\"\\\n       --proxy-user=USER       set USER as proxy username.\\n\"),\n    N_(\"\\\n       --proxy-password=PASS   set PASS as proxy password.\\n\"),\n    N_(\"\\\n       --referer=URL           include `Referer: URL' header in HTTP request.\\n\"),\n    N_(\"\\\n       --save-headers          save the HTTP headers to file.\\n\"),\n    N_(\"\\\n  -U,  --user-agent=AGENT      identify as AGENT instead of Wget/VERSION.\\n\"),\n    N_(\"\\\n       --no-http-keep-alive    disable HTTP keep-alive (persistent connections).\\n\"),\n    N_(\"\\\n       --no-cookies            don't use cookies.\\n\"),\n    N_(\"\\\n       --load-cookies=FILE     load cookies from FILE before session.\\n\"),\n    N_(\"\\\n       --save-cookies=FILE     save cookies to FILE after session.\\n\"),\n    N_(\"\\\n       --keep-session-cookies  load and save session (non-permanent) cookies.\\n\"),\n    N_(\"\\\n       --post-data=STRING      use the POST method; send STRING as the data.\\n\"),\n    N_(\"\\\n       --post-file=FILE        use the POST method; send contents of FILE.\\n\"),\n    N_(\"\\\n       --content-disposition   honor the Content-Disposition header when\\n\\\n                               choosing local file names (EXPERIMENTAL).\\n\"),\n    N_(\"\\\n       --auth-no-challenge     send Basic HTTP authentication information\\n\\\n                               without first waiting for the server's\\n\\\n                               challenge.\\n\"),\n    \"\\n\",\n\n#ifdef HAVE_SSL\n    N_(\"\\\nHTTPS (SSL/TLS) options:\\n\"),\n    N_(\"\\\n       --secure-protocol=PR     choose secure protocol, one of auto, SSLv2,\\n\\\n                                SSLv3, and TLSv1.\\n\"),\n    N_(\"\\\n       --no-check-certificate   don't validate the server's certificate.\\n\"),\n    N_(\"\\\n       --certificate=FILE       client certificate file.\\n\"),\n    N_(\"\\\n       --certificate-type=TYPE  client certificate type, PEM or DER.\\n\"),\n    N_(\"\\\n       --private-key=FILE       private key file.\\n\"),\n    N_(\"\\\n       --private-key-type=TYPE  private key type, PEM or DER.\\n\"),\n    N_(\"\\\n       --ca-certificate=FILE    file with the bundle of CA's.\\n\"),\n    N_(\"\\\n       --ca-directory=DIR       directory where hash list of CA's is stored.\\n\"),\n    N_(\"\\\n       --random-file=FILE       file with random data for seeding the SSL PRNG.\\n\"),\n    N_(\"\\\n       --egd-file=FILE          file naming the EGD socket with random data.\\n\"),\n    \"\\n\",\n#endif /* HAVE_SSL */\n\n    N_(\"\\\nFTP options:\\n\"),\n#ifdef __VMS\n    N_(\"\\\n       --ftp-stmlf             Use Stream_LF format for all binary FTP files.\\n\"),\n#endif /* def __VMS */\n    N_(\"\\\n       --ftp-user=USER         set ftp user to USER.\\n\"),\n    N_(\"\\\n       --ftp-password=PASS     set ftp password to PASS.\\n\"),\n    N_(\"\\\n       --no-remove-listing     don't remove `.listing' files.\\n\"),\n    N_(\"\\\n       --no-glob               turn off FTP file name globbing.\\n\"),\n    N_(\"\\\n       --no-passive-ftp        disable the \\\"passive\\\" transfer mode.\\n\"),\n    N_(\"\\\n       --retr-symlinks         when recursing, get linked-to files (not dir).\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nRecursive download:\\n\"),\n    N_(\"\\\n  -r,  --recursive          specify recursive download.\\n\"),\n    N_(\"\\\n  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).\\n\"),\n    N_(\"\\\n       --delete-after       delete files locally after downloading them.\\n\"),\n    N_(\"\\\n  -k,  --convert-links      make links in downloaded HTML or CSS point to\\n\\\n                            local files.\\n\"),\n#ifdef __VMS\n    N_(\"\\\n  -K,  --backup-converted   before converting file X, back up as X_orig.\\n\"),\n#else /* def __VMS */\n    N_(\"\\\n  -K,  --backup-converted   before converting file X, back up as X.orig.\\n\"),\n#endif /* def __VMS [else] */\n    N_(\"\\\n  -m,  --mirror             shortcut for -N -r -l inf --no-remove-listing.\\n\"),\n    N_(\"\\\n  -p,  --page-requisites    get all images, etc. needed to display HTML page.\\n\"),\n    N_(\"\\\n       --strict-comments    turn on strict (SGML) handling of HTML comments.\\n\"),\n    \"\\n\",\n\n    N_(\"\\\nRecursive accept/reject:\\n\"),\n    N_(\"\\\n  -A,  --accept=LIST               comma-separated list of accepted extensions.\\n\"),\n    N_(\"\\\n  -R,  --reject=LIST               comma-separated list of rejected extensions.\\n\"),\n    N_(\"\\\n  -D,  --domains=LIST              comma-separated list of accepted domains.\\n\"),\n    N_(\"\\\n       --exclude-domains=LIST      comma-separated list of rejected domains.\\n\"),\n    N_(\"\\\n       --follow-ftp                follow FTP links from HTML documents.\\n\"),\n    N_(\"\\\n       --follow-tags=LIST          comma-separated list of followed HTML tags.\\n\"),\n    N_(\"\\\n       --ignore-tags=LIST          comma-separated list of ignored HTML tags.\\n\"),\n    N_(\"\\\n  -H,  --span-hosts                go to foreign hosts when recursive.\\n\"),\n    N_(\"\\\n  -L,  --relative                  follow relative links only.\\n\"),\n    N_(\"\\\n  -I,  --include-directories=LIST  list of allowed directories.\\n\"),\n    N_(\"\\\n  -X,  --exclude-directories=LIST  list of excluded directories.\\n\"),\n    N_(\"\\\n  -np, --no-parent                 don't ascend to the parent directory.\\n\"),\n    \"\\n\",\n\n    N_(\"Mail bug reports and suggestions to <bug-wget@gnu.org>.\\n\")\n  };\n\n  size_t i;\n\n  printf (_(\"GNU Wget %s, a non-interactive network retriever.\\n\"),\n          version_string);\n  print_usage (0);\n\n  for (i = 0; i < countof (help); i++)\n    fputs (_(help[i]), stdout);\n\n  exit (0);\n}", "target": 1, "cwe": ["CWE-20"], "message": "Introduce --trust-server-names.  Close CVE-2010-2252."}
{"func": "http_loop (struct url *u, char **newloc, char **local_file, const char *referer,\n           int *dt, struct url *proxy, struct iri *iri)\n{\n  int count;\n  bool got_head = false;         /* used for time-stamping and filename detection */\n  bool time_came_from_head = false;\n  bool got_name = false;\n  char *tms;\n  const char *tmrate;\n  uerr_t err, ret = TRYLIMEXC;\n  time_t tmr = -1;               /* remote time-stamp */\n  struct http_stat hstat;        /* HTTP status */\n  struct_stat st;\n  bool send_head_first = true;\n  char *file_name;\n  bool force_full_retrieve = false;\n\n  /* Assert that no value for *LOCAL_FILE was passed. */\n  assert (local_file == NULL || *local_file == NULL);\n\n  /* Set LOCAL_FILE parameter. */\n  if (local_file && opt.output_document)\n    *local_file = HYPHENP (opt.output_document) ? NULL : xstrdup (opt.output_document);\n\n  /* Reset NEWLOC parameter. */\n  *newloc = NULL;\n\n  /* This used to be done in main(), but it's a better idea to do it\n     here so that we don't go through the hoops if we're just using\n     FTP or whatever. */\n  if (opt.cookies)\n    load_cookies ();\n\n  /* Warn on (likely bogus) wildcard usage in HTTP. */\n  if (opt.ftp_glob && has_wildcards_p (u->path))\n    logputs (LOG_VERBOSE, _(\"Warning: wildcards not supported in HTTP.\\n\"));\n\n  /* Setup hstat struct. */\n  xzero (hstat);\n  hstat.referer = referer;\n\n  if (opt.output_document)\n    {\n      hstat.local_file = xstrdup (opt.output_document);\n      got_name = true;\n    }\n  else if (!opt.content_disposition)\n    {\n      hstat.local_file = url_file_name (u);\n      got_name = true;\n    }\n\n  /* TODO: Ick! This code is now in both gethttp and http_loop, and is\n   * screaming for some refactoring. */\n  if (got_name && file_exists_p (hstat.local_file) && opt.noclobber && !opt.output_document)\n    {\n      /* If opt.noclobber is turned on and file already exists, do not\n         retrieve the file. But if the output_document was given, then this\n         test was already done and the file didn't exist. Hence the !opt.output_document */\n      logprintf (LOG_VERBOSE, _(\"\\\nFile %s already there; not retrieving.\\n\\n\"),\n                 quote (hstat.local_file));\n      /* If the file is there, we suppose it's retrieved OK.  */\n      *dt |= RETROKF;\n\n      /* #### Bogusness alert.  */\n      /* If its suffix is \"html\" or \"htm\" or similar, assume text/html.  */\n      if (has_html_suffix_p (hstat.local_file))\n        *dt |= TEXTHTML;\n\n      ret = RETROK;\n      goto exit;\n    }\n\n  /* Reset the counter. */\n  count = 0;\n\n  /* Reset the document type. */\n  *dt = 0;\n\n  /* Skip preliminary HEAD request if we're not in spider mode.  */\n  if (!opt.spider)\n    send_head_first = false;\n\n  /* Send preliminary HEAD request if -N is given and we have an existing\n   * destination file. */\n  file_name = url_file_name (u);\n  if (opt.timestamping && (file_exists_p (file_name)\n                           || opt.content_disposition))\n    send_head_first = true;\n  xfree (file_name);\n\n  /* THE loop */\n  do\n    {\n      /* Increment the pass counter.  */\n      ++count;\n      sleep_between_retrievals (count);\n\n      /* Get the current time string.  */\n      tms = datetime_str (time (NULL));\n\n      if (opt.spider && !got_head)\n        logprintf (LOG_VERBOSE, _(\"\\\nSpider mode enabled. Check if remote file exists.\\n\"));\n\n      /* Print fetch message, if opt.verbose.  */\n      if (opt.verbose)\n        {\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n\n          if (count > 1)\n            {\n              char tmp[256];\n              sprintf (tmp, _(\"(try:%2d)\"), count);\n              logprintf (LOG_NOTQUIET, \"--%s--  %s  %s\\n\",\n                         tms, tmp, hurl);\n            }\n          else\n            {\n              logprintf (LOG_NOTQUIET, \"--%s--  %s\\n\",\n                         tms, hurl);\n            }\n\n#ifdef WINDOWS\n          ws_changetitle (hurl);\n#endif\n          xfree (hurl);\n        }\n\n      /* Default document type is empty.  However, if spider mode is\n         on or time-stamping is employed, HEAD_ONLY commands is\n         encoded within *dt.  */\n      if (send_head_first && !got_head)\n        *dt |= HEAD_ONLY;\n      else\n        *dt &= ~HEAD_ONLY;\n\n      /* Decide whether or not to restart.  */\n      if (force_full_retrieve)\n        hstat.restval = hstat.len;\n      else if (opt.always_rest\n          && got_name\n          && stat (hstat.local_file, &st) == 0\n          && S_ISREG (st.st_mode))\n        /* When -c is used, continue from on-disk size.  (Can't use\n           hstat.len even if count>1 because we don't want a failed\n           first attempt to clobber existing data.)  */\n        hstat.restval = st.st_size;\n      else if (count > 1)\n        /* otherwise, continue where the previous try left off */\n        hstat.restval = hstat.len;\n      else\n        hstat.restval = 0;\n\n      /* Decide whether to send the no-cache directive.  We send it in\n         two cases:\n           a) we're using a proxy, and we're past our first retrieval.\n              Some proxies are notorious for caching incomplete data, so\n              we require a fresh get.\n           b) caching is explicitly inhibited. */\n      if ((proxy && count > 1)        /* a */\n          || !opt.allow_cache)        /* b */\n        *dt |= SEND_NOCACHE;\n      else\n        *dt &= ~SEND_NOCACHE;\n\n      /* Try fetching the document, or at least its head.  */\n      err = gethttp (u, &hstat, dt, proxy, iri);\n\n      /* Time?  */\n      tms = datetime_str (time (NULL));\n\n      /* Get the new location (with or without the redirection).  */\n      if (hstat.newloc)\n        *newloc = xstrdup (hstat.newloc);\n\n      switch (err)\n        {\n        case HERR: case HEOF: case CONSOCKERR: case CONCLOSED:\n        case CONERROR: case READERR: case WRITEFAILED:\n        case RANGEERR: case FOPEN_EXCL_ERR:\n          /* Non-fatal errors continue executing the loop, which will\n             bring them to \"while\" statement at the end, to judge\n             whether the number of tries was exceeded.  */\n          printwhat (count, opt.ntry);\n          continue;\n        case FWRITEERR: case FOPENERR:\n          /* Another fatal error.  */\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"Cannot write to %s (%s).\\n\"),\n                     quote (hstat.local_file), strerror (errno));\n        case HOSTERR: case CONIMPOSSIBLE: case PROXERR: case AUTHFAILED:\n        case SSLINITFAILED: case CONTNOTSUPPORTED: case VERIFCERTERR:\n          /* Fatal errors just return from the function.  */\n          ret = err;\n          goto exit;\n        case CONSSLERR:\n          /* Another fatal error.  */\n          logprintf (LOG_NOTQUIET, _(\"Unable to establish SSL connection.\\n\"));\n          ret = err;\n          goto exit;\n        case NEWLOCATION:\n          /* Return the new location to the caller.  */\n          if (!*newloc)\n            {\n              logprintf (LOG_NOTQUIET,\n                         _(\"ERROR: Redirection (%d) without location.\\n\"),\n                         hstat.statcode);\n              ret = WRONGCODE;\n            }\n          else\n            {\n              ret = NEWLOCATION;\n            }\n          goto exit;\n        case RETRUNNEEDED:\n          /* The file was already fully retrieved. */\n          ret = RETROK;\n          goto exit;\n        case RETRFINISHED:\n          /* Deal with you later.  */\n          break;\n        default:\n          /* All possibilities should have been exhausted.  */\n          abort ();\n        }\n\n      if (!(*dt & RETROKF))\n        {\n          char *hurl = NULL;\n          if (!opt.verbose)\n            {\n              /* #### Ugly ugly ugly! */\n              hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n              logprintf (LOG_NONVERBOSE, \"%s:\\n\", hurl);\n            }\n\n          /* Fall back to GET if HEAD fails with a 500 or 501 error code. */\n          if (*dt & HEAD_ONLY\n              && (hstat.statcode == 500 || hstat.statcode == 501))\n            {\n              got_head = true;\n              continue;\n            }\n          /* Maybe we should always keep track of broken links, not just in\n           * spider mode.\n           * Don't log error if it was UTF-8 encoded because we will try\n           * once unencoded. */\n          else if (opt.spider && !iri->utf8_encode)\n            {\n              /* #### Again: ugly ugly ugly! */\n              if (!hurl)\n                hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n              nonexisting_url (hurl);\n              logprintf (LOG_NOTQUIET, _(\"\\\nRemote file does not exist -- broken link!!!\\n\"));\n            }\n          else\n            {\n              logprintf (LOG_NOTQUIET, _(\"%s ERROR %d: %s.\\n\"),\n                         tms, hstat.statcode,\n                         quotearg_style (escape_quoting_style, hstat.error));\n            }\n          logputs (LOG_VERBOSE, \"\\n\");\n          ret = WRONGCODE;\n          xfree_null (hurl);\n          goto exit;\n        }\n\n      /* Did we get the time-stamp? */\n      if (!got_head)\n        {\n          got_head = true;    /* no more time-stamping */\n\n          if (opt.timestamping && !hstat.remote_time)\n            {\n              logputs (LOG_NOTQUIET, _(\"\\\nLast-modified header missing -- time-stamps turned off.\\n\"));\n            }\n          else if (hstat.remote_time)\n            {\n              /* Convert the date-string into struct tm.  */\n              tmr = http_atotm (hstat.remote_time);\n              if (tmr == (time_t) (-1))\n                logputs (LOG_VERBOSE, _(\"\\\nLast-modified header invalid -- time-stamp ignored.\\n\"));\n              if (*dt & HEAD_ONLY)\n                time_came_from_head = true;\n            }\n\n          if (send_head_first)\n            {\n              /* The time-stamping section.  */\n              if (opt.timestamping)\n                {\n                  if (hstat.orig_file_name) /* Perform the following\n                                               checks only if the file\n                                               we're supposed to\n                                               download already exists.  */\n                    {\n                      if (hstat.remote_time &&\n                          tmr != (time_t) (-1))\n                        {\n                          /* Now time-stamping can be used validly.\n                             Time-stamping means that if the sizes of\n                             the local and remote file match, and local\n                             file is newer than the remote file, it will\n                             not be retrieved.  Otherwise, the normal\n                             download procedure is resumed.  */\n                          if (hstat.orig_file_tstamp >= tmr)\n                            {\n                              if (hstat.contlen == -1\n                                  || hstat.orig_file_size == hstat.contlen)\n                                {\n                                  logprintf (LOG_VERBOSE, _(\"\\\nServer file no newer than local file %s -- not retrieving.\\n\\n\"),\n                                             quote (hstat.orig_file_name));\n                                  ret = RETROK;\n                                  goto exit;\n                                }\n                              else\n                                {\n                                  logprintf (LOG_VERBOSE, _(\"\\\nThe sizes do not match (local %s) -- retrieving.\\n\"),\n                                             number_to_static_string (hstat.orig_file_size));\n                                }\n                            }\n                          else\n                            {\n                              force_full_retrieve = true;\n                              logputs (LOG_VERBOSE,\n                                       _(\"Remote file is newer, retrieving.\\n\"));\n                            }\n\n                          logputs (LOG_VERBOSE, \"\\n\");\n                        }\n                    }\n\n                  /* free_hstat (&hstat); */\n                  hstat.timestamp_checked = true;\n                }\n\n              if (opt.spider)\n                {\n                  bool finished = true;\n                  if (opt.recursive)\n                    {\n                      if (*dt & TEXTHTML)\n                        {\n                          logputs (LOG_VERBOSE, _(\"\\\nRemote file exists and could contain links to other resources -- retrieving.\\n\\n\"));\n                          finished = false;\n                        }\n                      else\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists but does not contain any link -- not retrieving.\\n\\n\"));\n                          ret = RETROK; /* RETRUNNEEDED is not for caller. */\n                        }\n                    }\n                  else\n                    {\n                      if (*dt & TEXTHTML)\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists and could contain further links,\\n\\\nbut recursion is disabled -- not retrieving.\\n\\n\"));\n                        }\n                      else\n                        {\n                          logprintf (LOG_VERBOSE, _(\"\\\nRemote file exists.\\n\\n\"));\n                        }\n                      ret = RETROK; /* RETRUNNEEDED is not for caller. */\n                    }\n\n                  if (finished)\n                    {\n                      logprintf (LOG_NONVERBOSE,\n                                 _(\"%s URL: %s %2d %s\\n\"),\n                                 tms, u->url, hstat.statcode,\n                                 hstat.message ? quotearg_style (escape_quoting_style, hstat.message) : \"\");\n                      goto exit;\n                    }\n                }\n\n              got_name = true;\n              *dt &= ~HEAD_ONLY;\n              count = 0;          /* the retrieve count for HEAD is reset */\n              continue;\n            } /* send_head_first */\n        } /* !got_head */\n\n      if (opt.useservertimestamps\n          && (tmr != (time_t) (-1))\n          && ((hstat.len == hstat.contlen) ||\n              ((hstat.res == 0) && (hstat.contlen == -1))))\n        {\n          const char *fl = NULL;\n          set_local_file (&fl, hstat.local_file);\n          if (fl)\n            {\n              time_t newtmr = -1;\n              /* Reparse time header, in case it's changed. */\n              if (time_came_from_head\n                  && hstat.remote_time && hstat.remote_time[0])\n                {\n                  newtmr = http_atotm (hstat.remote_time);\n                  if (newtmr != (time_t)-1)\n                    tmr = newtmr;\n                }\n              touch (fl, tmr);\n            }\n        }\n      /* End of time-stamping section. */\n\n      tmrate = retr_rate (hstat.rd_size, hstat.dltime);\n      total_download_time += hstat.dltime;\n\n      if (hstat.len == hstat.contlen)\n        {\n          if (*dt & RETROKF)\n            {\n              bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n              logprintf (LOG_VERBOSE,\n                         write_to_stdout\n                         ? _(\"%s (%s) - written to stdout %s[%s/%s]\\n\\n\")\n                         : _(\"%s (%s) - %s saved [%s/%s]\\n\\n\"),\n                         tms, tmrate,\n                         write_to_stdout ? \"\" : quote (hstat.local_file),\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen));\n              logprintf (LOG_NONVERBOSE,\n                         \"%s URL:%s [%s/%s] -> \\\"%s\\\" [%d]\\n\",\n                         tms, u->url,\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen),\n                         hstat.local_file, count);\n            }\n          ++numurls;\n          total_downloaded_bytes += hstat.rd_size;\n\n          /* Remember that we downloaded the file for later \".orig\" code. */\n          if (*dt & ADDED_HTML_EXTENSION)\n            downloaded_file(FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED, hstat.local_file);\n          else\n            downloaded_file(FILE_DOWNLOADED_NORMALLY, hstat.local_file);\n\n          ret = RETROK;\n          goto exit;\n        }\n      else if (hstat.res == 0) /* No read error */\n        {\n          if (hstat.contlen == -1)  /* We don't know how much we were supposed\n                                       to get, so assume we succeeded. */\n            {\n              if (*dt & RETROKF)\n                {\n                  bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n                  logprintf (LOG_VERBOSE,\n                             write_to_stdout\n                             ? _(\"%s (%s) - written to stdout %s[%s]\\n\\n\")\n                             : _(\"%s (%s) - %s saved [%s]\\n\\n\"),\n                             tms, tmrate,\n                             write_to_stdout ? \"\" : quote (hstat.local_file),\n                             number_to_static_string (hstat.len));\n                  logprintf (LOG_NONVERBOSE,\n                             \"%s URL:%s [%s] -> \\\"%s\\\" [%d]\\n\",\n                             tms, u->url, number_to_static_string (hstat.len),\n                             hstat.local_file, count);\n                }\n              ++numurls;\n              total_downloaded_bytes += hstat.rd_size;\n\n              /* Remember that we downloaded the file for later \".orig\" code. */\n              if (*dt & ADDED_HTML_EXTENSION)\n                downloaded_file(FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED, hstat.local_file);\n              else\n                downloaded_file(FILE_DOWNLOADED_NORMALLY, hstat.local_file);\n\n              ret = RETROK;\n              goto exit;\n            }\n          else if (hstat.len < hstat.contlen) /* meaning we lost the\n                                                 connection too soon */\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Connection closed at byte %s. \"),\n                         tms, tmrate, number_to_static_string (hstat.len));\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          else if (hstat.len != hstat.restval)\n            /* Getting here would mean reading more data than\n               requested with content-length, which we never do.  */\n            abort ();\n          else\n            {\n              /* Getting here probably means that the content-length was\n               * _less_ than the original, local size. We should probably\n               * truncate or re-read, or something. FIXME */\n              ret = RETROK;\n              goto exit;\n            }\n        }\n      else /* from now on hstat.res can only be -1 */\n        {\n          if (hstat.contlen == -1)\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Read error at byte %s (%s).\"),\n                         tms, tmrate, number_to_static_string (hstat.len),\n                         hstat.rderrmsg);\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          else /* hstat.res == -1 and contlen is given */\n            {\n              logprintf (LOG_VERBOSE,\n                         _(\"%s (%s) - Read error at byte %s/%s (%s). \"),\n                         tms, tmrate,\n                         number_to_static_string (hstat.len),\n                         number_to_static_string (hstat.contlen),\n                         hstat.rderrmsg);\n              printwhat (count, opt.ntry);\n              continue;\n            }\n        }\n      /* not reached */\n    }\n  while (!opt.ntry || (count < opt.ntry));\n\nexit:\n  if (ret == RETROK)\n    *local_file = xstrdup (hstat.local_file);\n  free_hstat (&hstat);\n\n  return ret;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Introduce --trust-server-names.  Close CVE-2010-2252."}
{"func": "ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy, \n          bool recursive, bool glob)\n{\n  ccon con;                     /* FTP connection */\n  uerr_t res;\n\n  *dt = 0;\n\n  xzero (con);\n\n  con.csock = -1;\n  con.st = ON_YOUR_OWN;\n  con.rs = ST_UNIX;\n  con.id = NULL;\n  con.proxy = proxy;\n\n  /* If the file name is empty, the user probably wants a directory\n     index.  We'll provide one, properly HTML-ized.  Unless\n     opt.htmlify is 0, of course.  :-) */\n  if (!*u->file && !recursive)\n    {\n      struct fileinfo *f;\n      res = ftp_get_listing (u, &con, &f);\n\n      if (res == RETROK)\n        {\n          if (opt.htmlify && !opt.spider)\n            {\n              char *filename = (opt.output_document\n                                ? xstrdup (opt.output_document)\n                                : (con.target ? xstrdup (con.target)\n                                   : url_file_name (u)));\n              res = ftp_index (filename, u, f);\n              if (res == FTPOK && opt.verbose)\n                {\n                  if (!opt.output_document)\n                    {\n                      struct_stat st;\n                      wgint sz;\n                      if (stat (filename, &st) == 0)\n                        sz = st.st_size;\n                      else\n                        sz = -1;\n                      logprintf (LOG_NOTQUIET,\n                                 _(\"Wrote HTML-ized index to %s [%s].\\n\"),\n                                 quote (filename), number_to_static_string (sz));\n                    }\n                  else\n                    logprintf (LOG_NOTQUIET,\n                               _(\"Wrote HTML-ized index to %s.\\n\"),\n                               quote (filename));\n                }\n              xfree (filename);\n            }\n          freefileinfo (f);\n        }\n    }\n  else\n    {\n      bool ispattern = false;\n      if (glob)\n        {\n          /* Treat the URL as a pattern if the file name part of the\n             URL path contains wildcards.  (Don't check for u->file\n             because it is unescaped and therefore doesn't leave users\n             the option to escape literal '*' as %2A.)  */\n          char *file_part = strrchr (u->path, '/');\n          if (!file_part)\n            file_part = u->path;\n          ispattern = has_wildcards_p (file_part);\n        }\n      if (ispattern || recursive || opt.timestamping)\n        {\n          /* ftp_retrieve_glob is a catch-all function that gets called\n             if we need globbing, time-stamping or recursion.  Its\n             third argument is just what we really need.  */\n          res = ftp_retrieve_glob (u, &con,\n                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);\n        }\n      else\n        res = ftp_loop_internal (u, NULL, &con, local_file);\n    }\n  if (res == FTPOK)\n    res = RETROK;\n  if (res == RETROK)\n    *dt |= RETROKF;\n  /* If a connection was left, quench it.  */\n  if (con.csock != -1)\n    fd_close (con.csock);\n  xfree_null (con.id);\n  con.id = NULL;\n  xfree_null (con.target);\n  con.target = NULL;\n  return res;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Introduce --trust-server-names.  Close CVE-2010-2252."}
{"func": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\n\nerr_out:\n\tkfree(rule_buf);\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-190"], "message": "ethtool: Fix potential kernel buffer overflow in ETHTOOL_GRXCLSRLALL\n\nOn a 32-bit machine, info.rule_cnt >= 0x40000000 leads to integer\noverflow and the buffer may be smaller than needed.  Since\nETHTOOL_GRXCLSRLALL is unprivileged, this can presumably be used for at\nleast denial of service.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void Server::msgQueryUsers(ServerUser *uSource, MumbleProto::QueryUsers &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tMumbleProto::QueryUsers reply;\n\n\tfor (int i=0;i<msg.ids_size();++i) {\n\t\tint id = msg.ids(i);\n\t\tif (id >= 0) {\n\t\t\tconst QString &name = getUserName(id);\n\t\t\tif (! name.isEmpty()) {\n\t\t\t\treply.add_ids(id);\n\t\t\t\treply.add_names(u8(name));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=0;i<msg.names_size();++i) {\n\t\tQString name = u8(msg.names(i));\n\t\tint id = getUserID(name);\n\t\tif (id >= 0) {\n\t\t\tname = getUserName(id);\n\t\t\treply.add_ids(id);\n\t\t\treply.add_names(u8(name));\n\t\t}\n\t}\n\n\tsendMessage(uSource, reply);\n}", "target": 1, "cwe": ["CWE-20"], "message": "Don't crash on long usernames"}
{"func": "int Server::authenticate(QString &name, const QString &pw, const QStringList &emails, const QString &certhash, bool bStrongCert, const QList<QSslCertificate> &certs) {\n\tint res = -2;\n\n\temit authenticateSig(res, name, certs, certhash, bStrongCert, pw);\n\n\tif (res != -2) {\n\t\t// External authentication handled it. Ignore certificate completely.\n\t\tif (res != -1) {\n\t\t\tTransactionHolder th;\n\t\t\tQSqlQuery &query = *th.qsqQuery;\n\n\t\t\tint lchan=readLastChannel(res);\n\t\t\tif (lchan < 0)\n\t\t\t\tlchan = 0;\n\n\t\t\tSQLPREP(\"REPLACE INTO `%1users` (`server_id`, `user_id`, `name`, `lastchannel`) VALUES (?,?,?,?)\");\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tquery.addBindValue(name);\n\t\t\tquery.addBindValue(lchan);\n\t\t\tSQLEXEC();\n\t\t}\n\t\tif (res >= 0) {\n\t\t\tqhUserNameCache.remove(res);\n\t\t\tqhUserIDCache.remove(name);\n\t\t}\n\t\treturn res;\n\t}\n\n\tTransactionHolder th;\n\tQSqlQuery &query = *th.qsqQuery;\n\n\tSQLPREP(\"SELECT `user_id`,`name`,`pw` FROM `%1users` WHERE `server_id` = ? AND `name` like ?\");\n\tquery.addBindValue(iServerNum);\n\tquery.addBindValue(name);\n\tSQLEXEC();\n\tif (query.next()) {\n\t\tres = -1;\n\t\tQString storedpw = query.value(2).toString();\n\t\tQString hashedpw = QString::fromLatin1(sha1(pw).toHex());\n\n\t\tif (! storedpw.isEmpty() && (storedpw == hashedpw)) {\n\t\t\tname = query.value(1).toString();\n\t\t\tres = query.value(0).toInt();\n\t\t} else if (query.value(0).toInt() == 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// No password match. Try cert or email match, but only for non-SuperUser.\n\tif (!certhash.isEmpty() && (res < 0)) {\n\t\tSQLPREP(\"SELECT `user_id` FROM `%1user_info` WHERE `server_id` = ? AND `key` = ? AND `value` = ?\");\n\t\tquery.addBindValue(iServerNum);\n\t\tquery.addBindValue(ServerDB::User_Hash);\n\t\tquery.addBindValue(certhash);\n\t\tSQLEXEC();\n\t\tif (query.next()) {\n\t\t\tres = query.value(0).toInt();\n\t\t} else if (bStrongCert) {\n\t\t\tforeach(const QString &email, emails) {\n\t\t\t\tif (! email.isEmpty()) {\n\t\t\t\t\tquery.addBindValue(iServerNum);\n\t\t\t\t\tquery.addBindValue(ServerDB::User_Email);\n\t\t\t\t\tquery.addBindValue(email);\n\t\t\t\t\tSQLEXEC();\n\t\t\t\t\tif (query.next()) {\n\t\t\t\t\t\tres = query.value(0).toInt();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res > 0) {\n\t\t\tSQLPREP(\"SELECT `name` FROM `%1users` WHERE `server_id` = ? AND `user_id` = ?\");\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tSQLEXEC();\n\t\t\tif (! query.next()) {\n\t\t\t\tres = -1;\n\t\t\t} else {\n\t\t\t\tname = query.value(0).toString();\n\t\t\t}\n\t\t}\n\t}\n\tif (! certhash.isEmpty() && (res > 0)) {\n\t\tSQLPREP(\"REPLACE INTO `%1user_info` (`server_id`, `user_id`, `key`, `value`) VALUES (?, ?, ?, ?)\");\n\t\tquery.addBindValue(iServerNum);\n\t\tquery.addBindValue(res);\n\t\tquery.addBindValue(ServerDB::User_Hash);\n\t\tquery.addBindValue(certhash);\n\t\tSQLEXEC();\n\t\tif (! emails.isEmpty()) {\n\t\t\tquery.addBindValue(iServerNum);\n\t\t\tquery.addBindValue(res);\n\t\t\tquery.addBindValue(ServerDB::User_Email);\n\t\t\tquery.addBindValue(emails.at(0));\n\t\t\tSQLEXEC();\n\t\t}\n\t}\n\tif (res >= 0) {\n\t\tqhUserNameCache.remove(res);\n\t\tqhUserIDCache.remove(name);\n\t}\n\treturn res;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Don't crash on long usernames"}
{"func": "int Server::getUserID(const QString &name) {\n\tif (qhUserIDCache.contains(name))\n\t\treturn qhUserIDCache.value(name);\n\tint id = -2;\n\temit nameToIdSig(id, name);\n\tif (id != -2) {\n\t\tqhUserIDCache.insert(name, id);\n\t\tqhUserNameCache.insert(id, name);\n\t\treturn id;\n\t}\n\tTransactionHolder th;\n\n\tQSqlQuery &query = *th.qsqQuery;\n\tSQLPREP(\"SELECT `user_id` FROM `%1users` WHERE `server_id` = ? AND `name` like ?\");\n\tquery.addBindValue(iServerNum);\n\tquery.addBindValue(name);\n\tSQLEXEC();\n\tif (query.next()) {\n\t\tid = query.value(0).toInt();\n\t\tqhUserIDCache.insert(name, id);\n\t\tqhUserNameCache.insert(id, name);\n\t}\n\treturn id;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Don't crash on long usernames"}
{"func": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !GTK_WIDGET_MAPPED(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tGTK_WIDGET_MAPPED(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(widget->window,\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%d;%dt\",\n\t\t\t\t   width + VTE_PAD_WIDTH, height + VTE_PAD_WIDTH);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%d;%dt\",\n\t\t\t\t   widget->allocation.height - 2 * VTE_PAD_WIDTH,\n\t\t\t\t   widget->allocation.width - 2 * VTE_PAD_WIDTH);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - 2 * VTE_PAD_WIDTH,\n\t\t\t\t\theight - 2 * VTE_PAD_WIDTH);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report the icon title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting icon title.\\n\");\n\t\t\tvte_terminal_feed_child(terminal, _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report the window title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window title.\\n\");\n\t\t\tvte_terminal_feed_child(terminal, _VTE_CAP_OSC \"LTerminal\" _VTE_CAP_ST, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tVTE_PAD_WIDTH * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "cwe": [], "message": "fix bug #548272\n\nsvn path=/trunk/; revision=2365"}
{"func": "vte_sequence_handler_window_manipulation (VteTerminal *terminal, GValueArray *params)\n{\n\tGdkScreen *gscreen;\n\tVteScreen *screen;\n\tGValue *value;\n\tGtkWidget *widget;\n\tchar buf[128];\n\tlong param, arg1, arg2;\n\tgint width, height;\n\tguint i;\n\tGtkAllocation allocation;\n\n\twidget = &terminal->widget;\n\tscreen = terminal->pvt->screen;\n\n\tfor (i = 0; ((params != NULL) && (i < params->n_values)); i++) {\n\t\targ1 = arg2 = -1;\n\t\tif (i + 1 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 1);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ1 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tif (i + 2 < params->n_values) {\n\t\t\tvalue = g_value_array_get_nth(params, i + 2);\n\t\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\t\targ2 = g_value_get_long(value);\n\t\t\t}\n\t\t}\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tparam = g_value_get_long(value);\n\t\tswitch (param) {\n\t\tcase 1:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Deiconifying window.\\n\");\n\t\t\tvte_terminal_emit_deiconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Iconifying window.\\n\");\n\t\t\tvte_terminal_emit_iconify_window(terminal);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif ((arg1 != -1) && (arg2 != -2)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Moving window to \"\n\t\t\t\t\t\t\"%ld,%ld.\\n\", arg1, arg2);\n\t\t\t\tvte_terminal_emit_move_window(terminal,\n\t\t\t\t\t\t\t      arg1, arg2);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ldx%ld pixels).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Raising window.\\n\");\n\t\t\tvte_terminal_emit_raise_window(terminal);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE, \"Lowering window.\\n\");\n\t\t\tvte_terminal_emit_lower_window(terminal);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Refreshing window.\\n\");\n\t\t\t_vte_invalidate_all(terminal);\n\t\t\tvte_terminal_emit_refresh_window(terminal);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif ((arg1 != -1) && (arg2 != -1)) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing window \"\n\t\t\t\t\t\t\"(to %ld columns, %ld rows).\\n\",\n\t\t\t\t\t\targ2, arg1);\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\targ2 * terminal->char_width +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.left +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\targ1 * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.bottom);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tswitch (arg1) {\n\t\t\tcase 0:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Restoring window.\\n\");\n\t\t\t\tvte_terminal_emit_restore_window(terminal);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Maximizing window.\\n\");\n\t\t\t\tvte_terminal_emit_maximize_window(terminal);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\t/* If we're unmapped, then we're iconified. */\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"%dt\",\n\t\t\t\t   1 + !gtk_widget_get_mapped(widget));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window state %s.\\n\",\n\t\t\t\t\tgtk_widget_get_mapped(widget) ?\n\t\t\t\t\t\"non-iconified\" : \"iconified\");\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t/* Send window location, in pixels. */\n\t\t\tgdk_window_get_origin(gtk_widget_get_window(widget),\n\t\t\t\t\t      &width, &height);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"3;%d;%dt\",\n\t\t\t\t   width + terminal->pvt->inner_border.left,\n                                   height + terminal->pvt->inner_border.top);\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window location\"\n\t\t\t\t\t\"(%d++,%d++).\\n\",\n\t\t\t\t\twidth, height);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t/* Send window size, in pixels. */\n\t\t\tgtk_widget_get_allocation(widget, &allocation);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"4;%d;%dt\",\n\t\t\t\t   allocation.height -\n                                       (terminal->pvt->inner_border.top +\n                                        terminal->pvt->inner_border.bottom),\n\t\t\t\t   allocation.width -\n                                       (terminal->pvt->inner_border.left +\n                                        terminal->pvt->inner_border.right));\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window size \"\n\t\t\t\t\t\"(%dx%dn\",\n\t\t\t\t\twidth - (terminal->pvt->inner_border.left + terminal->pvt->inner_border.right),\n\t\t\t\t\theight - (terminal->pvt->inner_border.top + terminal->pvt->inner_border.bottom));\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\t/* Send widget size, in cells. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting widget size.\\n\");\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"8;%ld;%ldt\",\n\t\t\t\t   terminal->row_count,\n\t\t\t\t   terminal->column_count);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting screen size.\\n\");\n\t\t\tgscreen = gtk_widget_get_screen(widget);\n\t\t\theight = gdk_screen_get_height(gscreen);\n\t\t\twidth = gdk_screen_get_width(gscreen);\n\t\t\tg_snprintf(buf, sizeof(buf),\n\t\t\t\t   _VTE_CAP_CSI \"9;%ld;%ldt\",\n\t\t\t\t   height / terminal->char_height,\n\t\t\t\t   width / terminal->char_width);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\t/* Report the icon title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\"Reporting icon title.\\n\");\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"L%s\" _VTE_CAP_ST,\n\t\t\t\t    terminal->icon_title);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t/* Report the window title. */\n\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\"Reporting window title.\\n\");\n\t\t\tg_snprintf (buf, sizeof (buf),\n\t\t\t\t    _VTE_CAP_OSC \"l%s\" _VTE_CAP_ST,\n\t\t\t\t    terminal->window_title);\n\t\t\tvte_terminal_feed_child(terminal, buf, -1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (param >= 24) {\n\t\t\t\t_vte_debug_print(VTE_DEBUG_PARSE,\n\t\t\t\t\t\t\"Resizing to %ld rows.\\n\",\n\t\t\t\t\t       \tparam);\n\t\t\t\t/* Resize to the specified number of\n\t\t\t\t * rows. */\n\t\t\t\tvte_terminal_emit_resize_window(terminal,\n\t\t\t\t\t\t\t\tterminal->column_count * terminal->char_width +\n                                                                terminal->pvt->inner_border.left +\n                                                                terminal->pvt->inner_border.right,\n\t\t\t\t\t\t\t\tparam * terminal->char_height +\n\t\t\t\t\t\t\t\tterminal->pvt->inner_border.top +\n                                                                terminal->pvt->inner_border.bottom);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "cwe": [], "message": "Fix terminal title reporting\n\nFixed CVE-2003-0070 again.\nSee also http://marc.info/?l=bugtraq&m=104612710031920&w=2 .\n(cherry picked from commit 6042c75b5a6daa0e499e61c8e07242d890d38ff1)"}
{"func": "  main( int    argc,\n        char*  argv[] )\n  {\n    int    old_ptsize, orig_ptsize, file;\n    int    first_glyph = 0;\n    int    XisSetup = 0;\n    char*  execname;\n    int    option;\n    int    file_loaded;\n\n    grEvent  event;\n\n\n    execname = ft_basename( argv[0] );\n\n    while ( 1 )\n    {\n      option = getopt( argc, argv, \"d:e:f:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'd':\n        parse_design_coords( optarg );\n        break;\n\n      case 'e':\n        encoding = (FT_Encoding)make_tag( optarg );\n        break;\n\n      case 'f':\n        first_glyph = atoi( optarg );\n        break;\n\n      case 'r':\n        res = atoi( optarg );\n        if ( res < 1 )\n          usage( execname );\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if ( argc <= 1 )\n      usage( execname );\n\n    if ( sscanf( argv[0], \"%d\", &orig_ptsize ) != 1 )\n      orig_ptsize = 64;\n\n    file = 1;\n\n    /* Initialize engine */\n    error = FT_Init_FreeType( &library );\n    if ( error )\n      PanicZ( \"Could not initialize FreeType library\" );\n\n  NewFile:\n    ptsize      = orig_ptsize;\n    hinted      = 1;\n    file_loaded = 0;\n\n    /* Load face */\n    error = FT_New_Face( library, argv[file], 0, &face );\n    if ( error )\n      goto Display_Font;\n\n    if ( encoding != FT_ENCODING_NONE )\n    {\n      error = FT_Select_Charmap( face, encoding );\n      if ( error )\n        goto Display_Font;\n    }\n\n    /* retrieve multiple master information */\n    error = FT_Get_MM_Var( face, &multimaster );\n    if ( error )\n      goto Display_Font;\n\n    /* if the user specified a position, use it, otherwise */\n    /* set the current position to the median of each axis */\n    {\n      int  n;\n\n\n      for ( n = 0; n < (int)multimaster->num_axis; n++ )\n      {\n        design_pos[n] = n < requested_cnt ? requested_pos[n]\n                                          : multimaster->axis[n].def;\n        if ( design_pos[n] < multimaster->axis[n].minimum )\n          design_pos[n] = multimaster->axis[n].minimum;\n        else if ( design_pos[n] > multimaster->axis[n].maximum )\n          design_pos[n] = multimaster->axis[n].maximum;\n      }\n    }\n\n    error = FT_Set_Var_Design_Coordinates( face,\n                                           multimaster->num_axis,\n                                           design_pos );\n    if ( error )\n      goto Display_Font;\n\n    file_loaded++;\n\n    Reset_Scale( ptsize );\n\n    num_glyphs = face->num_glyphs;\n    glyph      = face->glyph;\n    size       = face->size;\n\n  Display_Font:\n    /* initialize graphics if needed */\n    if ( !XisSetup )\n    {\n      XisSetup = 1;\n      Init_Display();\n    }\n\n    grSetTitle( surface, \"FreeType Glyph Viewer - press F1 for help\" );\n    old_ptsize = ptsize;\n\n    if ( file_loaded >= 1 )\n    {\n      Fail = 0;\n      Num  = first_glyph;\n\n      if ( Num >= num_glyphs )\n        Num = num_glyphs - 1;\n\n      if ( Num < 0 )\n        Num = 0;\n    }\n\n    for ( ;; )\n    {\n      int  key;\n\n\n      Clear_Display();\n\n      if ( file_loaded >= 1 )\n      {\n        switch ( render_mode )\n        {\n        case 0:\n          Render_Text( Num );\n          break;\n\n        default:\n          Render_All( Num, ptsize );\n        }\n\n        sprintf( Header, \"%s %s (file %s)\",\n                         face->family_name,\n                         face->style_name,\n                         ft_basename( argv[file] ) );\n\n        if ( !new_header )\n          new_header = Header;\n\n        grWriteCellString( &bit, 0, 0, new_header, fore_color );\n        new_header = 0;\n\n        sprintf( Header, \"axis: \" );\n        {\n          int  n;\n\n\n          for ( n = 0; n < (int)multimaster->num_axis; n++ )\n          {\n            char  temp[32];\n\n\n            sprintf( temp, \"  %s:%g\",\n                           multimaster->axis[n].name,\n                           design_pos[n]/65536. );\n            strcat( Header, temp );\n          }\n        }\n        grWriteCellString( &bit, 0, 16, Header, fore_color );\n\n        sprintf( Header, \"at %d points, first glyph = %d\",\n                         ptsize,\n                         Num );\n      }\n      else\n      {\n        sprintf( Header, \"%s: not an MM font file, or could not be opened\",\n                         ft_basename( argv[file] ) );\n      }\n\n      grWriteCellString( &bit, 0, 8, Header, fore_color );\n      grRefreshSurface( surface );\n\n      grListenSurface( surface, 0, &event );\n      if ( !( key = Process_Event( &event ) ) )\n        goto End;\n\n      if ( key == 'n' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file < argc - 1 )\n          file++;\n\n        goto NewFile;\n      }\n\n      if ( key == 'p' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file > 1 )\n          file--;\n\n        goto NewFile;\n      }\n\n      if ( ptsize != old_ptsize )\n      {\n        Reset_Scale( ptsize );\n\n        old_ptsize = ptsize;\n      }\n    }\n\n  End:\n    grDoneSurface( surface );\n    grDoneDevices();\n\n    free            ( multimaster );\n    FT_Done_Face    ( face        );\n    FT_Done_FreeType( library     );\n\n    printf( \"Execution completed successfully.\\n\" );\n    printf( \"Fails = %d\\n\", Fail );\n\n    exit( 0 );      /* for safety reasons */\n    return 0;       /* never reached */\n  }", "target": 1, "cwe": ["CWE-120"], "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows."}
{"func": "  write_header( FT_Error error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n    const char*  format;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      Fatal( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\",\n                 face->family_name, face->style_name, basename );\n        break;\n\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\",\n                 basename, (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = (const char *)status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0, status.header,\n                       display->fore_color );\n\n    format = \"at %g points, first glyph index = %d\";\n\n    snprintf( status.header_buffer, 256, format, status.ptsize/64., status.Num );\n\n    if ( FT_HAS_GLYPH_NAMES( face ) )\n    {\n      char*  p;\n      int    format_len, gindex, size;\n\n\n      size = strlen( status.header_buffer );\n      p    = status.header_buffer + size;\n      size = 256 - size;\n\n      format = \", name = \";\n      format_len = strlen( format );\n\n      if ( size >= format_len + 2 )\n      {\n        gindex = status.Num;\n\n        strcpy( p, format );\n        if ( FT_Get_Glyph_Name( face, gindex, p + format_len, size - format_len ) )\n          *p = '\\0';\n      }\n    }\n\n    status.header = (const char *)status.header_buffer;\n    grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    grRefreshSurface( display->surface );\n  }", "target": 1, "cwe": ["CWE-120"], "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows."}
{"func": "  write_header( FT_Error  error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      PanicZ( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\", face->family_name,\n                 face->style_name, basename );\n        break;\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\", basename,\n            (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0,\n                       status.header, display->fore_color );\n\n    sprintf( status.header_buffer, \"at %g points, angle = %d\",\n             status.ptsize/64.0, status.angle );\n    grWriteCellString( display->bitmap, 0, CELLSTRING_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    grRefreshSurface( display->surface );\n  }", "target": 1, "cwe": ["CWE-120"], "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows."}
{"func": "  write_header( FT_Error  error_code )\n  {\n    FT_Face      face;\n    const char*  basename;\n    const char*  format;\n\n\n    error = FTC_Manager_LookupFace( handle->cache_manager,\n                                    handle->scaler.face_id, &face );\n    if ( error )\n      Fatal( \"can't access font file\" );\n\n    if ( !status.header )\n    {\n      basename = ft_basename( handle->current_font->filepathname );\n\n      switch ( error_code )\n      {\n      case FT_Err_Ok:\n        sprintf( status.header_buffer, \"%s %s (file `%s')\",\n                 face->family_name, face->style_name, basename );\n        break;\n      case FT_Err_Invalid_Pixel_Size:\n        sprintf( status.header_buffer, \"Invalid pixel size (file `%s')\",\n                 basename );\n        break;\n      case FT_Err_Invalid_PPem:\n        sprintf( status.header_buffer, \"Invalid ppem value (file `%s')\",\n                 basename );\n        break;\n      default:\n        sprintf( status.header_buffer, \"File `%s': error 0x%04x\",\n                 basename, (FT_UShort)error_code );\n        break;\n      }\n\n      status.header = status.header_buffer;\n    }\n\n    grWriteCellString( display->bitmap, 0, 0,\n                       status.header, display->fore_color );\n\n    format = status.encoding != FT_ENCODING_NONE\n             ? \"at %g points, first char code = 0x%x\"\n             : \"at %g points, first glyph index = %d\";\n\n    snprintf( status.header_buffer, 256, format,\n              status.ptsize / 64.0, status.Num );\n\n    if ( FT_HAS_GLYPH_NAMES( face ) )\n    {\n      char*  p;\n      int    format_len, gindex, size;\n\n\n      size = strlen( status.header_buffer );\n      p    = status.header_buffer + size;\n      size = 256 - size;\n\n      format = \", name = \";\n      format_len = strlen( format );\n\n      if ( size >= format_len + 2 )\n      {\n        gindex = status.Num;\n        if ( status.encoding != FT_ENCODING_NONE )\n          gindex = FTDemo_Get_Index( handle, status.Num );\n\n        strcpy( p, format );\n        if ( FT_Get_Glyph_Name( face, gindex,\n                                p + format_len, size - format_len ) )\n          *p = '\\0';\n      }\n    }\n\n    status.header = status.header_buffer;\n    grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,\n                       status.header_buffer, display->fore_color );\n\n    if ( status.use_custom_lcd_filter )\n    {\n      int             fwi = status.fw_index;\n      unsigned char  *fw  = status.filter_weights;\n\n\n      sprintf( status.header_buffer,\n               \"%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s\",\n               fwi == 0 ? \"[\" : \" \", fw[0], fwi == 0 ? \"]\" : \" \",\n               fwi == 1 ? \"[\" : \" \", fw[1], fwi == 1 ? \"]\" : \" \",\n               fwi == 2 ? \"[\" : \" \", fw[2], fwi == 2 ? \"]\" : \" \",\n               fwi == 3 ? \"[\" : \" \", fw[3], fwi == 3 ? \"]\" : \" \",\n               fwi == 4 ? \"[\" : \" \", fw[4], fwi == 4 ? \"]\" : \" \" );\n      grWriteCellString( display->bitmap, 0, 2 * HEADER_HEIGHT,\n                         status.header_buffer, display->fore_color );\n    }\n\n    grRefreshSurface( display->surface );\n  }", "target": 1, "cwe": ["CWE-120"], "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows."}
{"func": "  write_message( RenderState  state )\n  {\n    ADisplay  adisplay = (ADisplay)state->display.disp;\n\n\n    if ( state->message == NULL )\n    {\n      FontFace  face = &state->faces[state->face_index];\n      int       idx, total;\n\n\n      idx   = face->index;\n      total = 1;\n      while ( total + state->face_index < state->num_faces &&\n              face[total].filepath == face[0].filepath     )\n        total++;\n\n      total += idx;\n\n      state->message = state->message0;\n      if ( total > 1 )\n        sprintf( state->message0, \"%s %d/%d @ %5.1fpt\",\n                 state->filename, idx + 1, total,\n                 state->char_size );\n      else\n        sprintf( state->message0, \"%s @ %5.1fpt\",\n                 state->filename,\n                 state->char_size );\n    }\n\n    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,\n                       adisplay->fore_color );\n\n    state->message = NULL;\n  }", "target": 1, "cwe": ["CWE-120"], "message": "Fix Savannah bug #30054.\n\n* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,\nsrc/ftview.c: Use precision for `%s' where appropriate to avoid\nbuffer overflows."}
{"func": "  main( int    argc,\n        char*  argv[] )\n  {\n    int    old_ptsize, orig_ptsize, file;\n    int    first_glyph = 0;\n    int    XisSetup = 0;\n    char*  execname;\n    int    option;\n    int    file_loaded;\n\n    grEvent  event;\n\n\n    execname = ft_basename( argv[0] );\n\n    while ( 1 )\n    {\n      option = getopt( argc, argv, \"d:e:f:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'd':\n        parse_design_coords( optarg );\n        break;\n\n      case 'e':\n        encoding = (FT_Encoding)make_tag( optarg );\n        break;\n\n      case 'f':\n        first_glyph = atoi( optarg );\n        break;\n\n      case 'r':\n        res = atoi( optarg );\n        if ( res < 1 )\n          usage( execname );\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if ( argc <= 1 )\n      usage( execname );\n\n    if ( sscanf( argv[0], \"%d\", &orig_ptsize ) != 1 )\n      orig_ptsize = 64;\n\n    file = 1;\n\n    /* Initialize engine */\n    error = FT_Init_FreeType( &library );\n    if ( error )\n      PanicZ( \"Could not initialize FreeType library\" );\n\n  NewFile:\n    ptsize      = orig_ptsize;\n    hinted      = 1;\n    file_loaded = 0;\n\n    /* Load face */\n    error = FT_New_Face( library, argv[file], 0, &face );\n    if ( error )\n      goto Display_Font;\n\n    if ( encoding != FT_ENCODING_NONE )\n    {\n      error = FT_Select_Charmap( face, encoding );\n      if ( error )\n        goto Display_Font;\n    }\n\n    /* retrieve multiple master information */\n    error = FT_Get_MM_Var( face, &multimaster );\n    if ( error )\n      goto Display_Font;\n\n    /* if the user specified a position, use it, otherwise */\n    /* set the current position to the median of each axis */\n    {\n      int  n;\n\n\n      for ( n = 0; n < (int)multimaster->num_axis; n++ )\n      {\n        design_pos[n] = n < requested_cnt ? requested_pos[n]\n                                          : multimaster->axis[n].def;\n        if ( design_pos[n] < multimaster->axis[n].minimum )\n          design_pos[n] = multimaster->axis[n].minimum;\n        else if ( design_pos[n] > multimaster->axis[n].maximum )\n          design_pos[n] = multimaster->axis[n].maximum;\n      }\n    }\n\n    error = FT_Set_Var_Design_Coordinates( face,\n                                           multimaster->num_axis,\n                                           design_pos );\n    if ( error )\n      goto Display_Font;\n\n    file_loaded++;\n\n    Reset_Scale( ptsize );\n\n    num_glyphs = face->num_glyphs;\n    glyph      = face->glyph;\n    size       = face->size;\n\n  Display_Font:\n    /* initialize graphics if needed */\n    if ( !XisSetup )\n    {\n      XisSetup = 1;\n      Init_Display();\n    }\n\n    grSetTitle( surface, \"FreeType Glyph Viewer - press F1 for help\" );\n    old_ptsize = ptsize;\n\n    if ( file_loaded >= 1 )\n    {\n      Fail = 0;\n      Num  = first_glyph;\n\n      if ( Num >= num_glyphs )\n        Num = num_glyphs - 1;\n\n      if ( Num < 0 )\n        Num = 0;\n    }\n\n    for ( ;; )\n    {\n      int  key;\n\n\n      Clear_Display();\n\n      if ( file_loaded >= 1 )\n      {\n        switch ( render_mode )\n        {\n        case 0:\n          Render_Text( Num );\n          break;\n\n        default:\n          Render_All( Num, ptsize );\n        }\n\n        sprintf( Header, \"%.50s %.50s (file %.100s)\",\n                         face->family_name,\n                         face->style_name,\n                         ft_basename( argv[file] ) );\n\n        if ( !new_header )\n          new_header = Header;\n\n        grWriteCellString( &bit, 0, 0, new_header, fore_color );\n        new_header = 0;\n\n        sprintf( Header, \"axis: \" );\n        {\n          int  n;\n\n\n          for ( n = 0; n < (int)multimaster->num_axis; n++ )\n          {\n            char  temp[32];\n\n\n            sprintf( temp, \"  %s:%g\",\n                           multimaster->axis[n].name,\n                           design_pos[n]/65536. );\n            strcat( Header, temp );\n          }\n        }\n        grWriteCellString( &bit, 0, 16, Header, fore_color );\n\n        sprintf( Header, \"at %d points, first glyph = %d\",\n                         ptsize,\n                         Num );\n      }\n      else\n      {\n        sprintf( Header, \"%.100s: not an MM font file, or could not be opened\",\n                         ft_basename( argv[file] ) );\n      }\n\n      grWriteCellString( &bit, 0, 8, Header, fore_color );\n      grRefreshSurface( surface );\n\n      grListenSurface( surface, 0, &event );\n      if ( !( key = Process_Event( &event ) ) )\n        goto End;\n\n      if ( key == 'n' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file < argc - 1 )\n          file++;\n\n        goto NewFile;\n      }\n\n      if ( key == 'p' )\n      {\n        if ( file_loaded >= 1 )\n          FT_Done_Face( face );\n\n        if ( file > 1 )\n          file--;\n\n        goto NewFile;\n      }\n\n      if ( ptsize != old_ptsize )\n      {\n        Reset_Scale( ptsize );\n\n        old_ptsize = ptsize;\n      }\n    }\n\n  End:\n    grDoneSurface( surface );\n    grDoneDevices();\n\n    free            ( multimaster );\n    FT_Done_Face    ( face        );\n    FT_Done_FreeType( library     );\n\n    printf( \"Execution completed successfully.\\n\" );\n    printf( \"Fails = %d\\n\", Fail );\n\n    exit( 0 );      /* for safety reasons */\n    return 0;       /* never reached */\n  }", "target": 1, "cwe": ["CWE-120"], "message": "ftmulti: Fix possible buffer overflow.\nBased on a patch from Marek Ka\u0161\u00edk <mkasik@redhat.com>.\n\n* src/ftmulti.c (main): Limit axis name length in `Header'."}
{"func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}", "target": 1, "cwe": ["CWE-476"], "message": "KEYS: Fix RCU no-lock warning in keyctl_session_to_parent()\n\nThere's an protected access to the parent process's credentials in the middle\nof keyctl_session_to_parent().  This results in the following RCU warning:\n\n  ===================================================\n  [ INFO: suspicious rcu_dereference_check() usage. ]\n  ---------------------------------------------------\n  security/keys/keyctl.c:1291 invoked rcu_dereference_check() without protection!\n\n  other info that might help us debug this:\n\n  rcu_scheduler_active = 1, debug_locks = 0\n  1 lock held by keyctl-session-/2137:\n   #0:  (tasklist_lock){.+.+..}, at: [<ffffffff811ae2ec>] keyctl_session_to_parent+0x60/0x236\n\n  stack backtrace:\n  Pid: 2137, comm: keyctl-session- Not tainted 2.6.36-rc2-cachefs+ #1\n  Call Trace:\n   [<ffffffff8105606a>] lockdep_rcu_dereference+0xaa/0xb3\n   [<ffffffff811ae379>] keyctl_session_to_parent+0xed/0x236\n   [<ffffffff811af77e>] sys_keyctl+0xb4/0xb6\n   [<ffffffff81001eab>] system_call_fastpath+0x16/0x1b\n\nThe code should take the RCU read lock to make sure the parents credentials\ndon't go away, even though it's holding a spinlock and has IRQ disabled.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "long keyctl_session_to_parent(void)\n{\n#ifdef TIF_NOTIFY_RESUME\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct cred *cred, *oldcred;\n\tkey_ref_t keyring_r;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\n\tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tparent = me->real_parent;\n\tret = -EPERM;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto not_permitted;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto not_permitted;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n\t\tgoto already_same;\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (pcred->uid\t!= mycred->euid\t||\n\t    pcred->euid\t!= mycred->euid\t||\n\t    pcred->suid\t!= mycred->euid\t||\n\t    pcred->gid\t!= mycred->egid\t||\n\t    pcred->egid\t!= mycred->egid\t||\n\t    pcred->sgid\t!= mycred->egid)\n\t\tgoto not_permitted;\n\n\t/* the keyrings must have the same UID */\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n\t    mycred->tgcred->session_keyring->uid != mycred->euid)\n\t\tgoto not_permitted;\n\n\t/* if there's an already pending keyring replacement, then we replace\n\t * that */\n\toldcred = parent->replacement_session_keyring;\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tparent->replacement_session_keyring = cred;\n\tcred = NULL;\n\tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldcred)\n\t\tput_cred(oldcred);\n\treturn 0;\n\nalready_same:\n\tret = 0;\nnot_permitted:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n\n#else /* !TIF_NOTIFY_RESUME */\n\t/*\n\t * To be removed when TIF_NOTIFY_RESUME has been implemented on\n\t * m68k/xtensa\n\t */\n#warning TIF_NOTIFY_RESUME not implemented\n\treturn -EOPNOTSUPP;\n#endif /* !TIF_NOTIFY_RESUME */\n}", "target": 1, "cwe": ["CWE-476"], "message": "KEYS: Fix bug in keyctl_session_to_parent() if parent has no session keyring\n\nFix a bug in keyctl_session_to_parent() whereby it tries to check the ownership\nof the parent process's session keyring whether or not the parent has a session\nkeyring [CVE-2010-2960].\n\nThis results in the following oops:\n\n  BUG: unable to handle kernel NULL pointer dereference at 00000000000000a0\n  IP: [<ffffffff811ae4dd>] keyctl_session_to_parent+0x251/0x443\n  ...\n  Call Trace:\n   [<ffffffff811ae2f3>] ? keyctl_session_to_parent+0x67/0x443\n   [<ffffffff8109d286>] ? __do_fault+0x24b/0x3d0\n   [<ffffffff811af98c>] sys_keyctl+0xb4/0xb8\n   [<ffffffff81001eab>] system_call_fastpath+0x16/0x1b\n\nif the parent process has no session keyring.\n\nIf the system is using pam_keyinit then it mostly protected against this as all\nprocesses derived from a login will have inherited the session keyring created\nby pam_keyinit during the log in procedure.\n\nTo test this, pam_keyinit calls need to be commented out in /etc/pam.d/.\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * AKPM: should this return a partial result if some of the IOs were\n\t * successfully submitted?\n\t */\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1, "cwe": ["CWE-190"], "message": "aio: check for multiplication overflow in do_io_submit\n\nTavis Ormandy pointed out that do_io_submit does not do proper bounds\nchecking on the passed-in iocb array:\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(nr < 0))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EINVAL;\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(iocbpp)))))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EFAULT; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0^^^^^^^^^^^^^^^^^^\n\nThe attached patch checks for overflow, and if it is detected, the\nnumber of iocbs submitted is scaled down to a number that will fit in\nthe long. \u00a0This is an ok thing to do, as sys_io_submit is documented as\nreturning the number of iocbs submitted, so callers should handle a\nreturn value of less than the 'nr' argument passed in.\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: Jeff Moyer <jmoyer@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "snd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\tsnd_seq_oss_readq_delete(dp->readq);\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_port(dp);\n\tdelete_seq_queue(dp->queue);\n\tkfree(dp);\n\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-415"], "message": "ALSA: seq/oss - Fix double-free at error path of snd_seq_oss_open()\n\nThe error handling in snd_seq_oss_open() has several bad codes that\ndo dereferecing released pointers and double-free of kmalloc'ed data.\nThe object dp is release in free_devinfo() that is called via\nprivate_free callback.  The rest shouldn't touch this object any more.\n\nThe patch changes delete_port() to call kfree() in any case, and gets\nrid of unnecessary calls of destructors in snd_seq_oss_open().\n\nFixes CVE-2010-3080.\n\nReported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nCc: <stable@kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>"}
{"func": "delete_port(struct seq_oss_devinfo *dp)\n{\n\tif (dp->port < 0)\n\t\treturn 0;\n\n\tdebug_printk((\"delete_port %i\\n\", dp->port));\n\treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n}", "target": 1, "cwe": ["CWE-415"], "message": "ALSA: seq/oss - Fix double-free at error path of snd_seq_oss_open()\n\nThe error handling in snd_seq_oss_open() has several bad codes that\ndo dereferecing released pointers and double-free of kmalloc'ed data.\nThe object dp is release in free_devinfo() that is called via\nprivate_free callback.  The rest shouldn't touch this object any more.\n\nThe patch changes delete_port() to call kfree() in any case, and gets\nrid of unnecessary calls of destructors in snd_seq_oss_open().\n\nFixes CVE-2010-3080.\n\nReported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nCc: <stable@kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>"}
{"func": "load_status_changed_cb (WebKitWebView *view,\n                        GParamSpec *spec,\n                        EphyEmbed *embed)\n{\n  EphyEmbedPrivate *priv = embed->priv;\n  WebKitLoadStatus status = webkit_web_view_get_load_status (view);\n\n  if (status == WEBKIT_LOAD_COMMITTED) {\n    const gchar* uri;\n    EphyWebViewSecurityLevel security_level;\n\n    uri = webkit_web_view_get_uri (view);\n\n    ephy_embed_destroy_top_widgets (embed);\n\n    if (g_strcmp0 (uri, priv->loading_uri) != 0) {\n      g_free (priv->loading_uri);\n      priv->loading_uri = g_strdup (uri);\n    }\n\n    ephy_web_view_location_changed (EPHY_WEB_VIEW (view),\n                                    uri);\n    restore_zoom_level (embed, uri);\n    ephy_history_add_page (embed->priv->history,\n                           uri,\n                           FALSE,\n                           FALSE);\n\n    /*\n     * FIXME: as a temporary workaround while soup lacks the needed\n     * security API, determine security level based on the existence of\n     * a 'https' prefix for the URI\n     */\n    if (uri && g_str_has_prefix (uri, \"https\"))\n      security_level = EPHY_WEB_VIEW_STATE_IS_SECURE_HIGH;\n    else\n      security_level = EPHY_WEB_VIEW_STATE_IS_UNKNOWN;\n\n    ephy_web_view_set_security_level (EPHY_WEB_VIEW (view), security_level);\n  } else if (status == WEBKIT_LOAD_PROVISIONAL || status == WEBKIT_LOAD_FINISHED) {\n    EphyWebViewNetState estate = EPHY_WEB_VIEW_STATE_UNKNOWN;\n    char *loading_uri = NULL;\n\n    if (status == WEBKIT_LOAD_PROVISIONAL) {\n      WebKitWebFrame *frame;\n      WebKitWebDataSource *source;\n      WebKitNetworkRequest *request;\n\n      frame = webkit_web_view_get_main_frame (view);\n      source = webkit_web_frame_get_provisional_data_source (frame);\n      request = webkit_web_data_source_get_initial_request (source);\n      loading_uri = g_strdup (webkit_network_request_get_uri (request));\n\n      /* We also store the URI we are currently loading here, because\n       * we will want to use it in WEBKIT_LOAD_FINISHED, because if a\n       * load fails we may never get to committed */\n      priv->loading_uri = g_strdup (loading_uri);\n\n      estate = (EphyWebViewNetState) (estate |\n                                      EPHY_WEB_VIEW_STATE_START |\n                                      EPHY_WEB_VIEW_STATE_NEGOTIATING |\n                                      EPHY_WEB_VIEW_STATE_IS_REQUEST |\n                                      EPHY_WEB_VIEW_STATE_IS_NETWORK);\n      \n      g_signal_emit_by_name (EPHY_WEB_VIEW (view), \"new-document-now\", loading_uri);\n    } else if (status == WEBKIT_LOAD_FINISHED) {\n      loading_uri = priv->loading_uri;\n\n      /* Will be freed below */\n      priv->loading_uri = NULL;\n\n      estate = (EphyWebViewNetState) (estate |\n                                      EPHY_WEB_VIEW_STATE_STOP |\n                                      EPHY_WEB_VIEW_STATE_IS_DOCUMENT |\n                                      EPHY_WEB_VIEW_STATE_IS_NETWORK);\n    }\n\n    ephy_web_view_update_from_net_state (EPHY_WEB_VIEW (view),\n                                         loading_uri,\n                                         (EphyWebViewNetState)estate);\n\n    g_free (loading_uri);\n\n  }\n}", "target": 1, "cwe": [], "message": "Report broken certs through the padlock icon\n\nThis uses a new feature in libsoup that reports through a\nSoupMessageFlag whether the message is talking to a server that has a\ntrusted server.\n\nBug #600663"}
{"func": "ephy_embed_single_initialize (EphyEmbedSingle *single)\n{\n  SoupSession *session;\n  SoupCookieJar *jar;\n  char *filename;\n  char *cookie_policy;\n\n  /* Initialise nspluginwrapper's plugins if available */\n  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)\n    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);\n\n  ephy_embed_prefs_init ();\n\n  session = webkit_get_default_session ();\n\n  /* Store cookies in moz-compatible SQLite format */\n  filename = g_build_filename (ephy_dot_dir (), \"cookies.sqlite\", NULL);\n  jar = soup_cookie_jar_sqlite_new (filename, FALSE);\n  g_free (filename);\n  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);\n  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);\n  g_free (cookie_policy);\n\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));\n  g_object_unref (jar);\n\n  /* Use GNOME proxy settings through libproxy */\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n\n#ifdef SOUP_TYPE_PASSWORD_MANAGER\n  /* Use GNOME keyring to store passwords. Only add the manager if we\n     are not using a private session, otherwise we want any new\n     password to expire when we exit *and* we don't want to use any\n     existing password in the keyring */\n  if (ephy_has_private_profile () == FALSE)\n    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);\n#endif\n\n  return TRUE;\n}", "target": 1, "cwe": [], "message": "Report broken certs through the padlock icon\n\nThis uses a new feature in libsoup that reports through a\nSoupMessageFlag whether the message is talking to a server that has a\ntrusted server.\n\nBug #600663"}
{"func": "ephy_embed_single_initialize (EphyEmbedSingle *single)\n{\n  SoupSession *session;\n  SoupCookieJar *jar;\n  char *filename;\n  char *cookie_policy;\n\n  /* Initialise nspluginwrapper's plugins if available */\n  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)\n    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);\n\n  ephy_embed_prefs_init ();\n\n  session = webkit_get_default_session ();\n\n#ifdef GTLS_SYSTEM_CA_FILE\n  /* Check SSL certificates */\n\n  if (g_file_test (GTLS_SYSTEM_CA_FILE, G_FILE_TEST_EXISTS)) {\n    g_object_set (session,\n                  SOUP_SESSION_SSL_CA_FILE, GTLS_SYSTEM_CA_FILE,\n                  \"ignore-ssl-cert-errors\", TRUE,\n                  NULL);\n  } else {\n    g_warning (_(\"CA Certificates file we should use was not found, \"\\\n                 \"all SSL sites will be considered to have a broken certificate.\"));\n  }\n#endif\n\n  /* Store cookies in moz-compatible SQLite format */\n  filename = g_build_filename (ephy_dot_dir (), \"cookies.sqlite\", NULL);\n  jar = soup_cookie_jar_sqlite_new (filename, FALSE);\n  g_free (filename);\n  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);\n  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);\n  g_free (cookie_policy);\n\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));\n  g_object_unref (jar);\n\n  /* Use GNOME proxy settings through libproxy */\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n\n#ifdef SOUP_TYPE_PASSWORD_MANAGER\n  /* Use GNOME keyring to store passwords. Only add the manager if we\n     are not using a private session, otherwise we want any new\n     password to expire when we exit *and* we don't want to use any\n     existing password in the keyring */\n  if (ephy_has_private_profile () == FALSE)\n    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);\n#endif\n\n  return TRUE;\n}", "target": 1, "cwe": [], "message": "Fix last patch to account for changes in soup API, and bump required version"}
{"func": "static inline void kvm_load_fs(u16 sel)\n{\n\tasm(\"mov %0, %%fs\" : : \"rm\"(sel));\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static inline u16 kvm_read_gs(void)\n{\n\tu16 seg;\n\tasm(\"mov %%gs, %0\" : \"=g\"(seg));\n\treturn seg;\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tunsigned long flags;\n\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n\tif (vmx->host_state.fs_reload_needed)\n\t\tkvm_load_fs(vmx->host_state.fs_sel);\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n\t\t/*\n\t\t * If we have to reload gs, we must take care to\n\t\t * preserve our gs base.\n\t\t */\n\t\tlocal_irq_save(flags);\n\t\tkvm_load_gs(vmx->host_state.gs_sel);\n#ifdef CONFIG_X86_64\n\t\twrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));\n#endif\n\t\tlocal_irq_restore(flags);\n\t}\n\treload_tss();\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t}\n#endif\n\tif (current_thread_info()->status & TS_USEDFPU)\n\t\tclts();\n\tload_gdt(&__get_cpu_var(host_gdt));\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n\tu32 host_sysenter_cs, msr_low, msr_high;\n\tu32 junk;\n\tu64 host_pat, tsc_this, tsc_base;\n\tunsigned long a;\n\tstruct desc_ptr dt;\n\tint i;\n\tunsigned long kvm_vmx_return;\n\tu32 exec_control;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL,\n\t\tvmcs_config.pin_based_exec_ctrl);\n\n\texec_control = vmcs_config.cpu_based_exec_ctrl;\n\tif (!vm_need_tpr_shadow(vmx->vcpu.kvm)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\t\tif (!vm_need_virtualize_apic_accesses(vmx->vcpu.kvm))\n\t\t\texec_control &=\n\t\t\t\t~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tif (vmx->vpid == 0)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\t\tif (!enable_ept) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\t\tenable_unrestricted_guest = 0;\n\t\t}\n\t\tif (!enable_unrestricted_guest)\n\t\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\t\tif (!ple_gap)\n\t\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmcs_write32(PLE_WINDOW, ple_window);\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, !!bypass_guest_pf);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, !!bypass_guest_pf);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_writel(HOST_CR0, read_cr0() | X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_FS_SELECTOR, kvm_read_fs());    /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, kvm_read_gs());    /* 22.2.4 */\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\n\tasm(\"mov $.Lkvm_vmx_return, %0\" : \"=r\"(kvm_vmx_return));\n\tvmcs_writel(HOST_RIP, kvm_vmx_return); /* 22.2.5 */\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\trdmsr(MSR_IA32_SYSENTER_CS, host_sysenter_cs, junk);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, host_sysenter_cs);\n\trdmsrl(MSR_IA32_SYSENTER_ESP, a);\n\tvmcs_writel(HOST_IA32_SYSENTER_ESP, a);   /* 22.2.3 */\n\trdmsrl(MSR_IA32_SYSENTER_EIP, a);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, a);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\tvmcs_write64(HOST_IA32_PAT, host_pat);\n\t}\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, msr_low, msr_high);\n\t\thost_pat = msr_low | ((u64) msr_high << 32);\n\t\t/* Write the default value follow host pat */\n\t\tvmcs_write64(GUEST_IA32_PAT, host_pat);\n\t\t/* Keep arch.pat sync with GUEST_IA32_PAT */\n\t\tvmx->vcpu.arch.pat = host_pat;\n\t}\n\n\tfor (i = 0; i < NR_VMX_MSR; ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvmcs_write32(VM_ENTRY_CONTROLS, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n\n\ttsc_base = vmx->vcpu.kvm->arch.vm_init_tsc;\n\trdtscll(tsc_this);\n\tif (tsc_this < vmx->vcpu.kvm->arch.vm_init_tsc)\n\t\ttsc_base = tsc_this;\n\n\tguest_write_tsc(0, tsc_base);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tvmx->host_state.fs_sel = kvm_read_fs();\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tvmx->host_state.gs_sel = kvm_read_gs();\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t}\n#endif\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static inline u16 kvm_read_fs(void)\n{\n\tu16 seg;\n\tasm(\"mov %%fs, %0\" : \"=g\"(seg));\n\treturn seg;\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu16 fs_selector;\n\tu16 gs_selector;\n\tu16 ldt_selector;\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsave_host_msrs(vcpu);\n\tfs_selector = kvm_read_fs();\n\tgs_selector = kvm_read_gs();\n\tldt_selector = kvm_read_ldt();\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\t/* required for live migration with NPT */\n\tif (npt_enabled)\n\t\tsvm->vmcb->save.cr3 = vcpu->arch.cr3;\n\n\tclgi();\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\"R\"bp; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\"R\"bx \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\"R\"cx \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\"R\"dx \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\"R\"si \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\"R\"di \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\"R\"bp \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\"R\"ax \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\"R\"ax \\n\\t\"\n\t\t__ex(SVM_VMLOAD) \"\\n\\t\"\n\t\t__ex(SVM_VMRUN) \"\\n\\t\"\n\t\t__ex(SVM_VMSAVE) \"\\n\\t\"\n\t\t\"pop %%\"R\"ax \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\"R\"bx, %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"cx, %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"dx, %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"si, %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"di, %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\"R\"bp, %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n#endif\n\t\t\"pop %%\"R\"bp\"\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n\t\t, R\"bx\", R\"cx\", R\"dx\", R\"si\", R\"di\"\n#ifdef CONFIG_X86_64\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#endif\n\t\t);\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tkvm_load_fs(fs_selector);\n\tkvm_load_gs(gs_selector);\n\tkvm_load_ldt(ldt_selector);\n\tload_host_msrs(vcpu);\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tstgi();\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static inline void kvm_load_gs(u16 sel)\n{\n\tasm(\"mov %0, %%gs\" : : \"rm\"(sel));\n}", "target": 1, "cwe": ["CWE-400"], "message": "KVM: Fix fs/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": " */\nxmlNodePtr\nxmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur != NULL && cur->children != NULL)\n        return cur->children ;\n    if (cur == NULL) cur = ctxt->context->node;\n    if (cur == NULL) return(NULL) ; /* ERROR */\n    if (cur->next != NULL) return(cur->next) ;\n    do {\n        cur = cur->parent;\n        if (cur == NULL) break;\n        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);\n        if (cur->next != NULL) return(cur->next);\n    } while (cur != NULL);", "target": 1, "cwe": ["CWE-119"], "message": "Fix the semantic of XPath axis for namespace/attribute context nodes\n\nThe processing of namespace and attributes nodes was not compliant\nto the XPath-1.0 specification"}
{"func": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n\tif (cur->type == XML_NAMESPACE_DECL)\n\t    cur = (xmlNodePtr)((xmlNsPtr)cur)->next;\n        ctxt->ancestor = cur->parent;\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 1, "cwe": ["CWE-119"], "message": "Fix the semantic of XPath axis for namespace/attribute context nodes\n\nThe processing of namespace and attributes nodes was not compliant\nto the XPath-1.0 specification"}
{"func": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL)\n        cur = ctxt->context->node;\n    if (cur == NULL)\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));", "target": 1, "cwe": ["CWE-119"], "message": "Fix the semantic of XPath axis for namespace/attribute context nodes\n\nThe processing of namespace and attributes nodes was not compliant\nto the XPath-1.0 specification"}
{"func": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur == NULL)\n        cur = ctxt->context->node;\n    if (cur == NULL)\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));", "target": 1, "cwe": ["CWE-119"], "message": "Fix a change of semantic on XPath preceding and following axis\n\nThis was introduced in the prevous fix, while preceding-sibling and\nfollowing sibling axis are empty for attributes and namespaces,\npreceding and following axis should still work based on the parent\nelement. However the parent element is not available for a namespace\nnode, so we keep the axis empty in that case."}
{"func": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 1, "cwe": ["CWE-119"], "message": "Fix a change of semantic on XPath preceding and following axis\n\nThis was introduced in the prevous fix, while preceding-sibling and\nfollowing sibling axis are empty for attributes and namespaces,\npreceding and following axis should still work based on the parent\nelement. However the parent element is not available for a namespace\nnode, so we keep the axis empty in that case."}
{"func": " */\nxmlNodePtr\nxmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur != NULL) {\n        if ((cur->type == XML_ATTRIBUTE_NODE) ||\n            (cur->type == XML_NAMESPACE_DECL))\n            return(NULL);\n        if (cur->children != NULL)\n            return cur->children ;\n    }\n    if (cur == NULL) cur = ctxt->context->node;\n    if (cur == NULL) return(NULL) ; /* ERROR */\n    if (cur->next != NULL) return(cur->next) ;\n    do {\n        cur = cur->parent;\n        if (cur == NULL) break;\n        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);\n        if (cur->next != NULL) return(cur->next);\n    } while (cur != NULL);", "target": 1, "cwe": ["CWE-119"], "message": "Fix a change of semantic on XPath preceding and following axis\n\nThis was introduced in the prevous fix, while preceding-sibling and\nfollowing sibling axis are empty for attributes and namespaces,\npreceding and following axis should still work based on the parent\nelement. However the parent element is not available for a namespace\nnode, so we keep the axis empty in that case."}
{"func": "static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk\t= sock->sk;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tuaddr->sa_family = AF_PACKET;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n\tif (dev)\n\t\tstrlcpy(uaddr->sa_data, dev->name, 15);\n\telse\n\t\tmemset(uaddr->sa_data, 0, 14);\n\trcu_read_unlock();\n\t*uaddr_len = sizeof(*uaddr);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-909"], "message": "net: packet: fix information leak to userland\n\npacket_getname_spkt() doesn't initialize all members of sa_data field of\nsockaddr struct if strlen(dev->name) < 13.  This structure is then copied\nto userland.  It leads to leaking of contents of kernel stack memory.\nWe have to fully fill sa_data with strncpy() instead of strlcpy().\n\nThe same with packet_getname(): it doesn't initialize sll_pkttype field of\nsockaddr_ll.  Set it to zero.\n\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int packet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, sll, uaddr);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_ifindex = po->ifindex;\n\tsll->sll_protocol = po->num;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n\tif (dev) {\n\t\tsll->sll_hatype = dev->type;\n\t\tsll->sll_halen = dev->addr_len;\n\t\tmemcpy(sll->sll_addr, dev->dev_addr, dev->addr_len);\n\t} else {\n\t\tsll->sll_hatype = 0;\t/* Bad: we have no ARPHRD_UNSPEC */\n\t\tsll->sll_halen = 0;\n\t}\n\trcu_read_unlock();\n\t*uaddr_len = offsetof(struct sockaddr_ll, sll_addr) + sll->sll_halen;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-909"], "message": "net: packet: fix information leak to userland\n\npacket_getname_spkt() doesn't initialize all members of sa_data field of\nsockaddr struct if strlen(dev->name) < 13.  This structure is then copied\nto userland.  It leads to leaking of contents of kernel stack memory.\nWe have to fully fill sa_data with strncpy() instead of strlcpy().\n\nThe same with packet_getname(): it doesn't initialize sll_pkttype field of\nsockaddr_ll.  Set it to zero.\n\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow =\n\t\tkvm_x86_ops->get_interrupt_shadow(vcpu,\n\t\t\tKVM_X86_SHADOW_INT_MOV_SS | KVM_X86_SHADOW_INT_STI);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\n\tevents->sipi_vector = vcpu->arch.sipi_vector;\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n}", "target": 1, "cwe": ["CWE-200"], "message": "KVM: x86: fix information leak to userland\n\nStructures kvm_vcpu_events, kvm_debugregs, kvm_pit_state2 and\nkvm_clock_data are copied to userland with some padding and reserved\nfields unitialized.  It leads to leaking of contents of kernel stack\nmemory.  We have to initialize them to zero.\n\nIn patch v1 Jan Kiszka suggested to fill reserved fields with zeros\ninstead of memset'ting the whole struct.  It makes sense as these\nfields are explicitly marked as padding.  No more fields need zeroing.\n\nKVM-Stable-Tag.\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}", "target": 1, "cwe": ["CWE-200"], "message": "KVM: x86: fix information leak to userland\n\nStructures kvm_vcpu_events, kvm_debugregs, kvm_pit_state2 and\nkvm_clock_data are copied to userland with some padding and reserved\nfields unitialized.  It leads to leaking of contents of kernel stack\nmemory.  We have to initialize them to zero.\n\nIn patch v1 Jan Kiszka suggested to fill reserved fields with zeros\ninstead of memset'ting the whole struct.  It makes sense as these\nfields are explicitly marked as padding.  No more fields need zeroing.\n\nKVM-Stable-Tag.\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tdbgregs->dr6 = vcpu->arch.dr6;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "KVM: x86: fix information leak to userland\n\nStructures kvm_vcpu_events, kvm_debugregs, kvm_pit_state2 and\nkvm_clock_data are copied to userland with some padding and reserved\nfields unitialized.  It leads to leaking of contents of kernel stack\nmemory.  We have to initialize them to zero.\n\nIn patch v1 Jan Kiszka suggested to fill reserved fields with zeros\ninstead of memset'ting the whole struct.  It makes sense as these\nfields are explicitly marked as padding.  No more fields need zeroing.\n\nKVM-Stable-Tag.\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "long kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof irq_event))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (irqchip_in_kernel(kvm)) {\n\t\t\t__s32 status;\n\t\t\tstatus = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event.irq, irq_event.level);\n\t\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tirq_event.status = status;\n\t\t\t\tif (copy_to_user(argp, &irq_event,\n\t\t\t\t\t\t\tsizeof irq_event))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tr = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip = kmalloc(sizeof(*chip), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!chip)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(chip, argp, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip = kmalloc(sizeof(*chip), GFP_KERNEL);\n\n\t\tr = -ENOMEM;\n\t\tif (!chip)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(chip, argp, sizeof *chip))\n\t\t\tgoto set_irqchip_out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}", "target": 1, "cwe": ["CWE-200"], "message": "KVM: x86: fix information leak to userland\n\nStructures kvm_vcpu_events, kvm_debugregs, kvm_pit_state2 and\nkvm_clock_data are copied to userland with some padding and reserved\nfields unitialized.  It leads to leaking of contents of kernel stack\nmemory.  We have to initialize them to zero.\n\nIn patch v1 Jan Kiszka suggested to fill reserved fields with zeros\ninstead of memset'ting the whole struct.  It makes sense as these\nfields are explicitly marked as padding.  No more fields need zeroing.\n\nKVM-Stable-Tag.\nSigned-off-by: Vasiliy Kulikov <segooon@gmail.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "mono_lookup_pinvoke_call (MonoMethod *method, const char **exc_class, const char **exc_arg)\n{\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *)method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tguint32 scope_token;\n\tconst char *import = NULL;\n\tconst char *orig_scope;\n\tconst char *new_scope;\n\tchar *error_msg;\n\tchar *full_name, *file_name;\n\tint i;\n\tMonoDl *module = NULL;\n\n\tg_assert (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL);\n\n\tif (piinfo->addr)\n\t\treturn piinfo->addr;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *method_aux = \n\t\t\tg_hash_table_lookup (\n\t\t\t\t((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!method_aux)\n\t\t\treturn NULL;\n\n\t\timport = method_aux->dllentry;\n\t\torig_scope = method_aux->dll;\n\t}\n\telse {\n\t\tif (!piinfo->implmap_idx)\n\t\t\treturn NULL;\n\n\t\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\t\tpiinfo->piflags = im_cols [MONO_IMPLMAP_FLAGS];\n\t\timport = mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]);\n\t\tscope_token = mono_metadata_decode_row_col (mr, im_cols [MONO_IMPLMAP_SCOPE] - 1, MONO_MODULEREF_NAME);\n\t\torig_scope = mono_metadata_string_heap (image, scope_token);\n\t}\n\n\tmono_dllmap_lookup (image, orig_scope, import, &new_scope, &import);\n\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\"DllImport attempting to load: '%s'.\", new_scope);\n\n\tif (exc_class) {\n\t\t*exc_class = NULL;\n\t\t*exc_arg = NULL;\n\t}\n\n\t/* we allow a special name to dlopen from the running process namespace */\n\tif (strcmp (new_scope, \"__Internal\") == 0)\n\t\tmodule = mono_dl_open (NULL, MONO_DL_LAZY, &error_msg);\n\n\t/*\n\t * Try loading the module using a variety of names\n\t */\n\tfor (i = 0; i < 4; ++i) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t/* Try the original name */\n\t\t\tfile_name = g_strdup (new_scope);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* Try trimming the .dll extension */\n\t\t\tif (strstr (new_scope, \".dll\") == (new_scope + strlen (new_scope) - 4)) {\n\t\t\t\tfile_name = g_strdup (new_scope);\n\t\t\t\tfile_name [strlen (new_scope) - 4] = '\\0';\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (strstr (new_scope, \"lib\") != new_scope) {\n\t\t\t\tfile_name = g_strdup_printf (\"lib%s\", new_scope);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n#ifndef TARGET_WIN32\n\t\t\tif (!g_ascii_strcasecmp (\"user32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel32.dll\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"user32\", new_scope) ||\n\t\t\t    !g_ascii_strcasecmp (\"kernel\", new_scope)) {\n\t\t\t\tfile_name = g_strdup (\"libMonoSupportW.so\");\n\t\t\t} else\n#endif\n\t\t\t\t    continue;\n#ifndef TARGET_WIN32\n\t\t\tbreak;\n#endif\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (NULL, file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport loading location: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\"DllImport error loading library: '%s'.\",\n\t\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tvoid *iter = NULL;\n\t\t\twhile ((full_name = mono_dl_build_path (\".\", file_name, &iter))) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading library: '%s'.\", full_name);\n\t\t\t\tmodule = cached_module_load (full_name, MONO_DL_LAZY, &error_msg);\n\t\t\t\tif (!module) {\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t\t\tg_free (error_msg);\n\t\t\t\t}\n\t\t\t\tg_free (full_name);\n\t\t\t\tif (module)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!module) {\n\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\"DllImport loading: '%s'.\", file_name);\n\t\t\tmodule = cached_module_load (file_name, MONO_DL_LAZY, &error_msg);\n\t\t\tif (!module) {\n\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\"DllImport error loading library '%s'.\",\n\t\t\t\t\t\terror_msg);\n\t\t\t}\n\t\t}\n\n\t\tg_free (file_name);\n\n\t\tif (module)\n\t\t\tbreak;\n\t}\n\n\tif (!module) {\n\t\tmono_trace (G_LOG_LEVEL_WARNING, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"DllImport unable to load library '%s'.\",\n\t\t\t\terror_msg);\n\t\tg_free (error_msg);\n\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"DllNotFoundException\";\n\t\t\t*exc_arg = new_scope;\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef TARGET_WIN32\n\tif (import && import [0] == '#' && isdigit (import [1])) {\n\t\tchar *end;\n\t\tlong id;\n\n\t\tid = strtol (import + 1, &end, 10);\n\t\tif (id > 0 && *end == '\\0')\n\t\t\timport++;\n\t}\n#endif\n\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\"Searching for '%s'.\", import);\n\n\tif (piinfo->piflags & PINVOKE_ATTRIBUTE_NO_MANGLE) {\n\t\terror_msg = mono_dl_symbol (module, import, &piinfo->addr); \n\t} else {\n\t\tchar *mangled_name = NULL, *mangled_name2 = NULL;\n\t\tint mangle_charset;\n\t\tint mangle_stdcall;\n\t\tint mangle_param_count;\n#ifdef TARGET_WIN32\n\t\tint param_count;\n#endif\n\n\t\t/*\n\t\t * Search using a variety of mangled names\n\t\t */\n\t\tfor (mangle_charset = 0; mangle_charset <= 1; mangle_charset ++) {\n\t\t\tfor (mangle_stdcall = 0; mangle_stdcall <= 1; mangle_stdcall ++) {\n\t\t\t\tgboolean need_param_count = FALSE;\n#ifdef TARGET_WIN32\n\t\t\t\tif (mangle_stdcall > 0)\n\t\t\t\t\tneed_param_count = TRUE;\n#endif\n\t\t\t\tfor (mangle_param_count = 0; mangle_param_count <= (need_param_count ? 256 : 0); mangle_param_count += 4) {\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tmangled_name = (char*)import;\n\t\t\t\t\tswitch (piinfo->piflags & PINVOKE_ATTRIBUTE_CHAR_SET_MASK) {\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_UNICODE:\n\t\t\t\t\t\t/* Try the mangled name first */\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_AUTO:\n#ifdef TARGET_WIN32\n\t\t\t\t\t\tif (mangle_charset == 0)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"W\", NULL);\n#else\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n#endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PINVOKE_ATTRIBUTE_CHAR_SET_ANSI:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Try the mangled name last */\n\t\t\t\t\t\tif (mangle_charset == 1)\n\t\t\t\t\t\t\tmangled_name = g_strconcat (import, \"A\", NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n#ifdef TARGET_WIN32\n\t\t\t\t\tif (mangle_param_count == 0)\n\t\t\t\t\t\tparam_count = mono_method_signature (method)->param_count * sizeof (gpointer);\n\t\t\t\t\telse\n\t\t\t\t\t\t/* Try brute force, since it would be very hard to compute the stack usage correctly */\n\t\t\t\t\t\tparam_count = mangle_param_count;\n\n\t\t\t\t\t/* Try the stdcall mangled name */\n\t\t\t\t\t/* \n\t\t\t\t\t * gcc under windows creates mangled names without the underscore, but MS.NET\n\t\t\t\t\t * doesn't support it, so we doesn't support it either.\n\t\t\t\t\t */\n\t\t\t\t\tif (mangle_stdcall == 1)\n\t\t\t\t\t\tmangled_name2 = g_strdup_printf (\"_%s@%d\", mangled_name, param_count);\n\t\t\t\t\telse\n\t\t\t\t\t\tmangled_name2 = mangled_name;\n#else\n\t\t\t\t\tmangled_name2 = mangled_name;\n#endif\n\n\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\"Probing '%s'.\", mangled_name2);\n\n\t\t\t\t\terror_msg = mono_dl_symbol (module, mangled_name2, &piinfo->addr);\n\n\t\t\t\t\tif (piinfo->addr)\n\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_DLLIMPORT,\n\t\t\t\t\t\t\t\t\t\"Found as '%s'.\", mangled_name2);\n\n\t\t\t\t\tif (mangled_name != mangled_name2)\n\t\t\t\t\t\tg_free (mangled_name2);\n\t\t\t\t\tif (mangled_name != import)\n\t\t\t\t\t\tg_free (mangled_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!piinfo->addr) {\n\t\tg_free (error_msg);\n\t\tif (exc_class) {\n\t\t\t*exc_class = \"EntryPointNotFoundException\";\n\t\t\t*exc_arg = import;\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn piinfo->addr;\n}", "target": 1, "cwe": [], "message": "Search for dllimported shared libs in the base directory, not cwd.\n\n* loader.c: we don't search the current directory anymore for shared\nlibraries referenced in DllImport attributes, as it has a slight\nsecurity risk. We search in the same directory where the referencing\nimage was loaded from, instead. Fixes bug# 641915."}
{"func": "int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tstruct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto short_packet;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto discard;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\n\tif (sk == NULL) {\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto discard;\n\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto discard;\n\t\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS,\n\t\t\t\tproto == IPPROTO_UDPLITE);\n\n\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* deliver */\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\tudpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n\nshort_packet:\n\tLIMIT_NETDEBUG(KERN_DEBUG \"UDP%sv6: short packet: %d/%u\\n\",\n\t\t       proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t       ulen, skb->len);\n\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tunsigned int i;\n\tstruct sock *sk;\n\tstruct sk_buff *skb1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\n\t\tsk = stack[i];\n\t\tif (skb1) {\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n\t\t\telse if (sk_add_backlog(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\ndrop:\n\t\tatomic_inc(&sk->sk_drops);\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_INERRORS, IS_UDPLITE(sk));\n\t}\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)\n{\n\tint rc = NET_RX_SUCCESS;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (nested)\n\t\tbh_lock_sock_nested(sk);\n\telse\n\t\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\t/*\n\t\t * trylock + unlock semantics:\n\t\t */\n\t\tmutex_acquire(&sk->sk_lock.dep_map, 0, 1, _RET_IP_);\n\n\t\trc = sk_backlog_rcv(sk, skb);\n\n\t\tmutex_release(&sk->sk_lock.dep_map, 1, _RET_IP_);\n\t} else if (sk_add_backlog(sk, skb)) {\n\t\tbh_unlock_sock(sk);\n\t\tatomic_inc(&sk->sk_drops);\n\t\tgoto discard_and_relse;\n\t}\n\n\tbh_unlock_sock(sk);\nout:\n\tsock_put(sk);\n\treturn rc;\ndiscard_and_relse:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\t/*\n\t *\tCharge it to the socket, dropping if the queue is full.\n\t */\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\tnf_reset(skb);\n\n\tif (up->encap_type) {\n\t\t/*\n\t\t * This is an encapsulation socket so pass the skb to\n\t\t * the socket's udp_encap_rcv() hook. Otherwise, just\n\t\t * fall through and pass this up the UDP socket.\n\t\t * up->encap_rcv() returns the following value:\n\t\t * =0 if skb was successfully passed to the encap\n\t\t *    handler or was discarded by it.\n\t\t * >0 if skb should be passed on to UDP.\n\t\t * <0 if skb should be resubmitted as proto -N\n\t\t */\n\n\t\t/* if we're overly short, let UDP handle it */\n\t\tif (skb->len > sizeof(struct udphdr) &&\n\t\t    up->encap_rcv != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = (*up->encap_rcv)(sk, skb);\n\t\t\tif (ret <= 0) {\n\t\t\t\tUDP_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t\t UDP_MIB_INDATAGRAMS,\n\t\t\t\t\t\t is_udplite);\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t}\n\n\t\t/* FALLTHROUGH -- it's a UDP Packet */\n\t}\n\n\t/*\n\t * \tUDP-Lite specific tests, ignored on UDP sockets\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\t/*\n\t\t * MIB statistics other than incrementing the error count are\n\t\t * disabled for the following two types of errors: these depend\n\t\t * on the application settings, not on the functioning of the\n\t\t * protocol stack as such.\n\t\t *\n\t\t * RFC 3828 here recommends (sec 3.3): \"There should also be a\n\t\t * way ... to ... at least let the receiving application block\n\t\t * delivery of packets with coverage values less than a value\n\t\t * provided by the application.\"\n\t\t */\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE: partial coverage \"\n\t\t\t\t\"%d while full coverage %d requested\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\t/* The next case involves violating the min. coverage requested\n\t\t * by the receiver. This is subtle: if receiver wants x and x is\n\t\t * greater than the buffersize/MTU then receiver will complain\n\t\t * that it wants x while sender emits packets of smaller size y.\n\t\t * Therefore the above ...()->partial_cov statement is essential.\n\t\t */\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING\n\t\t\t\t\"UDPLITE: coverage %d too small, need min %d\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (sk->sk_filter) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\trc = 0;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\trc = __udp_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tbh_unlock_sock(sk);\n\t\tgoto drop;\n\t}\n\tbh_unlock_sock(sk);\n\n\treturn rc;\n\ndrop:\n\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tatomic_inc(&sk->sk_drops);\n\tkfree_skb(skb);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n{\n\tif (sk->sk_backlog.len >= max(sk->sk_backlog.limit, sk->sk_rcvbuf << 1))\n\t\treturn -ENOBUFS;\n\n\t__sk_add_backlog(sk, skb);\n\tsk->sk_backlog.len += skb->truesize;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\n\tsk->sk_send_head\t=\tNULL;\n\n\tinit_timer(&sk->sk_timer);\n\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_backlog.limit\t=\tsk->sk_rcvbuf << 1;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_sleep\t=\t&sock->wait;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_sleep\t=\tNULL;\n\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\n\tsk->sk_peercred.pid \t=\t0;\n\tsk->sk_peercred.uid\t=\t-1;\n\tsk->sk_peercred.gid\t=\t-1;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\n\t/*\n\t * Before updating sk_refcnt, we must commit prior changes to memory\n\t * (Documentation/RCU/rculist_nulls.txt for details)\n\t */\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "SCTP_STATIC int sctp_init_sock(struct sock *sk)\n{\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_sock *sp;\n\n\tSCTP_DEBUG_PRINTK(\"sctp_init_sock(sk: %p)\\n\", sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = sctp_max_burst;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = sctp_max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = sctp_rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = sctp_rto_initial;\n\tsp->rtoinfo.srto_max     = sctp_rto_max;\n\tsp->rtoinfo.srto_min     = sctp_rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = sctp_max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = sctp_valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = sctp_hb_interval;\n\tsp->pathmaxrxt  = sctp_max_retrans_path;\n\tsp->pathmtu     = 0; // allow default discovery\n\tsp->sackdelay   = sctp_sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tsp->ep = ep;\n\tsp->hmac = NULL;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\tpercpu_counter_inc(&sctp_sockets_allocated);\n\n\t/* Set socket backlog limit. */\n\tsk->sk_backlog.limit = sysctl_sctp_rmem[1];\n\n\tlocal_bh_disable();\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\tlocal_bh_enable();\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-400"], "message": "net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1, "cwe": ["CWE-20"], "message": "Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847"}
{"func": "MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t/*FIXME but this no longer should happen*/\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t/*FIXME but I think this is no longer necessary*/\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);", "target": 1, "cwe": ["CWE-20"], "message": "Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847"}
{"func": "string_vformat(uschar *buffer, int buflen, char *format, va_list ap)\n{\nenum { L_NORMAL, L_SHORT, L_LONG, L_LONGLONG, L_LONGDOUBLE };\n\nBOOL yield = TRUE;\nint width, precision;\nchar *fp = format;             /* Deliberately not unsigned */\nuschar *p = buffer;\nuschar *last = buffer + buflen - 1;\n\nstring_datestamp_offset = -1;  /* Datestamp not inserted */\n\n/* Scan the format and handle the insertions */\n\nwhile (*fp != 0)\n  {\n  int length = L_NORMAL;\n  int *nptr;\n  int slen;\n  char *null = \"NULL\";         /* ) These variables */\n  char *item_start, *s;        /* ) are deliberately */\n  char newformat[16];          /* ) not unsigned */\n\n  /* Non-% characters just get copied verbatim */\n\n  if (*fp != '%')\n    {\n    if (p >= last) { yield = FALSE; break; }\n    *p++ = (uschar)*fp++;\n    continue;\n    }\n\n  /* Deal with % characters. Pick off the width and precision, for checking\n  strings, skipping over the flag and modifier characters. */\n\n  item_start = fp;\n  width = precision = -1;\n\n  if (strchr(\"-+ #0\", *(++fp)) != NULL)\n    {\n    if (*fp == '#') null = \"\";\n    fp++;\n    }\n\n  if (isdigit((uschar)*fp))\n    {\n    width = *fp++ - '0';\n    while (isdigit((uschar)*fp)) width = width * 10 + *fp++ - '0';\n    }\n  else if (*fp == '*')\n    {\n    width = va_arg(ap, int);\n    fp++;\n    }\n\n  if (*fp == '.')\n    {\n    if (*(++fp) == '*')\n      {\n      precision = va_arg(ap, int);\n      fp++;\n      }\n    else\n      {\n      precision = 0;\n      while (isdigit((uschar)*fp))\n        precision = precision*10 + *fp++ - '0';\n      }\n    }\n\n  /* Skip over 'h', 'L', 'l', and 'll', remembering the item length */\n\n  if (*fp == 'h')\n    { fp++; length = L_SHORT; }\n  else if (*fp == 'L')\n    { fp++; length = L_LONGDOUBLE; }\n  else if (*fp == 'l')\n    {\n    if (fp[1] == 'l')\n      {\n      fp += 2;\n      length = L_LONGLONG;\n      }\n    else\n      {\n      fp++;\n      length = L_LONG;\n      }\n    }\n\n  /* Handle each specific format type. */\n\n  switch (*fp++)\n    {\n    case 'n':\n    nptr = va_arg(ap, int *);\n    *nptr = p - buffer;\n    break;\n\n    case 'd':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n    if (p >= last - ((length > L_LONG)? 24 : 12))\n      { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp - item_start] = 0;\n\n    /* Short int is promoted to int when passing through ..., so we must use\n    int for va_arg(). */\n\n    switch(length)\n      {\n      case L_SHORT:\n      case L_NORMAL:   sprintf(CS p, newformat, va_arg(ap, int)); break;\n      case L_LONG:     sprintf(CS p, newformat, va_arg(ap, long int)); break;\n      case L_LONGLONG: sprintf(CS p, newformat, va_arg(ap, LONGLONG_T)); break;\n      }\n    while (*p) p++;\n    break;\n\n    case 'p':\n    if (p >= last - 24) { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp - item_start] = 0;\n    sprintf(CS p, newformat, va_arg(ap, void *));\n    while (*p) p++;\n    break;\n\n    /* %f format is inherently insecure if the numbers that it may be\n    handed are unknown (e.g. 1e300). However, in Exim, %f is used for\n    printing load averages, and these are actually stored as integers\n    (load average * 1000) so the size of the numbers is constrained.\n    It is also used for formatting sending rates, where the simplicity\n    of the format prevents overflow. */\n\n    case 'f':\n    case 'e':\n    case 'E':\n    case 'g':\n    case 'G':\n    if (precision < 0) precision = 6;\n    if (p >= last - precision - 8) { yield = FALSE; goto END_FORMAT; }\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp-item_start] = 0;\n    if (length == L_LONGDOUBLE)\n      sprintf(CS p, newformat, va_arg(ap, long double));\n    else\n      sprintf(CS p, newformat, va_arg(ap, double));\n    while (*p) p++;\n    break;\n\n    /* String types */\n\n    case '%':\n    if (p >= last) { yield = FALSE; goto END_FORMAT; }\n    *p++ = '%';\n    break;\n\n    case 'c':\n    if (p >= last) { yield = FALSE; goto END_FORMAT; }\n    *p++ = va_arg(ap, int);\n    break;\n\n    case 'D':                   /* Insert datestamp for log file names */\n    s = CS tod_stamp(tod_log_datestamp);\n    string_datestamp_offset = p - buffer;   /* Passed back via global */\n    goto INSERT_STRING;\n\n    case 's':\n    case 'S':                   /* Forces *lower* case */\n    s = va_arg(ap, char *);\n\n    INSERT_STRING:              /* Come to from %D above */\n    if (s == NULL) s = null;\n    slen = Ustrlen(s);\n\n    /* If the width is specified, check that there is a precision\n    set; if not, set it to the width to prevent overruns of long\n    strings. */\n\n    if (width >= 0)\n      {\n      if (precision < 0) precision = width;\n      }\n\n    /* If a width is not specified and the precision is specified, set\n    the width to the precision, or the string length if shorted. */\n\n    else if (precision >= 0)\n      {\n      width = (precision < slen)? precision : slen;\n      }\n\n    /* If neither are specified, set them both to the string length. */\n\n    else width = precision = slen;\n\n    /* Check string space, and add the string to the buffer if ok. If\n    not OK, add part of the string (debugging uses this to show as\n    much as possible). */\n\n    if (p >= last - width)\n      {\n      yield = FALSE;\n      width = precision = last - p - 1;\n      }\n    sprintf(CS p, \"%*.*s\", width, precision, s);\n    if (fp[-1] == 'S')\n      while (*p) { *p = tolower(*p); p++; }\n    else\n      while (*p) p++;\n    if (!yield) goto END_FORMAT;\n    break;\n\n    /* Some things are never used in Exim; also catches junk. */\n\n    default:\n    strncpy(newformat, item_start, fp - item_start);\n    newformat[fp-item_start] = 0;\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"string_format: unsupported type \"\n      \"in \\\"%s\\\" in \\\"%s\\\"\", newformat, format);\n    break;\n    }\n  }\n\n/* Ensure string is complete; return TRUE if got to the end of the format */\n\nEND_FORMAT:\n\n*p = 0;\nreturn yield;\n}", "target": 1, "cwe": [], "message": "Buffer overrun fix. fixes: bug #787"}
{"func": "handle_smtp_call(int *listen_sockets, int listen_socket_count,\n  int accept_socket, struct sockaddr *accepted)\n{\npid_t pid;\nunion sockaddr_46 interface_sockaddr;\nEXIM_SOCKLEN_T ifsize = sizeof(interface_sockaddr);\nint dup_accept_socket = -1;\nint max_for_this_host = 0;\nint wfsize = 0;\nint wfptr = 0;\nint use_log_write_selector = log_write_selector;\nuschar *whofrom = NULL;\n\nvoid *reset_point = store_get(0);\n\n/* Make the address available in ASCII representation, and also fish out\nthe remote port. */\n\nsender_host_address = host_ntoa(-1, accepted, NULL, &sender_host_port);\nDEBUG(D_any) debug_printf(\"Connection request from %s port %d\\n\",\n  sender_host_address, sender_host_port);\n\n/* Set up the output stream, check the socket has duplicated, and set up the\ninput stream. These operations fail only the exceptional circumstances. Note\nthat never_error() won't use smtp_out if it is NULL. */\n\nsmtp_out = fdopen(accept_socket, \"wb\");\nif (smtp_out == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_out failed\", US\"\", errno);\n  goto ERROR_RETURN;\n  }\n\ndup_accept_socket = dup(accept_socket);\nif (dup_accept_socket < 0)\n  {\n  never_error(US\"daemon: couldn't dup socket descriptor\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\nsmtp_in = fdopen(dup_accept_socket, \"rb\");\nif (smtp_in == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_in failed\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\n/* Get the data for the local interface address. Panic for most errors, but\n\"connection reset by peer\" just means the connection went away. */\n\nif (getsockname(accept_socket, (struct sockaddr *)(&interface_sockaddr),\n     &ifsize) < 0)\n  {\n  log_write(0, LOG_MAIN | ((errno == ECONNRESET)? 0 : LOG_PANIC),\n    \"getsockname() failed: %s\", strerror(errno));\n  smtp_printf(\"421 Local problem: getsockname() failed; please try again later\\r\\n\");\n  goto ERROR_RETURN;\n  }\n\ninterface_address = host_ntoa(-1, &interface_sockaddr, NULL, &interface_port);\nDEBUG(D_interface) debug_printf(\"interface address=%s port=%d\\n\",\n  interface_address, interface_port);\n\n/* Build a string identifying the remote host and, if requested, the port and\nthe local interface data. This is for logging; at the end of this function the\nmemory is reclaimed. */\n\nwhofrom = string_append(whofrom, &wfsize, &wfptr, 3, \"[\", sender_host_address, \"]\");\n\nif ((log_extra_selector & LX_incoming_port) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 2, \":\", string_sprintf(\"%d\",\n    sender_host_port));\n\nif ((log_extra_selector & LX_incoming_interface) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 4, \" I=[\",\n    interface_address, \"]:\", string_sprintf(\"%d\", interface_port));\n\nwhofrom[wfptr] = 0;    /* Terminate the newly-built string */\n\n/* Check maximum number of connections. We do not check for reserved\nconnections or unacceptable hosts here. That is done in the subprocess because\nit might take some time. */\n\nif (smtp_accept_max > 0 && smtp_accept_count >= smtp_accept_max)\n  {\n  DEBUG(D_any) debug_printf(\"rejecting SMTP connection: count=%d max=%d\\n\",\n    smtp_accept_count, smtp_accept_max);\n  smtp_printf(\"421 Too many concurrent SMTP connections; \"\n    \"please try again later.\\r\\n\");\n  log_write(L_connection_reject,\n            LOG_MAIN, \"Connection from %s refused: too many connections\",\n    whofrom);\n  goto ERROR_RETURN;\n  }\n\n/* If a load limit above which only reserved hosts are acceptable is defined,\nget the load average here, and if there are in fact no reserved hosts, do\nthe test right away (saves a fork). If there are hosts, do the check in the\nsubprocess because it might take time. */\n\nif (smtp_load_reserve >= 0)\n  {\n  load_average = OS_GETLOADAVG();\n  if (smtp_reserve_hosts == NULL && load_average > smtp_load_reserve)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: load average = %.2f\\n\",\n      (double)load_average/1000.0);\n    smtp_printf(\"421 Too much load; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: load average = %.2f\",\n      whofrom, (double)load_average/1000.0);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* Check that one specific host (strictly, IP address) is not hogging\nresources. This is done here to prevent a denial of service attack by someone\nforcing you to fork lots of times before denying service. The value of\nsmtp_accept_max_per_host is a string which is expanded. This makes it possible\nto provide host-specific limits according to $sender_host address, but because\nthis is in the daemon mainline, only fast expansions (such as inline address\nchecks) should be used. The documentation is full of warnings. */\n\nif (smtp_accept_max_per_host != NULL)\n  {\n  uschar *expanded = expand_string(smtp_accept_max_per_host);\n  if (expanded == NULL)\n    {\n    if (!expand_string_forcedfail)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"failed for %s: %s\", whofrom, expand_string_message);\n    }\n  /* For speed, interpret a decimal number inline here */\n  else\n    {\n    uschar *s = expanded;\n    while (isdigit(*s))\n      max_for_this_host = max_for_this_host * 10 + *s++ - '0';\n    if (*s != 0)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"for %s contains non-digit: %s\", whofrom, expanded);\n    }\n  }\n\n/* If we have fewer connections than max_for_this_host, we can skip the tedious\nper host_address checks. Note that at this stage smtp_accept_count contains the\ncount of *other* connections, not including this one. */\n\nif ((max_for_this_host > 0) &&\n    (smtp_accept_count >= max_for_this_host))\n  {\n  int i;\n  int host_accept_count = 0;\n  int other_host_count = 0;    /* keep a count of non matches to optimise */\n\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].host_address != NULL)\n      {\n      if (Ustrcmp(sender_host_address, smtp_slots[i].host_address) == 0)\n       host_accept_count++;\n      else\n       other_host_count++;\n\n      /* Testing all these strings is expensive - see if we can drop out\n      early, either by hitting the target, or finding there are not enough\n      connections left to make the target. */\n\n      if ((host_accept_count >= max_for_this_host) ||\n         ((smtp_accept_count - other_host_count) < max_for_this_host))\n       break;\n      }\n    }\n\n  if (host_accept_count >= max_for_this_host)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: too many from this \"\n      \"IP address: count=%d max=%d\\n\",\n      host_accept_count, max_for_this_host);\n    smtp_printf(\"421 Too many concurrent SMTP connections \"\n      \"from this IP address; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: too many connections \"\n      \"from that IP address\", whofrom);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* OK, the connection count checks have been passed. Before we can fork the\naccepting process, we must first log the connection if requested. This logging\nused to happen in the subprocess, but doing that means that the value of\nsmtp_accept_count can be out of step by the time it is logged. So we have to do\nthe logging here and accept the performance cost. Note that smtp_accept_count\nhasn't yet been incremented to take account of this connection.\n\nIn order to minimize the cost (because this is going to happen for every\nconnection), do a preliminary selector test here. This saves ploughing through\nthe generalized logging code each time when the selector is false. If the\nselector is set, check whether the host is on the list for logging. If not,\narrange to unset the selector in the subprocess. */\n\nif ((log_write_selector & L_smtp_connection) != 0)\n  {\n  uschar *list = hosts_connection_nolog;\n  if (list != NULL && verify_check_host(&list) == OK)\n    use_log_write_selector &= ~L_smtp_connection;\n  else\n    log_write(L_smtp_connection, LOG_MAIN, \"SMTP connection from %s \"\n      \"(TCP/IP connection count = %d)\", whofrom, smtp_accept_count + 1);\n  }\n\n/* Now we can fork the accepting process; do a lookup tidy, just in case any\nexpansion above did a lookup. */\n\nsearch_tidyup();\npid = fork();\n\n/* Handle the child process */\n\nif (pid == 0)\n  {\n  int i;\n  int queue_only_reason = 0;\n  int old_pool = store_pool;\n  int save_debug_selector = debug_selector;\n  BOOL local_queue_only;\n  BOOL session_local_queue_only;\n  #ifdef SA_NOCLDWAIT\n  struct sigaction act;\n  #endif\n\n  smtp_accept_count++;    /* So that it includes this process */\n\n  /* May have been modified for the subprocess */\n\n  log_write_selector = use_log_write_selector;\n\n  /* Get the local interface address into permanent store */\n\n  store_pool = POOL_PERM;\n  interface_address = string_copy(interface_address);\n  store_pool = old_pool;\n\n  /* Check for a tls-on-connect port */\n\n  if (host_is_tls_on_connect_port(interface_port)) tls_on_connect = TRUE;\n\n  /* Expand smtp_active_hostname if required. We do not do this any earlier,\n  because it may depend on the local interface address (indeed, that is most\n  likely what it depends on.) */\n\n  smtp_active_hostname = primary_hostname;\n  if (raw_active_hostname != NULL)\n    {\n    uschar *nah = expand_string(raw_active_hostname);\n    if (nah == NULL)\n      {\n      if (!expand_string_forcedfail)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failed to expand \\\"%s\\\" \"\n          \"(smtp_active_hostname): %s\", raw_active_hostname,\n          expand_string_message);\n        smtp_printf(\"421 Local configuration error; \"\n          \"please try again later.\\r\\n\");\n        mac_smtp_fflush();\n        search_tidyup();\n        _exit(EXIT_FAILURE);\n        }\n      }\n    else if (nah[0] != 0) smtp_active_hostname = nah;\n    }\n\n  /* Initialize the queueing flags */\n\n  queue_check_only();\n  session_local_queue_only = queue_only;\n\n  /* Close the listening sockets, and set the SIGCHLD handler to SIG_IGN.\n  We also attempt to set things up so that children are automatically reaped,\n  but just in case this isn't available, there's a paranoid waitpid() in the\n  loop too (except for systems where we are sure it isn't needed). See the more\n  extensive comment before the reception loop in exim.c for a fuller\n  explanation of this logic. */\n\n  for (i = 0; i < listen_socket_count; i++) (void)close(listen_sockets[i]);\n\n  #ifdef SA_NOCLDWAIT\n  act.sa_handler = SIG_IGN;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = SA_NOCLDWAIT;\n  sigaction(SIGCHLD, &act, NULL);\n  #else\n  signal(SIGCHLD, SIG_IGN);\n  #endif\n\n  /* Attempt to get an id from the sending machine via the RFC 1413\n  protocol. We do this in the sub-process in order not to hold up the\n  main process if there is any delay. Then set up the fullhost information\n  in case there is no HELO/EHLO.\n\n  If debugging is enabled only for the daemon, we must turn if off while\n  finding the id, but turn it on again afterwards so that information about the\n  incoming connection is output. */\n\n  if (debug_daemon) debug_selector = 0;\n  verify_get_ident(IDENT_PORT);\n  host_build_sender_fullhost();\n  debug_selector = save_debug_selector;\n\n  DEBUG(D_any)\n    debug_printf(\"Process %d is handling incoming connection from %s\\n\",\n      (int)getpid(), sender_fullhost);\n\n  /* Now disable debugging permanently if it's required only for the daemon\n  process. */\n\n  if (debug_daemon) debug_selector = 0;\n\n  /* If there are too many child processes for immediate delivery,\n  set the session_local_queue_only flag, which is initialized from the\n  configured value and may therefore already be TRUE. Leave logging\n  till later so it will have a message id attached. Note that there is no\n  possibility of re-calculating this per-message, because the value of\n  smtp_accept_count does not change in this subprocess. */\n\n  if (smtp_accept_queue > 0 && smtp_accept_count > smtp_accept_queue)\n    {\n    session_local_queue_only = TRUE;\n    queue_only_reason = 1;\n    }\n\n  /* Handle the start of the SMTP session, then loop, accepting incoming\n  messages from the SMTP connection. The end will come at the QUIT command,\n  when smtp_setup_msg() returns 0. A break in the connection causes the\n  process to die (see accept.c).\n\n  NOTE: We do *not* call smtp_log_no_mail() if smtp_start_session() fails,\n  because a log line has already been written for all its failure exists\n  (usually \"connection refused: <reason>\") and writing another one is\n  unnecessary clutter. */\n\n  if (!smtp_start_session())\n    {\n    mac_smtp_fflush();\n    search_tidyup();\n    _exit(EXIT_SUCCESS);\n    }\n\n  for (;;)\n    {\n    int rc;\n    message_id[0] = 0;            /* Clear out any previous message_id */\n    reset_point = store_get(0);   /* Save current store high water point */\n\n    DEBUG(D_any)\n      debug_printf(\"Process %d is ready for new message\\n\", (int)getpid());\n\n    /* Smtp_setup_msg() returns 0 on QUIT or if the call is from an\n    unacceptable host or if an ACL \"drop\" command was triggered, -1 on\n    connection lost, and +1 on validly reaching DATA. Receive_msg() almost\n    always returns TRUE when smtp_input is true; just retry if no message was\n    accepted (can happen for invalid message parameters). However, it can yield\n    FALSE if the connection was forcibly dropped by the DATA ACL. */\n\n    if ((rc = smtp_setup_msg()) > 0)\n      {\n      BOOL ok = receive_msg(FALSE);\n      search_tidyup();                    /* Close cached databases */\n      if (!ok)                            /* Connection was dropped */\n        {\n        mac_smtp_fflush();\n        smtp_log_no_mail();               /* Log no mail if configured */\n        _exit(EXIT_SUCCESS);\n        }\n      if (message_id[0] == 0) continue;   /* No message was accepted */\n      }\n    else\n      {\n      mac_smtp_fflush();\n      search_tidyup();\n      smtp_log_no_mail();                 /* Log no mail if configured */\n      _exit((rc == 0)? EXIT_SUCCESS : EXIT_FAILURE);\n      }\n\n    /* Show the recipients when debugging */\n\n    DEBUG(D_receive)\n      {\n      int i;\n      if (sender_address != NULL)\n        debug_printf(\"Sender: %s\\n\", sender_address);\n      if (recipients_list != NULL)\n        {\n        debug_printf(\"Recipients:\\n\");\n        for (i = 0; i < recipients_count; i++)\n          debug_printf(\"  %s\\n\", recipients_list[i].address);\n        }\n      }\n\n    /* A message has been accepted. Clean up any previous delivery processes\n    that have completed and are defunct, on systems where they don't go away\n    by themselves (see comments when setting SIG_IGN above). On such systems\n    (if any) these delivery processes hang around after termination until\n    the next message is received. */\n\n    #ifndef SIG_IGN_WORKS\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n    #endif\n\n    /* Reclaim up the store used in accepting this message */\n\n    store_reset(reset_point);\n\n    /* If queue_only is set or if there are too many incoming connections in\n    existence, session_local_queue_only will be TRUE. If it is not, check\n    whether we have received too many messages in this session for immediate\n    delivery. */\n\n    if (!session_local_queue_only &&\n        smtp_accept_queue_per_connection > 0 &&\n        receive_messagecount > smtp_accept_queue_per_connection)\n      {\n      session_local_queue_only = TRUE;\n      queue_only_reason = 2;\n      }\n\n    /* Initialize local_queue_only from session_local_queue_only. If it is not\n    true, and queue_only_load is set, check that the load average is below it.\n    If local_queue_only is set by this means, we also set if for the session if\n    queue_only_load_latch is true (the default). This means that, once set,\n    local_queue_only remains set for any subsequent messages on the same SMTP\n    connection. This is a deliberate choice; even though the load average may\n    fall, it doesn't seem right to deliver later messages on the same call when\n    not delivering earlier ones. However, the are special circumstances such as\n    very long-lived connections from scanning appliances where this is not the\n    best strategy. In such cases, queue_only_load_latch should be set false. */\n\n    local_queue_only = session_local_queue_only;\n    if (!local_queue_only && queue_only_load >= 0)\n      {\n      local_queue_only = (load_average = OS_GETLOADAVG()) > queue_only_load;\n      if (local_queue_only)\n        {\n        queue_only_reason = 3;\n        if (queue_only_load_latch) session_local_queue_only = TRUE;\n        }\n      }\n\n    /* Log the queueing here, when it will get a message id attached, but\n    not if queue_only is set (case 0). */\n\n    if (local_queue_only) switch(queue_only_reason)\n      {\n      case 1:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: too many connections \"\n                \"(%d, max %d)\", smtp_accept_count, smtp_accept_queue);\n      break;\n\n      case 2:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: more than %d messages \"\n                \"received in one connection\", smtp_accept_queue_per_connection);\n      break;\n\n      case 3:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: load average %.2f\",\n                (double)load_average/1000.0);\n      break;\n      }\n\n    /* If a delivery attempt is required, spin off a new process to handle it.\n    If we are not root, we have to re-exec exim unless deliveries are being\n    done unprivileged. */\n\n    else if (!queue_only_policy && !deliver_freeze)\n      {\n      pid_t dpid;\n\n      /* Before forking, ensure that the C output buffer is flushed. Otherwise\n      anything that it in it will get duplicated, leading to duplicate copies\n      of the pending output. */\n\n      mac_smtp_fflush();\n\n      if ((dpid = fork()) == 0)\n        {\n        (void)fclose(smtp_in);\n        (void)fclose(smtp_out);\n\n        /* Don't ever molest the parent's SSL connection, but do clean up\n        the data structures if necessary. */\n\n        #ifdef SUPPORT_TLS\n        tls_close(FALSE);\n        #endif\n\n        /* Reset SIGHUP and SIGCHLD in the child in both cases. */\n\n        signal(SIGHUP,  SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n\n        if (geteuid() != root_uid && !deliver_drop_privilege)\n          {\n          signal(SIGALRM, SIG_DFL);\n          (void)child_exec_exim(CEE_EXEC_PANIC, FALSE, NULL, FALSE, 2, US\"-Mc\",\n            message_id);\n          /* Control does not return here. */\n          }\n\n        /* No need to re-exec; SIGALRM remains set to the default handler */\n\n        (void)deliver_message(message_id, FALSE, FALSE);\n        search_tidyup();\n        _exit(EXIT_SUCCESS);\n        }\n\n      if (dpid > 0)\n        {\n        DEBUG(D_any) debug_printf(\"forked delivery process %d\\n\", (int)dpid);\n        }\n      else\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: delivery process fork \"\n          \"failed: %s\", strerror(errno));\n        }\n      }\n    }\n  }\n\n\n/* Carrying on in the parent daemon process... Can't do much if the fork\nfailed. Otherwise, keep count of the number of accepting processes and\nremember the pid for ticking off when the child completes. */\n\nif (pid < 0)\n  {\n  never_error(US\"daemon: accept process fork failed\", US\"Fork failed\", errno);\n  }\nelse\n  {\n  int i;\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].pid <= 0)\n      {\n      smtp_slots[i].pid = pid;\n      if (smtp_accept_max_per_host != NULL)\n        smtp_slots[i].host_address = string_copy_malloc(sender_host_address);\n      smtp_accept_count++;\n      break;\n      }\n    }\n  DEBUG(D_any) debug_printf(\"%d SMTP accept process%s running\\n\",\n    smtp_accept_count, (smtp_accept_count == 1)? \"\" : \"es\");\n  }\n\n/* Get here via goto in error cases */\n\nERROR_RETURN:\n\n/* Close the streams associated with the socket which will also close the\nsocket fds in this process. We can't do anything if fclose() fails, but\nlogging brings it to someone's attention. However, \"connection reset by peer\"\nisn't really a problem, so skip that one. On Solaris, a dropped connection can\nmanifest itself as a broken pipe, so drop that one too. If the streams don't\nexist, something went wrong while setting things up. Make sure the socket\ndescriptors are closed, in order to drop the connection. */\n\nif (smtp_out != NULL)\n  {\n  if (fclose(smtp_out) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_out) failed: %s\",\n      strerror(errno));\n  smtp_out = NULL;\n  }\nelse (void)close(accept_socket);\n\nif (smtp_in != NULL)\n  {\n  if (fclose(smtp_in) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_in) failed: %s\",\n      strerror(errno));\n  smtp_in = NULL;\n  }\nelse (void)close(dup_accept_socket);\n\n/* Release any store used in this process, including the store used for holding\nthe incoming host address and an expanded active_hostname. */\n\nstore_reset(reset_point);\nsender_host_address = NULL;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Set FD_CLOEXEC on SMTP sockets after forking to handle the connection."}
{"func": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\n\n/* Loop through the possible file names */\n\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  /* Cut out all the fancy processing unless specifically wanted */\n\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n\n  /* Try for the node-specific file if a node name exists */\n\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  /* CONFIGURE_FILE_USE_EUID */\n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  /* CONFIGURE_FILE_USE_NODE */\n\n  /* Otherwise, try the generic name, possibly with the euid added */\n\n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  /* CONFIGURE_FILE_USE_EUID */\n\n  /* Finally, try the unadorned name */\n\n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  /* if neither defined */\n\n  /* This is the common case when the fancy processing is not included. */\n\n  config_file = Ufopen(filename, \"rb\");\n  #endif\n\n  /* If the file does not exist, continue to try any others. For any other\n  error, break out (and die). */\n\n  if (config_file != NULL || errno != ENOENT) break;\n  }\n\n/* On success, save the name for verification; config_filename is used when\nlogging configuration errors (it changes for .included files) whereas\nconfig_main_filename is the name shown by -bP. Failure to open a configuration\nfile is a serious disaster. */\n\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\n\n/* Check the status of the file we have opened, unless it was specified on\nthe command line, in which case privilege was given away at the start. */\n\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n\n  if ((statbuf.st_uid != root_uid                /* owner not root */\n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           /* owner not the special one */\n       #endif\n         ) ||                                    /* or */\n      (statbuf.st_gid != root_gid                /* group not root & */\n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           /* group not the special one */\n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       /* group writeable  */\n                                                 /* or */\n      ((statbuf.st_mode & 2) != 0))              /* world writeable  */\n\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\n\n/* Process the main configuration settings. They all begin with a lower case\nletter. If we see something starting with an upper case letter, it is taken as\na macro definition. */\n\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\n\n\n/* If local_sender_retain is set, local_from_check must be unset. */\n\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\n\n/* If the timezone string is empty, set it to NULL, implying no TZ variable\nwanted. */\n\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\n\n/* The max retry interval must not be greater than 24 hours. */\n\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\n\n/* remote_max_parallel must be > 0 */\n\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\n\n/* Save the configured setting of freeze_tell, so we can re-instate it at the\nstart of a new SMTP message. */\n\nfreeze_tell_config = freeze_tell;\n\n/* The primary host name may be required for expansion of spool_directory\nand log_file_path, so make sure it is set asap. It is obtained from uname(),\nbut if that yields an unqualified value, make a FQDN by using gethostbyname to\ncanonize it. Some people like upper case letters in their host names, so we\ndon't force the case. */\n\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n\n  primary_hostname = string_copy(hostname);\n  }\n\n/* Set up default value for smtp_active_hostname */\n\nsmtp_active_hostname = primary_hostname;\n\n/* If spool_directory wasn't set in the build-time configuration, it must have\ngot set above. Of course, writing to the log may not work if log_file_path is\nnot set, but it will at least get to syslog or somewhere, with any luck. */\n\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\n\n/* Expand the spool directory name; it may, for example, contain the primary\nhost name. Same comment about failure. */\n\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\n\n/* Expand log_file_path, which must contain \"%s\" in any component that isn't\nthe null string or \"syslog\". It is also allowed to contain one instance of %D.\nHowever, it must NOT contain % followed by anything else. */\n\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       /* Fixed for log file path */\n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n\n  log_file_path = s;\n  }\n\n/* Interpret syslog_facility into an integer argument for 'ident' param to\nopenlog(). Default is LOG_MAIL set in globals.c. Allow the user to omit the\nleading \"log_\". */\n\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\n\n/* Expand pid_file_path */\n\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\n\n/* Compile the regex for matching a UUCP-style \"From_\" line in an incoming\nmessage. */\n\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\n\n/* Unpick the SMTP rate limiting options, if set */\n\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\n\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\n\n/* The qualify domains default to the primary host name */\n\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\n\n/* Setting system_filter_user in the configuration sets the gid as well if a\nname is given, but a numerical value does not. */\n\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\n\n/* If the errors_reply_to field is set, check that it is syntactically valid\nand ensure it contains a domain. */\n\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\n\n/* If smtp_accept_queue or smtp_accept_max_per_host is set, then\nsmtp_accept_max must also be set. */\n\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\n\n/* Set up the host number if anything is specified. It is an expanded string\nso that it can be computed from the host name, for example. We do this last\nso as to ensure that everything else is set up before the expansion. */\n\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n\n#ifdef SUPPORT_TLS\n/* If tls_verify_hosts is set, tls_verify_certificates must also be set */\n\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\n\n/* If openssl_options is set, validate it */\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}", "target": 1, "cwe": ["CWE-264"], "message": "Check configure file permissions even for non-default files if still privileged\n\n(Bug 1044, CVE-2010-4345)"}
{"func": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\n\n/* Loop through the possible file names */\n\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  /* Cut out all the fancy processing unless specifically wanted */\n\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n\n  /* Try for the node-specific file if a node name exists */\n\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  /* CONFIGURE_FILE_USE_EUID */\n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  /* CONFIGURE_FILE_USE_NODE */\n\n  /* Otherwise, try the generic name, possibly with the euid added */\n\n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  /* CONFIGURE_FILE_USE_EUID */\n\n  /* Finally, try the unadorned name */\n\n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  /* if neither defined */\n\n  /* This is the common case when the fancy processing is not included. */\n\n  config_file = Ufopen(filename, \"rb\");\n  #endif\n\n  /* If the file does not exist, continue to try any others. For any other\n  error, break out (and die). */\n\n  if (config_file != NULL || errno != ENOENT) break;\n  }\n\n/* On success, save the name for verification; config_filename is used when\nlogging configuration errors (it changes for .included files) whereas\nconfig_main_filename is the name shown by -bP. Failure to open a configuration\nfile is a serious disaster. */\n\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\n\n/* Check the status of the file we have opened, unless it was specified on\nthe command line, in which case privilege was given away at the start. */\n\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n\n  if ((statbuf.st_uid != root_uid &&             /* owner not root */\n       statbuf.st_uid != exim_uid                /* owner not exim */\n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           /* owner not the special one */\n       #endif\n         ) ||                                    /* or */\n      (statbuf.st_gid != exim_gid                /* group not exim & */\n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           /* group not the special one */\n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       /* group writeable  */\n                                                 /* or */\n      ((statbuf.st_mode & 2) != 0))              /* world writeable  */\n\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\n\n/* Process the main configuration settings. They all begin with a lower case\nletter. If we see something starting with an upper case letter, it is taken as\na macro definition. */\n\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\n\n\n/* If local_sender_retain is set, local_from_check must be unset. */\n\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\n\n/* If the timezone string is empty, set it to NULL, implying no TZ variable\nwanted. */\n\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\n\n/* The max retry interval must not be greater than 24 hours. */\n\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\n\n/* remote_max_parallel must be > 0 */\n\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\n\n/* Save the configured setting of freeze_tell, so we can re-instate it at the\nstart of a new SMTP message. */\n\nfreeze_tell_config = freeze_tell;\n\n/* The primary host name may be required for expansion of spool_directory\nand log_file_path, so make sure it is set asap. It is obtained from uname(),\nbut if that yields an unqualified value, make a FQDN by using gethostbyname to\ncanonize it. Some people like upper case letters in their host names, so we\ndon't force the case. */\n\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n\n  primary_hostname = string_copy(hostname);\n  }\n\n/* Set up default value for smtp_active_hostname */\n\nsmtp_active_hostname = primary_hostname;\n\n/* If spool_directory wasn't set in the build-time configuration, it must have\ngot set above. Of course, writing to the log may not work if log_file_path is\nnot set, but it will at least get to syslog or somewhere, with any luck. */\n\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\n\n/* Expand the spool directory name; it may, for example, contain the primary\nhost name. Same comment about failure. */\n\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\n\n/* Expand log_file_path, which must contain \"%s\" in any component that isn't\nthe null string or \"syslog\". It is also allowed to contain one instance of %D.\nHowever, it must NOT contain % followed by anything else. */\n\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       /* Fixed for log file path */\n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n\n  log_file_path = s;\n  }\n\n/* Interpret syslog_facility into an integer argument for 'ident' param to\nopenlog(). Default is LOG_MAIL set in globals.c. Allow the user to omit the\nleading \"log_\". */\n\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\n\n/* Expand pid_file_path */\n\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\n\n/* Compile the regex for matching a UUCP-style \"From_\" line in an incoming\nmessage. */\n\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\n\n/* Unpick the SMTP rate limiting options, if set */\n\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\n\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\n\n/* The qualify domains default to the primary host name */\n\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\n\n/* Setting system_filter_user in the configuration sets the gid as well if a\nname is given, but a numerical value does not. */\n\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\n\n/* If the errors_reply_to field is set, check that it is syntactically valid\nand ensure it contains a domain. */\n\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\n\n/* If smtp_accept_queue or smtp_accept_max_per_host is set, then\nsmtp_accept_max must also be set. */\n\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\n\n/* Set up the host number if anything is specified. It is an expanded string\nso that it can be computed from the host name, for example. We do this last\nso as to ensure that everything else is set up before the expansion. */\n\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n\n#ifdef SUPPORT_TLS\n/* If tls_verify_hosts is set, tls_verify_certificates must also be set */\n\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\n\n/* If openssl_options is set, validate it */\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't allow a configure file which is writeable by the Exim user or group\n\n(Bug 1044, CVE-2010-4345)"}
{"func": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else\n\t\txmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode);\n\n\t    valuePush(ctxt, contextObj);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n\t        xmlXPathObjectPtr tmp;\n\t\t/* pop the result */\n\t\ttmp = valuePop(ctxt);\n\t\txmlXPathReleaseObject(xpctxt, tmp);\n\t\t/* then pop off contextObj, which will be freed later */\n\t\tvaluePop(ctxt);\n\t\tgoto evaluation_error;\n\t    }\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }", "target": 1, "cwe": ["CWE-415"], "message": "Fix a potential freeing error in XPath"}
{"func": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\tif(st.st_size == 0)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}", "target": 1, "cwe": ["CWE-20"], "message": "backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643."}
{"func": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 || hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-20"], "message": "backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643."}
{"func": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643."}
{"func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';') \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n} /* token */", "target": 1, "cwe": ["CWE-20"], "message": "backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643."}
{"func": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-20"], "message": "backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643."}
{"func": "AvahiDnsPacket *avahi_recv_dns_packet_ipv6(\n        int fd,\n        AvahiIPv6Address *ret_src_address,\n        uint16_t *ret_src_port,\n        AvahiIPv6Address *ret_dst_address,\n        AvahiIfIndex *ret_iface,\n        uint8_t *ret_ttl) {\n\n    AvahiDnsPacket *p = NULL;\n    struct msghdr msg;\n    struct iovec io;\n    size_t aux[1024 / sizeof(size_t)];\n    ssize_t l;\n    int ms;\n    struct cmsghdr *cmsg;\n    int found_ttl = 0, found_iface = 0;\n    struct sockaddr_in6 sa;\n\n    assert(fd >= 0);\n\n    if (ioctl(fd, FIONREAD, &ms) < 0) {\n        avahi_log_warn(\"ioctl(): %s\", strerror(errno));\n        goto fail;\n    }\n\n    if (ms < 0) {\n        avahi_log_warn(\"FIONREAD returned negative value.\");\n        goto fail;\n    }\n\n    /* For corrupt packets FIONREAD returns zero size (See rhbz #607297) */\n    if (!ms)\n        goto fail;\n\n    p = avahi_dns_packet_new(ms + AVAHI_DNS_PACKET_EXTRA_SIZE);\n\n    io.iov_base = AVAHI_DNS_PACKET_DATA(p);\n    io.iov_len = p->max_size;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = (struct sockaddr*) &sa;\n    msg.msg_namelen = sizeof(sa);\n\n    msg.msg_iov = &io;\n    msg.msg_iovlen = 1;\n    msg.msg_control = aux;\n    msg.msg_controllen = sizeof(aux);\n    msg.msg_flags = 0;\n\n    if ((l = recvmsg(fd, &msg, 0)) < 0) {\n        /* Linux returns EAGAIN when an invalid IP packet has been\n        received. We suppress warnings in this case because this might\n        create quite a bit of log traffic on machines with unstable\n        links. (See #60) */\n\n        if (errno != EAGAIN)\n            avahi_log_warn(\"recvmsg(): %s\", strerror(errno));\n\n        goto fail;\n    }\n\n    assert(!(msg.msg_flags & MSG_CTRUNC));\n    assert(!(msg.msg_flags & MSG_TRUNC));\n\n    p->size = (size_t) l;\n\n    if (ret_src_port)\n        *ret_src_port = avahi_port_from_sockaddr((struct sockaddr*) &sa);\n\n    if (ret_src_address) {\n        AvahiAddress a;\n        avahi_address_from_sockaddr((struct sockaddr*) &sa, &a);\n        *ret_src_address = a.data.ipv6;\n    }\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_level == IPPROTO_IPV6) {\n\n            switch (cmsg->cmsg_type) {\n\n                case IPV6_HOPLIMIT:\n\n                    if (ret_ttl)\n                        *ret_ttl = (uint8_t) (*(int *) CMSG_DATA(cmsg));\n\n                    found_ttl = 1;\n\n                    break;\n\n                case IPV6_PKTINFO: {\n                    struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n\n                    if (ret_iface)\n                        *ret_iface = i->ipi6_ifindex;\n\n                    if (ret_dst_address)\n                        memcpy(ret_dst_address->address, i->ipi6_addr.s6_addr, 16);\n\n                    found_iface = 1;\n                    break;\n                }\n\n                default:\n                    avahi_log_warn(\"Unhandled cmsg_type : %d\", cmsg->cmsg_type);\n                    break;\n            }\n        }\n    }\n\n    assert(found_iface);\n    assert(found_ttl);\n\n    return p;\n\nfail:\n    if (p)\n        avahi_dns_packet_free(p);\n\n    return NULL;\n}", "target": 1, "cwe": ["CWE-399"], "message": "socket: Still read corrupt packets from the sockets\n\nElse, we end up with an infinite loop with 100% CPU.\n\nhttp://www.avahi.org/ticket/325\nhttps://bugzilla.redhat.com/show_bug.cgi?id=667187"}
{"func": "AvahiDnsPacket *avahi_recv_dns_packet_ipv4(\n        int fd,\n        AvahiIPv4Address *ret_src_address,\n        uint16_t *ret_src_port,\n        AvahiIPv4Address *ret_dst_address,\n        AvahiIfIndex *ret_iface,\n        uint8_t *ret_ttl) {\n\n    AvahiDnsPacket *p= NULL;\n    struct msghdr msg;\n    struct iovec io;\n    size_t aux[1024 / sizeof(size_t)]; /* for alignment on ia64 ! */\n    ssize_t l;\n    struct cmsghdr *cmsg;\n    int found_addr = 0;\n    int ms;\n    struct sockaddr_in sa;\n\n    assert(fd >= 0);\n\n    if (ioctl(fd, FIONREAD, &ms) < 0) {\n        avahi_log_warn(\"ioctl(): %s\", strerror(errno));\n        goto fail;\n    }\n\n    if (ms < 0) {\n        avahi_log_warn(\"FIONREAD returned negative value.\");\n        goto fail;\n    }\n\n    /* For corrupt packets FIONREAD returns zero size (See rhbz #607297) */\n    if (!ms)\n        goto fail;\n\n    p = avahi_dns_packet_new(ms + AVAHI_DNS_PACKET_EXTRA_SIZE);\n\n    io.iov_base = AVAHI_DNS_PACKET_DATA(p);\n    io.iov_len = p->max_size;\n\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_name = &sa;\n    msg.msg_namelen = sizeof(sa);\n    msg.msg_iov = &io;\n    msg.msg_iovlen = 1;\n    msg.msg_control = aux;\n    msg.msg_controllen = sizeof(aux);\n    msg.msg_flags = 0;\n\n    if ((l = recvmsg(fd, &msg, 0)) < 0) {\n        /* Linux returns EAGAIN when an invalid IP packet has been\n        received. We suppress warnings in this case because this might\n        create quite a bit of log traffic on machines with unstable\n        links. (See #60) */\n\n        if (errno != EAGAIN)\n            avahi_log_warn(\"recvmsg(): %s\", strerror(errno));\n\n        goto fail;\n    }\n\n    if (sa.sin_addr.s_addr == INADDR_ANY) {\n        /* Linux 2.4 behaves very strangely sometimes! */\n        goto fail;\n    }\n\n    assert(!(msg.msg_flags & MSG_CTRUNC));\n    assert(!(msg.msg_flags & MSG_TRUNC));\n\n    p->size = (size_t) l;\n\n    if (ret_src_port)\n        *ret_src_port = avahi_port_from_sockaddr((struct sockaddr*) &sa);\n\n    if (ret_src_address) {\n        AvahiAddress a;\n        avahi_address_from_sockaddr((struct sockaddr*) &sa, &a);\n        *ret_src_address = a.data.ipv4;\n    }\n\n    if (ret_ttl)\n        *ret_ttl = 255;\n\n    if (ret_iface)\n        *ret_iface = AVAHI_IF_UNSPEC;\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_level == IPPROTO_IP) {\n\n            switch (cmsg->cmsg_type) {\n#ifdef IP_RECVTTL\n                case IP_RECVTTL:\n#endif\n                case IP_TTL:\n                    if (ret_ttl)\n                        *ret_ttl = (uint8_t) (*(int *) CMSG_DATA(cmsg));\n\n                    break;\n\n#ifdef IP_PKTINFO\n                case IP_PKTINFO: {\n                    struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n\n                    if (ret_iface)\n                        *ret_iface = (int) i->ipi_ifindex;\n\n                    if (ret_dst_address)\n                        ret_dst_address->address = i->ipi_addr.s_addr;\n\n                    found_addr = 1;\n\n                    break;\n                }\n#endif\n\n#ifdef IP_RECVIF\n                case IP_RECVIF: {\n                    struct sockaddr_dl *sdl = (struct sockaddr_dl *) CMSG_DATA (cmsg);\n\n                    if (ret_iface)\n#ifdef __sun\n                        *ret_iface = *(uint_t*) sdl;\n#else\n                        *ret_iface = (int) sdl->sdl_index;\n#endif\n\n                    break;\n                }\n#endif\n\n#ifdef IP_RECVDSTADDR\n                case IP_RECVDSTADDR:\n                    if (ret_dst_address)\n                        memcpy(&ret_dst_address->address, CMSG_DATA (cmsg), 4);\n\n                    found_addr = 1;\n                    break;\n#endif\n\n                default:\n                    avahi_log_warn(\"Unhandled cmsg_type : %d\", cmsg->cmsg_type);\n                    break;\n            }\n        }\n    }\n\n    assert(found_addr);\n\n    return p;\n\nfail:\n    if (p)\n        avahi_dns_packet_free(p);\n\n    return NULL;\n}", "target": 1, "cwe": ["CWE-399"], "message": "socket: Still read corrupt packets from the sockets\n\nElse, we end up with an infinite loop with 100% CPU.\n\nhttp://www.avahi.org/ticket/325\nhttps://bugzilla.redhat.com/show_bug.cgi?id=667187"}
{"func": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}", "target": 1, "cwe": ["CWE-22"], "message": "Do not let a malicious patch create files above current directory\n\nThis addresses CVE-2010-4651, reported by Jakub Wilk.\nhttps://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-4651\n* src/util.c (strip_leading_slashes): Reject absolute file names\nand file names containing a component of \"..\".\n* tests/bad-filenames: New file.  Test for this.\n* tests/Makefile.am (TESTS): Add it.\nImprovements by Andreas Gruenbacher."}
{"func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\tif (client->server->timeout) \n\t\t\talarm(client->server->timeout);\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \tif (client->difffile>=0) { \n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE)\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %Lu (%Lu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize) ||\n\t\t    ((client->server->flags & F_READONLY) && request.type)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_AUTOREADONLY) ||\n\t\t\t\t\texpwrite(request.from, buf, len,\n\t\t\t\t\t\tclient)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "r134: CVE-2005-3534"}
{"func": "int mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh."}
{"func": "xfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_v1_t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);\n\tif (error)\n\t\treturn -error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -XFS_ERROR(EFAULT);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "xfs: zero proper structure size for geometry calls\n\nCommit 493f3358cb289ccf716c5a14fa5bb52ab75943e5 added this call to\nxfs_fs_geometry() in order to avoid passing kernel stack data back\nto user space:\n\n+       memset(geo, 0, sizeof(*geo));\n\nUnfortunately, one of the callers of that function passes the\naddress of a smaller data type, cast to fit the type that\nxfs_fs_geometry() requires.  As a result, this can happen:\n\nKernel panic - not syncing: stack-protector: Kernel stack is corrupted\nin: f87aca93\n\nPid: 262, comm: xfs_fsr Not tainted 2.6.38-rc6-493f3358cb2+ #1\nCall Trace:\n\n[<c12991ac>] ? panic+0x50/0x150\n[<c102ed71>] ? __stack_chk_fail+0x10/0x18\n[<f87aca93>] ? xfs_ioc_fsgeometry_v1+0x56/0x5d [xfs]\n\nFix this by fixing that one caller to pass the right type and then\ncopy out the subset it is interested in.\n\nNote: This patch is an alternative to one originally proposed by\nEric Sandeen.\n\nReported-by: Jeffrey Hundstad <jeffrey.hundstad@mnsu.edu>\nSigned-off-by: Alex Elder <aelder@sgi.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nTested-by: Jeffrey Hundstad <jeffrey.hundstad@mnsu.edu>"}
{"func": "_hb_buffer_add_output_glyph_ids( HB_Buffer  buffer,\n\t\t\t      HB_UShort  num_in,\n\t\t\t      HB_UShort  num_out,\n\t\t\t      const GlyphID *glyph_data,\n\t\t\t      HB_UShort  component,\n\t\t\t      HB_UShort  ligID )\n{\n  HB_Error  error;\n  HB_UShort i;\n  HB_UInt properties;\n  HB_UInt cluster;\n\n  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );\n  if ( error )\n    return error;\n\n  if ( !buffer->separate_out )\n    {\n      error = hb_buffer_duplicate_out_buffer( buffer );\n      if ( error )\n\treturn error;\n    }\n\n  properties = buffer->in_string[buffer->in_pos].properties;\n  cluster = buffer->in_string[buffer->in_pos].cluster;\n  if ( component == 0xFFFF )\n    component = buffer->in_string[buffer->in_pos].component;\n  if ( ligID == 0xFFFF )\n    ligID = buffer->in_string[buffer->in_pos].ligID;\n\n  for ( i = 0; i < num_out; i++ )\n  {\n    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];\n\n    item->gindex = glyph_data[i];\n    item->properties = properties;\n    item->cluster = cluster;\n    item->component = component;\n    item->ligID = ligID;\n    item->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  }\n\n  buffer->in_pos  += num_in;\n  buffer->out_pos += num_out;\n\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_ensure( HB_Buffer buffer,\n\t\t   HB_UInt   size )\n{\n  HB_UInt new_allocated = buffer->allocated;\n\n  if (size > new_allocated)\n    {\n      HB_Error error;\n\n      while (size > new_allocated)\n\tnew_allocated += (new_allocated >> 1) + 8;\n\n      if ( buffer->positions )\n        {\n\t  if ( REALLOC_ARRAY( buffer->positions, new_allocated, HB_PositionRec ) )\n\t    return error;\n\t}\n\n      if ( REALLOC_ARRAY( buffer->in_string, new_allocated, HB_GlyphItemRec ) )\n\treturn error;\n\n      if ( buffer->separate_out )\n        {\n\t  if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )\n\t    return error;\n\n\t  buffer->out_string = buffer->alt_string;\n\t}\n      else\n        {\n\t  buffer->out_string = buffer->in_string;\n\n\t  if ( buffer->alt_string )\n\t    {\n\t      if ( REALLOC_ARRAY( buffer->alt_string, new_allocated, HB_GlyphItemRec ) )\n\t\treturn error;\n\t    }\n\t}\n\n      buffer->allocated = new_allocated;\n    }\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "set_unicode_charmap (FT_Face face)\n{\n  int charmap;\n\n  for (charmap = 0; charmap < face->num_charmaps; charmap++)\n    if (face->charmaps[charmap]->encoding == ft_encoding_unicode)\n      {\n\tHB_Error error = FT_Set_Charmap(face, face->charmaps[charmap]);\n\treturn error == HB_Err_Ok;\n      }\n\n  return FALSE;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "release_buffer (HB_Buffer buffer, gboolean free_buffer)\n{\n  if (G_LIKELY (!free_buffer))\n    {\n      hb_buffer_clear (buffer);\n      G_UNLOCK (cached_buffer);\n    }\n  else\n    hb_buffer_free (buffer);\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "acquire_buffer (gboolean *free_buffer)\n{\n  HB_Buffer buffer;\n\n  if (G_LIKELY (G_TRYLOCK (cached_buffer)))\n    {\n      if (G_UNLIKELY (!cached_buffer))\n\thb_buffer_new (&cached_buffer);\n\n      buffer = cached_buffer;\n      *free_buffer = FALSE;\n    }\n  else\n    {\n      hb_buffer_new (&buffer);\n      *free_buffer = TRUE;\n    }\n\n  return buffer;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_next_glyph ( HB_Buffer buffer )\n{\n  HB_Error  error;\n\n  if ( buffer->separate_out )\n    {\n      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );\n      if ( error )\n\treturn error;\n\n      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];\n    }\n\n  buffer->in_pos++;\n  buffer->out_pos++;\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_clear_output( HB_Buffer buffer )\n{\n  buffer->out_length = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_add_output_glyph( HB_Buffer buffer,\n\t\t\t     HB_UInt   glyph_index,\n\t\t\t     HB_UShort component,\n\t\t\t     HB_UShort ligID )\n{\n  HB_UShort glyph_data =  glyph_index;\n\n  return _hb_buffer_add_output_glyphs ( buffer, 1, 1,\n\t\t\t\t\t&glyph_data, component, ligID );\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_add_output_glyphs( HB_Buffer  buffer,\n\t\t\t      HB_UShort  num_in,\n\t\t\t      HB_UShort  num_out,\n\t\t\t      HB_UShort *glyph_data,\n\t\t\t      HB_UShort  component,\n\t\t\t      HB_UShort  ligID )\n{\n  HB_Error  error;\n  HB_UShort i;\n  HB_UInt properties;\n  HB_UInt cluster;\n\n  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );\n  if ( error )\n    return error;\n\n  if ( !buffer->separate_out )\n    {\n      error = hb_buffer_duplicate_out_buffer( buffer );\n      if ( error )\n\treturn error;\n    }\n\n  properties = buffer->in_string[buffer->in_pos].properties;\n  cluster = buffer->in_string[buffer->in_pos].cluster;\n  if ( component == 0xFFFF )\n    component = buffer->in_string[buffer->in_pos].component;\n  if ( ligID == 0xFFFF )\n    ligID = buffer->in_string[buffer->in_pos].ligID;\n\n  for ( i = 0; i < num_out; i++ )\n  {\n    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];\n\n    item->gindex = glyph_data[i];\n    item->properties = properties;\n    item->cluster = cluster;\n    item->component = component;\n    item->ligID = ligID;\n    item->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  }\n\n  buffer->in_pos  += num_in;\n  buffer->out_pos += num_out;\n\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_new( HB_Buffer *pbuffer )\n{\n  HB_Buffer buffer;\n  HB_Error error;\n  \n  if ( ALLOC( buffer, sizeof( HB_BufferRec ) ) )\n    return error;\n\n  buffer->allocated = 0;\n  buffer->in_string = NULL;\n  buffer->alt_string = NULL;\n  buffer->positions = NULL;\n\n  hb_buffer_clear( buffer );\n\n  *pbuffer = buffer;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_pango_ot_info_position    (const PangoOTInfo    *info,\n\t\t\t    const PangoOTRuleset *ruleset,\n\t\t\t    PangoOTBuffer        *buffer)\n{\n  unsigned int i;\n\n  _hb_buffer_clear_positions (buffer->buffer);\n\n  hb_ot_layout_set_direction (info->layout,\n\t\t\t      buffer->rtl);\n  hb_ot_layout_set_hinting (info->layout,\n\t\t\t    buffer->font->is_hinted);\n  hb_ot_layout_set_scale (info->layout,\n\t\t\t  info->face->size->metrics.x_scale,\n\t\t\t  info->face->size->metrics.y_scale);\n  hb_ot_layout_set_ppem (info->layout,\n\t\t\t info->face->size->metrics.x_ppem,\n\t\t\t info->face->size->metrics.y_ppem);\n\n  for (i = 0; i < ruleset->rules->len; i++)\n    {\n      PangoOTRule *rule = &g_array_index (ruleset->rules, PangoOTRule, i);\n      hb_ot_layout_feature_mask_t mask;\n      unsigned int lookup_count, j;\n\n      if (rule->table_type != PANGO_OT_TABLE_GPOS)\n\tcontinue;\n\n      mask = rule->property_bit;\n      lookup_count = hb_ot_layout_feature_get_lookup_count (info->layout,\n\t\t\t\t\t\t\t    HB_OT_LAYOUT_TABLE_TYPE_GPOS,\n\t\t\t\t\t\t\t    rule->feature_index);\n\n      for (j = 0; j < lookup_count; j++)\n        {\n\t  unsigned int lookup_index;\n\n\t  lookup_index = hb_ot_layout_feature_get_lookup_index (info->layout,\n\t\t\t\t\t\t\t\tHB_OT_LAYOUT_TABLE_TYPE_GPOS,\n\t\t\t\t\t\t\t\trule->feature_index,\n\t\t\t\t\t\t\t\tj);\n\t  hb_ot_layout_position_lookup (info->layout,\n\t\t\t\t\tbuffer->buffer,\n\t\t\t\t\tlookup_index,\n\t\t\t\t\trule->property_bit);\n\t}\n\n    }\n\n    {\n      HB_UInt   i, j;\n      HB_Position positions = buffer->buffer->positions;\n\n      /* First handle all left-to-right connections */\n      for (j = 0; j < buffer->buffer->in_length; j++)\n      {\n\tif (positions[j].cursive_chain > 0)\n\t  positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;\n      }\n\n      /* Then handle all right-to-left connections */\n      for (i = buffer->buffer->in_length; i > 0; i--)\n      {\n\tj = i - 1;\n\n\tif (positions[j].cursive_chain < 0)\n\t  positions[j].y_pos += positions[j - positions[j].cursive_chain].y_pos;\n      }\n    }\n\n   buffer->applied_gpos = TRUE;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_add_glyph( HB_Buffer buffer,\n\t\t      HB_UInt   glyph_index,\n\t\t      HB_UInt   properties,\n\t\t      HB_UInt   cluster )\n{\n  HB_Error error;\n  HB_GlyphItem glyph;\n  \n  error = hb_buffer_ensure( buffer, buffer->in_length + 1 );\n  if ( error )\n    return error;\n\n  glyph = &buffer->in_string[buffer->in_length];\n  glyph->gindex = glyph_index;\n  glyph->properties = properties;\n  glyph->cluster = cluster;\n  glyph->component = 0;\n  glyph->ligID = 0;\n  glyph->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  \n  buffer->in_length++;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_replace_glyph( HB_Buffer buffer,\n\t\t\t  HB_UInt   glyph_index )\n{\n  if ( !buffer->separate_out )\n    {\n      buffer->out_string[buffer->out_pos].gindex = glyph_index;\n\n      buffer->in_pos++;\n      buffer->out_pos++;\n      buffer->out_length = buffer->out_pos;\n    }\n  else\n    {\n      return _hb_buffer_add_output_glyph( buffer, glyph_index, 0xFFFF, 0xFFFF );\n    }\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "get_glyph_class (gunichar   charcode,\n\t\t HB_UShort *class)\n{\n  /* For characters mapped into the Arabic Presentation forms, using properties\n   * derived as we apply GSUB substitutions will be more reliable\n   */\n  if ((charcode >= 0xFB50 && charcode <= 0xFDFF) || /* Arabic Presentation Forms-A */\n      (charcode >= 0xFE70 && charcode <= 0XFEFF))   /* Arabic Presentation Forms-B */\n    return FALSE;\n\n  switch ((int) g_unichar_type (charcode))\n    {\n    case G_UNICODE_COMBINING_MARK:\n    case G_UNICODE_ENCLOSING_MARK:\n    case G_UNICODE_NON_SPACING_MARK:\n      *class = 3;\t\t/* Mark glyph (non-spacing combining glyph) */\n      return TRUE;\n    case G_UNICODE_UNASSIGNED:\n    case G_UNICODE_PRIVATE_USE:\n      return FALSE;\t\t/* Unknown, don't assign a class; classes get\n\t\t\t\t * propagated during GSUB application */\n    default:\n      *class = 1;               /* Base glyph (single character, spacing glyph) */\n      return TRUE;\n    }\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_allocate_ligid( HB_Buffer buffer )\n{\n  return ++buffer->max_ligID;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_duplicate_out_buffer( HB_Buffer buffer )\n{\n  if ( !buffer->alt_string )\n    {\n      HB_Error error;\n\n      if ( ALLOC_ARRAY( buffer->alt_string, buffer->allocated, HB_GlyphItemRec ) )\n\treturn error;\n    }\n\n  buffer->out_string = buffer->alt_string;\n  memcpy( buffer->out_string, buffer->in_string, buffer->out_length * sizeof (buffer->out_string[0]) );\n  buffer->separate_out = TRUE;\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_swap( HB_Buffer buffer )\n{\n  HB_GlyphItem tmp_string;\n  int tmp_length;\n  int tmp_pos;\n\n  if ( buffer->separate_out )\n    {\n      tmp_string = buffer->in_string;\n      buffer->in_string = buffer->out_string;\n      buffer->out_string = tmp_string;\n      buffer->alt_string = buffer->out_string;\n    }\n\n  tmp_length = buffer->in_length;\n  buffer->in_length = buffer->out_length;\n  buffer->out_length = tmp_length;\n\n  tmp_pos = buffer->in_pos;\n  buffer->in_pos = buffer->out_pos;\n  buffer->out_pos = tmp_pos;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_free( HB_Buffer buffer )\n{\n  FREE( buffer->in_string );\n  FREE( buffer->alt_string );\n  buffer->out_string = NULL;\n  FREE( buffer->positions );\n  FREE( buffer );\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "_hb_buffer_clear_positions( HB_Buffer buffer )\n{\n  _hb_buffer_clear_output (buffer);\n\n  if ( !buffer->positions )\n    {\n      HB_Error error;\n\n      if ( ALLOC_ARRAY( buffer->positions, buffer->allocated, HB_PositionRec ) )\n\treturn error;\n    }\n\n  memset (buffer->positions, 0, sizeof (buffer->positions[0]) * buffer->in_length);\n\n  return HB_Err_Ok;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "hb_buffer_clear( HB_Buffer buffer )\n{\n  buffer->in_length = 0;\n  buffer->out_length = 0;\n  buffer->in_pos = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n  buffer->max_ligID = 0;\n}", "target": 1, "cwe": [], "message": "[HB] Remove all references to the old code!"}
{"func": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm) \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */", "target": 1, "cwe": [], "message": "backends: Fix another security issue in the dvi-backend\n\nThis is similar to one of the fixes from d4139205.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=640923"}
{"func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n} /* token */", "target": 1, "cwe": [], "message": "dvi: Another fix for buffer overwrite in dvi-backend\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=643882"}
{"func": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */", "target": 1, "cwe": [], "message": "dvi: Another fix for buffer overwrite in dvi-backend\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=643882"}
{"func": "vba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\t/* Not a string */\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret++;\n\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "libclamav/vba_extract.c: fix error path double free (bb#2486)"}
{"func": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t/* For the embedded inc. Matching put is in loop_inc_free() */\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1, "cwe": [], "message": "rds: prevent BUG_ON triggering on congestion map updates\n\nRecently had this bug halt reported to me:\n\nkernel BUG at net/rds/send.c:329!\nOops: Exception in kernel mode, sig: 5 [#1]\nSMP NR_CPUS=1024 NUMA pSeries\nModules linked in: rds sunrpc ipv6 dm_mirror dm_region_hash dm_log ibmveth sg\next4 jbd2 mbcache sd_mod crc_t10dif ibmvscsic scsi_transport_srp scsi_tgt\ndm_mod [last unloaded: scsi_wait_scan]\nNIP: d000000003ca68f4 LR: d000000003ca67fc CTR: d000000003ca8770\nREGS: c000000175cab980 TRAP: 0700   Not tainted  (2.6.32-118.el6.ppc64)\nMSR: 8000000000029032 <EE,ME,CE,IR,DR>  CR: 44000022  XER: 00000000\nTASK = c00000017586ec90[1896] 'krdsd' THREAD: c000000175ca8000 CPU: 0\nGPR00: 0000000000000150 c000000175cabc00 d000000003cb7340 0000000000002030\nGPR04: ffffffffffffffff 0000000000000030 0000000000000000 0000000000000030\nGPR08: 0000000000000001 0000000000000001 c0000001756b1e30 0000000000010000\nGPR12: d000000003caac90 c000000000fa2500 c0000001742b2858 c0000001742b2a00\nGPR16: c0000001742b2a08 c0000001742b2820 0000000000000001 0000000000000001\nGPR20: 0000000000000040 c0000001742b2814 c000000175cabc70 0800000000000000\nGPR24: 0000000000000004 0200000000000000 0000000000000000 c0000001742b2860\nGPR28: 0000000000000000 c0000001756b1c80 d000000003cb68e8 c0000001742b27b8\nNIP [d000000003ca68f4] .rds_send_xmit+0x4c4/0x8a0 [rds]\nLR [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\nCall Trace:\n[c000000175cabc00] [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\n(unreliable)\n[c000000175cabd30] [d000000003ca7e64] .rds_send_worker+0x54/0x100 [rds]\n[c000000175cabdb0] [c0000000000b475c] .worker_thread+0x1dc/0x3c0\n[c000000175cabed0] [c0000000000baa9c] .kthread+0xbc/0xd0\n[c000000175cabf90] [c000000000032114] .kernel_thread+0x54/0x70\nInstruction dump:\n4bfffd50 60000000 60000000 39080001 935f004c f91f0040 41820024 813d017c\n7d094a78 7d290074 7929d182 394a0020 <0b090000> 40e2ff68 4bffffa4 39200000\nKernel panic - not syncing: Fatal exception\nCall Trace:\n[c000000175cab560] [c000000000012e04] .show_stack+0x74/0x1c0 (unreliable)\n[c000000175cab610] [c0000000005a365c] .panic+0x80/0x1b4\n[c000000175cab6a0] [c00000000002fbcc] .die+0x21c/0x2a0\n[c000000175cab750] [c000000000030000] ._exception+0x110/0x220\n[c000000175cab910] [c000000000004b9c] program_check_common+0x11c/0x180\n\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\tunsigned int hdr_off, unsigned int sg, unsigned int off)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct ib_device *dev = ic->i_cm_id->device;\n\tstruct rds_ib_send_work *send = NULL;\n\tstruct rds_ib_send_work *first;\n\tstruct rds_ib_send_work *prev;\n\tstruct ib_send_wr *failed_wr;\n\tstruct scatterlist *scat;\n\tu32 pos;\n\tu32 i;\n\tu32 work_alloc;\n\tu32 credit_alloc = 0;\n\tu32 posted;\n\tu32 adv_credits = 0;\n\tint send_flags = 0;\n\tint bytes_sent = 0;\n\tint ret;\n\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t/* Do not send cong updates to IB loopback */\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\t/* FIXME we may overallocate here */\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {\n\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (ic->i_flowctl) {\n\t\tcredit_alloc = rds_ib_send_grab_credits(ic, work_alloc, &posted, 0, RDS_MAX_ADV_CREDIT);\n\t\tadv_credits += posted;\n\t\tif (credit_alloc < work_alloc) {\n\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - credit_alloc);\n\t\t\twork_alloc = credit_alloc;\n\t\t\tflow_controlled = 1;\n\t\t}\n\t\tif (work_alloc == 0) {\n\t\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\t\trds_ib_stats_inc(s_ib_tx_throttle);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* map the message the first time we see it */\n\tif (!ic->i_data_op) {\n\t\tif (rm->data.op_nents) {\n\t\t\trm->data.op_count = ib_dma_map_sg(dev,\n\t\t\t\t\t\t\t  rm->data.op_sg,\n\t\t\t\t\t\t\t  rm->data.op_nents,\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\trdsdebug(\"ic %p mapping rm %p: %d\\n\", ic, rm, rm->data.op_count);\n\t\t\tif (rm->data.op_count == 0) {\n\t\t\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\t\t\tret = -ENOMEM; /* XXX ? */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\trm->data.op_count = 0;\n\t\t}\n\n\t\trds_message_addref(rm);\n\t\tic->i_data_op = &rm->data;\n\n\t\t/* Finalize the header */\n\t\tif (test_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_ACK_REQUIRED;\n\t\tif (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;\n\n\t\t/* If it has a RDMA op, tell the peer we did it. This is\n\t\t * used by the peer to release use-once RDMA MRs. */\n\t\tif (rm->rdma.op_active) {\n\t\t\tstruct rds_ext_header_rdma ext_hdr;\n\n\t\t\text_hdr.h_rdma_rkey = cpu_to_be32(rm->rdma.op_rkey);\n\t\t\trds_message_add_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\tRDS_EXTHDR_RDMA, &ext_hdr, sizeof(ext_hdr));\n\t\t}\n\t\tif (rm->m_rdma_cookie) {\n\t\t\trds_message_add_rdma_dest_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\trds_rdma_cookie_key(rm->m_rdma_cookie),\n\t\t\t\t\trds_rdma_cookie_offset(rm->m_rdma_cookie));\n\t\t}\n\n\t\t/* Note - rds_ib_piggyb_ack clears the ACK_REQUIRED bit, so\n\t\t * we should not do this unless we have a chance of at least\n\t\t * sticking the header into the send ring. Which is why we\n\t\t * should call rds_ib_ring_alloc first. */\n\t\trm->m_inc.i_hdr.h_ack = cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\trds_message_make_checksum(&rm->m_inc.i_hdr);\n\n\t\t/*\n\t\t * Update adv_credits since we reset the ACK_REQUIRED bit.\n\t\t */\n\t\tif (ic->i_flowctl) {\n\t\t\trds_ib_send_grab_credits(ic, 0, &posted, 1, RDS_MAX_ADV_CREDIT - adv_credits);\n\t\t\tadv_credits += posted;\n\t\t\tBUG_ON(adv_credits > 255);\n\t\t}\n\t}\n\n\t/* Sometimes you want to put a fence between an RDMA\n\t * READ and the following SEND.\n\t * We could either do this all the time\n\t * or when requested by the user. Right now, we let\n\t * the application choose.\n\t */\n\tif (rm->rdma.op_active && rm->rdma.op_fence)\n\t\tsend_flags = IB_SEND_FENCE;\n\n\t/* Each frag gets a header. Msgs may be 0 bytes */\n\tsend = &ic->i_sends[pos];\n\tfirst = send;\n\tprev = NULL;\n\tscat = &ic->i_data_op->op_sg[sg];\n\ti = 0;\n\tdo {\n\t\tunsigned int len = 0;\n\n\t\t/* Set up the header */\n\t\tsend->s_wr.send_flags = send_flags;\n\t\tsend->s_wr.opcode = IB_WR_SEND;\n\t\tsend->s_wr.num_sge = 1;\n\t\tsend->s_wr.next = NULL;\n\t\tsend->s_queued = jiffies;\n\t\tsend->s_op = NULL;\n\n\t\tsend->s_sge[0].addr = ic->i_send_hdrs_dma\n\t\t\t+ (pos * sizeof(struct rds_header));\n\t\tsend->s_sge[0].length = sizeof(struct rds_header);\n\n\t\tmemcpy(&ic->i_send_hdrs[pos], &rm->m_inc.i_hdr, sizeof(struct rds_header));\n\n\t\t/* Set up the data, if present */\n\t\tif (i < work_alloc\n\t\t    && scat != &rm->data.op_sg[rm->data.op_count]) {\n\t\t\tlen = min(RDS_FRAG_SIZE, ib_sg_dma_len(dev, scat) - off);\n\t\t\tsend->s_wr.num_sge = 2;\n\n\t\t\tsend->s_sge[1].addr = ib_sg_dma_address(dev, scat) + off;\n\t\t\tsend->s_sge[1].length = len;\n\n\t\t\tbytes_sent += len;\n\t\t\toff += len;\n\t\t\tif (off == ib_sg_dma_len(dev, scat)) {\n\t\t\t\tscat++;\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t}\n\n\t\trds_ib_set_wr_signal_state(ic, send, 0);\n\n\t\t/*\n\t\t * Always signal the last one if we're stopping due to flow control.\n\t\t */\n\t\tif (ic->i_flowctl && flow_controlled && i == (work_alloc-1))\n\t\t\tsend->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;\n\n\t\tif (send->s_wr.send_flags & IB_SEND_SIGNALED)\n\t\t\tnr_sig++;\n\n\t\trdsdebug(\"send %p wr %p num_sge %u next %p\\n\", send,\n\t\t\t &send->s_wr, send->s_wr.num_sge, send->s_wr.next);\n\n\t\tif (ic->i_flowctl && adv_credits) {\n\t\t\tstruct rds_header *hdr = &ic->i_send_hdrs[pos];\n\n\t\t\t/* add credit and redo the header checksum */\n\t\t\thdr->h_credit = adv_credits;\n\t\t\trds_message_make_checksum(hdr);\n\t\t\tadv_credits = 0;\n\t\t\trds_ib_stats_inc(s_ib_tx_credit_updates);\n\t\t}\n\n\t\tif (prev)\n\t\t\tprev->s_wr.next = &send->s_wr;\n\t\tprev = send;\n\n\t\tpos = (pos + 1) % ic->i_send_ring.w_nr;\n\t\tsend = &ic->i_sends[pos];\n\t\ti++;\n\n\t} while (i < work_alloc\n\t\t && scat != &rm->data.op_sg[rm->data.op_count]);\n\n\t/* Account the RDS header in the number of bytes we sent, but just once.\n\t * The caller has no concept of fragmentation. */\n\tif (hdr_off == 0)\n\t\tbytes_sent += sizeof(struct rds_header);\n\n\t/* if we finished the message then send completion owns it */\n\tif (scat == &rm->data.op_sg[rm->data.op_count]) {\n\t\tprev->s_op = ic->i_data_op;\n\t\tprev->s_wr.send_flags |= IB_SEND_SOLICITED;\n\t\tic->i_data_op = NULL;\n\t}\n\n\t/* Put back wrs & credits we didn't use */\n\tif (i < work_alloc) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - i);\n\t\twork_alloc = i;\n\t}\n\tif (ic->i_flowctl && i < credit_alloc)\n\t\trds_ib_send_add_credits(conn, credit_alloc - i);\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\t/* XXX need to worry about failed_wr and partial sends. */\n\tfailed_wr = &first->s_wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);\n\trdsdebug(\"ic %p first %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t first, &first->s_wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &first->s_wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: ib_post_send to %pI4 \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tif (prev->s_op) {\n\t\t\tic->i_data_op = prev->s_op;\n\t\t\tprev->s_op = NULL;\n\t\t}\n\n\t\trds_ib_conn_error(ic->conn, \"ib_post_send failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = bytes_sent;\nout:\n\tBUG_ON(adv_credits);\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "rds: prevent BUG_ON triggering on congestion map updates\n\nRecently had this bug halt reported to me:\n\nkernel BUG at net/rds/send.c:329!\nOops: Exception in kernel mode, sig: 5 [#1]\nSMP NR_CPUS=1024 NUMA pSeries\nModules linked in: rds sunrpc ipv6 dm_mirror dm_region_hash dm_log ibmveth sg\next4 jbd2 mbcache sd_mod crc_t10dif ibmvscsic scsi_transport_srp scsi_tgt\ndm_mod [last unloaded: scsi_wait_scan]\nNIP: d000000003ca68f4 LR: d000000003ca67fc CTR: d000000003ca8770\nREGS: c000000175cab980 TRAP: 0700   Not tainted  (2.6.32-118.el6.ppc64)\nMSR: 8000000000029032 <EE,ME,CE,IR,DR>  CR: 44000022  XER: 00000000\nTASK = c00000017586ec90[1896] 'krdsd' THREAD: c000000175ca8000 CPU: 0\nGPR00: 0000000000000150 c000000175cabc00 d000000003cb7340 0000000000002030\nGPR04: ffffffffffffffff 0000000000000030 0000000000000000 0000000000000030\nGPR08: 0000000000000001 0000000000000001 c0000001756b1e30 0000000000010000\nGPR12: d000000003caac90 c000000000fa2500 c0000001742b2858 c0000001742b2a00\nGPR16: c0000001742b2a08 c0000001742b2820 0000000000000001 0000000000000001\nGPR20: 0000000000000040 c0000001742b2814 c000000175cabc70 0800000000000000\nGPR24: 0000000000000004 0200000000000000 0000000000000000 c0000001742b2860\nGPR28: 0000000000000000 c0000001756b1c80 d000000003cb68e8 c0000001742b27b8\nNIP [d000000003ca68f4] .rds_send_xmit+0x4c4/0x8a0 [rds]\nLR [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\nCall Trace:\n[c000000175cabc00] [d000000003ca67fc] .rds_send_xmit+0x3cc/0x8a0 [rds]\n(unreliable)\n[c000000175cabd30] [d000000003ca7e64] .rds_send_worker+0x54/0x100 [rds]\n[c000000175cabdb0] [c0000000000b475c] .worker_thread+0x1dc/0x3c0\n[c000000175cabed0] [c0000000000baa9c] .kthread+0xbc/0xd0\n[c000000175cabf90] [c000000000032114] .kernel_thread+0x54/0x70\nInstruction dump:\n4bfffd50 60000000 60000000 39080001 935f004c f91f0040 41820024 813d017c\n7d094a78 7d290074 7929d182 394a0020 <0b090000> 40e2ff68 4bffffa4 39200000\nKernel panic - not syncing: Fatal exception\nCall Trace:\n[c000000175cab560] [c000000000012e04] .show_stack+0x74/0x1c0 (unreliable)\n[c000000175cab610] [c0000000005a365c] .panic+0x80/0x1b4\n[c000000175cab6a0] [c00000000002fbcc] .die+0x21c/0x2a0\n[c000000175cab750] [c000000000030000] ._exception+0x110/0x220\n[c000000175cab910] [c000000000004b9c] program_check_common+0x11c/0x180\n\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct kmem_cache *ccid_kmem_cache_create(int obj_size, char *slab_name_fmt, const char *fmt,...)\n{\n\tstruct kmem_cache *slab;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(slab_name_fmt, sizeof(slab_name_fmt), fmt, args);\n\tva_end(args);\n\n\tslab = kmem_cache_create(slab_name_fmt, sizeof(struct ccid) + obj_size, 0,\n\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\treturn slab;\n}", "target": 1, "cwe": ["CWE-476"], "message": "dccp: fix bug in cache allocation\n\nThis fixes a bug introduced in commit de4ef86cfce60d2250111f34f8a084e769f23b16\n(\"dccp: fix dccp rmmod when kernel configured to use slub\", 17 Jan): the\nvsnprintf used sizeof(slab_name_fmt), which became truncated to 4 bytes, since\nslab_name_fmt is now a 4-byte pointer and no longer a 32-character array.\n\nThis lead to error messages such as\n FATAL: Error inserting dccp: No buffer space available\n\n >> kernel: [ 1456.341501] kmem_cache_create: duplicate cache cci\ngenerated due to the truncation after the 3rd character.\n\nFixed for the moment by introducing a symbolic constant. Tested to fix the bug.\n\nSigned-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n    xmlNodePtr cur = NULL;\n    unsigned long val;\n    xmlChar str[20];\n\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i, ret;\n\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t        cur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    /*\n     * Okay this is ugly but should work, use the NodePtr address\n     * to forge the ID\n     */\n    val = (unsigned long)((char *)cur - (char *)0);\n    val /= sizeof(xmlNode);\n    sprintf((char *)str, \"id%ld\", val);\n    valuePush(ctxt, xmlXPathNewString(str));\n}", "target": 1, "cwe": ["CWE-200"], "message": "Fix generate-id() to not expose object addresses\n\nAs pointed out by Chris Evans <scarybeasts@gmail.com> it's better\nsecurity wise to not expose object addresses directly, use a diff\nw.r.t. the document root own address to avoid this\n* libxslt/functions.c: fix IDs generation code"}
{"func": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-200"], "message": "char/tpm: Fix unitialized usage of data buffer\n\nThis patch fixes information leakage to the userspace by initializing\nthe data buffer to zero.\n\nReported-by: Peter Huewe <huewe.external@infineon.com>\nSigned-off-by: Peter Huewe <huewe.external@infineon.com>\nSigned-off-by: Marcel Selhorst <m.selhorst@sirrix.com>\n[ Also removed the silly \"* sizeof(u8)\".  If that isn't 1, we have way\n  deeper problems than a simple multiplication can fix.   - Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "_save_user_settings (GdmSessionWorker *worker,\n                     const char       *home_dir)\n{\n        GError *error;\n\n        if (!gdm_session_settings_is_loaded (worker->priv->user_settings)) {\n                return;\n        }\n\n        error = NULL;\n        if (!gdm_session_settings_save (worker->priv->user_settings,\n                                        home_dir, &error)) {\n                g_warning (\"could not save session and language settings: %s\",\n                           error->message);\n                g_error_free (error);\n        }\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "gdm_session_settings_load (GdmSessionSettings  *settings,\n                           const char          *home_directory,\n                           GError             **error)\n{\n        GKeyFile *key_file;\n        GError   *load_error;\n        gboolean  is_loaded;\n        char     *session_name;\n        char     *language_name;\n        char     *layout_name;\n        char     *filename;\n\n        g_return_val_if_fail (settings != NULL, FALSE);\n        g_return_val_if_fail (home_directory != NULL, FALSE);\n        g_return_val_if_fail (!gdm_session_settings_is_loaded (settings), FALSE);\n        filename = g_build_filename (home_directory, \".dmrc\", NULL);\n\n        is_loaded = FALSE;\n        key_file = g_key_file_new ();\n\n        load_error = NULL;\n        if (!g_key_file_load_from_file (key_file, filename,\n                                        G_KEY_FILE_NONE, &load_error)) {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        session_name = g_key_file_get_string (key_file, \"Desktop\", \"Session\",\n                                              &load_error);\n\n        if (session_name != NULL) {\n                gdm_session_settings_set_session_name (settings, session_name);\n                g_free (session_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        language_name = g_key_file_get_string (key_file, \"Desktop\", \"Language\",\n                                               &load_error);\n\n        if (language_name != NULL) {\n                gdm_session_settings_set_language_name (settings, language_name);\n                g_free (language_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        layout_name = g_key_file_get_string (key_file, \"Desktop\", \"Layout\",\n                                             &load_error);\n\n        if (layout_name != NULL) {\n                gdm_session_settings_set_layout_name (settings, layout_name);\n                g_free (layout_name);\n        } else if (g_error_matches (load_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND)) {\n                g_error_free (load_error);\n                load_error = NULL;\n        } else {\n                g_propagate_error (error, load_error);\n                goto out;\n        }\n\n        is_loaded = TRUE;\nout:\n        g_key_file_free (key_file);\n        g_free (filename);\n\n        return is_loaded;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "gdm_user_render_icon (GdmUser   *user,\n                      gint       icon_size)\n{\n        GdkPixbuf    *pixbuf;\n        GdkPixbuf    *framed;\n        char         *path;\n        char         *tmp;\n        gboolean      res;\n\n        g_return_val_if_fail (GDM_IS_USER (user), NULL);\n        g_return_val_if_fail (icon_size > 12, NULL);\n\n        path = NULL;\n\n        pixbuf = render_icon_from_home (user, icon_size);\n        if (pixbuf != NULL) {\n                goto out;\n        }\n\n        /* Try ${GlobalFaceDir}/${username} */\n        path = g_build_filename (GLOBAL_FACEDIR, user->user_name, NULL);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                pixbuf = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                pixbuf = NULL;\n        }\n\n        g_free (path);\n        if (pixbuf != NULL) {\n                goto out;\n        }\n\n        /* Finally, ${GlobalFaceDir}/${username}.png */\n        tmp = g_strconcat (user->user_name, \".png\", NULL);\n        path = g_build_filename (GLOBAL_FACEDIR, tmp, NULL);\n        g_free (tmp);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                pixbuf = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                pixbuf = NULL;\n        }\n        g_free (path);\n out:\n\n        if (pixbuf != NULL) {\n                framed = frame_pixbuf (pixbuf);\n                if (framed != NULL) {\n                        g_object_unref (pixbuf);\n                        pixbuf = framed;\n                }\n        }\n\n        return pixbuf;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "gdm_session_worker_start_user_session (GdmSessionWorker  *worker,\n                                       GError           **error)\n{\n        struct passwd *passwd_entry;\n        pid_t session_pid;\n        int   error_code;\n\n        g_debug (\"GdmSessionWorker: querying pam for user environment\");\n        gdm_session_worker_update_environment_from_pam (worker);\n\n        register_ck_session (worker);\n\n        passwd_entry = getpwnam (worker->priv->username);\n\n#ifdef  HAVE_LOGINDEVPERM\n        /*\n         * Only do logindevperm processing if /dev/console or\n         * a device associated with a VT\n         */\n        if (worker->priv->display_device != NULL &&\n           (strncmp (worker->priv->display_device, \"/dev/vt/\", strlen (\"/dev/vt/\")) == 0 ||\n            strcmp  (worker->priv->display_device, \"/dev/console\") == 0)) {\n                g_debug (\"Logindevperm login for user %s, device %s\",\n                         worker->priv->username,\n                         worker->priv->display_device);\n                (void) di_devperm_login (worker->priv->display_device,\n                                         passwd_entry->pw_uid,\n                                         passwd_entry->pw_gid,\n                                         NULL);\n        }\n#endif  /* HAVE_LOGINDEVPERM */\n\n        g_debug (\"GdmSessionWorker: opening user session with program '%s'\",\n                 worker->priv->arguments[0]);\n\n        error_code = PAM_SUCCESS;\n\n        session_pid = fork ();\n\n        if (session_pid < 0) {\n                g_set_error (error,\n                             GDM_SESSION_WORKER_ERROR,\n                             GDM_SESSION_WORKER_ERROR_OPENING_SESSION,\n                             \"%s\", g_strerror (errno));\n                error_code = PAM_ABORT;\n                goto out;\n        }\n\n        if (session_pid == 0) {\n                char **environment;\n                char  *home_dir;\n                int    fd;\n\n                if (setuid (worker->priv->uid) < 0) {\n                        g_debug (\"GdmSessionWorker: could not reset uid - %s\", g_strerror (errno));\n                        _exit (1);\n                }\n\n                if (setsid () < 0) {\n                        g_debug (\"GdmSessionWorker: could not set pid '%u' as leader of new session and process group - %s\",\n                                 (guint) getpid (), g_strerror (errno));\n                        _exit (2);\n                }\n\n                environment = gdm_session_worker_get_environment (worker);\n\n                g_assert (geteuid () == getuid ());\n\n                home_dir = g_hash_table_lookup (worker->priv->environment,\n                                                \"HOME\");\n\n                if ((home_dir == NULL) || g_chdir (home_dir) < 0) {\n                        g_chdir (\"/\");\n                }\n\n                fd = open (\"/dev/null\", O_RDWR);\n                dup2 (fd, STDIN_FILENO);\n                close (fd);\n\n                fd = _open_session_log (home_dir);\n                dup2 (fd, STDOUT_FILENO);\n                dup2 (fd, STDERR_FILENO);\n                close (fd);\n\n                _save_user_settings (worker, home_dir);\n\n                gdm_session_execute (worker->priv->arguments[0],\n                                     worker->priv->arguments,\n                                     environment,\n                                     TRUE);\n\n                g_debug (\"GdmSessionWorker: child '%s' could not be started - %s\",\n                         worker->priv->arguments[0],\n                         g_strerror (errno));\n                g_strfreev (environment);\n\n                _exit (127);\n        }\n\n        worker->priv->child_pid = session_pid;\n\n        g_debug (\"GdmSessionWorker: session opened creating reply...\");\n        g_assert (sizeof (GPid) <= sizeof (int));\n\n        g_debug (\"GdmSessionWorker: state SESSION_STARTED\");\n        worker->priv->state = GDM_SESSION_WORKER_STATE_SESSION_STARTED;\n\n        gdm_session_worker_watch_child (worker);\n\n out:\n        if (error_code != PAM_SUCCESS) {\n                gdm_session_worker_uninitialize_pam (worker, error_code);\n                return FALSE;\n        }\n\n        return TRUE;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "_change_user (GdmSessionWorker  *worker,\n              uid_t              uid,\n              gid_t              gid)\n{\n        gboolean ret;\n\n        ret = FALSE;\n\n#ifdef THE_MAN_PAGE_ISNT_LYING\n        /* pam_setcred wants to be called as the authenticated user\n         * but pam_open_session needs to be called as super-user.\n         *\n         * Set the real uid and gid to the user and give the user a\n         * temporary super-user effective id.\n         */\n        if (setreuid (uid, GDM_SESSION_ROOT_UID) < 0) {\n                return FALSE;\n        }\n#endif\n        worker->priv->uid = uid;\n\n        if (setgid (gid) < 0) {\n                return FALSE;\n        }\n\n        if (initgroups (worker->priv->username, gid) < 0) {\n                return FALSE;\n        }\n\n        return TRUE;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "attempt_to_load_user_settings (GdmSessionWorker *worker,\n                               const char       *username)\n{\n        struct passwd *passwd_entry;\n        uid_t          old_uid;\n        gid_t          old_gid;\n\n        old_uid = geteuid ();\n        old_gid = getegid ();\n\n        passwd_entry = getpwnam (username);\n\n        /* User input isn't a valid username\n         */\n        if (passwd_entry == NULL) {\n                return;\n        }\n\n        /* We may get called late in the pam conversation after\n         * the user has already been authenticated.  This could\n         * happen if for instance, the user's home directory isn't\n         * available until late in the pam conversation so user\n         * settings couldn't get loaded until late in the conversation.\n         * If we get called late the seteuid/setgid calls here will fail,\n         * but that's okay, because we'll already be the uid/gid we want\n         * to be.\n         */\n        setegid (passwd_entry->pw_gid);\n        seteuid (passwd_entry->pw_uid);\n\n        gdm_session_settings_load (worker->priv->user_settings,\n                                   passwd_entry->pw_dir,\n                                   NULL);\n\n        seteuid (old_uid);\n        setegid (old_gid);\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "render_icon_from_home (GdmUser *user,\n                       int      icon_size)\n{\n        GdkPixbuf  *retval;\n        char       *path;\n        gboolean    is_local;\n        gboolean    is_autofs;\n        gboolean    res;\n        char       *filesystem_type;\n\n        is_local = FALSE;\n\n        /* special case: look at parent of home to detect autofs\n           this is so we don't try to trigger an automount */\n        path = g_path_get_dirname (user->home_dir);\n        filesystem_type = get_filesystem_type (path);\n        is_autofs = (filesystem_type != NULL && strcmp (filesystem_type, \"autofs\") == 0);\n        g_free (filesystem_type);\n        g_free (path);\n\n        if (is_autofs) {\n                return NULL;\n        }\n\n        /* now check that home dir itself is local */\n        filesystem_type = get_filesystem_type (user->home_dir);\n        is_local = ((filesystem_type != NULL) &&\n                    (strcmp (filesystem_type, \"nfs\") != 0) &&\n                    (strcmp (filesystem_type, \"afs\") != 0) &&\n                    (strcmp (filesystem_type, \"autofs\") != 0) &&\n                    (strcmp (filesystem_type, \"unknown\") != 0) &&\n                    (strcmp (filesystem_type, \"ncpfs\") != 0));\n        g_free (filesystem_type);\n\n        /* only look at local home directories so we don't try to\n           read from remote (e.g. NFS) volumes */\n        if (! is_local) {\n                return NULL;\n        }\n\n        /* First, try \"~/.face\" */\n        path = g_build_filename (user->home_dir, \".face\", NULL);\n        res = check_user_file (path,\n                               user->uid,\n                               MAX_FILE_SIZE,\n                               RELAX_GROUP,\n                               RELAX_OTHER);\n        if (res) {\n                retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                           icon_size,\n                                                           icon_size,\n                                                           NULL);\n        } else {\n                retval = NULL;\n        }\n        g_free (path);\n\n        /* Next, try \"~/.face.icon\" */\n        if (retval == NULL) {\n                path = g_build_filename (user->home_dir,\n                                         \".face.icon\",\n                                         NULL);\n                res = check_user_file (path,\n                                       user->uid,\n                                       MAX_FILE_SIZE,\n                                       RELAX_GROUP,\n                                       RELAX_OTHER);\n                if (res) {\n                        retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                                   icon_size,\n                                                                   icon_size,\n                                                                   NULL);\n                } else {\n                        retval = NULL;\n                }\n\n                g_free (path);\n        }\n\n        /* Still nothing, try the user's personal GDM config */\n        if (retval == NULL) {\n                path = g_build_filename (user->home_dir,\n                                         \".gnome\",\n                                         \"gdm\",\n                                         NULL);\n                res = check_user_file (path,\n                                       user->uid,\n                                       MAX_FILE_SIZE,\n                                       RELAX_GROUP,\n                                       RELAX_OTHER);\n                if (res) {\n                        GKeyFile *keyfile;\n                        char     *icon_path;\n\n                        keyfile = g_key_file_new ();\n                        g_key_file_load_from_file (keyfile,\n                                                   path,\n                                                   G_KEY_FILE_NONE,\n                                                   NULL);\n\n                        icon_path = g_key_file_get_string (keyfile,\n                                                           \"face\",\n                                                           \"picture\",\n                                                           NULL);\n                        res = check_user_file (icon_path,\n                                               user->uid,\n                                               MAX_FILE_SIZE,\n                                               RELAX_GROUP,\n                                               RELAX_OTHER);\n                        if (icon_path && res) {\n                                retval = gdk_pixbuf_new_from_file_at_size (path,\n                                                                           icon_size,\n                                                                           icon_size,\n                                                                           NULL);\n                        } else {\n                                retval = NULL;\n                        }\n\n                        g_free (icon_path);\n                        g_key_file_free (keyfile);\n                } else {\n                        retval = NULL;\n                }\n\n                g_free (path);\n        }\n\n        return retval;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "gdm_session_worker_uninitialize_pam (GdmSessionWorker *worker,\n                                     int               status)\n{\n        g_debug (\"GdmSessionWorker: uninitializing PAM\");\n\n        if (worker->priv->pam_handle == NULL)\n                return;\n\n        if (worker->priv->state >= GDM_SESSION_WORKER_STATE_SESSION_OPENED) {\n                pam_close_session (worker->priv->pam_handle, 0);\n                gdm_session_auditor_report_logout (worker->priv->auditor);\n\n#ifdef  HAVE_LOGINDEVPERM\n                /*\n                 * Only do logindevperm processing if /dev/console or\n                 * a device associated with a VT\n                 */\n                if (worker->priv->display_device != NULL &&\n                   (strncmp (worker->priv->display_device, \"/dev/vt/\", strlen (\"/dev/vt/\")) == 0 ||\n                    strcmp  (worker->priv->display_device, \"/dev/console\") == 0)) {\n                        g_debug (\"Logindevperm logout for user %s, device %s\",\n                                 worker->priv->username,\n                                 worker->priv->display_device);\n                        (void) di_devperm_logout (worker->priv->display_device);\n                }\n#endif  /* HAVE_LOGINDEVPERM */\n\n        } else {\n                void *p;\n\n                if ((pam_get_item (worker->priv->pam_handle, PAM_USER, &p)) == PAM_SUCCESS) {\n                        gdm_session_auditor_set_username (worker->priv->auditor, (const char *)p);\n                }\n\n                gdm_session_auditor_report_login_failure (worker->priv->auditor,\n                                                          status,\n                                                          pam_strerror (worker->priv->pam_handle, status));\n        }\n\n        if (worker->priv->state >= GDM_SESSION_WORKER_STATE_ACCREDITED) {\n                pam_setcred (worker->priv->pam_handle, PAM_DELETE_CRED);\n        }\n\n        pam_end (worker->priv->pam_handle, status);\n        worker->priv->pam_handle = NULL;\n\n        gdm_session_worker_stop_auditor (worker);\n\n        g_debug (\"GdmSessionWorker: state NONE\");\n        worker->priv->state = GDM_SESSION_WORKER_STATE_NONE;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "check_user_file (const char *filename,\n                 uid_t       user,\n                 gssize      max_file_size,\n                 gboolean    relax_group,\n                 gboolean    relax_other)\n{\n        struct stat fileinfo;\n\n        if (max_file_size < 0) {\n                max_file_size = G_MAXSIZE;\n        }\n\n        /* Exists/Readable? */\n        if (stat (filename, &fileinfo) < 0) {\n                return FALSE;\n        }\n\n        /* Is a regular file */\n        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {\n                return FALSE;\n        }\n\n        /* Owned by user? */\n        if (G_UNLIKELY (fileinfo.st_uid != user)) {\n                return FALSE;\n        }\n\n        /* Group not writable or relax_group? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {\n                return FALSE;\n        }\n\n        /* Other not writable or relax_other? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !relax_other)) {\n                return FALSE;\n        }\n\n        /* Size is kosher? */\n        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {\n                return FALSE;\n        }\n\n        return TRUE;\n}", "target": 1, "cwe": [], "message": "Store the face and dmrc files in a cache.  Refer to bug #565151."}
{"func": "network_init ()\n{\n#ifdef HAVE_GNUTLS\n    char *ca_path, *ca_path2;\n\n    gnutls_global_init ();\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n    \n    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));\n    if (ca_path)\n    {\n        ca_path2 = string_replace (ca_path, \"%h\", weechat_home);\n        if (ca_path2)\n        {\n            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,\n                                                    GNUTLS_X509_FMT_PEM);\n            free (ca_path2);\n        }\n        free (ca_path);\n    }\n    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                     &hook_connect_gnutls_set_certificates);\n    network_init_ok = 1;\n#endif\n#ifdef HAVE_GCRYPT\n    gcry_check_version (GCRYPT_VERSION);\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix verification of SSL certificates by calling gnutls verify callback (patch #7459)"}
{"func": "irc_server_gnutls_callback (void *data, gnutls_session_t tls_session,\n                            const gnutls_datum_t *req_ca, int nreq,\n                            const gnutls_pk_algorithm_t *pk_algos,\n                            int pk_algos_len, gnutls_retr_st *answer)\n{\n    struct t_irc_server *server;\n    gnutls_retr_st tls_struct;\n    gnutls_x509_crt_t cert_temp;\n    const gnutls_datum_t *cert_list;\n    gnutls_datum_t filedatum;\n    unsigned int cert_list_len, status;\n    time_t cert_time;\n    char *cert_path0, *cert_path1, *cert_path2, *cert_str, *hostname;\n    const char *weechat_dir;\n    int rc, ret, i, j, hostname_match;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n    gnutls_datum_t cinfo;\n    int rinfo;\n#endif\n\n    /* make C compiler happy */\n    (void) req_ca;\n    (void) nreq;\n    (void) pk_algos;\n    (void) pk_algos_len;\n    \n    rc = 0;\n    \n    if (!data)\n        return -1;\n    \n    server = (struct t_irc_server *) data;\n    hostname = server->current_address;\n    hostname_match = 0;\n    \n    weechat_printf (server->buffer,\n                    _(\"gnutls: connected using %d-bit Diffie-Hellman shared \"\n                      \"secret exchange\"),\n                    IRC_SERVER_OPTION_INTEGER (server,\n                                               IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n    if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n    {\n        weechat_printf (server->buffer,\n                        _(\"%sgnutls: error while checking peer's certificate\"),\n                        weechat_prefix (\"error\"));\n        rc = -1;\n    }\n    else\n    {\n        /* some checks */\n        if (status & GNUTLS_CERT_INVALID)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: peer's certificate is NOT trusted\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        else\n        {\n            weechat_printf (server->buffer,\n                            _(\"gnutls: peer's certificate is trusted\"));\n        }\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: peer's certificate issuer is unknown\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        if (status & GNUTLS_CERT_REVOKED)\n        {\n            weechat_printf (server->buffer,\n                            _(\"%sgnutls: the certificate has been revoked\"),\n                            weechat_prefix (\"error\"));\n            rc = -1;\n        }\n        \n        /* check certificates */\n        if (gnutls_x509_crt_init (&cert_temp) >= 0)\n        {\n            cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n            if (cert_list)\n            {\n                weechat_printf (server->buffer,\n                                NG_(\"gnutls: receiving %d certificate\",\n                                    \"gnutls: receiving %d certificates\",\n                                    cert_list_len),\n                                cert_list_len);\n                for (i = 0, j = (int) cert_list_len; i < j; i++)\n                {\n                    if (gnutls_x509_crt_import (cert_temp, &cert_list[i], GNUTLS_X509_FMT_DER) >= 0)\n                    {\n                        /* checking if hostname matches in the first certificate */\n                        if (i == 0 && gnutls_x509_crt_check_hostname (cert_temp, hostname) != 0)\n                        {\n                            hostname_match = 1;\n                        }\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n                        /* displaying infos about certificate */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400\n                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_X509_CRT_ONELINE, &cinfo);\n#else\n                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n#endif\n                        if (rinfo == 0)\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\" - certificate[%d] info:\"), i + 1);\n                            weechat_printf (server->buffer,\n                                            \"   - %s\", cinfo.data);\n                            gnutls_free (cinfo.data);\n                        }\n#endif\n                        /* check expiration date */\n                        cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n                        if (cert_time < time(NULL))\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\"%sgnutls: certificate has expired\"),\n                                            weechat_prefix (\"error\"));\n                            rc = -1;\n                        }\n                        /* check expiration date */\n                        cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n                        if (cert_time > time(NULL))\n                        {\n                            weechat_printf (server->buffer,\n                                            _(\"%sgnutls: certificate is not yet activated\"),\n                                            weechat_prefix (\"error\"));\n                            rc = -1;\n                        }\n                    }\n                }\n                if (hostname_match == 0)\n                {\n                    weechat_printf (server->buffer,\n                                    _(\"%sgnutls: the hostname in the \"\n                                      \"certificate does NOT match \\\"%s\\\"\"),\n                                    weechat_prefix (\"error\"), hostname);\n                    rc = -1;\n                }\n            }\n        }\n    }\n    \n    /* using client certificate if it exists */\n    cert_path0 = (char *) IRC_SERVER_OPTION_STRING(server,\n                                                   IRC_SERVER_OPTION_SSL_CERT);\n    if (cert_path0 && cert_path0[0])\n    {\n        weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n        cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n        cert_path2 = (cert_path1) ?\n            weechat_string_expand_home (cert_path1) : NULL;\n        \n        if (cert_path2)\n        {\n            cert_str = weechat_file_get_content (cert_path2);\n            if (cert_str)\n            {\n                weechat_printf (server->buffer,\n                                _(\"gnutls: sending one certificate\"));\n                \n                filedatum.data = (unsigned char *) cert_str;\n                filedatum.size = strlen (cert_str);\n                \n                /* certificate */\n                gnutls_x509_crt_init (&server->tls_cert);\n                gnutls_x509_crt_import (server->tls_cert, &filedatum,\n                                        GNUTLS_X509_FMT_PEM);\n                \n                /* key */\n                gnutls_x509_privkey_init (&server->tls_cert_key);\n                ret = gnutls_x509_privkey_import (server->tls_cert_key,\n                                                  &filedatum,\n                                                  GNUTLS_X509_FMT_PEM);\n                if (ret < 0)\n                {\n                    ret = gnutls_x509_privkey_import_pkcs8 (server->tls_cert_key,\n                                                            &filedatum,\n                                                            GNUTLS_X509_FMT_PEM,\n                                                            NULL,\n                                                            GNUTLS_PKCS_PLAIN);\n                }\n                if (ret < 0)\n                {\n                    weechat_printf (server->buffer,\n                                    _(\"%sgnutls: invalid certificate \\\"%s\\\", \"\n                                      \"error: %s\"),\n                                    weechat_prefix (\"error\"), cert_path2,\n                                    gnutls_strerror (ret));\n                    rc = -1;\n                }\n                else\n                {\n                    tls_struct.type = GNUTLS_CRT_X509;\n                    tls_struct.ncerts = 1;\n                    tls_struct.deinit_all = 0;\n                    tls_struct.cert.x509 = &server->tls_cert;\n                    tls_struct.key.x509 = server->tls_cert_key;\n#if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n                    /* client certificate info */\n#if LIBGNUTLS_VERSION_NUMBER < 0x020400\n                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                   GNUTLS_X509_CRT_ONELINE,\n                                                   &cinfo);\n#else\n                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n                                                   GNUTLS_CRT_PRINT_ONELINE,\n                                                   &cinfo);\n#endif\n                    if (rinfo == 0)\n                    {\n                        weechat_printf (server->buffer,\n                                        _(\" - client certificate info (%s):\"),\n                                        cert_path2);\n                        weechat_printf (server->buffer, \"  - %s\", cinfo.data);\n                        gnutls_free (cinfo.data);\n                    }\n#endif\n                    memcpy (answer, &tls_struct, sizeof (gnutls_retr_st));\n                    free (cert_str);\n                }\n            }\n            else\n            {\n                weechat_printf (server->buffer,\n                                _(\"%sgnutls: unable to read certifcate \\\"%s\\\"\"),\n                                weechat_prefix (\"error\"), cert_path2);\n            }\n        }\n        \n        if (cert_path1)\n            free (cert_path1);\n        if (cert_path2)\n            free (cert_path2);\n    }\n    \n    /* an error should stop the handshake unless the user doesn't care */\n    if ((rc == -1)\n        && (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_SSL_VERIFY) == 0))\n    {\n        rc = 0;\n    }\n    \n    return rc;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix verification of SSL certificates by calling gnutls verify callback (patch #7459)"}
{"func": "hook_connect_gnutls_set_certificates (gnutls_session_t tls_session,\n                                      const gnutls_datum_t *req_ca, int nreq,\n                                      const gnutls_pk_algorithm_t *pk_algos,\n                                      int pk_algos_len,\n                                      gnutls_retr_st *answer)\n{\n    struct t_hook *ptr_hook;\n    int rc;\n    \n    rc = -1;\n    ptr_hook = weechat_hooks[HOOK_TYPE_CONNECT];\n    while (ptr_hook)\n    {\n        /* looking for the right hook using to the gnutls session pointer */\n        if (!ptr_hook->deleted\n            && HOOK_CONNECT(ptr_hook, gnutls_sess)\n            && (*(HOOK_CONNECT(ptr_hook, gnutls_sess)) == tls_session))\n        {\n            rc = (int) (HOOK_CONNECT(ptr_hook, gnutls_cb))\n                (ptr_hook->callback_data, tls_session, req_ca, nreq,\n                 pk_algos, pk_algos_len, answer);\n            break;\n        }\n        ptr_hook = ptr_hook->next_hook;\n    }\n    \n    return rc;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix verification of SSL certificates by calling gnutls verify callback (patch #7459)"}
{"func": "static int do_replace(struct net *net, const void __user *user,\n                      unsigned int len)\n{\n\tint ret;\n\tstruct arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"arp_tables: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: arp_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second is\nintroduced by 6b7d31fc (v2.6.15-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "static int compat_do_replace(struct net *net, void __user *user,\n\t\t\t     unsigned int len)\n{\n\tint ret;\n\tstruct compat_arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp), tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: arp_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second is\nintroduced by 6b7d31fc (v2.6.15-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "static int do_arpt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase ARPT_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttry_then_request_module(xt_find_revision(NFPROTO_ARP, rev.name,\n\t\t\t\t\t\t\t rev.revision, 1, &ret),\n\t\t\t\t\t\"arpt_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_arpt_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: arp_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second is\nintroduced by 6b7d31fc (v2.6.15-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "do_replace(struct net *net, const void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: ip_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first and the third bugs were introduced before the git epoch; the\nsecond was introduced in 2722971c (v2.6.17-rc1).  To trigger the bug\none should have CAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: ip_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first and the third bugs were introduced before the git epoch; the\nsecond was introduced in 2722971c (v2.6.17-rc1).  To trigger the bug\none should have CAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IPT_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase IPT_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IPT_SO_GET_REVISION_MATCH:\n\tcase IPT_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\t\tint target;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd == IPT_SO_GET_REVISION_TARGET)\n\t\t\ttarget = 1;\n\t\telse\n\t\t\ttarget = 0;\n\n\t\ttry_then_request_module(xt_find_revision(AF_INET, rev.name,\n\t\t\t\t\t\t\t rev.revision,\n\t\t\t\t\t\t\t target, &ret),\n\t\t\t\t\t\"ipt_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_ipt_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "netfilter: ip_tables: fix infoleak to userspace\n\nStructures ipt_replace, compat_ipt_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first and the third bugs were introduced before the git epoch; the\nsecond was introduced in 2722971c (v2.6.17-rc1).  To trigger the bug\none should have CAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\n\treturn size;\n}", "target": 1, "cwe": ["CWE-120"], "message": "netfilter: ipt_CLUSTERIP: fix buffer overflow\n\n'buffer' string is copied from userspace.  It is not checked whether it is\nzero terminated.  This may lead to overflow inside of simple_strtoul().\nChangli Gao suggested to copy not more than user supplied 'size' bytes.\n\nIt was introduced before the git epoch.  Files \"ipt_CLUSTERIP/*\" are\nroot writable only by default, however, on some setups permissions might be\nrelaxed to e.g. network admin user.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nAcked-by: Changli Gao <xiaosuo@gmail.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "do_ip6t_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IP6T_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tcase IP6T_SO_GET_ENTRIES:\n\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IP6T_SO_GET_REVISION_MATCH:\n\tcase IP6T_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\t\tint target;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd == IP6T_SO_GET_REVISION_TARGET)\n\t\t\ttarget = 1;\n\t\telse\n\t\t\ttarget = 0;\n\n\t\ttry_then_request_module(xt_find_revision(AF_INET6, rev.name,\n\t\t\t\t\t\t\t rev.revision,\n\t\t\t\t\t\t\t target, &ret),\n\t\t\t\t\t\"ip6t_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tduprintf(\"do_ip6t_get_ctl: unknown request %i\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "ipv6: netfilter: ip6_tables: fix infoleak to userspace\n\nStructures ip6t_replace, compat_ip6t_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second was\nintroduced in 3bc3fe5e (v2.6.25-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ip6t_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ip6t_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "ipv6: netfilter: ip6_tables: fix infoleak to userspace\n\nStructures ip6t_replace, compat_ip6t_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second was\nintroduced in 3bc3fe5e (v2.6.25-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "do_replace(struct net *net, const void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct ip6t_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ip6t_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\t/* choose the copy that is on our node/cpu */\n\tloc_cpu_entry = newinfo->entries[raw_smp_processor_id()];\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"ip_tables: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "ipv6: netfilter: ip6_tables: fix infoleak to userspace\n\nStructures ip6t_replace, compat_ip6t_replace, and xt_get_revision are\ncopied from userspace.  Fields of these structs that are\nzero-terminated strings are not checked.  When they are used as argument\nto a format string containing \"%s\" in request_module(), some sensitive\ninformation is leaked to userspace via argument of spawned modprobe\nprocess.\n\nThe first bug was introduced before the git epoch;  the second was\nintroduced in 3bc3fe5e (v2.6.25-rc1);  the third is introduced by\n6b7d31fc (v2.6.15-rc1).  To trigger the bug one should have\nCAP_NET_ADMIN.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}", "target": 1, "cwe": ["CWE-190"], "message": "PCX: Avoid allocation overflows.\n\nMultiplying gint values may overflow unless cast into a larger type."}
{"func": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1, "cwe": [], "message": "Prevent rt_sigqueueinfo and rt_tgsigqueueinfo from spoofing the signal code\n\nUserland should be able to trust the pid and uid of the sender of a\nsignal if the si_code is SI_TKILL.\n\nUnfortunately, the kernel has historically allowed sigqueueinfo() to\nsend any si_code at all (as long as it was negative - to distinguish it\nfrom kernel-generated signals like SIGILL etc), so it could spoof a\nSI_TKILL with incorrect siginfo values.\n\nHappily, it looks like glibc has always set si_code to the appropriate\nSI_QUEUE, so there are probably no actual user code that ever uses\nanything but the appropriate SI_QUEUE flag.\n\nSo just tighten the check for si_code (we used to allow any negative\nvalue), and add a (one-time) warning in case there are binaries out\nthere that might depend on using other si_code values.\n\nSigned-off-by: Julien Tinnes <jln@google.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1, "cwe": [], "message": "Prevent rt_sigqueueinfo and rt_tgsigqueueinfo from spoofing the signal code\n\nUserland should be able to trust the pid and uid of the sender of a\nsignal if the si_code is SI_TKILL.\n\nUnfortunately, the kernel has historically allowed sigqueueinfo() to\nsend any si_code at all (as long as it was negative - to distinguish it\nfrom kernel-generated signals like SIGILL etc), so it could spoof a\nSI_TKILL with incorrect siginfo values.\n\nHappily, it looks like glibc has always set si_code to the appropriate\nSI_QUEUE, so there are probably no actual user code that ever uses\nanything but the appropriate SI_QUEUE flag.\n\nSo just tighten the check for si_code (we used to allow any negative\nvalue), and add a (one-time) warning in case there are binaries out\nthere that might depend on using other si_code values.\n\nSigned-off-by: Julien Tinnes <jln@google.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info.si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info.si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1, "cwe": [], "message": "Relax si_code check in rt_sigqueueinfo and rt_tgsigqueueinfo\n\nCommit da48524eb206 (\"Prevent rt_sigqueueinfo and rt_tgsigqueueinfo\nfrom spoofing the signal code\") made the check on si_code too strict.\nThere are several legitimate places where glibc wants to queue a\nnegative si_code different from SI_QUEUE:\n\n - This was first noticed with glibc's aio implementation, which wants\n   to queue a signal with si_code SI_ASYNCIO; the current kernel\n   causes glibc's tst-aio4 test to fail because rt_sigqueueinfo()\n   fails with EPERM.\n\n - Further examination of the glibc source shows that getaddrinfo_a()\n   wants to use SI_ASYNCNL (which the kernel does not even define).\n   The timer_create() fallback code wants to queue signals with SI_TIMER.\n\nAs suggested by Oleg Nesterov <oleg@redhat.com>, loosen the check to\nforbid only the problematic SI_TKILL case.\n\nReported-by: Klaus Dittrich <kladit@arcor.de>\nAcked-by: Julien Tinnes <jln@google.com>\nCc: <stable@kernel.org>\nSigned-off-by: Roland Dreier <roland@purestorage.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1, "cwe": [], "message": "Relax si_code check in rt_sigqueueinfo and rt_tgsigqueueinfo\n\nCommit da48524eb206 (\"Prevent rt_sigqueueinfo and rt_tgsigqueueinfo\nfrom spoofing the signal code\") made the check on si_code too strict.\nThere are several legitimate places where glibc wants to queue a\nnegative si_code different from SI_QUEUE:\n\n - This was first noticed with glibc's aio implementation, which wants\n   to queue a signal with si_code SI_ASYNCIO; the current kernel\n   causes glibc's tst-aio4 test to fail because rt_sigqueueinfo()\n   fails with EPERM.\n\n - Further examination of the glibc source shows that getaddrinfo_a()\n   wants to use SI_ASYNCNL (which the kernel does not even define).\n   The timer_create() fallback code wants to queue signals with SI_TIMER.\n\nAs suggested by Oleg Nesterov <oleg@redhat.com>, loosen the check to\nforbid only the problematic SI_TKILL case.\n\nReported-by: Klaus Dittrich <kladit@arcor.de>\nAcked-by: Julien Tinnes <jln@google.com>\nCc: <stable@kernel.org>\nSigned-off-by: Roland Dreier <roland@purestorage.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\n\t//TODO: init batchObj (states _OK and new fields -- CHECK)\n\tASSERT(pThis != NULL);\n\n\t/* calling the consumer is quite different here than it is from a worker thread */\n\t/* we need to provide the consumer's return value back to the caller because in direct\n\t * mode the consumer probably has a lot to convey (which get's lost in the other modes\n\t * because they are asynchronous. But direct mode is deliberately synchronous.\n\t * rgerhards, 2008-02-12\n\t * We use our knowledge about the batch_t structure below, but without that, we\n\t * pay a too-large performance toll... -- rgerhards, 2009-04-22\n\t */\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; /* there always is only one in direct mode */\n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\n\tRETiRet;\n}", "target": 1, "cwe": ["CWE-772"], "message": "bugfix: memory leak when $RepeatedMsgReduction on was used\n\nbug tracker: http://bugzilla.adiscon.com/show_bug.cgi?id=225"}
{"func": "msg_t* MsgDup(msg_t* pOld)\n{\n\tmsg_t* pNew;\n\trsRetVal localRet;\n\n\tassert(pOld != NULL);\n\n\tBEGINfunc\n\tif(msgConstructWithTime(&pNew, &pOld->tTIMESTAMP, pOld->ttGenTime) != RS_RET_OK) {\n\t\treturn NULL;\n\t}\n\n\t/* now copy the message properties */\n\tpNew->iRefCount = 1;\n\tpNew->iSeverity = pOld->iSeverity;\n\tpNew->iFacility = pOld->iFacility;\n\tpNew->msgFlags = pOld->msgFlags;\n\tpNew->iProtocolVersion = pOld->iProtocolVersion;\n\tpNew->ttGenTime = pOld->ttGenTime;\n\tpNew->offMSG = pOld->offMSG;\n\tpNew->iLenRawMsg = pOld->iLenRawMsg;\n\tpNew->iLenMSG = pOld->iLenMSG;\n\tpNew->iLenTAG = pOld->iLenTAG;\n\tpNew->iLenHOSTNAME = pOld->iLenHOSTNAME;\n\tif((pOld->msgFlags & NEEDS_DNSRESOL) == 1) {\n\t\t\tlocalRet = msgSetFromSockinfo(pNew, pOld->rcvFrom.pfrominet);\n\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t/* if something fails, we accept loss of this property, it is\n\t\t\t\t * better than losing the whole message.\n\t\t\t\t */\n\t\t\t\tpNew->msgFlags &= ~NEEDS_DNSRESOL;\n\t\t\t}\n\t} else {\n\t\tif(pOld->rcvFrom.pRcvFrom != NULL) {\n\t\t\tpNew->rcvFrom.pRcvFrom = pOld->rcvFrom.pRcvFrom;\n\t\t\tprop.AddRef(pNew->rcvFrom.pRcvFrom);\n\t\t}\n\t}\n\tif(pOld->pRcvFromIP != NULL) {\n\t\tpNew->pRcvFromIP = pOld->pRcvFromIP;\n\t\tprop.AddRef(pNew->pRcvFromIP);\n\t}\n\tif(pOld->pInputName != NULL) {\n\t\tpNew->pInputName = pOld->pInputName;\n\t\tprop.AddRef(pNew->pInputName);\n\t}\n\t/* enable this, if someone actually uses UxTradMsg, delete after some time has\n\t * passed and nobody complained -- rgerhards, 2009-06-16\n\tpNew->offAfterPRI = pOld->offAfterPRI;\n\t*/\n\tif(pOld->iLenTAG > 0) {\n\t\tif(pOld->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t\tmemcpy(pNew->TAG.szBuf, pOld->TAG.szBuf, pOld->iLenTAG);\n\t\t} else {\n\t\t\tif((pNew->TAG.pszTAG = srUtilStrDup(pOld->TAG.pszTAG, pOld->iLenTAG)) == NULL) {\n\t\t\t\tmsgDestruct(&pNew);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpNew->iLenTAG = pOld->iLenTAG;\n\t\t}\n\t}\n\tif(pOld->iLenRawMsg < CONF_RAWMSG_BUFSIZE) {\n\t\tmemcpy(pNew->szRawMsg, pOld->szRawMsg, pOld->iLenRawMsg + 1);\n\t\tpNew->pszRawMsg = pNew->szRawMsg;\n\t} else {\n\t\ttmpCOPYSZ(RawMsg);\n\t}\n\tif(pOld->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {\n\t\tmemcpy(pNew->szHOSTNAME, pOld->szHOSTNAME, pOld->iLenHOSTNAME + 1);\n\t\tpNew->pszHOSTNAME = pNew->szHOSTNAME;\n\t} else {\n\t\ttmpCOPYSZ(HOSTNAME);\n\t}\n\n\ttmpCOPYCSTR(ProgName);\n\ttmpCOPYCSTR(StrucData);\n\ttmpCOPYCSTR(APPNAME);\n\ttmpCOPYCSTR(PROCID);\n\ttmpCOPYCSTR(MSGID);\n\n\t/* we do not copy all other cache properties, as we do not even know\n\t * if they are needed once again. So we let them re-create if needed.\n\t */\n\n\tENDfunc\n\treturn pNew;\n}", "target": 1, "cwe": ["CWE-772"], "message": "backporting abort condition fix from 5.7.7"}
{"func": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t/* start index of partial batch */\n\tint iNew;\t/* index for new (temporary) batch */\n\tDEFiRet;\n\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\n\twhile(1) { /* loop broken inside */\n\t\t/* search for first unprocessed element */\n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t/* just search, no action */;\n\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; /* everything processed */\n\n\t\t/* prepare temporary batch */\n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\t/* We indicate the element also as done, so it will not be processed again */\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; /* was left just right by the for loop */\n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\t/* process temp batch */\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\n\nfinalize_it:\n\tRETiRet;\n}", "target": 1, "cwe": ["CWE-772", "CWE-401"], "message": "bugfix: fixed a memory leak and potential abort condition\n\nthis could happen if multiple rulesets were used and some output batches\ncontained messages belonging to more than one ruleset.\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218"}
{"func": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\n\t// TODO: replace calloc by inidividual writes?\nfinalize_it:\n\tRETiRet;\n}", "target": 1, "cwe": ["CWE-772", "CWE-401"], "message": "bugfix: fixed a memory leak and potential abort condition\n\nthis could happen if multiple rulesets were used and some output batches\ncontained messages belonging to more than one ruleset.\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218"}
{"func": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1, "cwe": ["CWE-772", "CWE-401"], "message": "bugfix: fixed a memory leak and potential abort condition\n\nthis could happen if multiple rulesets were used and some output batches\ncontained messages belonging to more than one ruleset.\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226\nfixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218"}
{"func": "rfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion, updateCopyRegion, tmpRegion, cursorRegion;\n    sraRect cursorBounds = { 0, 0, 0, 0 };\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool cursorIsDrawn = FALSE;\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      cl->rfbFramebufferUpdateMessagesSent++;\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n      if (!rfbSendNewFBSize(cl, cl->screen->width, cl->screen->height)) {\n        return FALSE;\n      }\n      return rfbSendUpdateBuf(cl);\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    sraRgnOr(updateRegion,cl->copyRegion);\n\n    /*\n     * If the client doesn't support cursor updates, we want to draw\n     * the cursor locally, send the update and then undraw it.\n     * We only want to do this if the cursor has moved/changed or\n     * if it is contained in updateRegion\n     *\n     * We also want to send an update for the region where the cursor\n     * was last drawn, again only if the cursor has moved/changed.\n     */\n\n    LOCK(cl->screen->cursorMutex);\n\n    cursorRegion = NULL;\n    if (cl->enableCursorUpdates) {\n\tsendCursorShape = cl->cursorWasChanged;\n\tsendCursorPos   = cl->cursorWasMoved;\n    } else {\n\tsraRegionPtr lastDrawnCursorRegion;\n\n\tif (rfbGetCursorBounds(cl->screen, &cursorBounds)) {\n\t    cursorRegion = sraRgnCreateRect(cursorBounds.x1, cursorBounds.y1,\n\t\t\t\t\t    cursorBounds.x2, cursorBounds.y2);\n\t}\n\t\n\tlastDrawnCursorRegion = sraRgnCreateRect(cl->lastDrawnCursorBounds.x1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.x2,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y2);\n\n\tif (cursorRegion) {\n\t    sraRgnOr(cursorRegion, lastDrawnCursorRegion);\n\t    sraRgnDestroy(lastDrawnCursorRegion);\n\t} else {\n\t    cursorRegion = lastDrawnCursorRegion;\n\t}\n\n\tif (cl->cursorWasChanged || cl->cursorWasMoved)\n\t    sraRgnOr(updateRegion, cursorRegion);\n    }\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    if (!sraRgnAnd(updateRegion, cl->requestedRegion) &&\n\t!sendCursorShape && !sendCursorPos) {\n\tsraRgnDestroy(updateRegion);\n\tif (cursorRegion)\n\t    sraRgnDestroy(cursorRegion);\n\tUNLOCK(cl->updateMutex);\n\tUNLOCK(cl->cursorMutex);\n\treturn TRUE;\n    }\n\n    /*\n     * Put up the cursor if any part of it is in updateRegion.\n     */\n\n    if (cursorRegion) {\n\ttmpRegion = sraRgnCreateRgn(cursorRegion);\n\n\tif (sraRgnAnd(tmpRegion, updateRegion)) {\n\t    rfbDrawCursor(cl->screen, &cursorBounds);\n\t    cursorIsDrawn = TRUE;\n\n\t    cl->cursorWasMoved = FALSE;\n\t    cl->cursorWasChanged = FALSE;\n\t    cl->lastDrawnCursorBounds = cursorBounds;\n\n\t    sraRgnOr(cl->modifiedRegion, cursorRegion);\n\t    \n\t    sraRgnOr(updateRegion, cursorRegion);\n\t    sraRgnAnd(updateRegion, cl->requestedRegion);\n\t}\n\n\tsraRgnDestroy(tmpRegion);\n\tsraRgnDestroy(cursorRegion);\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n   /*\n     * Now send the update.\n     */\n\n    cl->rfbFramebufferUpdateMessagesSent++;\n\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            nUpdateRegionRects += (((w-1) / cl->correMaxWidth + 1)\n                                     * ((h-1) / cl->correMaxHeight + 1));\n        }\n\tsraRgnReleaseIterator(i);\n#ifdef HAVE_LIBZ\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n#ifdef HAVE_LIBJPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i);\n#endif\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n#ifdef HAVE_LIBZ\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef HAVE_LIBJPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif /* HAVE_LIBZ */\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n    UNLOCK(cl->cursorMutex);\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto tx_error;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t    goto tx_error;\n    }\n   \n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t    goto tx_error;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader\n                                      + w * (cl->format.bitsPerPixel / 8) * h);\n\n        switch (cl->preferredEncoding) {\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n#ifdef HAVE_LIBZ\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#ifdef HAVE_LIBJPEG\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#endif\n#endif\n#ifdef HAVE_LIBZ\n       case rfbEncodingZRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto tx_error;\n           break;\n#endif\n        }\n    }\n\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\tgoto tx_error;\n\n    if (!rfbSendUpdateBuf(cl))\n\tgoto tx_error;\n\n    sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n    \n    return TRUE;\n\n tx_error:\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n    if (i)\n\tsraRgnReleaseIterator(i);\n\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n\n    return FALSE;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Avoid out-of-bounds memory accesses\n\nThis fixes two critical security vulnerabilities that lead to an\nout-of-bounds memory access with a crafted client framebuffer update\nrequest packet. The dimensions of the update from the packet are checked\nto ensure that they are within the screen dimensions.\n\nThanks to Kevin Chen from the Bitblaze group for the reports in bugs\n641802 and 641803. The CVE identifiers for these vulnerabilities are\nCVE-2011-0904 and CVE-2011-0905."}
{"func": "rfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion, updateCopyRegion, tmpRegion, cursorRegion;\n    sraRect cursorBounds = { 0, 0, 0, 0 };\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool cursorIsDrawn = FALSE;\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      cl->rfbFramebufferUpdateMessagesSent++;\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n      if (!rfbSendNewFBSize(cl, cl->screen->width, cl->screen->height)) {\n        return FALSE;\n      }\n      return rfbSendUpdateBuf(cl);\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    sraRgnOr(updateRegion,cl->copyRegion);\n\n    /*\n     * If the client doesn't support cursor updates, we want to draw\n     * the cursor locally, send the update and then undraw it.\n     * We only want to do this if the cursor has moved/changed or\n     * if it is contained in updateRegion\n     *\n     * We also want to send an update for the region where the cursor\n     * was last drawn, again only if the cursor has moved/changed.\n     */\n\n    LOCK(cl->screen->cursorMutex);\n\n    cursorRegion = NULL;\n    if (cl->enableCursorUpdates) {\n\tsendCursorShape = cl->cursorWasChanged;\n\tsendCursorPos   = cl->cursorWasMoved;\n    } else {\n\tsraRegionPtr lastDrawnCursorRegion;\n\n\tif (rfbGetCursorBounds(cl->screen, &cursorBounds)) {\n\t    cursorRegion = sraRgnCreateRect(cursorBounds.x1, cursorBounds.y1,\n\t\t\t\t\t    cursorBounds.x2, cursorBounds.y2);\n\t}\n\t\n\tlastDrawnCursorRegion = sraRgnCreateRect(cl->lastDrawnCursorBounds.x1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y1,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.x2,\n\t\t\t\t\t\t cl->lastDrawnCursorBounds.y2);\n\n\tif (cursorRegion) {\n\t    sraRgnOr(cursorRegion, lastDrawnCursorRegion);\n\t    sraRgnDestroy(lastDrawnCursorRegion);\n\t} else {\n\t    cursorRegion = lastDrawnCursorRegion;\n\t}\n\n\tif (cl->cursorWasChanged || cl->cursorWasMoved)\n\t    sraRgnOr(updateRegion, cursorRegion);\n    }\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    if (!sraRgnAnd(updateRegion, cl->requestedRegion) &&\n\t!sendCursorShape && !sendCursorPos) {\n\tsraRgnDestroy(updateRegion);\n\tif (cursorRegion)\n\t    sraRgnDestroy(cursorRegion);\n\tUNLOCK(cl->updateMutex);\n\tUNLOCK(cl->cursorMutex);\n\treturn TRUE;\n    }\n\n    /*\n     * Put up the cursor if any part of it is in updateRegion.\n     */\n\n    if (cursorRegion) {\n\ttmpRegion = sraRgnCreateRgn(cursorRegion);\n\n\tif (sraRgnAnd(tmpRegion, updateRegion)) {\n\t    rfbDrawCursor(cl->screen, &cursorBounds);\n\t    cursorIsDrawn = TRUE;\n\n\t    cl->cursorWasMoved = FALSE;\n\t    cl->cursorWasChanged = FALSE;\n\t    cl->lastDrawnCursorBounds = cursorBounds;\n\n\t    sraRgnOr(cl->modifiedRegion, cursorRegion);\n\t    \n\t    sraRgnOr(updateRegion, cursorRegion);\n\t    sraRgnAnd(updateRegion, cl->requestedRegion);\n\t}\n\n\tsraRgnDestroy(tmpRegion);\n\tsraRgnDestroy(cursorRegion);\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n   /*\n     * Now send the update.\n     */\n\n    cl->rfbFramebufferUpdateMessagesSent++;\n\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            nUpdateRegionRects += (((w-1) / cl->correMaxWidth + 1)\n                                     * ((h-1) / cl->correMaxHeight + 1));\n        }\n\tsraRgnReleaseIterator(i);\n#ifdef VINO_HAVE_ZLIB\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n#ifdef VINO_HAVE_JPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i);\n#endif\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n#ifdef VINO_HAVE_ZLIB\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef VINO_HAVE_JPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif /* VINO_HAVE_ZLIB */\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n    UNLOCK(cl->cursorMutex);\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto tx_error;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t    goto tx_error;\n    }\n   \n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t    goto tx_error;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        cl->rfbRawBytesEquivalent += (sz_rfbFramebufferUpdateRectHeader\n                                      + w * (cl->format.bitsPerPixel / 8) * h);\n\n        switch (cl->preferredEncoding) {\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t\tgoto tx_error;\n            break;\n#ifdef VINO_HAVE_ZLIB\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#ifdef VINO_HAVE_JPEG\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t\tgoto tx_error;\n\t    break;\n#endif\n#endif\n#ifdef VINO_HAVE_ZLIB\n       case rfbEncodingZRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto tx_error;\n           break;\n#endif\n        }\n    }\n\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\tgoto tx_error;\n\n    if (!rfbSendUpdateBuf(cl))\n\tgoto tx_error;\n\n    sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n    \n    return TRUE;\n\n tx_error:\n    if (cursorIsDrawn)\n\trfbUndrawCursor(cl->screen, &cursorBounds);\n    if (i)\n\tsraRgnReleaseIterator(i);\n\n    sraRgnDestroy(updateCopyRegion);\n    sraRgnDestroy(updateRegion);\n\n    return FALSE;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Avoid out-of-bounds memory accesses\n\nThis fixes two critical security vulnerabilities that lead to an\nout-of-bounds memory access with a crafted client framebuffer update\nrequest packet. The dimensions of the update from the packet are checked\nto ensure that they are within the screen dimensions.\n\nThanks to Kevin Chen from the Bitblaze group for the reports in bugs\n641802 and 641803. The CVE identifiers for these vulnerabilities are\nCVE-2011-0904 and CVE-2011-0905."}
{"func": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Fix access to freed members of a dead thread\n\n* threads.c: Fix access to freed members of a dead thread. Found\nand fixed by Rodrigo Kumpera <rkumpera@novell.com>\nRef: CVE-2011-0992"}
{"func": "ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) ||\n\t\t\t(type->type == MONO_TYPE_VALUETYPE &&\n\t\t\t\t(!mono_type_get_class (type) ||\n\t\t\t\tmono_type_get_class (type)->has_references))) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array containing references\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}", "target": 1, "cwe": ["CWE-264"], "message": "Allow only primitive types/enums in RuntimeHelpers.InitializeArray ()."}
{"func": "ves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE))\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-362", "CWE-264"], "message": "Disable some of the FastCopy fast paths since they are racy."}
{"func": "void\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Don't use finalization to cleanup dynamic methods.\n\n        * reflection.c: Use a reference queue to cleanup\n        dynamic methods instead of finalization.\n\n        * runtime.c: Shutdown the dynamic method queue\n        before runtime cleanup begins.\n\n        * DynamicMethod.cs: No longer finalizable.\n\n        * icall-def.h: Remove unused dynamic method icall.\n\n        Fixes #660422\n\n    Implement a reference queue API.\n\n        * gc.c: A reference queue allows one to queue\n        callbcks for when objects are collected.\n        It allows for safe cleanup of objects that can\n        only be done when it is effectively collected.\n        The major difference with regular finalization\n        is that the collector makes sure the object\n        was collected - and can't be resurrected.\n\n        * gc-internal.h: Export entrypoints for the\n        new API."}
{"func": "void \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Don't use finalization to cleanup dynamic methods.\n\n        * reflection.c: Use a reference queue to cleanup\n        dynamic methods instead of finalization.\n\n        * runtime.c: Shutdown the dynamic method queue\n        before runtime cleanup begins.\n\n        * DynamicMethod.cs: No longer finalizable.\n\n        * icall-def.h: Remove unused dynamic method icall.\n\n        Fixes #660422\n\n    Implement a reference queue API.\n\n        * gc.c: A reference queue allows one to queue\n        callbcks for when objects are collected.\n        It allows for safe cleanup of objects that can\n        only be done when it is effectively collected.\n        The major difference with regular finalization\n        is that the collector makes sure the object\n        was collected - and can't be resurrected.\n\n        * gc-internal.h: Export entrypoints for the\n        new API."}
{"func": "void \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Don't use finalization to cleanup dynamic methods.\n\n        * reflection.c: Use a reference queue to cleanup\n        dynamic methods instead of finalization.\n\n        * runtime.c: Shutdown the dynamic method queue\n        before runtime cleanup begins.\n\n        * DynamicMethod.cs: No longer finalizable.\n\n        * icall-def.h: Remove unused dynamic method icall.\n\n        Fixes #660422\n\n    Implement a reference queue API.\n\n        * gc.c: A reference queue allows one to queue\n        callbcks for when objects are collected.\n        It allows for safe cleanup of objects that can\n        only be done when it is effectively collected.\n        The major difference with regular finalization\n        is that the collector makes sure the object\n        was collected - and can't be resurrected.\n\n        * gc-internal.h: Export entrypoints for the\n        new API."}
{"func": "mono_runtime_shutdown (void)\n{\n\tmono_domain_foreach (fire_process_exit_event, NULL);\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Don't use finalization to cleanup dynamic methods.\n\n\t* reflection.c: Use a reference queue to cleanup\n\tdynamic methods instead of finalization.\n\n\t* runtime.c: Shutdown the dynamic method queue\n\tbefore runtime cleanup begins.\n\n\t* DynamicMethod.cs: No longer finalizable.\n\n\t* icall-def.h: Remove unused dynamic method icall.\n\n\tFixes #660422"}
{"func": "mono_gc_init (void)\n{\n\tInitializeCriticalSection (&handle_section);\n\tInitializeCriticalSection (&allocator_section);\n\n\tInitializeCriticalSection (&finalizer_mutex);\n\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);\n\n\tmono_gc_base_init ();\n\n\tif (mono_gc_is_disabled ()) {\n\t\tgc_disabled = TRUE;\n\t\treturn;\n\t}\n\t\n\tfinalizer_event = CreateEvent (NULL, FALSE, FALSE, NULL);\n\tpending_done_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tshutdown_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tif (finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL) {\n\t\tg_assert_not_reached ();\n\t}\n#ifdef MONO_HAS_SEMAPHORES\n\tMONO_SEM_INIT (&finalizer_sem, 0);\n#endif\n\n\tgc_thread = mono_thread_create_internal (mono_domain_get (), finalizer_thread, NULL, FALSE);\n\tves_icall_System_Threading_Thread_SetName_internal (gc_thread, mono_string_new (mono_domain_get (), \"Finalizer\"));\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API."}
{"func": "void mono_gc_cleanup (void)\n{\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API."}
{"func": "mono_gc_cleanup (void)\n{\n#ifdef DEBUG\n\tg_message (\"%s: cleaning up finalizer\", __func__);\n#endif\n\n\tif (!gc_disabled) {\n\t\tResetEvent (shutdown_event);\n\t\tfinished = TRUE;\n\t\tif (mono_thread_internal_current () != gc_thread) {\n\t\t\tmono_gc_finalize_notify ();\n\t\t\t/* Finishing the finalizer thread, so wait a little bit... */\n\t\t\t/* MS seems to wait for about 2 seconds */\n\t\t\tif (WaitForSingleObjectEx (shutdown_event, 2000, FALSE) == WAIT_TIMEOUT) {\n\t\t\t\tint ret;\n\n\t\t\t\t/* Set a flag which the finalizer thread can check */\n\t\t\t\tsuspend_finalizers = TRUE;\n\n\t\t\t\t/* Try to abort the thread, in the hope that it is running managed code */\n\t\t\t\tmono_thread_internal_stop (gc_thread);\n\n\t\t\t\t/* Wait for it to stop */\n\t\t\t\tret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);\n\n\t\t\t\tif (ret == WAIT_TIMEOUT) {\n\t\t\t\t\t/* \n\t\t\t\t\t * The finalizer thread refused to die. There is not much we \n\t\t\t\t\t * can do here, since the runtime is shutting down so the \n\t\t\t\t\t * state the finalizer thread depends on will vanish.\n\t\t\t\t\t */\n\t\t\t\t\tg_warning (\"Shutting down finalizer thread timed out.\");\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: On unix, when the above wait returns, the thread \n\t\t\t\t\t * might still be running io-layer code, or pthreads code.\n\t\t\t\t\t */\n\t\t\t\t\tSleep (100);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tgc_thread = NULL;\n#ifdef HAVE_BOEHM_GC\n\t\tGC_finalizer_notifier = NULL;\n#endif\n\t}\n\n\tDeleteCriticalSection (&handle_section);\n\tDeleteCriticalSection (&allocator_section);\n\tDeleteCriticalSection (&finalizer_mutex);\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API."}
{"func": "void mono_gc_init (void)\n{\n\tInitializeCriticalSection (&handle_section);\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API."}
{"func": "finalizer_thread (gpointer unused)\n{\n\twhile (!finished) {\n\t\t/* Wait to be notified that there's at least one\n\t\t * finaliser to run\n\t\t */\n\n\t\tg_assert (mono_domain_get () == mono_get_root_domain ());\n\n#ifdef MONO_HAS_SEMAPHORES\n\t\tMONO_SEM_WAIT (&finalizer_sem);\n#else\n\t\t/* Use alertable=FALSE since we will be asked to exit using the event too */\n\t\tWaitForSingleObjectEx (finalizer_event, INFINITE, FALSE);\n#endif\n\n\t\tmono_console_handle_async_ops ();\n\n#ifndef DISABLE_ATTACH\n\t\tmono_attach_maybe_start ();\n#endif\n\n\t\tif (domains_to_finalize) {\n\t\t\tmono_finalizer_lock ();\n\t\t\tif (domains_to_finalize) {\n\t\t\t\tDomainFinalizationReq *req = domains_to_finalize->data;\n\t\t\t\tdomains_to_finalize = g_slist_remove (domains_to_finalize, req);\n\t\t\t\tmono_finalizer_unlock ();\n\n\t\t\t\tfinalize_domain_objects (req);\n\t\t\t} else {\n\t\t\t\tmono_finalizer_unlock ();\n\t\t\t}\n\t\t}\t\t\t\t\n\n\t\t/* If finished == TRUE, mono_gc_cleanup has been called (from mono_runtime_cleanup),\n\t\t * before the domain is unloaded.\n\t\t */\n\t\tmono_gc_invoke_finalizers ();\n\n\t\tSetEvent (pending_done_event);\n\t}\n\n\tSetEvent (shutdown_event);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399", "CWE-264"], "message": "Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API."}
{"func": "add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\trc = EX_FILEIO;\n\t}\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-20"], "message": "mtab: handle ENOSPC/EFBIG condition properly when altering mtab\n\nIt's possible that when mount.cifs goes to append the mtab that there\nwon't be enough space to do so, and the mntent won't be appended to the\nfile in its entirety.\n\nAdd a my_endmntent routine that will fflush and then fsync the FILE if\nthat succeeds. If either fails then it will truncate the file back to\nits provided size. It will then call endmntent unconditionally.\n\nHave add_mtab call fstat on the opened mtab file in order to get the\nsize of the file before it has been appended. Assuming that that\nsucceeds, use my_endmntent to ensure that the file is not corrupted\nbefore closing it. It's possible that we'll have a small race window\nwhere the mtab is incorrect, but it should be quickly corrected.\n\nThis was reported some time ago as CVE-2011-1678:\n\n    http://openwall.com/lists/oss-security/2011/03/04/9\n\n...and it seems to fix the reproducer that I was able to come up with.\n\nSigned-off-by: Jeff Layton <jlayton@samba.org>\nReviewed-by: Suresh Jayaraman <sjayaraman@suse.de>"}
{"func": "thunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}", "target": 1, "cwe": ["CWE-399", "CWE-134"], "message": "Don't interpret file display names as format strings\n\nThis avoids a segfault when copying/moving files containing \"%\" formatters\nin their name.\n\nSigned-off-by: Jannis Pohlmann <jannis@xfce.org>"}
{"func": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n\n    sector = ldq_p(&req->out->sector);\n\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1, "cwe": ["CWE-119"], "message": "virtio-blk: fail unaligned requests\n\nLike all block drivers virtio-blk should not allow small than block size\ngranularity access.  But given that the protocol specifies a\nbyte unit length field we currently accept such requests, which cause\nqemu to abort() in lower layers.  Add checks to the main read and\nwrite handlers to catch them early.\n\nReported-by: Conor Murphy <conor_murphy_virt@hotmail.com>\nTested-by: Conor Murphy <conor_murphy_virt@hotmail.com>\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n\n    sector = ldq_p(&req->out->sector);\n\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n\n    mrb->num_writes++;\n}", "target": 1, "cwe": ["CWE-119"], "message": "virtio-blk: fail unaligned requests\n\nLike all block drivers virtio-blk should not allow small than block size\ngranularity access.  But given that the protocol specifies a\nbyte unit length field we currently accept such requests, which cause\nqemu to abort() in lower layers.  Add checks to the main read and\nwrite handlers to catch them early.\n\nReported-by: Conor Murphy <conor_murphy_virt@hotmail.com>\nTested-by: Conor Murphy <conor_murphy_virt@hotmail.com>\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t/* The generic routines can't deal with 2 level gatt's */\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: could wrap */\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-190"], "message": "agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>"}
{"func": "int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tsize_t i;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t/* The generic routines know nothing of memory types */\n\t\treturn -EINVAL;\n\t}\n\n\t/* AK: bogus, should encode addresses > 4GB */\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\twritel(bridge->scratch_page, bridge->gatt_table+i);\n\t}\n\treadl(bridge->gatt_table+i-1);\t/* PCI Posting. */\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-190"], "message": "agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>"}
{"func": "static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"Backend is marked offline, retry later!\\n\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        /* password caching failures are not fatal errors */\n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_CMD_RENEW:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"unsupported PAM command [%d].\\n\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            DEBUG(0, (\"password not available, offline auth may not work.\\n\"));\n            ret = EOK; /* password caching failures are not fatal errors */\n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"Failed to cache password, offline auth may not work.\"\n                      \" (%d)[%s]!?\\n\", ret, strerror(ret)));\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}", "target": 1, "cwe": ["CWE-287"], "message": "Fix bad password caching when using automatic TGT renewal\n\nFixes CVE-2011-1758, https://fedorahosted.org/sssd/ticket/856"}
{"func": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1, "cwe": [], "message": "gre: fix netns vs proto registration ordering\n\nGRE protocol receive hook can be called right after protocol addition is done.\nIf netns stuff is not yet initialized, we're going to oops in\nnet_generic().\n\nThis is remotely oopsable if ip_gre is compiled as module and packet\ncomes at unfortunate moment of module loading.\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1, "cwe": [], "message": "gre: fix netns vs proto registration ordering\n\nGRE protocol receive hook can be called right after protocol addition is done.\nIf netns stuff is not yet initialized, we're going to oops in\nnet_generic().\n\nThis is remotely oopsable if ip_gre is compiled as module and packet\ncomes at unfortunate moment of module loading.\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\n\treturn err;\n}", "target": 1, "cwe": [], "message": "tunnels: fix netns vs proto registration ordering\n\nSame stuff as in ip_gre patch: receive hook can be called before netns\nsetup is done, oopsing in net_generic().\n\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void dkim_exim_verify_finish(void) {\n  pdkim_signature *sig = NULL;\n  int dkim_signers_size = 0;\n  int dkim_signers_ptr = 0;\n  dkim_signers = NULL;\n\n  /* Delete eventual previous signature chain */\n  dkim_signatures = NULL;\n\n  /* If we have arrived here with dkim_collect_input == FALSE, it\n     means there was a processing error somewhere along the way.\n     Log the incident and disable futher verification. */\n  if (!dkim_collect_input) {\n    log_write(0, LOG_MAIN, \"DKIM: Error while running this message through validation, disabling signature verification.\");\n    dkim_disable_verify = TRUE;\n    return;\n  }\n  dkim_collect_input = FALSE;\n\n  /* Finish DKIM operation and fetch link to signatures chain */\n  if (pdkim_feed_finish(dkim_verify_ctx,&dkim_signatures) != PDKIM_OK) return;\n\n  sig = dkim_signatures;\n  while (sig != NULL) {\n    int size = 0;\n    int ptr = 0;\n    /* Log a line for each signature */\n    uschar *logmsg = string_append(NULL, &size, &ptr, 5,\n\n      string_sprintf( \"DKIM: d=%s s=%s c=%s/%s a=%s \",\n                      sig->domain,\n                      sig->selector,\n                      (sig->canon_headers == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->canon_body    == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->algo          == PDKIM_ALGO_RSA_SHA256)?\"rsa-sha256\":\"rsa-sha1\"\n                    ),\n      ((sig->identity != NULL)?\n        string_sprintf(\"i=%s \", sig->identity)\n        :\n        US\"\"\n      ),\n      ((sig->created > 0)?\n        string_sprintf(\"t=%lu \", sig->created)\n        :\n        US\"\"\n      ),\n      ((sig->expires > 0)?\n        string_sprintf(\"x=%lu \", sig->expires)\n        :\n        US\"\"\n      ),\n      ((sig->bodylength > -1)?\n        string_sprintf(\"l=%lu \", sig->bodylength)\n        :\n        US\"\"\n      )\n    );\n\n    switch(sig->verify_status) {\n      case PDKIM_VERIFY_NONE:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[not verified]\");\n      break;\n      case PDKIM_VERIFY_INVALID:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[invalid - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"public key record (currently?) unavailable]\");\n          break;\n          case PDKIM_VERIFY_INVALID_BUFFER_SIZE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"overlong public key record]\");\n          break;\n          case PDKIM_VERIFY_INVALID_PUBKEY_PARSING:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"syntax error in public key record]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified problem]\");\n        }\n      break;\n      case PDKIM_VERIFY_FAIL:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification failed - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_FAIL_BODY:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"body hash mismatch (body probably modified in transit)]\");\n          break;\n          case PDKIM_VERIFY_FAIL_MESSAGE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"signature did not verify (headers probably modified in transit)]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified reason]\");\n        }\n      break;\n      case PDKIM_VERIFY_PASS:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification succeeded]\");\n      break;\n    }\n\n    logmsg[ptr] = '\\0';\n    log_write(0, LOG_MAIN, (char *)logmsg);\n\n    /* Build a colon-separated list of signing domains (and identities, if present) in dkim_signers */\n    dkim_signers = string_append(dkim_signers,\n                                 &dkim_signers_size,\n                                 &dkim_signers_ptr,\n                                 2,\n                                 sig->domain,\n                                 \":\"\n                                );\n\n    if (sig->identity != NULL) {\n      dkim_signers = string_append(dkim_signers,\n                                   &dkim_signers_size,\n                                   &dkim_signers_ptr,\n                                   2,\n                                   sig->identity,\n                                   \":\"\n                                  );\n    }\n\n    /* Process next signature */\n    sig = sig->next;\n  }\n\n  /* NULL-terminate and chop the last colon from the domain list */\n  if (dkim_signers != NULL) {\n    dkim_signers[dkim_signers_ptr] = '\\0';\n    if (Ustrlen(dkim_signers) > 0)\n      dkim_signers[Ustrlen(dkim_signers)-1] = '\\0';\n  }\n}", "target": 1, "cwe": ["CWE-134"], "message": "Bugzilla #1106: Don't pass DKIM compound log line as format string"}
{"func": "read_channel_data (FILE       *f,\n                   PSPimage   *ia,\n                   guchar    **pixels,\n                   guint       bytespp,\n                   guint       offset,\n                   GimpDrawable  *drawable,\n                   guint32     compressed_len)\n{\n  gint i, y, width = drawable->width, height = drawable->height;\n  gint npixels = width * height;\n  guchar *buf, *p, *q, *endq;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      q = pixels[0] + offset;\n      endq = q + npixels * bytespp;\n      buf = g_malloc (127);\n      while (q < endq)\n        {\n          p = buf;\n          fread (&runcount, 1, 1, f);\n          if (runcount > 128)\n            {\n              runcount -= 128;\n              fread (&byte, 1, 1, f);\n              memset (buf, byte, runcount);\n            }\n          else\n            fread (buf, runcount, 1, f);\n          if (bytespp == 1)\n            {\n              memmove (q, buf, runcount);\n              q += runcount;\n            }\n          else\n            {\n              p = buf;\n              for (i = 0; i < runcount; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n        }\n      g_free (buf);\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-787"], "message": "file-psp: fix for bogus input data. Fixes bug #639203"}
{"func": "policy_summarize(smartlist_t *policy)\n{\n  smartlist_t *summary = policy_summary_create();\n  smartlist_t *accepts, *rejects;\n  int i, last, start_prt;\n  size_t accepts_len, rejects_len, shorter_len, final_size;\n  char *accepts_str = NULL, *rejects_str = NULL, *shorter_str, *result;\n  const char *prefix;\n\n  tor_assert(policy);\n\n  /* Create the summary list */\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    policy_summary_add_item(summary, p);\n  });\n\n  /* Now create two lists of strings, one for accepted and one\n   * for rejected ports.  We take care to merge ranges so that\n   * we avoid getting stuff like \"1-4,5-9,10\", instead we want\n   * \"1-10\"\n   */\n  i = 0;\n  start_prt = 1;\n  accepts = smartlist_create();\n  rejects = smartlist_create();\n  while (1) {\n    last = i == smartlist_len(summary)-1;\n    if (last ||\n        AT(i)->accepted != AT(i+1)->accepted) {\n      char buf[POLICY_BUF_LEN];\n\n      if (start_prt == AT(i)->prt_max)\n        tor_snprintf(buf, sizeof(buf), \"%d\", start_prt);\n      else\n        tor_snprintf(buf, sizeof(buf), \"%d-%d\", start_prt, AT(i)->prt_max);\n\n      if (AT(i)->accepted)\n        smartlist_add(accepts, tor_strdup(buf));\n      else\n        smartlist_add(rejects, tor_strdup(buf));\n\n      if (last)\n        break;\n\n      start_prt = AT(i+1)->prt_min;\n    };\n    i++;\n  };\n\n  /* Figure out which of the two stringlists will be shorter and use\n   * that to build the result\n   */\n  if (smartlist_len(accepts) == 0) { /* no exits at all */\n    result = tor_strdup(\"reject 1-65535\");\n    goto cleanup;\n  }\n  if (smartlist_len(rejects) == 0) { /* no rejects at all */\n    result = tor_strdup(\"accept 1-65535\");\n    goto cleanup;\n  }\n\n  accepts_str = smartlist_join_strings(accepts, \",\", 0, &accepts_len);\n  rejects_str = smartlist_join_strings(rejects, \",\", 0, &rejects_len);\n\n  if (rejects_len > MAX_EXITPOLICY_SUMMARY_LEN &&\n      accepts_len > MAX_EXITPOLICY_SUMMARY_LEN) {\n    char *c;\n    shorter_str = accepts_str;\n    prefix = \"accept\";\n\n    c = shorter_str + (MAX_EXITPOLICY_SUMMARY_LEN-strlen(prefix)-1);\n    while (*c != ',' && c >= shorter_str)\n      c--;\n    tor_assert(c >= shorter_str);\n    tor_assert(*c == ',');\n    *c = '\\0';\n\n    shorter_len = strlen(shorter_str);\n  } else if (rejects_len < accepts_len) {\n    shorter_str = rejects_str;\n    shorter_len = rejects_len;\n    prefix = \"reject\";\n  } else {\n    shorter_str = accepts_str;\n    shorter_len = accepts_len;\n    prefix = \"accept\";\n  }\n\n  final_size = strlen(prefix)+1+shorter_len+1;\n  tor_assert(final_size <= MAX_EXITPOLICY_SUMMARY_LEN+1);\n  result = tor_malloc(final_size);\n  tor_snprintf(result, final_size, \"%s %s\", prefix, shorter_str);\n\ncleanup:\n  /* cleanup */\n  SMARTLIST_FOREACH(summary, policy_summary_item_t *, s, tor_free(s));\n  smartlist_free(summary);\n\n  tor_free(accepts_str);\n  SMARTLIST_FOREACH(accepts, char *, s, tor_free(s));\n  smartlist_free(accepts);\n\n  tor_free(rejects_str);\n  SMARTLIST_FOREACH(rejects, char *, s, tor_free(s));\n  smartlist_free(rejects);\n\n  return result;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix bounds-checking in policy_summarize\n\nFound by piebeer."}
{"func": "rfbNewTCPOrUDPClient(rfbScreenInfoPtr rfbScreen,\n                     int sock,\n                     rfbBool isUDP)\n{\n    rfbProtocolVersionMsg pv;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr cl,cl_;\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(struct sockaddr_in);\n    rfbProtocolExtension* extension;\n\n    cl = (rfbClientPtr)calloc(sizeof(rfbClientRec),1);\n\n    cl->screen = rfbScreen;\n    cl->sock = sock;\n    cl->viewOnly = FALSE;\n    /* setup pseudo scaling */\n    cl->scaledScreen = rfbScreen;\n    cl->scaledScreen->scaledScreenRefCount++;\n\n    rfbResetStats(cl);\n\n    cl->clientData = NULL;\n    cl->clientGoneHook = rfbDoNothingWithClient;\n\n    if(isUDP) {\n      rfbLog(\" accepted UDP client\\n\");\n    } else {\n      int one=1;\n\n      getpeername(sock, (struct sockaddr *)&addr, &addrlen);\n      cl->host = strdup(inet_ntoa(addr.sin_addr));\n\n      rfbLog(\"  other clients:\\n\");\n      iterator = rfbGetClientIterator(rfbScreen);\n      while ((cl_ = rfbClientIteratorNext(iterator)) != NULL) {\n        rfbLog(\"     %s\\n\",cl_->host);\n      }\n      rfbReleaseClientIterator(iterator);\n\n#ifndef WIN32\n      if (fcntl(sock, F_SETFL, O_NONBLOCK) < 0) {\n\trfbLogPerror(\"fcntl failed\");\n\tclose(sock);\n\treturn NULL;\n      }\n#endif\n\n      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t     (char *)&one, sizeof(one)) < 0) {\n\trfbLogPerror(\"setsockopt failed\");\n\tclose(sock);\n\treturn NULL;\n      }\n\n      FD_SET(sock,&(rfbScreen->allFds));\n\t\trfbScreen->maxFd = max(sock,rfbScreen->maxFd);\n\n      INIT_MUTEX(cl->outputMutex);\n      INIT_MUTEX(cl->refCountMutex);\n      INIT_COND(cl->deleteCond);\n\n      cl->state = RFB_PROTOCOL_VERSION;\n\n      cl->reverseConnection = FALSE;\n      cl->readyForSetColourMapEntries = FALSE;\n      cl->useCopyRect = FALSE;\n      cl->preferredEncoding = -1;\n      cl->correMaxWidth = 48;\n      cl->correMaxHeight = 48;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->zrleData = NULL;\n#endif\n\n      cl->copyRegion = sraRgnCreate();\n      cl->copyDX = 0;\n      cl->copyDY = 0;\n   \n      cl->modifiedRegion =\n\tsraRgnCreateRect(0,0,rfbScreen->width,rfbScreen->height);\n\n      INIT_MUTEX(cl->updateMutex);\n      INIT_COND(cl->updateCond);\n\n      cl->requestedRegion = sraRgnCreate();\n\n      cl->format = cl->screen->serverFormat;\n      cl->translateFn = rfbTranslateNone;\n      cl->translateLookupTable = NULL;\n\n      LOCK(rfbClientListMutex);\n\n      IF_PTHREADS(cl->refCount = 0);\n      cl->next = rfbScreen->clientHead;\n      cl->prev = NULL;\n      if (rfbScreen->clientHead)\n        rfbScreen->clientHead->prev = cl;\n\n      rfbScreen->clientHead = cl;\n      UNLOCK(rfbClientListMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->tightQualityLevel = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      {\n\tint i;\n\tfor (i = 0; i < 4; i++)\n          cl->zsActive[i] = FALSE;\n      }\n#endif\n#endif\n\n      cl->fileTransfer.fd = -1;\n\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->useRichCursorEncoding = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->enableKeyboardLedState = FALSE;\n      cl->enableSupportedMessages = FALSE;\n      cl->enableSupportedEncodings = FALSE;\n      cl->enableServerIdentity = FALSE;\n      cl->lastKeyboardLedState = -1;\n      cl->cursorX = rfbScreen->cursorX;\n      cl->cursorY = rfbScreen->cursorY;\n      cl->useNewFBSize = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->compStreamInited = FALSE;\n      cl->compStream.total_in = 0;\n      cl->compStream.total_out = 0;\n      cl->compStream.zalloc = Z_NULL;\n      cl->compStream.zfree = Z_NULL;\n      cl->compStream.opaque = Z_NULL;\n\n      cl->zlibCompressLevel = 5;\n#endif\n\n      cl->progressiveSliceY = 0;\n\n      cl->extensions = NULL;\n\n      cl->lastPtrX = -1;\n\n      sprintf(pv,rfbProtocolVersionFormat,rfbScreen->protocolMajorVersion, \n              rfbScreen->protocolMinorVersion);\n\n      if (rfbWriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n        rfbLogPerror(\"rfbNewClient: write\");\n        rfbCloseClient(cl);\n\trfbClientConnectionGone(cl);\n        return NULL;\n      }\n    }\n\n    for(extension = rfbGetExtensionIterator(); extension;\n\t    extension=extension->next) {\n\tvoid* data = NULL;\n\t/* if the extension does not have a newClient method, it wants\n\t * to be initialized later. */\n\tif(extension->newClient && extension->newClient(cl, &data))\n\t\trfbEnableExtension(cl, extension, data);\n    }\n    rfbReleaseExtensionIterator();\n\n    switch (cl->screen->newClientHook(cl)) {\n    case RFB_CLIENT_ON_HOLD:\n\t    cl->onHold = TRUE;\n\t    break;\n    case RFB_CLIENT_ACCEPT:\n\t    cl->onHold = FALSE;\n\t    break;\n    case RFB_CLIENT_REFUSE:\n\t    rfbCloseClient(cl);\n\t    rfbClientConnectionGone(cl);\n\t    cl = NULL;\n\t    break;\n    }\n    return cl;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbClientConnectionGone(rfbClientPtr cl)\n{\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    int i;\n#endif\n\n    LOCK(rfbClientListMutex);\n\n    if (cl->prev)\n        cl->prev->next = cl->next;\n    else\n        cl->screen->clientHead = cl->next;\n    if (cl->next)\n        cl->next->prev = cl->prev;\n\n    if(cl->sock>0)\n\tclose(cl->sock);\n\n    if (cl->scaledScreen!=NULL)\n        cl->scaledScreen->scaledScreenRefCount--;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    rfbFreeZrleData(cl);\n#endif\n\n    rfbFreeUltraData(cl);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(cl->screen->backgroundLoop != FALSE) {\n      int i;\n      do {\n\tLOCK(cl->refCountMutex);\n\ti=cl->refCount;\n\tif(i>0)\n\t  WAIT(cl->deleteCond,cl->refCountMutex);\n\tUNLOCK(cl->refCountMutex);\n      } while(i>0);\n    }\n#endif\n\n    UNLOCK(rfbClientListMutex);\n\n    if(cl->sock>=0)\n       FD_CLR(cl->sock,&(cl->screen->allFds));\n\n    cl->clientGoneHook(cl);\n\n    rfbLog(\"Client %s gone\\n\",cl->host);\n    free(cl->host);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    /* Release the compression state structures if any. */\n    if ( cl->compStreamInited ) {\n\tdeflateEnd( &(cl->compStream) );\n    }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    for (i = 0; i < 4; i++) {\n\tif (cl->zsActive[i])\n\t    deflateEnd(&cl->zsStruct[i]);\n    }\n#endif\n#endif\n\n    if (cl->screen->pointerClient == cl)\n        cl->screen->pointerClient = NULL;\n\n    sraRgnDestroy(cl->modifiedRegion);\n    sraRgnDestroy(cl->requestedRegion);\n    sraRgnDestroy(cl->copyRegion);\n\n    if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n    TINI_COND(cl->updateCond);\n    TINI_MUTEX(cl->updateMutex);\n\n    /* make sure outputMutex is unlocked before destroying */\n    LOCK(cl->outputMutex);\n    UNLOCK(cl->outputMutex);\n    TINI_MUTEX(cl->outputMutex);\n\n#ifdef CORBA\n    destroyConnection(cl);\n#endif\n\n    rfbPrintStats(cl);\n\n    free(cl);\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "void rfbTightCleanup(rfbScreenInfoPtr screen)\n{\n  if(tightBeforeBufSize) {\n    free(tightBeforeBuf);\n    tightBeforeBufSize=0;\n  }\n  if(tightAfterBufSize) {\n    free(tightAfterBuf);\n    tightAfterBufSize=0;\n  }\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;           \n            default:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "static void ZRLE_ENCODE (int x, int y, int w, int h,\n\t\t  zrleOutStream* os, void* buf\n                  EXTRA_ARGS\n                  )\n{\n  int ty;\n  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {\n    int tx, th = rfbZRLETileHeight;\n    if (th > y+h-ty) th = y+h-ty;\n    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {\n      int tw = rfbZRLETileWidth;\n      if (tw > x+w-tx) tw = x+w-tx;\n\n      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);\n\n      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,\n\t\t      cl->zywrleLevel, cl->zywrleBuf);\n    }\n  }\n  zrleOutStreamFlush(os);\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbSendBell(rfbScreenInfoPtr rfbScreen)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n    rfbBellMsg b;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl=rfbClientIteratorNext(i))) {\n\tb.type = rfbBell;\n\tif (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n\t    rfbLogPerror(\"rfbSendBell: write\");\n\t    rfbCloseClient(cl);\n\t}\n    }\n    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);\n    rfbReleaseClientIterator(i);\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbBool rfbSendRectEncodingZRLE(rfbClientPtr cl, int x, int y, int w, int h)\n{\n  zrleOutStream* zos;\n  rfbFramebufferUpdateRectHeader rect;\n  rfbZRLEHeader hdr;\n  int i;\n\n  if (cl->preferredEncoding == rfbEncodingZYWRLE) {\n\t  if (cl->tightQualityLevel < 0) {\n\t\t  cl->zywrleLevel = 1;\n\t  } else if (cl->tightQualityLevel < 3) {\n\t\t  cl->zywrleLevel = 3;\n\t  } else if (cl->tightQualityLevel < 6) {\n\t\t  cl->zywrleLevel = 2;\n\t  } else {\n\t\t  cl->zywrleLevel = 1;\n\t  }\n  } else\n\t  cl->zywrleLevel = 0;\n\n  if (!cl->zrleData)\n    cl->zrleData = zrleOutStreamNew();\n  zos = cl->zrleData;\n  zos->in.ptr = zos->in.start;\n  zos->out.ptr = zos->out.start;\n\n  switch (cl->format.bitsPerPixel) {\n\n  case 8:\n    zrleEncode8NE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    break;\n\n  case 16:\n\tif (cl->format.greenMax > 0x1F) {\n\t\tif (cl->format.bigEndian)\n\t\t  zrleEncode16BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t\telse\n\t\t  zrleEncode16LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t} else {\n\t\tif (cl->format.bigEndian)\n\t\t  zrleEncode15BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t\telse\n\t\t  zrleEncode15LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\t}\n    break;\n\n  case 32: {\n    rfbBool fitsInLS3Bytes\n      = ((cl->format.redMax   << cl->format.redShift)   < (1<<24) &&\n         (cl->format.greenMax << cl->format.greenShift) < (1<<24) &&\n         (cl->format.blueMax  << cl->format.blueShift)  < (1<<24));\n\n    rfbBool fitsInMS3Bytes = (cl->format.redShift   > 7  &&\n                           cl->format.greenShift > 7  &&\n                           cl->format.blueShift  > 7);\n\n    if ((fitsInLS3Bytes && !cl->format.bigEndian) ||\n        (fitsInMS3Bytes && cl->format.bigEndian)) {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode24ABE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode24ALE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n    else if ((fitsInLS3Bytes && cl->format.bigEndian) ||\n             (fitsInMS3Bytes && !cl->format.bigEndian)) {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode24BBE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode24BLE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n    else {\n\tif (cl->format.bigEndian)\n\t\tzrleEncode32BE(x, y, w, h, zos, zrleBeforeBuf, cl);\n\telse\n\t\tzrleEncode32LE(x, y, w, h, zos, zrleBeforeBuf, cl);\n    }\n  }\n    break;\n  }\n\n  rfbStatRecordEncodingSent(cl, rfbEncodingZRLE, sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader + ZRLE_BUFFER_LENGTH(&zos->out),\n      + w * (cl->format.bitsPerPixel / 8) * h);\n\n  if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader\n      > UPDATE_BUF_SIZE)\n    {\n      if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n    }\n\n  rect.r.x = Swap16IfLE(x);\n  rect.r.y = Swap16IfLE(y);\n  rect.r.w = Swap16IfLE(w);\n  rect.r.h = Swap16IfLE(h);\n  rect.encoding = Swap32IfLE(cl->preferredEncoding);\n\n  memcpy(cl->updateBuf+cl->ublen, (char *)&rect,\n         sz_rfbFramebufferUpdateRectHeader);\n  cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n  hdr.length = Swap32IfLE(ZRLE_BUFFER_LENGTH(&zos->out));\n\n  memcpy(cl->updateBuf+cl->ublen, (char *)&hdr, sz_rfbZRLEHeader);\n  cl->ublen += sz_rfbZRLEHeader;\n\n  /* copy into updateBuf and send from there.  Maybe should send directly? */\n\n  for (i = 0; i < ZRLE_BUFFER_LENGTH(&zos->out);) {\n\n    int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n    if (i + bytesToCopy > ZRLE_BUFFER_LENGTH(&zos->out)) {\n      bytesToCopy = ZRLE_BUFFER_LENGTH(&zos->out) - i;\n    }\n\n    memcpy(cl->updateBuf+cl->ublen, (uint8_t*)zos->out.start + i, bytesToCopy);\n\n    cl->ublen += bytesToCopy;\n    i += bytesToCopy;\n\n    if (cl->ublen == UPDATE_BUF_SIZE) {\n      if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n    }\n  }\n\n  return TRUE;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length)\n{\n    char *buffer=NULL, *p=NULL;\n    int retval=0;\n    char filename1[MAX_PATH];\n    char filename2[MAX_PATH];\n    char szFileTime[MAX_PATH];\n    struct stat statbuf;\n    uint32_t sizeHtmp=0;\n    int n=0;\n    char timespec[64];\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuff[sz_rfbBlockSize];\n    unsigned long nRawBytes = sz_rfbBlockSize;\n    int nRet = 0;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n        \n    /*\n    rfbLog(\"rfbProcessFileTransfer(%dtype, %dparam, %dsize, %dlen)\\n\", contentType, contentParam, size, length);\n    */\n\n    switch (contentType) {\n    case rfbDirContentRequest:\n        switch (contentParam) {\n        case rfbRDrivesList: /* Client requests the List of Local Drives */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDrivesList:\\n\");\n            */\n            /* Format when filled : \"C:\\<NULL>D:\\<NULL>....Z:\\<NULL><NULL>\n             *\n             * We replace the \"\\\" char following the drive letter and \":\"\n             * with a char corresponding to the type of drive\n             * We obtain something like \"C:l<NULL>D:c<NULL>....Z:n\\<NULL><NULL>\"\n             *  Isn't it ugly ?\n             * DRIVE_FIXED = 'l'     (local?)\n             * DRIVE_REMOVABLE = 'f' (floppy?)\n             * DRIVE_CDROM = 'c'\n             * DRIVE_REMOTE = 'n'\n             */\n            \n            /* in unix, there are no 'drives'  (We could list mount points though)\n             * We fake the root as a \"C:\" for the Winblows users\n             */\n            filename2[0]='C';\n            filename2[1]=':';\n            filename2[2]='l';\n            filename2[3]=0;\n            filename2[4]=0;\n            retval = rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADrivesList, 0, 5, filename2);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n            break;\n        case rfbRDirContent: /* Client requests the content of a directory */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent\\n\");\n            */\n            if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n            retval = rfbSendDirContent(cl, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        break;\n\n    case rfbDirPacket:\n        rfbLog(\"rfbProcessFileTransfer() rfbDirPacket\\n\");\n        break;\n    case rfbFileAcceptHeader:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileAcceptHeader\\n\");\n        break;\n    case rfbCommandReturn:\n        rfbLog(\"rfbProcessFileTransfer() rfbCommandReturn\\n\");\n        break;\n    case rfbFileChecksums:\n        /* Destination file already exists - the viewer sends the checksums */\n        rfbLog(\"rfbProcessFileTransfer() rfbFileChecksums\\n\");\n        break;\n    case rfbFileTransferAccess:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferAccess\\n\");\n        break;\n\n    /*\n     * sending from the server to the viewer\n     */\n\n    case rfbFileTransferRequest:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest:\\n\");\n        */\n        /* add some space to the end of the buffer as we will be adding a timespec to it */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        /* The client requests a File */\n        rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n        cl->fileTransfer.fd=open(filename1, O_RDONLY, 0744);\n\n        /*\n        */\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), cl->fileTransfer.fd);\n        \n        if (cl->fileTransfer.fd!=-1) {\n            if (fstat(cl->fileTransfer.fd, &statbuf)!=0) {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n            }\n            else\n            {\n              /* Add the File Time Stamp to the filename */\n              strftime(timespec, sizeof(timespec), \"%m/%d/%Y %H:%M\",gmtime(&statbuf.st_ctime));\n              buffer=realloc(buffer, length + strlen(timespec) + 2); /* comma, and Null term */\n              if (buffer==NULL) {\n                  rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\", length + strlen(timespec) + 2);\n                  return FALSE;\n              }\n              strcat(buffer,\",\");\n              strcat(buffer, timespec);\n              length = strlen(buffer);\n              if (DB) rfbLog(\"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\", buffer);\n            }\n        }\n\n        /* The viewer supports compression if size==1 */\n        cl->fileTransfer.compressionEnabled = (size==1);\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\")%s\\n\", buffer, filename1, (size==1?\" <Compression Enabled>\":\"\"));\n        */\n\n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : statbuf.st_size), length, buffer);\n\n        if (cl->fileTransfer.fd==-1)\n        {\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = statbuf.st_size;\n        cl->fileTransfer.numPackets = statbuf.st_size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 0;\n        cl->fileTransfer.sending = 0; /* set when we receive a rfbFileHeader: */\n\n        /* TODO: finish 64-bit file size support */\n        sizeHtmp = 0;        \n        if (rfbWriteExact(cl, (char *)&sizeHtmp, 4) < 0) {\n          rfbLogPerror(\"rfbProcessFileTransfer: write\");\n          rfbCloseClient(cl);\n          if (buffer!=NULL) free(buffer);\n          return FALSE;\n        }\n        break;\n\n    case rfbFileHeader:\n        /* Destination file (viewer side) is ready for reception (size > 0) or not (size = -1) */\n        if (size==-1) {\n            rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (error, aborting)\\n\");\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            return TRUE;\n        }\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (%d bytes of a file)\\n\", size);\n        */\n\n        /* Starts the transfer! */\n        cl->fileTransfer.sending=1;\n        return rfbSendFileTransferChunk(cl);\n        break;\n\n\n    /*\n     * sending from the viewer to the server\n     */\n\n    case rfbFileTransferOffer:\n        /* client is sending a file to us */\n        /* buffer contains full path name (plus FileTime) */\n        /* size contains size of the file */\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n\n        /* Parse the FileTime */\n        p = strrchr(buffer, ',');\n        if (p!=NULL) {\n            *p = '\\0';\n            strcpy(szFileTime, p+1);\n        } else\n            szFileTime[0]=0;\n\n\n\n        /* Need to read in sizeHtmp */\n        if ((n = rfbReadExact(cl, (char *)&sizeHtmp, 4)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessFileTransfer: read sizeHtmp\");\n            rfbCloseClient(cl);\n            /* NOTE: don't forget to free(buffer) if you return early! */\n            if (buffer!=NULL) free(buffer);\n            return FALSE;\n        }\n        sizeHtmp = Swap32IfLE(sizeHtmp);\n        \n        rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n\n        /* If the file exists... We can send a rfbFileChecksums back to the client before we send an rfbFileAcceptHeader */\n        /* TODO: Delta Transfer */\n\n        cl->fileTransfer.fd=open(filename1, O_CREAT|O_WRONLY|O_TRUNC, 0744);\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), (cl->fileTransfer.fd==-1?strerror(errno):\"\"), cl->fileTransfer.fd);\n        /*\n        */\n        \n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileAcceptHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : 0), length, buffer);\n        if (cl->fileTransfer.fd==-1) {\n            free(buffer);\n            return retval;\n        }\n        \n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = size;\n        cl->fileTransfer.numPackets = size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 1;\n        cl->fileTransfer.sending = 0;\n        break;\n\n    case rfbFilePacket:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFilePacket:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        if (cl->fileTransfer.fd!=-1) {\n            /* buffer contains the contents of the file */\n            if (size==0)\n                retval=write(cl->fileTransfer.fd, buffer, length);\n            else\n            {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                /* compressed packet */\n                nRet = uncompress(compBuff,&nRawBytes,(const unsigned char*)buffer, length);\n                retval=write(cl->fileTransfer.fd, compBuff, nRawBytes);\n#else\n                /* Write the file out as received... */\n                retval=write(cl->fileTransfer.fd, buffer, length);\n#endif\n            }\n            if (retval==-1)\n            {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n            }\n        }\n        break;\n\n    case rfbEndOfFile:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbEndOfFile\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n            close(cl->fileTransfer.fd);\n        cl->fileTransfer.fd=-1;\n        cl->fileTransfer.sending   = 0;\n        cl->fileTransfer.receiving = 0;\n        break;\n\n    case rfbAbortFileTransfer:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbAbortFileTransfer\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n        {\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            cl->fileTransfer.sending   = 0;\n            cl->fileTransfer.receiving = 0;\n        }\n        else\n        {\n            /* We use this message for FileTransfer rights (<=RC18 versions)\n             * The client asks for FileTransfer permission\n             */\n            if (contentParam == 0)\n            {\n                rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\\n\");\n                /* Old method for FileTransfer handshake perimssion (<=RC18) (Deny it)*/\n                return rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, -1, 0, \"\");\n            }\n            /* New method is allowed */\n            if (cl->screen->getFileTransferPermission!=NULL)\n            {\n                if (cl->screen->getFileTransferPermission(cl)==TRUE)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* Deny */\n                }\n            }\n            else\n            {\n                if (cl->screen->permitFileTransfer)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED by default!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* DEFAULT: DENY (for security) */\n                }\n                \n            }\n        }\n        break;\n\n\n    case rfbCommand:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbCommand:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        switch (contentParam) {\n        case rfbCDirCreate:  /* Client requests the creation of a directory */\n            rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n            retval = mkdir(filename1, 0755);\n            if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, (retval==-1?\"Failed\":\"Success\"));\n            /*\n            */\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbADirCreate, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileDelete: /* Client requests the deletion of a file */\n            rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n            if (stat(filename1,&statbuf)==0)\n            {\n                if (S_ISDIR(statbuf.st_mode))\n                    retval = rmdir(filename1);\n                else\n                    retval = unlink(filename1);\n            }\n            else retval=-1;\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileDelete, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileRename: /* Client requests the Renaming of a file/directory */\n            p = strrchr(buffer, '*');\n            if (p != NULL)\n            {\n                /* Split into 2 filenames ('*' is a seperator) */\n                *p = '\\0';\n                rfbFilenameTranslate2UNIX(cl, buffer, filename1);\n                rfbFilenameTranslate2UNIX(cl, p+1,    filename2);\n                retval = rename(filename1,filename2);\n                if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\\\"%s\\\"->\\\"%s\\\" -->> \\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, p+1, filename2, (retval==-1?\"Failed\":\"Success\"));\n                /*\n                */\n                /* Restore the buffer so the reply is good */\n                *p = '*';\n                retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileRename, retval, length, buffer);\n                if (buffer!=NULL) free(buffer);\n                return retval;\n            }\n            break;\n        }\n    \n        break;\n    }\n\n    /* NOTE: don't forget to free(buffer) if you return early! */\n    if (buffer!=NULL) free(buffer);\n    return TRUE;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "clientOutput(void *data)\n{\n    rfbClientPtr cl = (rfbClientPtr)data;\n    rfbBool haveUpdate;\n    sraRegion* updateRegion;\n\n    while (1) {\n        haveUpdate = false;\n        while (!haveUpdate) {\n            if (cl->sock == -1) {\n                /* Client has disconnected. */\n                return NULL;\n            }\n\t    LOCK(cl->updateMutex);\n\t    haveUpdate = FB_UPDATE_PENDING(cl);\n\t    if(!haveUpdate) {\n\t\tupdateRegion = sraRgnCreateRgn(cl->modifiedRegion);\n\t\thaveUpdate = sraRgnAnd(updateRegion,cl->requestedRegion);\n\t\tsraRgnDestroy(updateRegion);\n\t    }\n\n            if (!haveUpdate) {\n                WAIT(cl->updateCond, cl->updateMutex);\n            }\n\t    UNLOCK(cl->updateMutex);\n        }\n        \n        /* OK, now, to save bandwidth, wait a little while for more\n           updates to come along. */\n        usleep(cl->screen->deferUpdateTime * 1000);\n\n        /* Now, get the region we're going to update, and remove\n           it from cl->modifiedRegion _before_ we send the update.\n           That way, if anything that overlaps the region we're sending\n           is updated, we'll be sure to do another update later. */\n        LOCK(cl->updateMutex);\n\tupdateRegion = sraRgnCreateRgn(cl->modifiedRegion);\n        UNLOCK(cl->updateMutex);\n\n        /* Now actually send the update. */\n\trfbIncrClientRef(cl);\n        rfbSendFramebufferUpdate(cl, updateRegion);\n\trfbDecrClientRef(cl);\n\n\tsraRgnDestroy(updateRegion);\n    }\n\n    /* Not reached. */\n    return NULL;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "void ZRLE_ENCODE_TILE(PIXEL_T* data, int w, int h, zrleOutStream* os,\n\tint zywrle_level, int *zywrleBuf)\n{\n  /* First find the palette and the number of runs */\n\n  zrlePaletteHelper *ph;\n\n  int runs = 0;\n  int singlePixels = 0;\n\n  rfbBool useRle;\n  rfbBool usePalette;\n\n  int estimatedBytes;\n  int plainRleBytes;\n  int i;\n\n  PIXEL_T* ptr = data;\n  PIXEL_T* end = ptr + h * w;\n  *end = ~*(end-1); /* one past the end is different so the while loop ends */\n\n  ph = &paletteHelper;\n  zrlePaletteHelperInit(ph);\n\n  while (ptr < end) {\n    PIXEL_T pix = *ptr;\n    if (*++ptr != pix) {\n      singlePixels++;\n    } else {\n      while (*++ptr == pix) ;\n      runs++;\n    }\n    zrlePaletteHelperInsert(ph, pix);\n  }\n\n  /* Solid tile is a special case */\n\n  if (ph->size == 1) {\n    zrleOutStreamWriteU8(os, 1);\n    zrleOutStreamWRITE_PIXEL(os, ph->palette[0]);\n    return;\n  }\n\n  /* Try to work out whether to use RLE and/or a palette.  We do this by\n     estimating the number of bytes which will be generated and picking the\n     method which results in the fewest bytes.  Of course this may not result\n     in the fewest bytes after compression... */\n\n  useRle = FALSE;\n  usePalette = FALSE;\n\n  estimatedBytes = w * h * (BPPOUT/8); /* start assuming raw */\n\n#if BPP!=8\n  if (zywrle_level > 0 && !(zywrle_level & 0x80))\n\t  estimatedBytes >>= zywrle_level;\n#endif\n\n  plainRleBytes = ((BPPOUT/8)+1) * (runs + singlePixels);\n\n  if (plainRleBytes < estimatedBytes) {\n    useRle = TRUE;\n    estimatedBytes = plainRleBytes;\n  }\n\n  if (ph->size < 128) {\n    int paletteRleBytes = (BPPOUT/8) * ph->size + 2 * runs + singlePixels;\n\n    if (paletteRleBytes < estimatedBytes) {\n      useRle = TRUE;\n      usePalette = TRUE;\n      estimatedBytes = paletteRleBytes;\n    }\n\n    if (ph->size < 17) {\n      int packedBytes = ((BPPOUT/8) * ph->size +\n                         w * h * bitsPerPackedPixel[ph->size-1] / 8);\n\n      if (packedBytes < estimatedBytes) {\n        useRle = FALSE;\n        usePalette = TRUE;\n        estimatedBytes = packedBytes;\n      }\n    }\n  }\n\n  if (!usePalette) ph->size = 0;\n\n  zrleOutStreamWriteU8(os, (useRle ? 128 : 0) | ph->size);\n\n  for (i = 0; i < ph->size; i++) {\n    zrleOutStreamWRITE_PIXEL(os, ph->palette[i]);\n  }\n\n  if (useRle) {\n\n    PIXEL_T* ptr = data;\n    PIXEL_T* end = ptr + w * h;\n    PIXEL_T* runStart;\n    PIXEL_T pix;\n    while (ptr < end) {\n      int len;\n      runStart = ptr;\n      pix = *ptr++;\n      while (*ptr == pix && ptr < end)\n        ptr++;\n      len = ptr - runStart;\n      if (len <= 2 && usePalette) {\n        int index = zrlePaletteHelperLookup(ph, pix);\n        if (len == 2)\n          zrleOutStreamWriteU8(os, index);\n        zrleOutStreamWriteU8(os, index);\n        continue;\n      }\n      if (usePalette) {\n        int index = zrlePaletteHelperLookup(ph, pix);\n        zrleOutStreamWriteU8(os, index | 128);\n      } else {\n        zrleOutStreamWRITE_PIXEL(os, pix);\n      }\n      len -= 1;\n      while (len >= 255) {\n        zrleOutStreamWriteU8(os, 255);\n        len -= 255;\n      }\n      zrleOutStreamWriteU8(os, len);\n    }\n\n  } else {\n\n    /* no RLE */\n\n    if (usePalette) {\n      int bppp;\n      PIXEL_T* ptr = data;\n\n      /* packed pixels */\n\n      assert (ph->size < 17);\n\n      bppp = bitsPerPackedPixel[ph->size-1];\n\n      for (i = 0; i < h; i++) {\n        zrle_U8 nbits = 0;\n        zrle_U8 byte = 0;\n\n        PIXEL_T* eol = ptr + w;\n\n        while (ptr < eol) {\n          PIXEL_T pix = *ptr++;\n          zrle_U8 index = zrlePaletteHelperLookup(ph, pix);\n          byte = (byte << bppp) | index;\n          nbits += bppp;\n          if (nbits >= 8) {\n            zrleOutStreamWriteU8(os, byte);\n            nbits = 0;\n          }\n        }\n        if (nbits > 0) {\n          byte <<= 8 - nbits;\n          zrleOutStreamWriteU8(os, byte);\n        }\n      }\n    } else {\n\n      /* raw */\n\n#if BPP!=8\n      if (zywrle_level > 0 && !(zywrle_level & 0x80)) {\n        ZYWRLE_ANALYZE(data, data, w, h, w, zywrle_level, zywrleBuf);\n\tZRLE_ENCODE_TILE(data, w, h, os, zywrle_level | 0x80, zywrleBuf);\n      }\n      else\n#endif\n      {\n#ifdef CPIXEL\n        PIXEL_T *ptr;\n        for (ptr = data; ptr < data+w*h; ptr++)\n          zrleOutStreamWRITE_PIXEL(os, *ptr);\n#else\n        zrleOutStreamWriteBytes(os, (zrle_U8 *)data, w*h*(BPP/8));\n#endif\n      }\n    }\n  }\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbSendAuthCaps(rfbClientPtr cl)\n{\n    rfbAuthenticationCapsMsg caps;\n    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];\n    int count = 0;\n    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);\n\n    rfbLog(\"tightvnc-filetransfer/rfbSendAuthCaps\\n\");\n\n    if(rtcp == NULL)\n\treturn;\n\n    if (cl->screen->authPasswdData && !cl->reverseConnection) {\n\t/* chk if this condition is valid or not. */\n\t    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);\n\t    rtcp->authCaps[count++] = rfbAuthVNC;\n    }\n\n    rtcp->nAuthCaps = count;\n    caps.nAuthTypes = Swap32IfLE((uint32_t)count);\n    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {\n\trfbLogPerror(\"rfbSendAuthCaps: write\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n\n    if (count) {\n\tif (rfbWriteExact(cl, (char *)&caplist[0],\n\t\t       count * sz_rfbCapabilityInfo) < 0) {\n\t    rfbLogPerror(\"rfbSendAuthCaps: write\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\t/* Dispatch client input to rfbProcessClientAuthType. */\n\t/* Call the function for authentication from here */\n\trfbProcessClientAuthType(cl);\n    } else {\n\t/* Dispatch client input to rfbProcessClientInitMessage. */\n\tcl->state = RFB_INITIALISATION;\n    }\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "void rfbFreeZrleData(rfbClientPtr cl)\n{\n  if (cl->zrleData)\n    zrleOutStreamFree(cl->zrleData);\n  cl->zrleData = NULL;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, char *buffer)\n{\n    rfbFileTransferMsg ft;\n    ft.type = rfbFileTransfer;\n    ft.contentType = contentType;\n    ft.contentParam = contentParam;\n    ft.pad          = 0; /* UltraVNC did not Swap16LE(ft.contentParam) (Looks like it might be BigEndian) */\n    ft.size         = Swap32IfLE(size);\n    ft.length       = Swap32IfLE(length);\n    \n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n    /*\n    rfbLog(\"rfbSendFileTransferMessage( %dtype, %dparam, %dsize, %dlen, %p)\\n\", contentType, contentParam, size, length, buffer);\n    */\n    if (rfbWriteExact(cl, (char *)&ft, sz_rfbFileTransferMsg) < 0) {\n        rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if (length>0)\n    {\n        if (rfbWriteExact(cl, buffer, length) < 0) {\n            rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n\n    rfbStatRecordMessageSent(cl, rfbFileTransfer, sz_rfbFileTransferMsg+length, sz_rfbFileTransferMsg+length);\n\n    return TRUE;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbProcessClientAuthType(rfbClientPtr cl)\n{\n    uint32_t auth_type;\n    int n, i;\n    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);\n\n    rfbLog(\"tightvnc-filetransfer/rfbProcessClientAuthType\\n\");\n\n    if(rtcp == NULL)\n\treturn;\n\n    /* Read authentication type selected by the client. */\n    n = rfbReadExact(cl, (char *)&auth_type, sizeof(auth_type));\n    if (n <= 0) {\n\tif (n == 0)\n\t    rfbLog(\"rfbProcessClientAuthType: client gone\\n\");\n\telse\n\t    rfbLogPerror(\"rfbProcessClientAuthType: read\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n    auth_type = Swap32IfLE(auth_type);\n\n    /* Make sure it was present in the list sent by the server. */\n    for (i = 0; i < rtcp->nAuthCaps; i++) {\n\tif (auth_type == rtcp->authCaps[i])\n\t    break;\n    }\n    if (i >= rtcp->nAuthCaps) {\n\trfbLog(\"rfbProcessClientAuthType: \"\n\t       \"wrong authentication type requested\\n\");\n\trfbCloseClient(cl);\n\treturn;\n    }\n\n    switch (auth_type) {\n    case rfbAuthNone:\n\t/* Dispatch client input to rfbProcessClientInitMessage. */\n\tcl->state = RFB_INITIALISATION;\n\tbreak;\n    case rfbAuthVNC:\n\trfbVncAuthSendChallenge(cl);\n\tbreak;\n    default:\n\trfbLog(\"rfbProcessClientAuthType: unknown authentication scheme\\n\");\n\trfbCloseClient(cl);\n    }\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "rfbSendSetColourMapEntries(rfbClientPtr cl,\n                           int firstColour,\n                           int nColours)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    char *wbuf = buf;\n    rfbSetColourMapEntriesMsg *scme;\n    uint16_t *rgb;\n    rfbColourMap* cm = &cl->screen->colourMap;\n    int i, len;\n\n    if (nColours > 256) {\n\t/* some rare hardware has, e.g., 4096 colors cells: PseudoColor:12 */\n    \twbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);\n    }\n\n    scme = (rfbSetColourMapEntriesMsg *)wbuf;\n    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);\n\n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(firstColour);\n    scme->nColours = Swap16IfLE(nColours);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    for (i = 0; i < nColours; i++) {\n      if(i<(int)cm->count) {\n\tif(cm->is16) {\n\t  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);\n\t} else {\n\t  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);\n\t}\n      }\n    }\n\n    len += nColours * 3 * 2;\n\n    if (rfbWriteExact(cl, wbuf, len) < 0) {\n\trfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n\trfbCloseClient(cl);\n        if (wbuf != buf) free(wbuf);\n\treturn FALSE;\n    }\n\n    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);\n    if (wbuf != buf) free(wbuf);\n    return TRUE;\n}", "target": 1, "cwe": [], "message": "Thread safety for zrle, zlib, tight.\nProposed tight security type fix for debian bug 517422."}
{"func": "xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n    int i;\n\n\n    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||\n        (ns->type != XML_NAMESPACE_DECL) ||\n\t(node->type != XML_ELEMENT_NODE))\n\treturn;\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * prevent duplicates\n     */\n    for (i = 0;i < cur->nodeNr;i++) {\n        if ((cur->nodeTab[i] != NULL) &&\n\t    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n\t    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n\t    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n\t    return;\n    }\n\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds"}
{"func": "xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {\n    int i, j, initNr, skip;\n    xmlNodePtr n1, n2;\n\n    if (val2 == NULL) return(val1);\n    if (val1 == NULL) {\n\tval1 = xmlXPathNodeSetCreate(NULL);\n    if (val1 == NULL)\n        return (NULL);\n#if 0\n\t/*\n\t* TODO: The optimization won't work in every case, since\n\t*  those nasty namespace nodes need to be added with\n\t*  xmlXPathNodeSetDupNs() to the set; thus a pure\n\t*  memcpy is not possible.\n\t*  If there was a flag on the nodesetval, indicating that\n\t*  some temporary nodes are in, that would be helpfull.\n\t*/\n\t/*\n\t* Optimization: Create an equally sized node-set\n\t* and memcpy the content.\n\t*/\n\tval1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n\tif (val1 == NULL)\n\t    return(NULL);\n\tif (val2->nodeNr != 0) {\n\t    if (val2->nodeNr == 1)\n\t\t*(val1->nodeTab) = *(val2->nodeTab);\n\t    else {\n\t\tmemcpy(val1->nodeTab, val2->nodeTab,\n\t\t    val2->nodeNr * sizeof(xmlNodePtr));\n\t    }\n\t    val1->nodeNr = val2->nodeNr;\n\t}\n\treturn(val1);\n#endif\n    }\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    initNr = val1->nodeNr;\n\n    for (i = 0;i < val2->nodeNr;i++) {\n\tn2 = val2->nodeTab[i];\n\t/*\n\t * check against duplicates\n\t */\n\tskip = 0;\n\tfor (j = 0; j < initNr; j++) {\n\t    n1 = val1->nodeTab[j];\n\t    if (n1 == n2) {\n\t\tskip = 1;\n\t\tbreak;\n\t    } else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t       (n2->type == XML_NAMESPACE_DECL)) {\n\t\tif ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t{\n\t\t    skip = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (skip)\n\t    continue;\n\n\t/*\n\t * grow the nodeTab if needed\n\t */\n\tif (val1->nodeMax == 0) {\n\t    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t\t    sizeof(xmlNodePtr));\n\t    if (val1->nodeTab == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    memset(val1->nodeTab, 0 ,\n\t\t   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t    val1->nodeMax = XML_NODESET_DEFAULT;\n\t} else if (val1->nodeNr == val1->nodeMax) {\n\t    xmlNodePtr *temp;\n\n\t    val1->nodeMax *= 2;\n\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\t    if (temp == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    val1->nodeTab = temp;\n\t}\n\tif (n2->type == XML_NAMESPACE_DECL) {\n\t    xmlNsPtr ns = (xmlNsPtr) n2;\n\n\t    val1->nodeTab[val1->nodeNr++] =\n\t\txmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t} else\n\t    val1->nodeTab[val1->nodeNr++] = n2;\n    }\n\n    return(val1);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds"}
{"func": "xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n    if ((cur == NULL) || (val == NULL)) return;\n\n#if 0\n    if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))\n\treturn;\t/* an XSLT fake node */\n#endif\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n\txmlNsPtr ns = (xmlNsPtr) val;\n\n\tcur->nodeTab[cur->nodeNr++] =\n\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n\tcur->nodeTab[cur->nodeNr++] = val;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds"}
{"func": "xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t\t    int hasNullEntries)\n{\n    if (set2 == NULL)\n\treturn(set1);\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i;\n\txmlNodePtr n2;\n\n\tif (set1 == NULL)\n\t    set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    set1->nodeTab[set1->nodeNr++] = n2;\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds"}
{"func": "xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t     int hasNullEntries)\n{\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i, j, initNbSet1;\n\txmlNodePtr n1, n2;\n\n\tif (set1 == NULL)\n            set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tinitNbSet1 = set1->nodeNr;\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    /*\n\t    * Skip duplicates.\n\t    */\n\t    for (j = 0; j < initNbSet1; j++) {\n\t\tn1 = set1->nodeTab[j];\n\t\tif (n1 == n2) {\n\t\t    goto skip_node;\n\t\t} else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t    (n2->type == XML_NAMESPACE_DECL))\n\t\t{\n\t\t    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t\t(xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t    {\n\t\t\t/*\n\t\t\t* Free the namespace node.\n\t\t\t*/\n\t\t\tset2->nodeTab[i] = NULL;\n\t\t\txmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n\t\t\tgoto skip_node;\n\t\t    }\n\t\t}\n\t    }\n\t    /*\n\t    * grow the nodeTab if needed\n\t    */\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    if (n2->type == XML_NAMESPACE_DECL) {\n\t\txmlNsPtr ns = (xmlNsPtr) n2;\n\n\t\tset1->nodeTab[set1->nodeNr++] =\n\t\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t    } else\n\t\tset1->nodeTab[set1->nodeNr++] = n2;\nskip_node:\n\t    {}\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds"}
{"func": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\tprintk(KERN_ERR \"hfs: invalid btree extent records (0 size).\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-264"], "message": "hfs: fix hfs_find_init() sb->ext_tree NULL ptr oops\n\nClement Lecigne reports a filesystem which causes a kernel oops in\nhfs_find_init() trying to dereference sb->ext_tree which is NULL.\n\nThis proves to be because the filesystem has a corrupted MDB extent\nrecord, where the extents file does not fit into the first three extents\nin the file record (the first blocks).\n\nIn hfs_get_block() when looking up the blocks for the extent file\n(HFS_EXT_CNID), it fails the first blocks special case, and falls\nthrough to the extent code (which ultimately calls hfs_find_init())\nwhich is in the process of being initialised.\n\nHfs avoids this scenario by always having the extents b-tree fitting\ninto the first blocks (the extents B-tree can't have overflow extents).\n\nThe fix is to check at mount time that the B-tree fits into first\nblocks, i.e.  fail if HFS_I(inode)->alloc_blocks >=\nHFS_I(inode)->first_blocks\n\nNote, the existing commit 47f365eb57573 (\"hfs: fix oops on mount with\ncorrupted btree extent records\") becomes subsumed into this as a special\ncase, but only for the extents B-tree (HFS_EXT_CNID), it is perfectly\nacceptable for the catalog B-Tree file to grow beyond three extents,\nwith the remaining extent descriptors in the extents overfow.\n\nThis fixes CVE-2011-2203\n\nReported-by: Clement LECIGNE <clement.lecigne@netasq.com>\nSigned-off-by: Phillip Lougher <plougher@redhat.com>\nCc: Jeff Mahoney <jeffm@suse.com>\nCc: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "gdk_pixbuf__gif_image_load (FILE *file, GError **error)\n{\n\tGifContext *context;\n\tGdkPixbuf *pixbuf;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        if (context == NULL) {\n                g_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                     _(\"Not enough memory to load GIF file\"));\n                return NULL;\n        }\n        \n\tcontext->file = file;\n        context->error = error;\n        context->stop_after_first_frame = TRUE;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error_literal (context->error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                             _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n        }\n        \n        pixbuf = gdk_pixbuf_animation_get_static_image (GDK_PIXBUF_ANIMATION (context->animation));\n\n        if (pixbuf)\n                g_object_ref (pixbuf);\n\n        g_object_unref (context->animation);\n        \n        g_free (context->buf);\n\tg_free (context);\n \n\treturn pixbuf;\n}", "target": 1, "cwe": [], "message": "GIF: Don't return a partially initialized pixbuf structure\n\nIt was found that gdk-pixbuf GIF image loader gdk_pixbuf__gif_image_load()\nroutine did not properly handle certain return values from their subroutines.\nA remote attacker could provide a specially-crafted GIF image, which once\nopened in an application, linked against gdk-pixbuf would lead to gdk-pixbuf\nto return partially initialized pixbuf structure, possibly having huge\nwidth and height, leading to that particular application termination due\nexcessive memory use.\n\nThe CVE identifier of CVE-2011-2485 has been assigned to this issue."}
{"func": "const char *string_of_NPPVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPPVpluginNameString);\n\t_(NPPVpluginDescriptionString);\n\t_(NPPVpluginWindowBool);\n\t_(NPPVpluginTransparentBool);\n\t_(NPPVjavaClass);\n\t_(NPPVpluginWindowSize);\n\t_(NPPVpluginTimerInterval);\n\t_(NPPVpluginScriptableInstance);\n\t_(NPPVpluginScriptableIID);\n\t_(NPPVjavascriptPushCallerBool);\n\t_(NPPVpluginKeepLibraryInMemory);\n\t_(NPPVpluginNeedsXEmbed);\n\t_(NPPVpluginScriptableNPObject);\n\t_(NPPVformValue);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPPVpluginScriptableInstance);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Support all the new variables added"}
{"func": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n\t_(NPNVWindowNPObject);\n\t_(NPNVPluginElementNPObject);\n\t_(NPNVSupportsWindowless);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Support all the new variables added"}
{"func": "g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)\n{\n  D(bug(\"NPN_GetValue instance=%p, variable=%d [%s]\\n\", instance, variable, string_of_NPNVariable(variable)));\n\n  if (!thread_check()) {\n\tnpw_printf(\"WARNING: NPN_GetValue not called from the main thread\\n\");\n\treturn NPERR_INVALID_INSTANCE_ERROR;\n  }\n\n  PluginInstance *plugin = NULL;\n  if (instance)\n\tplugin = PLUGIN_INSTANCE(instance);\n\n  switch (variable) {\n  case NPNVxDisplay:\n\t*(void **)value = x_display;\n\tbreak;\n  case NPNVxtAppContext:\n\t*(void **)value = XtDisplayToApplicationContext(x_display);\n\tbreak;\n  case NPNVToolkit:\n\t*(NPNToolkitType *)value = NPW_TOOLKIT;\n\tbreak;\n#if USE_XPCOM\n  case NPNVserviceManager: {\n\tnsIServiceManager *sm;\n\tint ret = NS_GetServiceManager(&sm);\n\tif (NS_FAILED(ret)) {\n\t  npw_printf(\"WARNING: NS_GetServiceManager failed\\n\");\n\t  return NPERR_GENERIC_ERROR;\n\t}\n\t*(nsIServiceManager **)value = sm;\n\tbreak;\n  }\n  case NPNVDOMWindow:\n  case NPNVDOMElement:\n\tnpw_printf(\"WARNING: %s is not supported by NPN_GetValue()\\n\", string_of_NPNVariable(variable));\n\treturn NPERR_INVALID_PARAM;\n#endif\n  case NPNVnetscapeWindow:\n\tif (plugin == NULL) {\n\t  npw_printf(\"ERROR: NPNVnetscapeWindow requires a non NULL instance\\n\");\n\t  return NPERR_INVALID_INSTANCE_ERROR;\n\t}\n\tif (plugin->browser_toplevel == NULL) {\n\t  GdkNativeWindow netscape_xid = None;\n\t  NPError error = g_NPN_GetValue_real(instance, variable, &netscape_xid);\n\t  if (error != NPERR_NO_ERROR)\n\t\treturn error;\n\t  if (netscape_xid == None)\n\t\treturn NPERR_GENERIC_ERROR;\n\t  plugin->browser_toplevel = gdk_window_foreign_new(netscape_xid);\n\t  if (plugin->browser_toplevel == NULL)\n\t\treturn NPERR_GENERIC_ERROR;\n\t}\n\t*((GdkNativeWindow *)value) = GDK_WINDOW_XWINDOW(plugin->browser_toplevel);\n\tbreak;\n#if ALLOW_WINDOWLESS_PLUGINS\n  case NPNVSupportsWindowless:\n#endif\n  case NPNVSupportsXEmbedBool:\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\treturn g_NPN_GetValue_real(instance, variable, value);\n  default:\n\tswitch (variable & 0xff) {\n\tcase 13: /* NPNVToolkit */\n\t  if (NPW_TOOLKIT == NPNVGtk2) {\n\t\t// Gtk2 does not need to depend on a specific C++ ABI\n\t\t*(NPNToolkitType *)value = NPW_TOOLKIT;\n\t\treturn NPERR_NO_ERROR;\n\t  }\n\t  break;\n\t}\n\tD(bug(\"WARNING: unhandled variable %d (%s) in NPN_GetValue()\\n\", variable, string_of_NPNVariable(variable)));\n\treturn NPERR_INVALID_PARAM;\n  }\n\n  return NPERR_NO_ERROR;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Support all the new variables added"}
{"func": "int rpc_type_of_NPPVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPPVpluginNameString:\n  case NPPVpluginDescriptionString:\n  case NPPVformValue: // byte values of 0 does not appear in the UTF-8 encoding but for U+0000\n\ttype = RPC_TYPE_STRING;\n\tbreak;\n  case NPPVpluginWindowSize:\n  case NPPVpluginTimerInterval:\n\ttype = RPC_TYPE_INT32;\n\tbreak;\n  case NPPVpluginNeedsXEmbed:\n  case NPPVpluginWindowBool:\n  case NPPVpluginTransparentBool:\n  case NPPVjavascriptPushCallerBool:\n  case NPPVpluginKeepLibraryInMemory:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPPVpluginScriptableNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Support all the new variables added"}
{"func": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n  case NPNVisOfflineBool:\n  case NPNVSupportsXEmbedBool:\n  case NPNVSupportsWindowless:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Support all the new variables added"}
{"func": "xmlCharEncFirstLineInt(xmlCharEncodingHandler *handler, xmlBufferPtr out,\n                       xmlBufferPtr in, int len) {\n    int ret = -2;\n    int written;\n    int toconv;\n\n    if (handler == NULL) return(-1);\n    if (out == NULL) return(-1);\n    if (in == NULL) return(-1);\n\n    /* calculate space available */\n    written = out->size - out->use;\n    toconv = in->use;\n    /*\n     * echo '<?xml version=\"1.0\" encoding=\"UCS4\"?>' | wc -c => 38\n     * 45 chars should be sufficient to reach the end of the encoding\n     * declaration without going too far inside the document content.\n     * on UTF-16 this means 90bytes, on UCS4 this means 180\n     * The actual value depending on guessed encoding is passed as @len\n     * if provided\n     */\n    if (len >= 0) {\n        if (toconv > len)\n            toconv = len;\n    } else {\n        if (toconv > 180)\n            toconv = 180;\n    }\n    if (toconv * 2 >= written) {\n        xmlBufferGrow(out, toconv);\n\twritten = out->size - out->use - 1;\n    }\n\n    if (handler->input != NULL) {\n\tret = handler->input(&out->content[out->use], &written,\n\t                     in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n    }\n#ifdef LIBXML_ICONV_ENABLED\n    else if (handler->iconv_in != NULL) {\n\tret = xmlIconvWrapper(handler->iconv_in, &out->content[out->use],\n\t                      &written, in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n\tif (ret == -1) ret = -3;\n    }\n#endif /* LIBXML_ICONV_ENABLED */\n#ifdef LIBXML_ICU_ENABLED\n    else if (handler->uconv_in != NULL) {\n\tret = xmlUconvWrapper(handler->uconv_in, 1, &out->content[out->use],\n\t                      &written, in->content, &toconv);\n\txmlBufferShrink(in, toconv);\n\tout->use += written;\n\tout->content[out->use] = 0;\n\tif (ret == -1) ret = -3;\n    }\n#endif /* LIBXML_ICU_ENABLED */\n#ifdef DEBUG_ENCODING\n    switch (ret) {\n        case 0:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"converted %d bytes to %d bytes of input\\n\",\n\t            toconv, written);\n\t    break;\n        case -1:\n\t    xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n\t            toconv, written, in->use);\n\t    break;\n        case -2:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"input conversion failed due to input error\\n\");\n\t    break;\n        case -3:\n\t    xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n\t            toconv, written, in->use);\n\t    break;\n\tdefault:\n\t    xmlGenericError(xmlGenericErrorContext,\"Unknown input conversion failed %d\\n\", ret);\n    }\n#endif /* DEBUG_ENCODING */\n    /*\n     * Ignore when input buffer is not on a boundary\n     */\n    if (ret == -3) ret = 0;\n    if (ret == -1) ret = 0;\n    return(ret);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix an off by one error in encoding\n\nthis off by one error doesn't seems to reproduce on linux\nbut the error is real."}
{"func": "xmlCharEncInFunc(xmlCharEncodingHandler * handler, xmlBufferPtr out,\n                 xmlBufferPtr in)\n{\n    int ret = -2;\n    int written;\n    int toconv;\n\n    if (handler == NULL)\n        return (-1);\n    if (out == NULL)\n        return (-1);\n    if (in == NULL)\n        return (-1);\n\n    toconv = in->use;\n    if (toconv == 0)\n        return (0);\n    written = out->size - out->use;\n    if (toconv * 2 >= written) {\n        xmlBufferGrow(out, out->size + toconv * 2);\n        written = out->size - out->use - 1;\n    }\n    if (handler->input != NULL) {\n        ret = handler->input(&out->content[out->use], &written,\n                             in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n    }\n#ifdef LIBXML_ICONV_ENABLED\n    else if (handler->iconv_in != NULL) {\n        ret = xmlIconvWrapper(handler->iconv_in, &out->content[out->use],\n                              &written, in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n        if (ret == -1)\n            ret = -3;\n    }\n#endif /* LIBXML_ICONV_ENABLED */\n#ifdef LIBXML_ICU_ENABLED\n    else if (handler->uconv_in != NULL) {\n        ret = xmlUconvWrapper(handler->uconv_in, 1, &out->content[out->use],\n                              &written, in->content, &toconv);\n        xmlBufferShrink(in, toconv);\n        out->use += written;\n        out->content[out->use] = 0;\n        if (ret == -1)\n            ret = -3;\n    }\n#endif /* LIBXML_ICU_ENABLED */\n    switch (ret) {\n        case 0:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                            \"converted %d bytes to %d bytes of input\\n\",\n                            toconv, written);\n#endif\n            break;\n        case -1:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                         \"converted %d bytes to %d bytes of input, %d left\\n\",\n                            toconv, written, in->use);\n#endif\n            break;\n        case -3:\n#ifdef DEBUG_ENCODING\n            xmlGenericError(xmlGenericErrorContext,\n                        \"converted %d bytes to %d bytes of input, %d left\\n\",\n                            toconv, written, in->use);\n#endif\n            break;\n        case -2: {\n            char buf[50];\n\n\t    snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n\t\t     in->content[0], in->content[1],\n\t\t     in->content[2], in->content[3]);\n\t    buf[49] = 0;\n\t    xmlEncodingErr(XML_I18N_CONV_FAILED,\n\t\t    \"input conversion failed due to input error, bytes %s\\n\",\n\t\t           buf);\n        }\n    }\n    /*\n     * Ignore when input buffer is not on a boundary\n     */\n    if (ret == -3)\n        ret = 0;\n    return (written? written : ret);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix an off by one error in encoding\n\nthis off by one error doesn't seems to reproduce on linux\nbut the error is real."}
{"func": "static char **fill_envp(struct dhcp_packet *packet)\n{\n\tint envc;\n\tint i;\n\tchar **envp, **curr;\n\tconst char *opt_name;\n\tuint8_t *temp;\n\tuint8_t overload = 0;\n\n#define BITMAP unsigned\n#define BBITS (sizeof(BITMAP) * 8)\n#define BMASK(i) (1 << (i & (sizeof(BITMAP) * 8 - 1)))\n#define FOUND_OPTS(i) (found_opts[(unsigned)i / BBITS])\n\tBITMAP found_opts[256 / BBITS];\n\n\tmemset(found_opts, 0, sizeof(found_opts));\n\n\t/* We need 6 elements for:\n\t * \"interface=IFACE\"\n\t * \"ip=N.N.N.N\" from packet->yiaddr\n\t * \"siaddr=IP\" from packet->siaddr_nip (unless 0)\n\t * \"boot_file=FILE\" from packet->file (unless overloaded)\n\t * \"sname=SERVER_HOSTNAME\" from packet->sname (unless overloaded)\n\t * terminating NULL\n\t */\n\tenvc = 6;\n\t/* +1 element for each option, +2 for subnet option: */\n\tif (packet) {\n\t\t/* note: do not search for \"pad\" (0) and \"end\" (255) options */\n\t\tfor (i = 1; i < 255; i++) {\n\t\t\ttemp = udhcp_get_option(packet, i);\n\t\t\tif (temp) {\n\t\t\t\tif (i == DHCP_OPTION_OVERLOAD)\n\t\t\t\t\toverload = *temp;\n\t\t\t\telse if (i == DHCP_SUBNET)\n\t\t\t\t\tenvc++; /* for $mask */\n\t\t\t\tenvc++;\n\t\t\t\t/*if (i != DHCP_MESSAGE_TYPE)*/\n\t\t\t\tFOUND_OPTS(i) |= BMASK(i);\n\t\t\t}\n\t\t}\n\t}\n\tcurr = envp = xzalloc(sizeof(envp[0]) * envc);\n\n\t*curr = xasprintf(\"interface=%s\", client_config.interface);\n\tputenv(*curr++);\n\n\tif (!packet)\n\t\treturn envp;\n\n\t/* Export BOOTP fields. Fields we don't (yet?) export:\n\t * uint8_t op;      // always BOOTREPLY\n\t * uint8_t htype;   // hardware address type. 1 = 10mb ethernet\n\t * uint8_t hlen;    // hardware address length\n\t * uint8_t hops;    // used by relay agents only\n\t * uint32_t xid;\n\t * uint16_t secs;   // elapsed since client began acquisition/renewal\n\t * uint16_t flags;  // only one flag so far: bcast. Never set by server\n\t * uint32_t ciaddr; // client IP (usually == yiaddr. can it be different\n\t *                  // if during renew server wants to give us differn IP?)\n\t * uint32_t gateway_nip; // relay agent IP address\n\t * uint8_t chaddr[16]; // link-layer client hardware address (MAC)\n\t * TODO: export gateway_nip as $giaddr?\n\t */\n\t/* Most important one: yiaddr as $ip */\n\t*curr = xmalloc(sizeof(\"ip=255.255.255.255\"));\n\tsprint_nip(*curr, \"ip=\", (uint8_t *) &packet->yiaddr);\n\tputenv(*curr++);\n\tif (packet->siaddr_nip) {\n\t\t/* IP address of next server to use in bootstrap */\n\t\t*curr = xmalloc(sizeof(\"siaddr=255.255.255.255\"));\n\t\tsprint_nip(*curr, \"siaddr=\", (uint8_t *) &packet->siaddr_nip);\n\t\tputenv(*curr++);\n\t}\n\tif (!(overload & FILE_FIELD) && packet->file[0]) {\n\t\t/* watch out for invalid packets */\n\t\t*curr = xasprintf(\"boot_file=%.\"DHCP_PKT_FILE_LEN_STR\"s\", packet->file);\n\t\tputenv(*curr++);\n\t}\n\tif (!(overload & SNAME_FIELD) && packet->sname[0]) {\n\t\t/* watch out for invalid packets */\n\t\t*curr = xasprintf(\"sname=%.\"DHCP_PKT_SNAME_LEN_STR\"s\", packet->sname);\n\t\tputenv(*curr++);\n\t}\n\n\t/* Export known DHCP options */\n\topt_name = dhcp_option_strings;\n\ti = 0;\n\twhile (*opt_name) {\n\t\tuint8_t code = dhcp_optflags[i].code;\n\t\tBITMAP *found_ptr = &FOUND_OPTS(code);\n\t\tBITMAP found_mask = BMASK(code);\n\t\tif (!(*found_ptr & found_mask))\n\t\t\tgoto next;\n\t\t*found_ptr &= ~found_mask; /* leave only unknown options */\n\t\ttemp = udhcp_get_option(packet, code);\n\t\t*curr = xmalloc_optname_optval(temp, &dhcp_optflags[i], opt_name);\n\t\tputenv(*curr++);\n\t\tif (code == DHCP_SUBNET) {\n\t\t\t/* Subnet option: make things like \"$ip/$mask\" possible */\n\t\t\tuint32_t subnet;\n\t\t\tmove_from_unaligned32(subnet, temp);\n\t\t\t*curr = xasprintf(\"mask=%u\", mton(subnet));\n\t\t\tputenv(*curr++);\n\t\t}\n next:\n\t\topt_name += strlen(opt_name) + 1;\n\t\ti++;\n\t}\n\t/* Export unknown options */\n\tfor (i = 0; i < 256;) {\n\t\tBITMAP bitmap = FOUND_OPTS(i);\n\t\tif (!bitmap) {\n\t\t\ti += BBITS;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bitmap & BMASK(i)) {\n\t\t\tunsigned len, ofs;\n\n\t\t\ttemp = udhcp_get_option(packet, i);\n\t\t\t/* udhcp_get_option returns ptr to data portion,\n\t\t\t * need to go back to get len\n\t\t\t */\n\t\t\tlen = temp[-OPT_DATA + OPT_LEN];\n\t\t\t*curr = xmalloc(sizeof(\"optNNN=\") + 1 + len*2);\n\t\t\tofs = sprintf(*curr, \"opt%u=\", i);\n\t\t\t*bin2hex(*curr + ofs, (void*) temp, len) = '\\0';\n\t\t\tputenv(*curr++);\n\t\t}\n\t\ti++;\n\t}\n\n\treturn envp;\n}", "target": 1, "cwe": ["CWE-20"], "message": "udhcpc: sanitize hostnames in incoming packets. Closes 3979.\n\nThe following options are replaced with string \"bad\" if they\ncontain malformed hostname:\nHOST_NAME, DOMAIN_NAME, NIS_DOMAIN, TFTP_SERVER_NAME\n\nfunction                                             old     new   delta\nxmalloc_optname_optval                               850     888     +38\nattach_option                                        440     443      +3\nlen_of_option_as_string                               13      14      +1\ndhcp_option_lengths                                   13      14      +1\n------------------------------------------------------------------------------\n(add/remove: 0/0 grow/shrink: 4/0 up/down: 43/0)               Total: 43 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\t/* option points to OPT_DATA, need to go back to get OPT_LEN */\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n\ttype = optflag->flags & OPTION_TYPE_MASK;\n\toptlen = dhcp_option_lengths[type];\n\tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen - 1) / (unsigned)optlen);\n\n\tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n\tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n//\t\tcase OPTION_BOOLEAN:\n//\t\t\tdest += sprintf(dest, *option ? \"yes\" : \"no\");\n//\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n//\t\tcase OPTION_S16:\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: options which use 'return' instead of 'break'\n\t\t * (for example, OPTION_STRING) skip the code which handles\n\t\t * the case of list of options.\n\t\t */\n\t\tcase OPTION_STRING:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\t/* Option binary format:\n\t\t\t * mask [one byte, 0..32]\n\t\t\t * ip [big endian, 0..4 bytes depending on mask]\n\t\t\t * router [big endian, 4 bytes]\n\t\t\t * may be repeated\n\t\t\t *\n\t\t\t * We convert it to a string \"IP/MASK ROUTER IP2/MASK2 ROUTER2\"\n\t\t\t */\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { /* mask + 0-byte ip + router */\n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */\n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* print ip/mask */\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\t/* print router */\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\t/* Option binary format (see RFC 5969):\n\t\t\t *  0                   1                   2                   3\n\t\t\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |                           6rdPrefix                           |\n\t\t\t * ...                        (16 octets)                        ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * ...                   6rdBRIPv4Address(es)                    ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * We convert it to a string\n\t\t\t * \"IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...\"\n\t\t\t *\n\t\t\t * Sanity check: ensure that our length is at least 22 bytes, that\n\t\t\t * IPv4MaskLen <= 32,\n\t\t\t * 6rdPrefixLen <= 128,\n\t\t\t * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128\n\t\t\t * (2nd condition need no check - it follows from 1st and 3rd).\n\t\t\t * Else, return envvar with empty value (\"optname=\")\n\t\t\t */\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\t/* IPv4MaskLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefixLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefix */\n\t\t\t\tdest += sprint_nip6(dest, /* \"\", */ option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\t/* \"+ 4\" above corresponds to the length of IPv4 addr\n\t\t\t\t * we consume in the loop below */\n\t\t\t\twhile (1) {\n\t\t\t\t\t/* 6rdBRIPv4Address(es) */\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; /* do we have yet another 4+ bytes? */\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; /* no */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\t/* unpack option into dest; use ret for prefix (i.e., \"optname=\") */\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\t/* error. return \"optname=\" string */\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\t/* Option binary format:\n\t\t\t * type: byte\n\t\t\t * type=0: domain names, dns-compressed\n\t\t\t * type=1: IP addrs\n\t\t\t */\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} /* switch */\n\n\t\t/* If we are here, try to format any remaining data\n\t\t * in the option as another, similarly-formatted option\n\t\t */\n\t\toption += optlen;\n\t\tlen -= optlen;\n// TODO: it can be a list only if (optflag->flags & OPTION_LIST).\n// Should we bail out/warn if we see multi-ip option which is\n// not allowed to be such (for example, DHCP_BROADCAST)? -\n\t\tif (len < optlen /* || !(optflag->flags & OPTION_LIST) */)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} /* while */\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-20"], "message": "udhcpc: sanitize hostnames in incoming packets. Closes 3979.\n\nThe following options are replaced with string \"bad\" if they\ncontain malformed hostname:\nHOST_NAME, DOMAIN_NAME, NIS_DOMAIN, TFTP_SERVER_NAME\n\nfunction                                             old     new   delta\nxmalloc_optname_optval                               850     888     +38\nattach_option                                        440     443      +3\nlen_of_option_as_string                               13      14      +1\ndhcp_option_lengths                                   13      14      +1\n------------------------------------------------------------------------------\n(add/remove: 0/0 grow/shrink: 4/0 up/down: 43/0)               Total: 43 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg)\n{\n\tstruct option_set **opt_list = arg;\n\tchar *opt, *val, *endptr;\n\tchar *str;\n\tconst struct dhcp_optflag *optflag;\n\tstruct dhcp_optflag bin_optflag;\n\tunsigned optcode;\n\tint retval, length;\n\tchar buffer[8] ALIGNED(4);\n\tuint16_t *result_u16 = (uint16_t *) buffer;\n\tuint32_t *result_u32 = (uint32_t *) buffer;\n\n\t/* Cheat, the only *const* str possible is \"\" */\n\tstr = (char *) const_str;\n\topt = strtok(str, \" \\t=\");\n\tif (!opt)\n\t\treturn 0;\n\n\toptcode = bb_strtou(opt, NULL, 0);\n\tif (!errno && optcode < 255) {\n\t\t/* Raw (numeric) option code */\n\t\tbin_optflag.flags = OPTION_BIN;\n\t\tbin_optflag.code = optcode;\n\t\toptflag = &bin_optflag;\n\t} else {\n\t\toptflag = &dhcp_optflags[udhcp_option_idx(opt)];\n\t}\n\n\tretval = 0;\n\tdo {\n\t\tval = strtok(NULL, \", \\t\");\n\t\tif (!val)\n\t\t\tbreak;\n\t\tlength = dhcp_option_lengths[optflag->flags & OPTION_TYPE_MASK];\n\t\tretval = 0;\n\t\topt = buffer; /* new meaning for variable opt */\n\t\tswitch (optflag->flags & OPTION_TYPE_MASK) {\n\t\tcase OPTION_IP:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tbreak;\n\t\tcase OPTION_IP_PAIR:\n\t\t\tretval = udhcp_str2nip(val, buffer);\n\t\t\tval = strtok(NULL, \", \\t/-\");\n\t\t\tif (!val)\n\t\t\t\tretval = 0;\n\t\t\tif (retval)\n\t\t\t\tretval = udhcp_str2nip(val, buffer + 4);\n\t\t\tbreak;\n\t\tcase OPTION_STRING:\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n#endif\n\t\t\tlength = strnlen(val, 254);\n\t\t\tif (length > 0) {\n\t\t\t\topt = val;\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t\tbreak;\n//\t\tcase OPTION_BOOLEAN: {\n//\t\t\tstatic const char no_yes[] ALIGN1 = \"no\\0yes\\0\";\n//\t\t\tbuffer[0] = retval = index_in_strings(no_yes, val);\n//\t\t\tretval++; /* 0 - bad; 1: \"no\" 2: \"yes\" */\n//\t\t\tbreak;\n//\t\t}\n\t\tcase OPTION_U8:\n\t\t\tbuffer[0] = strtoul(val, &endptr, 0);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t/* htonX are macros in older libc's, using temp var\n\t\t * in code below for safety */\n\t\t/* TODO: use bb_strtoX? */\n\t\tcase OPTION_U16: {\n\t\t\tunsigned long tmp = strtoul(val, &endptr, 0);\n\t\t\t*result_u16 = htons(tmp);\n\t\t\tretval = (endptr[0] == '\\0' /*&& tmp < 0x10000*/);\n\t\t\tbreak;\n\t\t}\n//\t\tcase OPTION_S16: {\n//\t\t\tlong tmp = strtol(val, &endptr, 0);\n//\t\t\t*result_u16 = htons(tmp);\n//\t\t\tretval = (endptr[0] == '\\0');\n//\t\t\tbreak;\n//\t\t}\n\t\tcase OPTION_U32: {\n\t\t\tunsigned long tmp = strtoul(val, &endptr, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32: {\n\t\t\tlong tmp = strtol(val, &endptr, 0);\n\t\t\t*result_u32 = htonl(tmp);\n\t\t\tretval = (endptr[0] == '\\0');\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_BIN: /* handled in attach_option() */\n\t\t\topt = val;\n\t\t\tretval = 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (retval)\n\t\t\tattach_option(opt_list, optflag, opt, length);\n\t} while (retval && optflag->flags & OPTION_LIST);\n\n\treturn retval;\n}", "target": 1, "cwe": ["CWE-20"], "message": "udhcpc: sanitize hostnames in incoming packets. Closes 3979.\n\nThe following options are replaced with string \"bad\" if they\ncontain malformed hostname:\nHOST_NAME, DOMAIN_NAME, NIS_DOMAIN, TFTP_SERVER_NAME\n\nfunction                                             old     new   delta\nxmalloc_optname_optval                               850     888     +38\nattach_option                                        440     443      +3\nlen_of_option_as_string                               13      14      +1\ndhcp_option_lengths                                   13      14      +1\n------------------------------------------------------------------------------\n(add/remove: 0/0 grow/shrink: 4/0 up/down: 43/0)               Total: 43 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "static NOINLINE void attach_option(\n\t\tstruct option_set **opt_list,\n\t\tconst struct dhcp_optflag *optflag,\n\t\tchar *buffer,\n\t\tint length)\n{\n\tstruct option_set *existing, *new, **curr;\n\tchar *allocated = NULL;\n\n\texisting = udhcp_find_option(*opt_list, optflag->code);\n\tif (!existing) {\n\t\tlog2(\"Attaching option %02x to list\", optflag->code);\n\t\tallocated = allocate_tempopt_if_needed(optflag, buffer, &length);\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {\n\t\t\t/* reuse buffer and length for RFC1035-formatted string */\n\t\t\tallocated = buffer = (char *)dname_enc(NULL, 0, buffer, &length);\n\t\t}\n#endif\n\t\t/* make a new option */\n\t\tnew = xmalloc(sizeof(*new));\n\t\tnew->data = xmalloc(length + OPT_DATA);\n\t\tnew->data[OPT_CODE] = optflag->code;\n\t\tnew->data[OPT_LEN] = length;\n\t\tmemcpy(new->data + OPT_DATA, (allocated ? allocated : buffer), length);\n\n\t\tcurr = opt_list;\n\t\twhile (*curr && (*curr)->data[OPT_CODE] < optflag->code)\n\t\t\tcurr = &(*curr)->next;\n\n\t\tnew->next = *curr;\n\t\t*curr = new;\n\t\tgoto ret;\n\t}\n\n\tif (optflag->flags & OPTION_LIST) {\n\t\tunsigned old_len;\n\n\t\t/* add it to an existing option */\n\t\tlog2(\"Attaching option %02x to existing member of list\", optflag->code);\n\t\tallocated = allocate_tempopt_if_needed(optflag, buffer, &length);\n\t\told_len = existing->data[OPT_LEN];\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_DNS_STRING) {\n\t\t\t/* reuse buffer and length for RFC1035-formatted string */\n\t\t\tallocated = buffer = (char *)dname_enc(existing->data + OPT_DATA, old_len, buffer, &length);\n\t\t}\n#endif\n\t\tif (old_len + length < 255) {\n\t\t\t/* actually 255 is ok too, but adding a space can overlow it */\n\n\t\t\texisting->data = xrealloc(existing->data, OPT_DATA + 1 + old_len + length);\n\t\t\tif ((optflag->flags & OPTION_TYPE_MASK) == OPTION_STRING) {\n\t\t\t\t/* add space separator between STRING options in a list */\n\t\t\t\texisting->data[OPT_DATA + old_len] = ' ';\n\t\t\t\told_len++;\n\t\t\t}\n\t\t\tmemcpy(existing->data + OPT_DATA + old_len, buffer, length);\n\t\t\texisting->data[OPT_LEN] = old_len + length;\n\t\t} /* else, ignore the data, we could put this in a second option in the future */\n\t} /* else, ignore the new data */\n\n ret:\n\tfree(allocated);\n}", "target": 1, "cwe": ["CWE-20"], "message": "udhcpc: sanitize hostnames in incoming packets. Closes 3979.\n\nThe following options are replaced with string \"bad\" if they\ncontain malformed hostname:\nHOST_NAME, DOMAIN_NAME, NIS_DOMAIN, TFTP_SERVER_NAME\n\nfunction                                             old     new   delta\nxmalloc_optname_optval                               850     888     +38\nattach_option                                        440     443      +3\nlen_of_option_as_string                               13      14      +1\ndhcp_option_lengths                                   13      14      +1\n------------------------------------------------------------------------------\n(add/remove: 0/0 grow/shrink: 4/0 up/down: 43/0)               Total: 43 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) {\n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}", "target": 1, "cwe": ["CWE-189"], "message": "bb#2818"}
{"func": "static int check_mtab(const char *progname, const char *devname,\n\t\t      const char *dir)\n{\n\tif (check_newline(progname, devname) == -1 ||\n\t    check_newline(progname, dir) == -1)\n\t\treturn EX_USAGE;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "mount.cifs: check_newline returns EX_USAGE on error, not -1\n\nReported-by: Jan Lieskovsky <jlieskov@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@samba.org>"}
{"func": "gdk_pixbuf__tiff_image_begin_load (ModulePreparedNotifyFunc prepare_func,\n\t\t\t\t   ModuleUpdatedNotifyFunc update_func,\n\t\t\t\t   gpointer user_data,\n                                   GError **error)\n{\n\tTiffData *context;\n\tgint fd;\n\n\tcontext = g_new (TiffData, 1);\n\tcontext->prepare_func = prepare_func;\n\tcontext->update_func = update_func;\n\tcontext->user_data = user_data;\n\tcontext->all_okay = TRUE;\n\tfd = g_file_open_tmp (\"gdkpixbuf-tif-tmp.XXXXXX\", &context->tempname,\n\t\t\t      NULL);\n\tif (fd < 0) {\n\t\tg_free (context);\n\t\treturn NULL;\n\t}\n\n\tcontext->file = fdopen (fd, \"w\");\n\tif (context->file == NULL) {\n                g_free (context->tempname);\n\t\tg_free (context);\n\t\treturn NULL;\n\t}\n\n\treturn context;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)\n{\n        LoadContext* lc = context;\n\n        g_return_val_if_fail(lc != NULL, TRUE);\n\n        /* FIXME this thing needs to report errors if\n         * we have unused image data\n         */\n        \n        gdk_pixbuf_unref(lc->pixbuf);\n        \n        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);\n        g_free(lc);\n\n        return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__gif_image_load_animation (FILE *file,\n                                      GError **error)\n{\n\tGifContext *context;\n\tGdkPixbufAnimation *animation;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        context->error = error;\n\tcontext->file = file;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n\n                g_object_unref (G_OBJECT (context->animation));\n                context->animation = NULL;\n        }\n\n        if (context->animation)\n                animation = GDK_PIXBUF_ANIMATION (context->animation);\n        else\n                animation = NULL;\n\n        if (context->error && *(context->error))\n                g_print (\"%s\\n\", (*(context->error))->message);\n        \n        g_free (context->buf);\n\tg_free (context);\n\treturn animation;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "lzw_read_byte (GifContext *context)\n{\n\tint code, incode;\n\tgint retval;\n\tgint my_retval;\n\tregister int i;\n\n\tif (context->lzw_code_pending != -1) {\n\t\tretval = context->lzw_code_pending;\n\t\tcontext->lzw_code_pending = -1;\n\t\treturn retval;\n\t}\n\n\tif (context->lzw_fresh) {\n\t\tcontext->lzw_fresh = FALSE;\n\t\tdo {\n\t\t\tretval = get_code (context, context->lzw_code_size);\n\t\t\tif (retval < 0) {\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tcontext->lzw_firstcode = context->lzw_oldcode = retval;\n\t\t} while (context->lzw_firstcode == context->lzw_clear_code);\n\t\treturn context->lzw_firstcode;\n\t}\n\n\tif (context->lzw_sp > context->lzw_stack) {\n\t\tmy_retval = *--(context->lzw_sp);\n\t\treturn my_retval;\n\t}\n\n\twhile ((code = get_code (context, context->lzw_code_size)) >= 0) {\n\t\tif (code == context->lzw_clear_code) {\n\t\t\tfor (i = 0; i < context->lzw_clear_code; ++i) {\n\t\t\t\tcontext->lzw_table[0][i] = 0;\n\t\t\t\tcontext->lzw_table[1][i] = i;\n\t\t\t}\n\t\t\tfor (; i < (1 << MAX_LZW_BITS); ++i)\n\t\t\t\tcontext->lzw_table[0][i] = context->lzw_table[1][i] = 0;\n\t\t\tcontext->lzw_code_size = context->lzw_set_code_size + 1;\n\t\t\tcontext->lzw_max_code_size = 2 * context->lzw_clear_code;\n\t\t\tcontext->lzw_max_code = context->lzw_clear_code + 2;\n\t\t\tcontext->lzw_sp = context->lzw_stack;\n\n\t\t\tset_gif_lzw_clear_code (context);\n\t\t\treturn -3;\n\t\t} else if (code == context->lzw_end_code) {\n\t\t\tint count;\n\t\t\tunsigned char buf[260];\n\n\t\t\t/*g_error (\" DID WE EVER EVER GET HERE\\n\");*/\n\t\t\tg_warning (\"Unhandled Case.  If you have an image that causes this, let me <jrb@redhat.com> know.\\n\");\n\n\t\t\tif (ZeroDataBlock) {\n\t\t\t\treturn -2;\n\t\t\t}\n\n\t\t\twhile ((count = GetDataBlock (context, buf)) > 0)\n\t\t\t\t;\n\n\t\t\tif (count != 0) {\n\t\t\t\t/*g_print (_(\"GIF: missing EOD in data stream (common occurence)\"));*/\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\n\t\tincode = code;\n\n\t\tif (code >= context->lzw_max_code) {\n\t\t\t*(context->lzw_sp)++ = context->lzw_firstcode;\n\t\t\tcode = context->lzw_oldcode;\n\t\t}\n\n\t\twhile (code >= context->lzw_clear_code) {\n\t\t\t*(context->lzw_sp)++ = context->lzw_table[1][code];\n\n\t\t\tif (code == context->lzw_table[0][code]) {\n                                g_set_error (context->error,\n                                             GDK_PIXBUF_ERROR,\n                                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                             _(\"Circular table entry in GIF file\"));\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tcode = context->lzw_table[0][code];\n\t\t}\n\n\t\t*(context->lzw_sp)++ = context->lzw_firstcode = context->lzw_table[1][code];\n\n\t\tif ((code = context->lzw_max_code) < (1 << MAX_LZW_BITS)) {\n\t\t\tcontext->lzw_table[0][code] = context->lzw_oldcode;\n\t\t\tcontext->lzw_table[1][code] = context->lzw_firstcode;\n\t\t\t++context->lzw_max_code;\n\t\t\tif ((context->lzw_max_code >= context->lzw_max_code_size) &&\n\t\t\t    (context->lzw_max_code_size < (1 << MAX_LZW_BITS))) {\n\t\t\t\tcontext->lzw_max_code_size *= 2;\n\t\t\t\t++context->lzw_code_size;\n\t\t\t}\n\t\t}\n\n\t\tcontext->lzw_oldcode = incode;\n\n\t\tif (context->lzw_sp > context->lzw_stack) {\n\t\t\tmy_retval = *--(context->lzw_sp);\n\t\t\treturn my_retval;\n\t\t}\n\t}\n\treturn code;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gif_get_lzw (GifContext *context)\n{\n\tguchar *dest, *temp;\n\tgint lower_bound, upper_bound; /* bounds for emitting the area_updated signal */\n\tgboolean bound_flag;\n\tgint first_pass; /* bounds for emitting the area_updated signal */\n\tgint v;\n\n\tif (context->frame == NULL) {\n                context->frame = g_new (GdkPixbufFrame, 1);\n\n                context->frame->composited = NULL;\n                context->frame->revert = NULL;\n                \n                context->frame->pixbuf =\n                        gdk_pixbuf_new (GDK_COLORSPACE_RGB,\n                                        TRUE,\n                                        8,\n                                        context->frame_len,\n                                        context->frame_height);\n                \n                context->frame->x_offset = context->x_offset;\n                context->frame->y_offset = context->y_offset;\n                context->frame->need_recomposite = TRUE;\n                \n                /* GIF delay is in hundredths, we want thousandths */\n                context->frame->delay_time = context->gif89.delay_time * 10;\n                context->frame->elapsed = context->animation->total_time;\n                context->animation->total_time += context->frame->delay_time;\n                \n                switch (context->gif89.disposal) {\n                case 0:\n                case 1:\n                        context->frame->action = GDK_PIXBUF_FRAME_RETAIN;\n                        break;\n                case 2:\n                        context->frame->action = GDK_PIXBUF_FRAME_DISPOSE;\n                        break;\n                case 3:\n                        context->frame->action = GDK_PIXBUF_FRAME_REVERT;\n                        break;\n                default:\n                        context->frame->action = GDK_PIXBUF_FRAME_RETAIN;\n                        break;\n                }\n\n                context->frame->bg_transparent = (context->gif89.transparent == context->background_index);\n                \n                {\n                        /* Update animation size */\n                        int w, h;\n                        \n                        context->animation->n_frames ++;\n                        context->animation->frames = g_list_append (context->animation->frames, context->frame);\n\n                        w = context->frame->x_offset +\n                                gdk_pixbuf_get_width (context->frame->pixbuf);\n                        h = context->frame->y_offset +\n                                gdk_pixbuf_get_height (context->frame->pixbuf);\n                        if (w > context->animation->width)\n                                context->animation->width = w;\n                        if (h > context->animation->height)\n                                context->animation->height = h;\n                }\n\n                /* Only call prepare_func for the first frame */\n\t\tif (context->animation->frames->next == NULL) { \n                        if (context->prepare_func)\n                                (* context->prepare_func) (context->frame->pixbuf,\n                                                           GDK_PIXBUF_ANIMATION (context->animation),\n                                                           context->user_data);\n                } else {\n                        /* Otherwise init frame with last frame */\n                        GList *link;\n                        GdkPixbufFrame *prev_frame;\n                        \n                        link = g_list_find (context->animation->frames, context->frame);\n\n                        prev_frame = link->prev->data;\n\n                        gdk_pixbuf_gif_anim_frame_composite (context->animation, prev_frame);\n\n                        gdk_pixbuf_copy_area (prev_frame->composited,\n                                              context->frame->x_offset,\n                                              context->frame->y_offset,\n                                              gdk_pixbuf_get_width (context->frame->pixbuf),\n                                              gdk_pixbuf_get_height (context->frame->pixbuf),\n                                              context->frame->pixbuf,\n                                              0, 0);\n                }\n        }\n\n\tdest = gdk_pixbuf_get_pixels (context->frame->pixbuf);\n\n\tbound_flag = FALSE;\n\tlower_bound = upper_bound = context->draw_ypos;\n\tfirst_pass = context->draw_pass;\n\n\twhile (TRUE) {\n                guchar (*cmap)[MAXCOLORMAPSIZE];\n\n                if (context->frame_cmap_active)\n                        cmap = context->frame_color_map;\n                else\n                        cmap = context->global_color_map;\n                \n\t\tv = lzw_read_byte (context);\n\t\tif (v < 0) {\n\t\t\tgoto finished_data;\n\t\t}\n\t\tbound_flag = TRUE;\n\n                g_assert (gdk_pixbuf_get_has_alpha (context->frame->pixbuf));\n                \n                temp = dest + context->draw_ypos * gdk_pixbuf_get_rowstride (context->frame->pixbuf) + context->draw_xpos * 4;\n                *temp = cmap [0][(guchar) v];\n                *(temp+1) = cmap [1][(guchar) v];\n                *(temp+2) = cmap [2][(guchar) v];\n                *(temp+3) = (guchar) ((v == context->gif89.transparent) ? 0 : 255);\n\n\t\tif (context->prepare_func && context->frame_interlace)\n\t\t\tgif_fill_in_lines (context, dest, v);\n\n\t\tcontext->draw_xpos++;\n                \n\t\tif (context->draw_xpos == context->frame_len) {\n\t\t\tcontext->draw_xpos = 0;\n\t\t\tif (context->frame_interlace) {\n\t\t\t\tswitch (context->draw_pass) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tcontext->draw_ypos += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tcontext->draw_ypos += 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tcontext->draw_ypos += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (context->draw_ypos >= context->frame_height) {\n\t\t\t\t\tcontext->draw_pass++;\n\t\t\t\t\tswitch (context->draw_pass) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcontext->draw_ypos = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcontext->draw_ypos = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcontext->draw_ypos = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontext->draw_ypos++;\n\t\t\t}\n\t\t\tif (context->draw_pass != first_pass) {\n\t\t\t\tif (context->draw_ypos > lower_bound) {\n\t\t\t\t\tlower_bound = 0;\n\t\t\t\t\tupper_bound = context->frame_height;\n\t\t\t\t} else {\n                                        \n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tupper_bound = context->draw_ypos;\n\t\t}\n\t\tif (context->draw_ypos >= context->frame_height)\n\t\t\tbreak;\n\t}\n\n done:\n\n        context->state = GIF_GET_NEXT_STEP;\n\n        v = 0;\n\n finished_data:\n        \n        if (bound_flag)\n                context->frame->need_recomposite = TRUE;\n        \n\tif (bound_flag && context->update_func) {\n\t\tif (lower_bound <= upper_bound && first_pass == context->draw_pass) {\n\t\t\t(* context->update_func)\n\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t 0, lower_bound,\n\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t upper_bound - lower_bound,\n\t\t\t\t context->user_data);\n\t\t} else {\n\t\t\tif (lower_bound <= upper_bound) {\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t gdk_pixbuf_get_height (context->frame->pixbuf),\n\t\t\t\t\t context->user_data);\n\t\t\t} else {\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t upper_bound,\n\t\t\t\t\t context->user_data);\n\t\t\t\t(* context->update_func)\n\t\t\t\t\t(context->frame->pixbuf,\n\t\t\t\t\t context->frame->x_offset,\n                                         lower_bound + context->frame->y_offset,\n\t\t\t\t\t gdk_pixbuf_get_width (context->frame->pixbuf),\n\t\t\t\t\t gdk_pixbuf_get_height (context->frame->pixbuf),\n\t\t\t\t\t context->user_data);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context->state == GIF_GET_NEXT_STEP) {\n                /* Will be freed with context->animation, we are just\n                 * marking that we're done with it (no current frame)\n                 */\n\t\tcontext->frame = NULL;\n                context->frame_cmap_active = FALSE;\n\t}\n\t\n\treturn v;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf_loader_close (GdkPixbufLoader *loader,\n                         GError         **error)\n{\n  GdkPixbufLoaderPrivate *priv;\n  gboolean retval = TRUE;\n  \n  g_return_val_if_fail (loader != NULL, TRUE);\n  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), TRUE);\n  \n  priv = loader->priv;\n  \n  /* we expect it's not closed */\n  g_return_val_if_fail (priv->closed == FALSE, TRUE);\n  \n  /* We have less the 128 bytes in the image.  Flush it, and keep going. */\n  if (priv->image_module == NULL)\n    gdk_pixbuf_loader_load_module (loader, NULL, NULL);\n  \n  if (priv->image_module && priv->image_module->stop_load)\n    retval = priv->image_module->stop_load (priv->context, error);\n  \n  priv->closed = TRUE;\n  \n  g_signal_emit (G_OBJECT (loader), pixbuf_loader_signals[CLOSED], 0);\n\n  return retval;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "png_error_callback(png_structp png_read_ptr,\n                   png_const_charp error_msg)\n{\n        LoadContext* lc;\n        \n        lc = png_get_error_ptr(png_read_ptr);\n        \n        lc->fatal_error_occurred = TRUE;\n\n        /* I don't trust libpng to call the error callback only once,\n         * so check for already-set error\n         */\n        if (lc->error && *lc->error == NULL) {\n                g_set_error (lc->error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                             _(\"Fatal error reading PNG image file: %s\"),\n                             error_msg);\n        }\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gif_read (GifContext *context, guchar *buffer, size_t len)\n{\n\tgint retval;\n#ifdef IO_GIFDEBUG\n\tgint i;\n#endif\n\tif (context->file) {\n#ifdef IO_GIFDEBUG\n\t\tcount += len;\n\t\tg_print (\"Fsize :%d\\tcount :%d\\t\", len, count);\n#endif\n\t\tretval = (fread(buffer, len, 1, context->file) != 0);\n\n                if (!retval && ferror (context->file))\n                        g_set_error (context->error,\n                                     G_FILE_ERROR,\n                                     g_file_error_from_errno (errno),\n                                     _(\"Failure reading GIF: %s\"), strerror (errno));\n                \n#ifdef IO_GIFDEBUG\n\t\tif (len < 100) {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tg_print (\"%d \", buffer[i]);\n\t\t}\n\t\tg_print (\"\\n\");\n#endif\n                \n\t\treturn retval;\n\t} else {\n#ifdef IO_GIFDEBUG\n/*  \t\tg_print (\"\\tlooking for %d bytes.  size == %d, ptr == %d\\n\", len, context->size, context->ptr); */\n#endif\n\t\tif ((context->size - context->ptr) >= len) {\n#ifdef IO_GIFDEBUG\n\t\t\tcount += len;\n#endif\n\t\t\tmemcpy (buffer, context->buf + context->ptr, len);\n\t\t\tcontext->ptr += len;\n\t\t\tcontext->amount_needed = 0;\n#ifdef IO_GIFDEBUG\n\t\t\tg_print (\"Psize :%d\\tcount :%d\\t\", len, count);\n\t\t\tif (len < 100) {\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t\tg_print (\"%d \", buffer[i]);\n\t\t\t}\n\t\t\tg_print (\"\\n\");\n#endif\n\t\t\treturn TRUE;\n\t\t}\n\t\tcontext->amount_needed = len - (context->size - context->ptr);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__tiff_image_load (FILE *f, GError **error)\n{\n\treturn gdk_pixbuf__tiff_image_load_real (f, NULL, error);\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__tiff_fill_vtable (GdkPixbufModule *module)\n{\n  module->load = gdk_pixbuf__tiff_image_load;\n  module->begin_load = gdk_pixbuf__tiff_image_begin_load;\n  module->stop_load = gdk_pixbuf__tiff_image_stop_load;\n  module->load_increment = gdk_pixbuf__tiff_image_load_increment;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__tiff_image_load_real (FILE *f, TiffData *context, GError **error)\n{\n\tTIFF *tiff;\n\tguchar *pixels = NULL;\n\tguchar *tmppix;\n\tgint w, h, x, y, num_pixs, fd;\n\tuint32 *rast, *tmp_rast;\n\tGdkPixbuf *pixbuf;\n\t\n\tfd = fileno (f);\n\ttiff = TIFFFdOpen (fd, \"libpixbuf-tiff\", \"r\");\n\n\tif (!tiff) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                             _(\"Failed to open TIFF image\"));\n\t\treturn NULL;\n        }\n                \n\tTIFFGetField (tiff, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField (tiff, TIFFTAG_IMAGELENGTH, &h);\n\tnum_pixs = w * h;\n\tpixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, w, h);\n\n        if (!pixbuf) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                             _(\"Insufficient memory to open TIFF file\"));\n\t\tTIFFClose (tiff);\n\t\treturn NULL;\n        }\n        \n\tif (context)\n\t\t(* context->prepare_func) (pixbuf, NULL, context->user_data);\n\n\t/* Yes, it needs to be _TIFFMalloc... */\n\trast = (uint32 *) _TIFFmalloc (num_pixs * sizeof (uint32));\n\n\tif (!rast) {\n                g_set_error (error,\n                             GDK_PIXBUF_ERROR,\n                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                             _(\"Insufficient memory to open TIFF file\"));\n\t\tTIFFClose (tiff);\n\t\treturn NULL;\n\t}\n\n\tif (TIFFReadRGBAImage (tiff, w, h, rast, 0)) {\n\t\tpixels = gdk_pixbuf_get_pixels (pixbuf);\n\n                g_assert (pixels);\n                \n\t\ttmppix = pixels;\n\n\t\tfor (y = 0; y < h; y++) {\n\t\t\t/* Unexplainable...are tiffs backwards? */\n\t\t\t/* Also looking at the GIMP plugin, this\n\t\t\t * whole reading thing can be a bit more\n\t\t\t * robust.\n\t\t\t */\n\t\t\ttmp_rast = rast + ((h - y - 1) * w);\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\ttmppix[0] = TIFFGetR (*tmp_rast);\n\t\t\t\ttmppix[1] = TIFFGetG (*tmp_rast);\n\t\t\t\ttmppix[2] = TIFFGetB (*tmp_rast);\n\t\t\t\ttmppix[3] = TIFFGetA (*tmp_rast);\n\t\t\t\ttmp_rast++;\n\t\t\t\ttmppix += 4;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree (rast);\n\tTIFFClose (tiff);\n\n\tif (context) {\n\t\t(* context->update_func) (pixbuf, 0, 0, w, h, context->user_data);\n\t\tgdk_pixbuf_unref (pixbuf);\n\t}\n\n\treturn pixbuf;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__tiff_image_load_increment (gpointer data, const guchar *buf,\n                                       guint size, GError **error)\n{\n\tTiffData *context = (TiffData *) data;\n\n\tg_return_val_if_fail (data != NULL, FALSE);\n\n\tif (fwrite (buf, sizeof (guchar), size, context->file) != size) {\n\t\tcontext->all_okay = FALSE;\n                g_set_error (error,\n                             G_FILE_ERROR,\n                             g_file_error_from_errno (errno),\n                             _(\"Failed to write to temporary file when loading TIFF image\"));\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf_loader_write (GdkPixbufLoader *loader,\n\t\t\t const guchar    *buf,\n\t\t\t gsize            count,\n                         GError         **error)\n{\n  GdkPixbufLoaderPrivate *priv;\n  \n  g_return_val_if_fail (loader != NULL, FALSE);\n  g_return_val_if_fail (GDK_IS_PIXBUF_LOADER (loader), FALSE);\n  \n  g_return_val_if_fail (buf != NULL, FALSE);\n  g_return_val_if_fail (count >= 0, FALSE);\n  \n  priv = loader->priv;\n  \n  /* we expect it's not to be closed */\n  g_return_val_if_fail (priv->closed == FALSE, FALSE);\n  \n  if (priv->image_module == NULL)\n    {\n      gint eaten;\n      \n      eaten = gdk_pixbuf_loader_eat_header_write (loader, buf, count, error);\n      if (eaten <= 0)\n\treturn FALSE;\n      \n      count -= eaten;\n      buf += eaten;\n    }\n  \n  if (count > 0 && priv->image_module->load_increment)\n    {\n      gboolean retval;\n      retval = priv->image_module->load_increment (priv->context, buf, count,\n                                                   error);\n      if (!retval && error && *error == NULL)\n        {\n          /* Fix up busted image loader */\n          g_warning (\"Bug! loader '%s' didn't set an error on failure\",\n                     priv->image_module->module_name);\n          g_set_error (error,\n                       GDK_PIXBUF_ERROR,\n                       GDK_PIXBUF_ERROR_FAILED,\n                       _(\"Internal error: Image loader module '%s'\"\n                         \" failed to begin loading an image, but didn't\"\n                         \" give a reason for the failure\"),\n                       priv->image_module->module_name);\n        }\n\n      return retval;\n    }\n      \n  return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__gif_image_begin_load (ModulePreparedNotifyFunc prepare_func,\n\t\t\t\t  ModuleUpdatedNotifyFunc update_func,\n\t\t\t\t  gpointer user_data,\n                                  GError **error)\n{\n\tGifContext *context;\n\n#ifdef IO_GIFDEBUG\n\tcount = 0;\n#endif\n\tcontext = new_context ();\n        context->error = error;\n\tcontext->prepare_func = prepare_func;\n\tcontext->update_func = update_func;\n\tcontext->user_data = user_data;\n\n\treturn (gpointer) context;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__gif_image_load (FILE *file, GError **error)\n{\n\tGifContext *context;\n\tGdkPixbuf *pixbuf;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\tcontext->file = file;\n        context->error = error;\n        \n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n        }\n        \n        pixbuf = gdk_pixbuf_animation_get_static_image (GDK_PIXBUF_ANIMATION (context->animation));\n\n        if (pixbuf)\n                g_object_ref (G_OBJECT (pixbuf));\n\n        g_object_unref (G_OBJECT (context->animation));\n        \n        g_free (context->buf);\n\tg_free (context);\n \n\treturn pixbuf;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__png_image_save (FILE          *f, \n                            GdkPixbuf     *pixbuf, \n                            gchar        **keys,\n                            gchar        **values,\n                            GError       **error)\n{\n       png_structp png_ptr;\n       png_infop info_ptr;\n       guchar *ptr;\n       guchar *pixels;\n       int x, y, j;\n       png_bytep row_ptr, data = NULL;\n       png_color_8 sig_bit;\n       int w, h, rowstride;\n       int has_alpha;\n       int bpc;\n\n       if (keys && *keys) {\n               g_warning (\"Bad option name '%s' passed to PNG saver\",\n                          *keys);\n               return FALSE;\n#if 0\n               gchar **kiter = keys;\n               gchar **viter = values;\n\n               \n               while (*kiter) {\n                       \n                       ++kiter;\n                       ++viter;\n               }\n#endif\n       }\n       \n       bpc = gdk_pixbuf_get_bits_per_sample (pixbuf);\n       w = gdk_pixbuf_get_width (pixbuf);\n       h = gdk_pixbuf_get_height (pixbuf);\n       rowstride = gdk_pixbuf_get_rowstride (pixbuf);\n       has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);\n       pixels = gdk_pixbuf_get_pixels (pixbuf);\n\n       png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING,\n                                          error,\n                                          png_simple_error_callback,\n                                          png_simple_warning_callback);\n\n       g_return_val_if_fail (png_ptr != NULL, FALSE);\n\n       info_ptr = png_create_info_struct (png_ptr);\n       if (info_ptr == NULL) {\n               png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n               return FALSE;\n       }\n       if (setjmp (png_ptr->jmpbuf)) {\n               png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n               return FALSE;\n       }\n       png_init_io (png_ptr, f);\n       if (has_alpha) {\n               png_set_IHDR (png_ptr, info_ptr, w, h, bpc,\n                             PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE,\n                             PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n#ifdef WORDS_BIGENDIAN\n               png_set_swap_alpha (png_ptr);\n#else\n               png_set_bgr (png_ptr);\n#endif\n       } else {\n               png_set_IHDR (png_ptr, info_ptr, w, h, bpc,\n                             PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,\n                             PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n               data = g_try_malloc (w * 3 * sizeof (char));\n\n               if (data == NULL) {\n                       /* Check error NULL, normally this would be broken,\n                        * but libpng makes me want to code defensively.\n                        */\n                       if (error && *error == NULL) {\n                               g_set_error (error,\n                                            GDK_PIXBUF_ERROR,\n                                            GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,\n                                            _(\"Insufficient memory to save PNG file\"));\n                       }\n                       png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n                       return FALSE;\n               }\n       }\n       sig_bit.red = bpc;\n       sig_bit.green = bpc;\n       sig_bit.blue = bpc;\n       sig_bit.alpha = bpc;\n       png_set_sBIT (png_ptr, info_ptr, &sig_bit);\n       png_write_info (png_ptr, info_ptr);\n       png_set_shift (png_ptr, &sig_bit);\n       png_set_packing (png_ptr);\n\n       ptr = pixels;\n       for (y = 0; y < h; y++) {\n               if (has_alpha)\n                       row_ptr = (png_bytep)ptr;\n               else {\n                       for (j = 0, x = 0; x < w; x++)\n                               memcpy (&(data[x*3]), &(ptr[x*3]), 3);\n\n                       row_ptr = (png_bytep)data;\n               }\n               png_write_rows (png_ptr, &row_ptr, 1);\n               ptr += rowstride;\n       }\n\n       if (data)\n               g_free (data);\n\n       png_write_end (png_ptr, info_ptr);\n       png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n\n       return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "new_context (void)\n{\n\tGifContext *context;\n\n\tcontext = g_new0 (GifContext, 1);\n\n        context->animation = g_object_new (GDK_TYPE_PIXBUF_GIF_ANIM, NULL);        \n\tcontext->frame = NULL;\n\tcontext->file = NULL;\n\tcontext->state = GIF_START;\n\tcontext->prepare_func = NULL;\n\tcontext->update_func = NULL;\n\tcontext->user_data = NULL;\n\tcontext->buf = NULL;\n\tcontext->amount_needed = 0;\n\tcontext->gif89.transparent = -1;\n\tcontext->gif89.delay_time = -1;\n\tcontext->gif89.input_flag = -1;\n\tcontext->gif89.disposal = -1;\n\n\treturn context;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__gif_image_load_increment (gpointer data,\n                                      const guchar *buf, guint size,\n                                      GError **error)\n{\n\tgint retval;\n\tGifContext *context = (GifContext *) data;\n\n        context->error = error;\n        \n\tif (context->amount_needed == 0) {\n\t\t/* we aren't looking for some bytes. */\n\t\t/* we can use buf now, but we don't want to keep it around at all.\n\t\t * it will be gone by the end of the call. */\n\t\tcontext->buf = (guchar*) buf; /* very dubious const cast */\n\t\tcontext->ptr = 0;\n\t\tcontext->size = size;\n\t} else {\n\t\t/* we need some bytes */\n\t\tif (size < context->amount_needed) {\n\t\t\tcontext->amount_needed -= size;\n\t\t\t/* copy it over and return */\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t\treturn TRUE;\n\t\t} else if (size == context->amount_needed) {\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t} else {\n\t\t\tcontext->buf = g_realloc (context->buf, context->size + size);\n\t\t\tmemcpy (context->buf + context->size, buf, size);\n\t\t\tcontext->size += size;\n\t\t}\n\t}\n\n\tretval = gif_main_loop (context);\n\n\tif (retval == -2)\n\t\treturn FALSE;\n\tif (retval == -1) {\n\t\t/* we didn't have enough memory */\n\t\t/* prepare for the next image_load_increment */\n\t\tif (context->buf == buf) {\n\t\t\tg_assert (context->size == size);\n\t\t\tcontext->buf = (guchar *)g_new (guchar, context->amount_needed + (context->size - context->ptr));\n\t\t\tmemcpy (context->buf, buf + context->ptr, context->size - context->ptr);\n\t\t} else {\n\t\t\t/* copy the left overs to the begining of the buffer */\n\t\t\t/* and realloc the memory */\n\t\t\tmemmove (context->buf, context->buf + context->ptr, context->size - context->ptr);\n\t\t\tcontext->buf = g_realloc (context->buf, context->amount_needed + (context->size - context->ptr));\n\t\t}\n\t\tcontext->size = context->size - context->ptr;\n\t\tcontext->ptr = 0;\n\t} else {\n\t\t/* we are prolly all done */\n\t\tif (context->buf == buf)\n\t\t\tcontext->buf = NULL;\n\t}\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gdk_pixbuf__tiff_image_stop_load (gpointer data,\n                                  GError **error)\n{\n\tTiffData *context = (TiffData*) data;\n        gboolean retval = FALSE;\n        \n\tg_return_val_if_fail (data != NULL, TRUE);\n\n\tfflush (context->file);\n\trewind (context->file);\n\tif (context->all_okay) {\n                GdkPixbuf *pixbuf;\n\t\tpixbuf = gdk_pixbuf__tiff_image_load_real (context->file, context, error);\n                if (pixbuf != NULL)\n                        retval = TRUE;\n        }\n\n\tfclose (context->file);\n\tunlink (context->tempname);\n\tg_free (context->tempname);\n\tg_free ((TiffData *) context);\n\n        return TRUE;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "gif_prepare_lzw (GifContext *context)\n{\n\tgint i;\n\n\tif (!gif_read (context, &(context->lzw_set_code_size), 1)) {\n\t\t/*g_message (_(\"GIF: EOF / read error on image data\\n\"));*/\n\t\treturn -1;\n\t}\n\n\tcontext->lzw_code_size = context->lzw_set_code_size + 1;\n\tcontext->lzw_clear_code = 1 << context->lzw_set_code_size;\n\tcontext->lzw_end_code = context->lzw_clear_code + 1;\n\tcontext->lzw_max_code_size = 2 * context->lzw_clear_code;\n\tcontext->lzw_max_code = context->lzw_clear_code + 2;\n\tcontext->lzw_fresh = TRUE;\n\tcontext->code_curbit = 0;\n\tcontext->code_lastbit = 0;\n\tcontext->code_last_byte = 0;\n\tcontext->code_done = FALSE;\n\n\tfor (i = 0; i < context->lzw_clear_code; ++i) {\n\t\tcontext->lzw_table[0][i] = 0;\n\t\tcontext->lzw_table[1][i] = i;\n\t}\n\tfor (; i < (1 << MAX_LZW_BITS); ++i)\n\t\tcontext->lzw_table[0][i] = context->lzw_table[1][0] = 0;\n\n\tcontext->lzw_sp = context->lzw_stack;\n\tgif_set_get_lzw (context);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Initial stab at getting the focus code to work.\n\nFri Jun  1 18:54:47 2001  Jonathan Blandford  <jrb@redhat.com>\n\n\t* gtk/gtktreeview.c: (gtk_tree_view_focus): Initial stab at\n\tgetting the focus code to work.\n\t(gtk_tree_view_class_init): Add a bunch of keybindings.\n\n\t* gtk/gtktreeviewcolumn.c\n\t(gtk_tree_view_column_set_cell_data_func):\n\ts/GtkCellDataFunc/GtkTreeCellDataFunc.\n\t(_gtk_tree_view_column_set_tree_view): Use \"notify::model\" instead\n\tof \"properties_changed\" to help justify the death of the latter\n\tsignal. (-:\n\n\t* tests/testtreefocus.c (main): Let some columns be focussable to\n\ttest focus better."}
{"func": "load_image (gchar *filename)\n{\n  FILE *fd;\n  char * name_buf;\n  unsigned char buf[16];\n  unsigned char c;\n  CMap localColorMap;\n  int grayScale;\n  int useGlobalColormap;\n  int bitPixel;\n  int imageCount = 0;\n  char version[4];\n  gint32 image_ID = -1;\n\n  fd = fopen (filename, \"rb\");\n  if (!fd)\n    {\n      g_message (\"GIF: can't open \\\"%s\\\"\\n\", filename);\n      return -1;\n    }\n\n  if (run_mode != GIMP_RUN_NONINTERACTIVE)\n    {\n      name_buf = g_strdup_printf (_(\"Loading %s:\"), filename);\n      gimp_progress_init (name_buf);\n      g_free (name_buf);\n    }\n\n  if (!ReadOK (fd, buf, 6))\n    {\n      g_message (\"GIF: error reading magic number\\n\");\n      return -1;\n    }\n\n  if (strncmp ((char *) buf, \"GIF\", 3) != 0)\n    {\n      g_message (\"GIF: not a GIF file\\n\");\n      return -1;\n    }\n\n  strncpy (version, (char *) buf + 3, 3);\n  version[3] = '\\0';\n\n  if ((strcmp (version, \"87a\") != 0) && (strcmp (version, \"89a\") != 0))\n    {\n      g_message (\"GIF: bad version number, not '87a' or '89a'\\n\");\n      return -1;\n    }\n\n  if (!ReadOK (fd, buf, 7))\n    {\n      g_message (\"GIF: failed to read screen descriptor\\n\");\n      return -1;\n    }\n\n  GifScreen.Width = LM_to_uint (buf[0], buf[1]);\n  GifScreen.Height = LM_to_uint (buf[2], buf[3]);\n  GifScreen.BitPixel = 2 << (buf[4] & 0x07);\n  GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);\n  GifScreen.Background = buf[5];\n  GifScreen.AspectRatio = buf[6];\n\n  if (BitSet (buf[4], LOCALCOLORMAP))\n    {\n      /* Global Colormap */\n      if (ReadColorMap (fd, GifScreen.BitPixel, GifScreen.ColorMap, &GifScreen.GrayScale))\n\t{\n\t  g_message (\"GIF: error reading global colormap\\n\");\n\t  return -1;\n\t}\n    }\n\n  if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)\n    {\n      g_message (\"GIF: warning - non-square pixels\\n\");\n    }\n\n\n  highest_used_index = 0;\n      \n\n  for (;;)\n    {\n      if (!ReadOK (fd, &c, 1))\n\t{\n\t  g_message (\"GIF: EOF / read error on image data\\n\");\n\t  return image_ID; /* will be -1 if failed on first image! */\n\t}\n\n      if (c == ';')\n\t{\n\t  /* GIF terminator */\n\t  return image_ID;\n\t}\n\n      if (c == '!')\n\t{\n\t  /* Extension */\n\t  if (!ReadOK (fd, &c, 1))\n\t    {\n\t      g_message (\"GIF: EOF / read error on extension function code\\n\");\n\t      return image_ID; /* will be -1 if failed on first image! */\n\t    }\n\t  DoExtension (fd, c);\n\t  continue;\n\t}\n\n      if (c != ',')\n\t{\n\t  /* Not a valid start character */\n\t  g_warning (\"GIF: bogus character 0x%02x, ignoring\\n\", (int) c);\n\t  continue;\n\t}\n\n      ++imageCount;\n\n      if (!ReadOK (fd, buf, 9))\n\t{\n\t  g_message (\"GIF: couldn't read left/top/width/height\\n\");\n\t  return image_ID; /* will be -1 if failed on first image! */\n\t}\n\n      useGlobalColormap = !BitSet (buf[8], LOCALCOLORMAP);\n\n      bitPixel = 1 << ((buf[8] & 0x07) + 1);\n\n      if (!useGlobalColormap)\n\t{\n\t  if (ReadColorMap (fd, bitPixel, localColorMap, &grayScale))\n\t    {\n\t      g_message (\"GIF: error reading local colormap\\n\");\n\t      return image_ID; /* will be -1 if failed on first image! */\n\t    }\n\t  image_ID = ReadImage (fd, filename, LM_to_uint (buf[4], buf[5]),\n\t\t\t\tLM_to_uint (buf[6], buf[7]),\n\t\t\t\tlocalColorMap, bitPixel,\n\t\t\t\tgrayScale,\n\t\t\t\tBitSet (buf[8], INTERLACE), imageCount,\n\t\t\t\t(guint) LM_to_uint (buf[0], buf[1]),\n\t\t\t\t(guint) LM_to_uint (buf[2], buf[3]),\n\t\t\t\tGifScreen.Width,\n\t\t\t\tGifScreen.Height\n\t\t\t\t);\n\t}\n      else\n\t{\n\t  image_ID = ReadImage (fd, filename, LM_to_uint (buf[4], buf[5]),\n\t\t\t\tLM_to_uint (buf[6], buf[7]),\n\t\t\t\tGifScreen.ColorMap, GifScreen.BitPixel,\n\t\t\t\tGifScreen.GrayScale,\n\t\t\t\tBitSet (buf[8], INTERLACE), imageCount,\n\t\t\t\t(guint) LM_to_uint (buf[0], buf[1]),\n\t\t\t\t(guint) LM_to_uint (buf[2], buf[3]),\n\t\t\t\tGifScreen.Width,\n\t\t\t\tGifScreen.Height\n\t\t\t\t);\n\t}\n\n#ifdef FACEHUGGERS\n      if (comment_parasite != NULL)\n\t{\n\t  gimp_image_parasite_attach (image_ID, comment_parasite);\n\t  gimp_parasite_free (comment_parasite);\n\t  comment_parasite = NULL;\n\t}\n#endif\n\n    }\n\n  return image_ID;\n}", "target": 1, "cwe": ["CWE-20"], "message": "When initializing the LZW state, watch out for a completely bogus\n\n\n\t* plug-ins/common/gifload.c: When initializing the LZW state,\n\twatch out for a completely bogus input_code_size [based on fix\n\tby Raphael Quinet]  Also, fix a stupid old bug when clearing the\n\tcode table between subimages.  (Enables us to deal better with errors\n\twhen the stream is corrupted pretty early in a subimage.) [me]"}
{"func": "LZWReadByte (FILE *fd,\n\t     int   flag,\n\t     int   input_code_size)\n{\n  static int fresh = FALSE;\n  int code, incode;\n  static int code_size, set_code_size;\n  static int max_code, max_code_size;\n  static int firstcode, oldcode;\n  static int clear_code, end_code;\n  static int table[2][(1 << MAX_LZW_BITS)];\n  static int stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  register int i;\n\n  if (flag)\n    {\n      set_code_size = input_code_size;\n      code_size = set_code_size + 1;\n      clear_code = 1 << set_code_size;\n      end_code = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      for (i = 0; i < clear_code; ++i)\n\t{\n\t  table[0][i] = 0;\n\t  table[1][i] = i;\n\t}\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n\ttable[0][i] = table[1][0] = 0;\n\n      sp = stack;\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n\t{\n\t  firstcode = oldcode =\n\t    GetCode (fd, code_size, FALSE);\n\t}\n      while (firstcode == clear_code);\n      return firstcode;\n    }\n\n  if (sp > stack)\n    return *--sp;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n\t{\n\t  for (i = 0; i < clear_code; ++i)\n\t    {\n\t      table[0][i] = 0;\n\t      table[1][i] = i;\n\t    }\n\t  for (; i < (1 << MAX_LZW_BITS); ++i)\n\t    table[0][i] = table[1][i] = 0;\n\t  code_size = set_code_size + 1;\n\t  max_code_size = 2 * clear_code;\n\t  max_code = clear_code + 2;\n\t  sp = stack;\n\t  firstcode = oldcode =\n\t    GetCode (fd, code_size, FALSE);\n\t  return firstcode;\n\t}\n      else if (code == end_code)\n\t{\n\t  int count;\n\t  unsigned char buf[260];\n\n\t  if (ZeroDataBlock)\n\t    return -2;\n\n\t  while ((count = GetDataBlock (fd, buf)) > 0)\n\t    ;\n\n\t  if (count != 0)\n\t    g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\t  return -2;\n\t}\n\n      incode = code;\n\n      if (code >= max_code)\n\t{\n\t  *sp++ = firstcode;\n\t  code = oldcode;\n\t}\n\n      while (code >= clear_code)\n\t{\n\t  *sp++ = table[1][code];\n\t  if (code == table[0][code])\n\t    {\n\t      g_message (\"GIF: circular table entry BIG ERROR\\n\");\n\t      gimp_quit ();\n\t    }\n\t  code = table[0][code];\n\t}\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n\t{\n\t  table[0][code] = oldcode;\n\t  table[1][code] = firstcode;\n\t  ++max_code;\n\t  if ((max_code >= max_code_size) &&\n\t      (max_code_size < (1 << MAX_LZW_BITS)))\n\t    {\n\t      max_code_size *= 2;\n\t      ++code_size;\n\t    }\n\t}\n\n      oldcode = incode;\n\n      if (sp > stack)\n\treturn *--sp;\n    }\n  return code;\n}", "target": 1, "cwe": ["CWE-20"], "message": "When initializing the LZW state, watch out for a completely bogus\n\n\n\t* plug-ins/common/gifload.c: When initializing the LZW state,\n\twatch out for a completely bogus input_code_size [based on fix\n\tby Raphael Quinet]  Also, fix a stupid old bug when clearing the\n\tcode table between subimages.  (Enables us to deal better with errors\n\twhen the stream is corrupted pretty early in a subimage.) [me]"}
{"func": "int parseLegacySyslogMsg(msg_t *pMsg, int flags)\n{\n\tuchar *p2parse;\n\tint lenMsg;\n\tint i;\t/* general index for parsing */\n\tuchar bufParseTAG[CONF_TAG_MAXSIZE];\n\tuchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];\n\tBEGINfunc\n\n\tassert(pMsg != NULL);\n\tassert(pMsg->pszRawMsg != NULL);\n\tlenMsg = pMsg->iLenRawMsg - pMsg->offAfterPRI; /* note: offAfterPRI is already the number of PRI chars (do not add one!) */\n\tp2parse = pMsg->pszRawMsg + pMsg->offAfterPRI; /* point to start of text, after PRI */\n\n\t/* Check to see if msg contains a timestamp. We start by assuming\n\t * that the message timestamp is the time of reception (which we \n\t * generated ourselfs and then try to actually find one inside the\n\t * message. There we go from high-to low precison and are done\n\t * when we find a matching one. -- rgerhards, 2008-09-16\n\t */\n\tif(datetime.ParseTIMESTAMP3339(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3339 */;\n\t} else if(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t} else if(*p2parse == ' ' && lenMsg > 1) { /* try to see if it is slighly malformed - HP procurve seems to do that sometimes */\n\t\t++p2parse;\t/* move over space */\n\t\t--lenMsg;\n\t\tif(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t\t/* indeed, we got it! */\n\t\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t\t} else {/* parse pointer needs to be restored, as we moved it off-by-one\n\t\t\t * for this try.\n\t\t\t */\n\t\t\t--p2parse;\n\t\t\t++lenMsg;\n\t\t}\n\t}\n\n\tif(flags & IGNDATE) {\n\t\t/* we need to ignore the msg data, so simply copy over reception date */\n\t\tmemcpy(&pMsg->tTIMESTAMP, &pMsg->tRcvdAt, sizeof(struct syslogTime));\n\t}\n\n\t/* rgerhards, 2006-03-13: next, we parse the hostname and tag. But we \n\t * do this only when the user has not forbidden this. I now introduce some\n\t * code that allows a user to configure rsyslogd to treat the rest of the\n\t * message as MSG part completely. In this case, the hostname will be the\n\t * machine that we received the message from and the tag will be empty. This\n\t * is meant to be an interim solution, but for now it is in the code.\n\t */\n\tif(bParseHOSTNAMEandTAG && !(flags & INTERNAL_MSG)) {\n\t\t/* parse HOSTNAME - but only if this is network-received!\n\t\t * rger, 2005-11-14: we still have a problem with BSD messages. These messages\n\t\t * do NOT include a host name. In most cases, this leads to the TAG to be treated\n\t\t * as hostname and the first word of the message as the TAG. Clearly, this is not\n\t\t * of advantage ;) I think I have now found a way to handle this situation: there\n\t\t * are certain characters which are frequently used in TAG (e.g. ':'), which are\n\t\t * *invalid* in host names. So while parsing the hostname, I check for these characters.\n\t\t * If I find them, I set a simple flag but continue. After parsing, I check the flag.\n\t\t * If it was set, then we most probably do not have a hostname but a TAG. Thus, I change\n\t\t * the fields. I think this logic shall work with any type of syslog message.\n\t\t * rgerhards, 2009-06-23: and I now have extended this logic to every character\n\t\t * that is not a valid hostname.\n\t\t */\n\t\tif(lenMsg > 0 && flags & PARSE_HOSTNAME) {\n\t\t\ti = 0;\n\t\t\twhile(i < lenMsg && (isalnum(p2parse[i]) || p2parse[i] == '.' || p2parse[i] == '.'\n\t\t\t\t|| p2parse[i] == '_' || p2parse[i] == '-') && i < (CONF_HOSTNAME_MAXSIZE - 1)) {\n\t\t\t\tbufParseHOSTNAME[i] = p2parse[i];\n\t\t\t\t++i;\n\t\t\t}\n\n\t\t\tif(i == lenMsg) {\n\t\t\t\t/* we have a message that is empty immediately after the hostname,\n\t\t\t\t * but the hostname thus is valid! -- rgerhards, 2010-02-22\n\t\t\t\t */\n\t\t\t\tp2parse += i;\n\t\t\t\tlenMsg -= i;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t} else if(i > 0 && p2parse[i] == ' ' && isalnum(p2parse[i-1])) {\n\t\t\t\t/* we got a hostname! */\n\t\t\t\tp2parse += i + 1; /* \"eat\" it (including SP delimiter) */\n\t\t\t\tlenMsg -= i + 1;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t}\n\t\t}\n\n\t\t/* now parse TAG - that should be present in message from all sources.\n\t\t * This code is somewhat not compliant with RFC 3164. As of 3164,\n\t\t * the TAG field is ended by any non-alphanumeric character. In\n\t\t * practice, however, the TAG often contains dashes and other things,\n\t\t * which would end the TAG. So it is not desirable. As such, we only\n\t\t * accept colon and SP to be terminators. Even there is a slight difference:\n\t\t * a colon is PART of the TAG, while a SP is NOT part of the tag\n\t\t * (it is CONTENT). Starting 2008-04-04, we have removed the 32 character\n\t\t * size limit (from RFC3164) on the tag. This had bad effects on existing\n\t\t * envrionments, as sysklogd didn't obey it either (probably another bug\n\t\t * in RFC3164...). We now receive the full size, but will modify the\n\t\t * outputs so that only 32 characters max are used by default.\n\t\t */\n\t\ti = 0;\n\t\twhile(lenMsg > 0 && *p2parse != ':' && *p2parse != ' ' && i < CONF_TAG_MAXSIZE) {\n\t\t\tbufParseTAG[i++] = *p2parse++;\n\t\t\t--lenMsg;\n\t\t}\n\t\tif(lenMsg > 0 && *p2parse == ':') {\n\t\t\t++p2parse; \n\t\t\t--lenMsg;\n\t\t\tbufParseTAG[i++] = ':';\n\t\t}\n\n\t\t/* no TAG can only be detected if the message immediatly ends, in which case an empty TAG\n\t\t * is considered OK. So we do not need to check for empty TAG. -- rgerhards, 2009-06-23\n\t\t */\n\t\tbufParseTAG[i] = '\\0';\t/* terminate string */\n\t\tMsgSetTAG(pMsg, bufParseTAG, i);\n\t} else {/* we enter this code area when the user has instructed rsyslog NOT\n\t\t * to parse HOSTNAME and TAG - rgerhards, 2006-03-13\n\t\t */\n\t\tif(!(flags & INTERNAL_MSG)) {\n\t\t\tDBGPRINTF(\"HOSTNAME and TAG not parsed by user configuraton.\\n\");\n\t\t}\n\t}\n\n\t/* The rest is the actual MSG */\n\tMsgSetMSGoffs(pMsg, p2parse - pMsg->pszRawMsg);\n\n\tENDfunc\n\treturn 0; /* all ok */\n}", "target": 1, "cwe": ["CWE-119"], "message": "bugfix: off-by-one(two) bug in legacy syslog parser"}
{"func": "LZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n  static gint stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode & 255;\n    }\n\n  if (sp > stack)\n    return (*--sp) & 255;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode & 255;\n        }\n      else if (code == end_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code >= max_code)\n        {\n          *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code)\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return (*--sp) & 255;\n    }\n\n  return code & 255;\n}", "target": 1, "cwe": ["CWE-787"], "message": "file-gif-load: fix heap corruption and buffer overflow (CVE-2011-2896)"}
{"func": "ssize_t tpm_write(struct file *file, const char __user *buf,\n\t\t  size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tsize_t in_size = size, out_size;\n\n\t/* cannot perform a write until the read has cleared\n\t   either via tpm_read or a user_read_timer timeout */\n\twhile (atomic_read(&chip->data_pending) != 0)\n\t\tmsleep(TPM_TIMEOUT);\n\n\tmutex_lock(&chip->buffer_mutex);\n\n\tif (in_size > TPM_BUFSIZE)\n\t\tin_size = TPM_BUFSIZE;\n\n\tif (copy_from_user\n\t    (chip->data_buffer, (void __user *) buf, in_size)) {\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\t/* atomic tpm command send and result receive */\n\tout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\n\n\tatomic_set(&chip->data_pending, out_size);\n\tmutex_unlock(&chip->buffer_mutex);\n\n\t/* Set a timeout by which the reader must come claim the result */\n\tmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\n\n\treturn in_size;\n}", "target": 1, "cwe": ["CWE-200"], "message": "TPM: Call tpm_transmit with correct size\n\nThis patch changes the call of tpm_transmit by supplying the size of the\nuserspace buffer instead of TPM_BUFSIZE.\n\nThis got assigned CVE-2011-1161.\n\n[The first hunk didn't make much sense given one could expect\n way less data than TPM_BUFSIZE, so added tpm_transmit boundary\n check over bufsiz instead]\nSigned-off-by: Rajiv Andrade <srajiv@linux.vnet.ibm.com>"}
{"func": "static ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\n\t\t\t    size_t bufsiz)\n{\n\tssize_t rc;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\n\tcount = be32_to_cpu(*((__be32 *) (buf + 2)));\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(chip->dev,\n\t\t\t\"invalid count value %x %zx \\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\tmutex_lock(&chip->tpm_mutex);\n\n\tif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_send: error %zd\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (chip->vendor.irq)\n\t\tgoto out_recv;\n\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->vendor.status(chip);\n\t\tif ((status & chip->vendor.req_complete_mask) ==\n\t\t    chip->vendor.req_complete_val)\n\t\t\tgoto out_recv;\n\n\t\tif ((status == chip->vendor.req_canceled)) {\n\t\t\tdev_err(chip->dev, \"Operation Canceled\\n\");\n\t\t\trc = -ECANCELED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(TPM_TIMEOUT);\t/* CHECK */\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\n\tchip->vendor.cancel(chip);\n\tdev_err(chip->dev, \"Operation Timed out\\n\");\n\trc = -ETIME;\n\tgoto out;\n\nout_recv:\n\trc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\n\tif (rc < 0)\n\t\tdev_err(chip->dev,\n\t\t\t\"tpm_transmit: tpm_recv: error %zd\\n\", rc);\nout:\n\tmutex_unlock(&chip->tpm_mutex);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "message": "TPM: Call tpm_transmit with correct size\n\nThis patch changes the call of tpm_transmit by supplying the size of the\nuserspace buffer instead of TPM_BUFSIZE.\n\nThis got assigned CVE-2011-1161.\n\n[The first hunk didn't make much sense given one could expect\n way less data than TPM_BUFSIZE, so added tpm_transmit boundary\n check over bufsiz instead]\nSigned-off-by: Rajiv Andrade <srajiv@linux.vnet.ibm.com>"}
{"func": "ssize_t tpm_read(struct file *file, char __user *buf,\n\t\t size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tssize_t ret_size;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tret_size = atomic_read(&chip->data_pending);\n\tatomic_set(&chip->data_pending, 0);\n\tif (ret_size > 0) {\t/* relay data */\n\t\tif (size < ret_size)\n\t\t\tret_size = size;\n\n\t\tmutex_lock(&chip->buffer_mutex);\n\t\tif (copy_to_user(buf, chip->data_buffer, ret_size))\n\t\t\tret_size = -EFAULT;\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t}\n\n\treturn ret_size;\n}", "target": 1, "cwe": ["CWE-200"], "message": "TPM: Zero buffer after copying to userspace\n\nSince the buffer might contain security related data it might be a good idea to\nzero the buffer after we have copied it to userspace.\n\nThis got assigned CVE-2011-1162.\n\nSigned-off-by: Rajiv Andrade <srajiv@linux.vnet.ibm.com>"}
{"func": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int do_adjtimex(struct timex *txc)\n{\n\tlong mtemp, save_adjust, rem;\n\ts64 freq_adj;\n\tint result;\n\n\t/* In order to modify anything, you gotta be super-user! */\n\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\t/* Now we validate the data before disabling interrupts */\n\n\tif ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {\n\t  /* singleshot must not be used with any other mode bits */\n\t\tif (txc->modes != ADJ_OFFSET_SINGLESHOT &&\n\t\t\t\t\ttxc->modes != ADJ_OFFSET_SS_READ)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))\n\t  /* adjustment Offset limited to +- .512 seconds */\n\t\tif (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )\n\t\t\treturn -EINVAL;\n\n\t/* if the quartz is off by more than 10% something is VERY wrong ! */\n\tif (txc->modes & ADJ_TICK)\n\t\tif (txc->tick <  900000/USER_HZ ||\n\t\t    txc->tick > 1100000/USER_HZ)\n\t\t\treturn -EINVAL;\n\n\twrite_seqlock_irq(&xtime_lock);\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\n\t/* Save for later - semantics of adjtime is to return old value */\n\tsave_adjust = time_adjust;\n\n#if 0\t/* STA_CLOCKERR is never set yet */\n\ttime_status &= ~STA_CLOCKERR;\t\t/* reset STA_CLOCKERR */\n#endif\n\t/* If there are input parameters, then process them */\n\tif (txc->modes)\n\t{\n\t    if (txc->modes & ADJ_STATUS)\t/* only set allowed bits */\n\t\ttime_status =  (txc->status & ~STA_RONLY) |\n\t\t\t      (time_status & STA_RONLY);\n\n\t    if (txc->modes & ADJ_FREQUENCY) {\t/* p. 22 */\n\t\tif (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_freq = ((s64)txc->freq * NSEC_PER_USEC)\n\t\t\t\t>> (SHIFT_USEC - SHIFT_NSEC);\n\t    }\n\n\t    if (txc->modes & ADJ_MAXERROR) {\n\t\tif (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_maxerror = txc->maxerror;\n\t    }\n\n\t    if (txc->modes & ADJ_ESTERROR) {\n\t\tif (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_esterror = txc->esterror;\n\t    }\n\n\t    if (txc->modes & ADJ_TIMECONST) {\t/* p. 24 */\n\t\tif (txc->constant < 0) {\t/* NTP v4 uses values > 6 */\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_constant = min(txc->constant + 4, (long)MAXTC);\n\t    }\n\n\t    if (txc->modes & ADJ_OFFSET) {\t/* values checked earlier */\n\t\tif (txc->modes == ADJ_OFFSET_SINGLESHOT) {\n\t\t    /* adjtime() is independent from ntp_adjtime() */\n\t\t    time_adjust = txc->offset;\n\t\t}\n\t\telse if (time_status & STA_PLL) {\n\t\t    time_offset = txc->offset * NSEC_PER_USEC;\n\n\t\t    /*\n\t\t     * Scale the phase adjustment and\n\t\t     * clamp to the operating range.\n\t\t     */\n\t\t    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);\n\t\t    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);\n\n\t\t    /*\n\t\t     * Select whether the frequency is to be controlled\n\t\t     * and in which mode (PLL or FLL). Clamp to the operating\n\t\t     * range. Ugly multiply/divide should be replaced someday.\n\t\t     */\n\n\t\t    if (time_status & STA_FREQHOLD || time_reftime == 0)\n\t\t        time_reftime = xtime.tv_sec;\n\t\t    mtemp = xtime.tv_sec - time_reftime;\n\t\t    time_reftime = xtime.tv_sec;\n\n\t\t    freq_adj = time_offset * mtemp;\n\t\t    freq_adj = shift_right(freq_adj, time_constant * 2 +\n\t\t\t\t\t   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);\n\t\t    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))\n\t\t\tfreq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);\n\t\t    freq_adj += time_freq;\n\t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n\t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n\t\t    time_offset = div_long_long_rem_signed(time_offset,\n\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n\t\t\t\t\t\t\t   &rem);\n\t\t    time_offset <<= SHIFT_UPDATE;\n\t\t} /* STA_PLL */\n\t    } /* txc->modes & ADJ_OFFSET */\n\t    if (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\t    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\t    ntp_update_frequency();\n\t} /* txc->modes */\nleave:\tif ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)\n\t\tresult = TIME_ERROR;\n\n\tif ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||\n\t\t\t(txc->modes == ADJ_OFFSET_SS_READ))\n\t\ttxc->offset = save_adjust;\n\telse\n\t\ttxc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *\n\t    \t\t\tNTP_INTERVAL_FREQ / 1000;\n\ttxc->freq\t   = (time_freq / NSEC_PER_USEC) <<\n\t\t\t\t(SHIFT_USEC - SHIFT_NSEC);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ;\n\ttxc->tick\t   = tick_usec;\n\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n\twrite_sequnlock_irq(&xtime_lock);\n\tdo_gettimeofday(&txc->time);\n\tnotify_cmos_timer();\n\treturn(result);\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\n\treturn dum2;\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\n\treturn res;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\n\tif (when == 0)\n\t\t/* Clear timer */\n\t\treturn 0;\n\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\t/* Fire the timer immediately */\n\t\t\twhen = 0;\n\t}\n\n\t/*\n\t * Convert to sgi clock period. Need to keep rtc_time() as near as possible\n\t * to getnstimeofday() in order to be as faithful as possible to the time\n\t * specified.\n\t */\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\n\t/*\n\t * We are allocating a local SHub comparator. If we would be moved to another\n\t * cpu then another SHub may be local to us. Prohibit that by switching off\n\t * preemption.\n\t */\n\tpreempt_disable();\n\n\tnodeid =  cpu_to_node(smp_processor_id());\n\n\t/* Lock the node timer structure */\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\n\tn = timers[nodeid].next;\n\n\t/* Add the new struct mmtimer to node's timer list */\n\tmmtimer_add_list(base);\n\n\tif (timers[nodeid].next == n) {\n\t\t/* No need to reprogram comparator for now */\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\n\t/* We need to reprogram the comparator */\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\n\tmmtimer_set_next_timer(nodeid);\n\n\t/* Unlock the node timer structure */\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\n\tpreempt_enable();\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tunsigned long remainder;\n\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\tl->min_time,\n\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\n\treturn ts;\n}", "target": 1, "cwe": ["CWE-189"], "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "pam_sm_authenticate (pam_handle_t * pamh,\n\t\t     int flags, int argc, const char **argv)\n{\n  int retval, rc;\n  const char *user = NULL;\n  const char *password = NULL;\n  char otp[MAX_TOKEN_ID_LEN + TOKEN_OTP_LEN + 1] = { 0 };\n  char otp_id[MAX_TOKEN_ID_LEN + 1] = { 0 };\n  int password_len = 0;\n  int skip_bytes = 0;\n  int valid_token = 0;\n  struct pam_conv *conv;\n  struct pam_message *pmsg[1], msg[1];\n  struct pam_response *resp;\n  int nargs = 1;\n  ykclient_t *ykc = NULL;\n  struct cfg cfg_st;\n  struct cfg *cfg = &cfg_st; /* for DBG macro */\n\n  parse_cfg (flags, argc, argv, cfg);\n\n  retval = pam_get_user (pamh, &user, NULL);\n  if (retval != PAM_SUCCESS)\n    {\n      DBG ((\"get user returned error: %s\", pam_strerror (pamh, retval)));\n      goto done;\n    }\n  DBG ((\"get user returned: %s\", user));\n\n  if (cfg->mode == CHRESP) {\n#if HAVE_LIBYKPERS_1\n    return do_challenge_response(pamh, cfg, user);\n#else\n    DBG ((\"no support for challenge/response\"));\n    retval = PAM_AUTH_ERR;\n    goto done;\n#endif\n  }\n\n  if (cfg->try_first_pass || cfg->use_first_pass)\n    {\n      retval = pam_get_item (pamh, PAM_AUTHTOK, (const void **) &password);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get password returned error: %s\",\n\t      pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n      DBG ((\"get password returned: %s\", password));\n    }\n\n  if (cfg->use_first_pass && password == NULL)\n    {\n      DBG ((\"use_first_pass set and no password, giving up\"));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  rc = ykclient_init (&ykc);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_init() failed (%d): %s\", rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  rc = ykclient_set_client_b64 (ykc, cfg->client_id, cfg->client_key);\n  if (rc != YKCLIENT_OK)\n    {\n      DBG ((\"ykclient_set_client_b64() failed (%d): %s\",\n\t    rc, ykclient_strerror (rc)));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  if (cfg->capath)\n    ykclient_set_ca_path (ykc, cfg->capath);\n\n  if (cfg->url)\n    ykclient_set_url_template (ykc, cfg->url);\n\n  if (password == NULL)\n    {\n      retval = pam_get_item (pamh, PAM_CONV, (const void **) &conv);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"get conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      pmsg[0] = &msg[0];\n      {\n\tconst char *query_template = \"Yubikey for `%s': \";\n\tsize_t len = strlen (query_template) + strlen (user);\n\tsize_t wrote;\n\n\tmsg[0].msg = malloc (len);\n\tif (!msg[0].msg)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n\n\twrote = snprintf ((char *) msg[0].msg, len, query_template, user);\n\tif (wrote < 0 || wrote >= len)\n\t  {\n\t    retval = PAM_BUF_ERR;\n\t    goto done;\n\t  }\n      }\n      msg[0].msg_style = cfg->verbose_otp ? PAM_PROMPT_ECHO_ON : PAM_PROMPT_ECHO_OFF;\n      resp = NULL;\n\n      retval = conv->conv (nargs, (const struct pam_message **) pmsg,\n\t\t\t   &resp, conv->appdata_ptr);\n\n      free ((char *) msg[0].msg);\n\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"conv returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n\n      if (resp->resp == NULL)\n\t{\n\t  DBG ((\"conv returned NULL passwd?\"));\n\t  goto done;\n\t}\n\n      DBG ((\"conv returned %i bytes\", strlen(resp->resp)));\n\n      password = resp->resp;\n    }\n\n  password_len = strlen (password);\n  if (password_len < (cfg->token_id_length + TOKEN_OTP_LEN))\n    {\n      DBG ((\"OTP too short to be considered : %i < %i\", password_len, (cfg->token_id_length + TOKEN_OTP_LEN)));\n      retval = PAM_AUTH_ERR;\n      goto done;\n    }\n\n  /* In case the input was systempassword+YubiKeyOTP, we want to skip over\n     \"systempassword\" when copying the token_id and OTP to separate buffers */\n  skip_bytes = password_len - (cfg->token_id_length + TOKEN_OTP_LEN);\n\n  DBG ((\"Skipping first %i bytes. Length is %i, token_id set to %i and token OTP always %i.\",\n\tskip_bytes, password_len, cfg->token_id_length, TOKEN_OTP_LEN));\n\n  /* Copy full YubiKey output (public ID + OTP) into otp */\n  strncpy (otp, password + skip_bytes, sizeof (otp) - 1);\n  /* Copy only public ID into otp_id. Destination buffer is zeroed. */\n  strncpy (otp_id, password + skip_bytes, cfg->token_id_length);\n\n  DBG ((\"OTP: %s ID: %s \", otp, otp_id));\n\n  /* user entered their system password followed by generated OTP? */\n  if (password_len > TOKEN_OTP_LEN + cfg->token_id_length)\n    {\n      char *onlypasswd = strdup (password);\n\n      onlypasswd[password_len - (TOKEN_OTP_LEN + cfg->token_id_length)] = '\\0';\n\n      DBG ((\"Extracted a probable system password entered before the OTP - \"\n\t    \"setting item PAM_AUTHTOK\"));\n\n      retval = pam_set_item (pamh, PAM_AUTHTOK, onlypasswd);\n      free (onlypasswd);\n      if (retval != PAM_SUCCESS)\n\t{\n\t  DBG ((\"set_item returned error: %s\", pam_strerror (pamh, retval)));\n\t  goto done;\n\t}\n    }\n  else\n    password = NULL;\n\n  rc = ykclient_request (ykc, otp);\n\n  DBG ((\"ykclient return value (%d): %s\", rc,\n\tykclient_strerror (rc)));\n\n  switch (rc)\n    {\n    case YKCLIENT_OK:\n      break;\n\n    case YKCLIENT_BAD_OTP:\n    case YKCLIENT_REPLAYED_OTP:\n      retval = PAM_AUTH_ERR;\n      goto done;\n\n    default:\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  /* authorize the user with supplied token id */\n  if (cfg->ldapserver != NULL || cfg->ldap_uri != NULL)\n    valid_token = authorize_user_token_ldap (cfg, user, otp_id);\n  else\n    valid_token = authorize_user_token (cfg, user, otp_id);\n\n  if (valid_token == 0)\n    {\n      DBG ((\"Yubikey not authorized to login as user\"));\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  if (ykc)\n    ykclient_done (&ykc);\n  if (cfg->alwaysok && retval != PAM_SUCCESS)\n    {\n      DBG ((\"alwaysok needed (otherwise return with %d)\", retval));\n      retval = PAM_SUCCESS;\n    }\n  DBG ((\"done. [%s]\", pam_strerror (pamh, retval)));\n  pam_set_data (pamh, \"yubico_setcred_return\", (void*) (intptr_t) retval, NULL);\n\n  return retval;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fix big security hole: Authentication succeeded when no password\nwas given, unless use_first_pass was being used.\nThis is fatal if pam_yubico is considered 'sufficient' in the PAM\nconfiguration.\n\nSigned-off-by: Nanakos Chrysostomos <nanakos@wired-net.gr>"}
{"func": "static struct wildmat *split_wildmats(char *str)\n{\n    const char *prefix;\n    char pattern[MAX_MAILBOX_BUFFER] = \"\", *p, *c;\n    struct wildmat *wild = NULL;\n    int n = 0;\n\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(pattern, sizeof(pattern), \"%s.\", prefix);\n    p = pattern + strlen(pattern);\n\n    /*\n     * split the list of wildmats\n     *\n     * we split them right to left because this is the order in which\n     * we want to test them (per RFC3977 section 4.2)\n     */\n    do {\n\tif ((c = strrchr(str, ',')))\n\t    *c++ = '\\0';\n\telse\n\t    c = str;\n\n\tif (!(n % 10)) /* alloc some more */\n\t    wild = xrealloc(wild, (n + 11) * sizeof(struct wildmat));\n\n\tif (*c == '!') wild[n].not = 1;\t\t/* not */\n\telse if (*c == '@') wild[n].not = -1;\t/* absolute not (feeding) */\n\telse wild[n].not = 0;\n\n\tstrcpy(p, wild[n].not ? c + 1 : c);\n\twild[n++].pat = xstrdup(pattern);\n    } while (c != str);\n    wild[n].pat = NULL;\n\n    return wild;\n}", "target": 1, "cwe": ["CWE-119"], "message": "CVE-2011-3208 - fix buffer overflow in nntpd"}
{"func": "xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {\n    if (ctxt->valueTab == NULL) {\n\t/* Allocate the value stack */\n\tctxt->valueTab = (xmlXPathObjectPtr *) \n\t\t\t xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n\tif (ctxt->valueTab == NULL) {\n\t    xmlXPtrErrMemory(\"allocating evaluation context\");\n\t    return;\n\t}\n\tctxt->valueNr = 0;\n\tctxt->valueMax = 10;\n\tctxt->value = NULL;\n    }\n    SKIP_BLANKS;\n    if (CUR == '/') {\n\txmlXPathRoot(ctxt);\n        xmlXPtrEvalChildSeq(ctxt, NULL);\n    } else {\n\txmlChar *name;\n\n\tname = xmlXPathParseName(ctxt);\n\tif (name == NULL)\n\t    XP_ERROR(XPATH_EXPR_ERROR);\n\tif (CUR == '(') {\n\t    xmlXPtrEvalFullXPtr(ctxt, name);\n\t    /* Short evaluation */\n\t    return;\n\t} else {\n\t    /* this handle both Bare Names and Child Sequences */\n\t    xmlXPtrEvalChildSeq(ctxt, name);\n\t}\n    }\n    SKIP_BLANKS;\n    if (CUR != 0)\n\tXP_ERROR(XPATH_EXPR_ERROR);\n}", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": " */\nstatic int\nxmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)\n{\n    xmlXPathCompExprPtr comp;\n\n    if ((ctxt == NULL) || (ctxt->comp == NULL))\n\treturn(-1);\n\n    if (ctxt->valueTab == NULL) {\n\t/* Allocate the value stack */\n\tctxt->valueTab = (xmlXPathObjectPtr *)\n\t\t\t xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n\tif (ctxt->valueTab == NULL) {\n\t    xmlXPathPErrMemory(ctxt, \"creating evaluation context\\n\");\n\t    xmlFree(ctxt);\n\t}\n\tctxt->valueNr = 0;\n\tctxt->valueMax = 10;\n\tctxt->value = NULL;\n    }\n#ifdef XPATH_STREAMING\n    if (ctxt->comp->stream) {\n\tint res;\n\n\tif (toBool) {\n\t    /*\n\t    * Evaluation to boolean result.\n\t    */\n\t    res = xmlXPathRunStreamEval(ctxt->context,\n\t\tctxt->comp->stream, NULL, 1);\n\t    if (res != -1)\n\t\treturn(res);\n\t} else {\n\t    xmlXPathObjectPtr resObj = NULL;\n\n\t    /*\n\t    * Evaluation to a sequence.\n\t    */\n\t    res = xmlXPathRunStreamEval(ctxt->context,\n\t\tctxt->comp->stream, &resObj, 0);\n\n\t    if ((res != -1) && (resObj != NULL)) {\n\t\tvaluePush(ctxt, resObj);\n\t\treturn(0);\n\t    }\n\t    if (resObj != NULL)\n\t\txmlXPathReleaseObject(ctxt->context, resObj);\n\t}\n\t/*\n\t* QUESTION TODO: This falls back to normal XPath evaluation\n\t* if res == -1. Is this intended?\n\t*/\n    }\n#endif\n    comp = ctxt->comp;\n    if (comp->last < 0) {\n\txmlGenericError(xmlGenericErrorContext,\n\t    \"xmlXPathRunEval: last is less than zero\\n\");\n\treturn(-1);\n    }\n    if (toBool)\n\treturn(xmlXPathCompOpEvalToBoolean(ctxt,\n\t    &comp->steps[comp->last], 0));\n    else\n\txmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": "\nstatic int\nxmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n\t\t\t\t      xmlXPathStepOpPtr op,\n\t\t\t\t      xmlNodeSetPtr set,\n\t\t\t\t      int contextSize,\n\t\t\t\t      int minPos,\n\t\t\t\t      int maxPos,\n\t\t\t\t      int hasNsNodes)\n{\n    if (op->ch1 != -1) {\n\txmlXPathCompExprPtr comp = ctxt->comp;\n\tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n\t    /*\n\t    * TODO: raise an internal error.\n\t    */\n\t}\n\tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n\t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n\tCHECK_ERROR0;\n\tif (contextSize <= 0)\n\t    return(0);\n    }\n    /*\n    * Check if the node set contains a sufficient number of nodes for\n    * the requested range.\n    */\n    if (contextSize < minPos) {\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\treturn(0);\n    }\n    if (op->ch2 == -1) {\n\t/*\n\t* TODO: Can this ever happen?\n\t*/\n\treturn (contextSize);\n    } else {\n\txmlDocPtr oldContextDoc;\n\tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n\txmlXPathStepOpPtr exprOp;\n\txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n\txmlNodePtr oldContextNode, contextNode = NULL;\n\txmlXPathContextPtr xpctxt = ctxt->context;\n\n#ifdef LIBXML_XPTR_ENABLED\n\t    /*\n\t    * URGENT TODO: Check the following:\n\t    *  We don't expect location sets if evaluating prediates, right?\n\t    *  Only filters should expect location sets, right?\n\t*/\n#endif /* LIBXML_XPTR_ENABLED */\n\n\t/*\n\t* Save old context.\n\t*/\n\toldContextNode = xpctxt->node;\n\toldContextDoc = xpctxt->doc;\n\t/*\n\t* Get the expression of this predicate.\n\t*/\n\texprOp = &ctxt->comp->steps[op->ch2];\n\tfor (i = 0; i < set->nodeNr; i++) {\n\t    if (set->nodeTab[i] == NULL)\n\t\tcontinue;\n\n\t    contextNode = set->nodeTab[i];\n\t    xpctxt->node = contextNode;\n\t    xpctxt->contextSize = contextSize;\n\t    xpctxt->proximityPosition = ++contextPos;\n\n\t    /*\n\t    * Initialize the new set.\n\t    * Also set the xpath document in case things like\n\t    * key() evaluation are attempted on the predicate\n\t    */\n\t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n\t\t(contextNode->doc != NULL))\n\t\txpctxt->doc = contextNode->doc;\n\t    /*\n\t    * Evaluate the predicate expression with 1 context node\n\t    * at a time; this node is packaged into a node set; this\n\t    * node set is handed over to the evaluation mechanism.\n\t    */\n\t    if (contextObj == NULL)\n\t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n\t    else\n\t\txmlXPathNodeSetAddUnique(contextObj->nodesetval,\n\t\t    contextNode);\n\n\t    valuePush(ctxt, contextObj);\n\t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n\n\t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n\t        xmlXPathObjectPtr tmp;\n\t\t/* pop the result if any */\n\t\ttmp = valuePop(ctxt);\n                if (tmp != contextObj) {\n                    /*\n                     * Free up the result\n                     * then pop off contextObj, which will be freed later\n                     */\n                    xmlXPathReleaseObject(xpctxt, tmp);\n                    valuePop(ctxt);\n                }\n\t\tgoto evaluation_error;\n\t    }\n\n\t    if (res)\n\t\tpos++;\n\n\t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n\t\t/*\n\t\t* Fits in the requested range.\n\t\t*/\n\t\tnewContextSize++;\n\t\tif (minPos == maxPos) {\n\t\t    /*\n\t\t    * Only 1 node was requested.\n\t\t    */\n\t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n\t\t\t/*\n\t\t\t* As always: take care of those nasty\n\t\t\t* namespace nodes.\n\t\t\t*/\n\t\t\tset->nodeTab[i] = NULL;\n\t\t    }\n\t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n\t\t    set->nodeNr = 1;\n\t\t    set->nodeTab[0] = contextNode;\n\t\t    goto evaluation_exit;\n\t\t}\n\t\tif (pos == maxPos) {\n\t\t    /*\n\t\t    * We are done.\n\t\t    */\n\t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n\t\t    goto evaluation_exit;\n\t\t}\n\t    } else {\n\t\t/*\n\t\t* Remove the entry from the initial node set.\n\t\t*/\n\t\tset->nodeTab[i] = NULL;\n\t\tif (contextNode->type == XML_NAMESPACE_DECL)\n\t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n\t    }\n\t    if (exprRes != NULL) {\n\t\txmlXPathReleaseObject(ctxt->context, exprRes);\n\t\texprRes = NULL;\n\t    }\n\t    if (ctxt->value == contextObj) {\n\t\t/*\n\t\t* Don't free the temporary XPath object holding the\n\t\t* context node, in order to avoid massive recreation\n\t\t* inside this loop.\n\t\t*/\n\t\tvaluePop(ctxt);\n\t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n\t    } else {\n\t\t/*\n\t\t* The object was lost in the evaluation machinery.\n\t\t* Can this happen? Maybe in case of internal-errors.\n\t\t*/\n\t\tcontextObj = NULL;\n\t    }\n\t}\n\tgoto evaluation_exit;\n\nevaluation_error:\n\txmlXPathNodeSetClear(set, hasNsNodes);\n\tnewContextSize = 0;\n\nevaluation_exit:\n\tif (contextObj != NULL) {\n\t    if (ctxt->value == contextObj)\n\t\tvaluePop(ctxt);\n\t    xmlXPathReleaseObject(xpctxt, contextObj);\n\t}\n\tif (exprRes != NULL)\n\t    xmlXPathReleaseObject(ctxt->context, exprRes);\n\t/*\n\t* Reset/invalidate the context.\n\t*/\n\txpctxt->node = oldContextNode;\n\txpctxt->doc = oldContextDoc;\n\txpctxt->contextSize = -1;\n\txpctxt->proximityPosition = -1;\n\treturn(newContextSize);\n    }", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": " */\nstatic xmlXPathParserContextPtr\nxmlXPathCompParserContext(xmlXPathCompExprPtr comp, xmlXPathContextPtr ctxt) {\n    xmlXPathParserContextPtr ret;\n\n    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));\n    if (ret == NULL) {\n        xmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n\n    /* Allocate the value stack */\n    ret->valueTab = (xmlXPathObjectPtr *)\n                     xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n    if (ret->valueTab == NULL) {\n\txmlFree(ret);\n\txmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n\treturn(NULL);\n    }\n    ret->valueNr = 0;\n    ret->valueMax = 10;\n    ret->value = NULL;\n\n    ret->context = ctxt;\n    ret->comp = comp;\n", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": " */\nstatic int\nxmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)\n{\n    int total = 0;\n    int equal, ret;\n    xmlXPathCompExprPtr comp;\n    xmlXPathObjectPtr arg1, arg2;\n    xmlNodePtr bak;\n    xmlDocPtr bakd;\n    int pp;\n    int cs;\n\n    CHECK_ERROR0;\n    comp = ctxt->comp;\n    switch (op->op) {\n        case XPATH_OP_END:\n            return (0);\n        case XPATH_OP_AND:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval &= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_OR:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            xmlXPathBooleanFunction(ctxt, 1);\n            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))\n                return (total);\n            arg2 = valuePop(ctxt);\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    if (ctxt->error) {\n\t\txmlXPathFreeObject(arg2);\n\t\treturn(0);\n\t    }\n            xmlXPathBooleanFunction(ctxt, 1);\n            arg1 = valuePop(ctxt);\n            arg1->boolval |= arg2->boolval;\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_EQUAL:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    if (op->value)\n\t\tequal = xmlXPathEqualValues(ctxt);\n\t    else\n\t\tequal = xmlXPathNotEqualValues(ctxt);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n            return (total);\n        case XPATH_OP_CMP:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);\n\t    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n            return (total);\n        case XPATH_OP_PLUS:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n\t\tctxt->context->doc = bakd;\n\t\tctxt->context->node = bak;\n\t\tctxt->context->proximityPosition = pp;\n\t\tctxt->context->contextSize = cs;\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    }\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathSubValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathAddValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathValueFlipSign(ctxt);\n            else if (op->value == 3) {\n                CAST_TO_NUMBER;\n                CHECK_TYPE0(XPATH_NUMBER);\n            }\n            return (total);\n        case XPATH_OP_MULT:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            if (op->value == 0)\n                xmlXPathMultValues(ctxt);\n            else if (op->value == 1)\n                xmlXPathDivValues(ctxt);\n            else if (op->value == 2)\n                xmlXPathModValues(ctxt);\n            return (total);\n        case XPATH_OP_UNION:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n\t    ctxt->context->doc = bakd;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->contextSize = cs;\n            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            CHECK_TYPE0(XPATH_NODESET);\n            arg2 = valuePop(ctxt);\n\n            CHECK_TYPE0(XPATH_NODESET);\n            arg1 = valuePop(ctxt);\n\n\t    if ((arg1->nodesetval == NULL) ||\n\t\t((arg2->nodesetval != NULL) &&\n\t\t (arg2->nodesetval->nodeNr != 0)))\n\t    {\n\t\targ1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n\t\t\t\t\t\t\targ2->nodesetval);\n\t    }\n\n            valuePush(ctxt, arg1);\n\t    xmlXPathReleaseObject(ctxt->context, arg2);\n            return (total);\n        case XPATH_OP_ROOT:\n            xmlXPathRoot(ctxt);\n            return (total);\n        case XPATH_OP_NODE:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n\t    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n\t\tctxt->context->node));\n            return (total);\n        case XPATH_OP_RESET:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t    CHECK_ERROR0;\n            ctxt->context->node = NULL;\n            return (total);\n        case XPATH_OP_COLLECT:{\n                if (op->ch1 == -1)\n                    return (total);\n\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n\n                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);\n                return (total);\n            }\n        case XPATH_OP_VALUE:\n            valuePush(ctxt,\n                      xmlXPathCacheObjectCopy(ctxt->context,\n\t\t\t(xmlXPathObjectPtr) op->value4));\n            return (total);\n        case XPATH_OP_VARIABLE:{\n\t\txmlXPathObjectPtr val;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->value5 == NULL) {\n\t\t    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n\t\t} else {\n                    const xmlChar *URI;\n\n                    URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                    if (URI == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: variable %s bound to undefined prefix %s\\n\",\n                                    (char *) op->value4, (char *)op->value5);\n                        return (total);\n                    }\n\t\t    val = xmlXPathVariableLookupNS(ctxt->context,\n                                                       op->value4, URI);\n\t\t    if (val == NULL) {\n\t\t\tctxt->error = XPATH_UNDEF_VARIABLE_ERROR;\n\t\t\treturn(0);\n\t\t    }\n                    valuePush(ctxt, val);\n                }\n                return (total);\n            }\n        case XPATH_OP_FUNCTION:{\n                xmlXPathFunction func;\n                const xmlChar *oldFunc, *oldFuncURI;\n\t\tint i;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tif (ctxt->valueNr < op->value) {\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"xmlXPathCompOpEval: parameter error\\n\");\n\t\t    ctxt->error = XPATH_INVALID_OPERAND;\n\t\t    return (total);\n\t\t}\n\t\tfor (i = 0; i < op->value; i++)\n\t\t    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"xmlXPathCompOpEval: parameter error\\n\");\n\t\t\tctxt->error = XPATH_INVALID_OPERAND;\n\t\t\treturn (total);\n\t\t    }\n                if (op->cache != NULL)\n                    XML_CAST_FPTR(func) = op->cache;\n                else {\n                    const xmlChar *URI = NULL;\n\n                    if (op->value5 == NULL)\n                        func =\n                            xmlXPathFunctionLookup(ctxt->context,\n                                                   op->value4);\n                    else {\n                        URI = xmlXPathNsLookup(ctxt->context, op->value5);\n                        if (URI == NULL) {\n                            xmlGenericError(xmlGenericErrorContext,\n            \"xmlXPathCompOpEval: function %s bound to undefined prefix %s\\n\",\n                                    (char *)op->value4, (char *)op->value5);\n                            return (total);\n                        }\n                        func = xmlXPathFunctionLookupNS(ctxt->context,\n                                                        op->value4, URI);\n                    }\n                    if (func == NULL) {\n                        xmlGenericError(xmlGenericErrorContext,\n                                \"xmlXPathCompOpEval: function %s not found\\n\",\n                                        (char *)op->value4);\n                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);\n                    }\n                    op->cache = XML_CAST_FPTR(func);\n                    op->cacheURI = (void *) URI;\n                }\n                oldFunc = ctxt->context->function;\n                oldFuncURI = ctxt->context->functionURI;\n                ctxt->context->function = op->value4;\n                ctxt->context->functionURI = op->cacheURI;\n                func(ctxt, op->value);\n                ctxt->context->function = oldFunc;\n                ctxt->context->functionURI = oldFuncURI;\n                return (total);\n            }\n        case XPATH_OP_ARG:\n\t    bakd = ctxt->context->doc;\n\t    bak = ctxt->context->node;\n\t    pp = ctxt->context->proximityPosition;\n\t    cs = ctxt->context->contextSize;\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    ctxt->context->contextSize = cs;\n\t    ctxt->context->proximityPosition = pp;\n\t    ctxt->context->node = bak;\n\t    ctxt->context->doc = bakd;\n\t    CHECK_ERROR0;\n            if (op->ch2 != -1) {\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);\n\t        ctxt->context->doc = bakd;\n\t        ctxt->context->node = bak;\n\t        CHECK_ERROR0;\n\t    }\n            return (total);\n        case XPATH_OP_PREDICATE:\n        case XPATH_OP_FILTER:{\n                xmlXPathObjectPtr res;\n                xmlXPathObjectPtr obj, tmp;\n                xmlNodeSetPtr newset = NULL;\n                xmlNodeSetPtr oldset;\n                xmlNodePtr oldnode;\n\t\txmlDocPtr oldDoc;\n                int i;\n\n                /*\n                 * Optimization for ()[1] selection i.e. the first elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n#ifdef XP_OPTIMIZED_FILTER_FIRST\n\t\t    /*\n\t\t    * FILTER TODO: Can we assume that the inner processing\n\t\t    *  will result in an ordered list if we have an\n\t\t    *  XPATH_OP_FILTER?\n\t\t    *  What about an additional field or flag on\n\t\t    *  xmlXPathObject like @sorted ? This way we wouln'd need\n\t\t    *  to assume anything, so it would be more robust and\n\t\t    *  easier to optimize.\n\t\t    */\n                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */\n\t\t     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */\n#else\n\t\t    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n#endif\n                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */\n                    xmlXPathObjectPtr val;\n\n                    val = comp->steps[op->ch2].value4;\n                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&\n                        (val->floatval == 1.0)) {\n                        xmlNodePtr first = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalFirst(ctxt,\n                                                    &comp->steps[op->ch1],\n                                                    &first);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the first value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1))\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        return (total);\n                    }\n                }\n                /*\n                 * Optimization for ()[last()] selection i.e. the last elem\n                 */\n                if ((op->ch1 != -1) && (op->ch2 != -1) &&\n                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n                    int f = comp->steps[op->ch2].ch1;\n\n                    if ((f != -1) &&\n                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n                        (comp->steps[f].value5 == NULL) &&\n                        (comp->steps[f].value == 0) &&\n                        (comp->steps[f].value4 != NULL) &&\n                        (xmlStrEqual\n                         (comp->steps[f].value4, BAD_CAST \"last\"))) {\n                        xmlNodePtr last = NULL;\n\n                        total +=\n                            xmlXPathCompOpEvalLast(ctxt,\n                                                   &comp->steps[op->ch1],\n                                                   &last);\n\t\t\tCHECK_ERROR0;\n                        /*\n                         * The nodeset should be in document order,\n                         * Keep only the last value\n                         */\n                        if ((ctxt->value != NULL) &&\n                            (ctxt->value->type == XPATH_NODESET) &&\n                            (ctxt->value->nodesetval != NULL) &&\n                            (ctxt->value->nodesetval->nodeTab != NULL) &&\n                            (ctxt->value->nodesetval->nodeNr > 1)) {\n                            ctxt->value->nodesetval->nodeTab[0] =\n                                ctxt->value->nodesetval->nodeTab[ctxt->\n                                                                 value->\n                                                                 nodesetval->\n                                                                 nodeNr -\n                                                                 1];\n                            ctxt->value->nodesetval->nodeNr = 1;\n                        }\n                        return (total);\n                    }\n                }\n\t\t/*\n\t\t* Process inner predicates first.\n\t\t* Example \"index[parent::book][1]\":\n\t\t* ...\n\t\t*   PREDICATE   <-- we are here \"[1]\"\n\t\t*     PREDICATE <-- process \"[parent::book]\" first\n\t\t*       SORT\n\t\t*         COLLECT  'parent' 'name' 'node' book\n\t\t*           NODE\n\t\t*     ELEM Object is a number : 1\n\t\t*/\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t\tCHECK_ERROR0;\n                if (op->ch2 == -1)\n                    return (total);\n                if (ctxt->value == NULL)\n                    return (total);\n\n                oldnode = ctxt->context->node;\n\n#ifdef LIBXML_XPTR_ENABLED\n                /*\n                 * Hum are we filtering the result of an XPointer expression\n                 */\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    xmlLocationSetPtr newlocset = NULL;\n                    xmlLocationSetPtr oldlocset;\n\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n                    ctxt->context->node = NULL;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation need to be tested to\n                         * decided whether the filter succeeded or not\n                         */\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPtrLocationSetAdd(newlocset,\n                                                  xmlXPathObjectCopy\n                                                  (oldlocset->locTab[i]));\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\n                    /*\n                     * The result is used as the new evaluation locset.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n                    valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                    ctxt->context->node = oldnode;\n                    return (total);\n                }\n#endif /* LIBXML_XPTR_ENABLED */\n\n                /*\n                 * Extract the old set, and then evaluate the result of the\n                 * expression for all the element in the set. use it to grow\n                 * up a new set.\n                 */\n                CHECK_TYPE0(XPATH_NODESET);\n                obj = valuePop(ctxt);\n                oldset = obj->nodesetval;\n\n                oldnode = ctxt->context->node;\n\t\toldDoc = ctxt->context->doc;\n                ctxt->context->node = NULL;\n\n                if ((oldset == NULL) || (oldset->nodeNr == 0)) {\n                    ctxt->context->contextSize = 0;\n                    ctxt->context->proximityPosition = 0;\n/*\n                    if (op->ch2 != -1)\n                        total +=\n                            xmlXPathCompOpEval(ctxt,\n                                               &comp->steps[op->ch2]);\n\t\t    CHECK_ERROR0;\n                    res = valuePop(ctxt);\n                    if (res != NULL)\n                        xmlXPathFreeObject(res);\n*/\n                    valuePush(ctxt, obj);\n                    ctxt->context->node = oldnode;\n                    CHECK_ERROR0;\n                } else {\n\t\t    tmp = NULL;\n                    /*\n                     * Initialize the new set.\n\t\t     * Also set the xpath document in case things like\n\t\t     * key() evaluation are attempted on the predicate\n                     */\n                    newset = xmlXPathNodeSetCreate(NULL);\n\t\t    /*\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"For each node in the node-set to be filtered, the\n\t\t    *  PredicateExpr is evaluated with that node as the\n\t\t    *  context node, with the number of nodes in the\n\t\t    *  node-set as the context size, and with the proximity\n\t\t    *  position of the node in the node-set with respect to\n\t\t    *  the axis as the context position;\"\n\t\t    * @oldset is the node-set\" to be filtered.\n\t\t    *\n\t\t    * SPEC XPath 1.0:\n\t\t    *  \"only predicates change the context position and\n\t\t    *  context size (see [2.4 Predicates]).\"\n\t\t    * Example:\n\t\t    *   node-set  context pos\n\t\t    *    nA         1\n\t\t    *    nB         2\n\t\t    *    nC         3\n\t\t    *   After applying predicate [position() > 1] :\n\t\t    *   node-set  context pos\n\t\t    *    nB         1\n\t\t    *    nC         2\n\t\t    *\n\t\t    * removed the first node in the node-set, then\n\t\t    * the context position of the\n\t\t    */\n                    for (i = 0; i < oldset->nodeNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of\n                         * a single item in the nodeset.\n                         */\n                        ctxt->context->node = oldset->nodeTab[i];\n\t\t\tif ((oldset->nodeTab[i]->type != XML_NAMESPACE_DECL) &&\n\t\t\t    (oldset->nodeTab[i]->doc != NULL))\n\t\t            ctxt->context->doc = oldset->nodeTab[i]->doc;\n\t\t\tif (tmp == NULL) {\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n\t\t\t} else {\n\t\t\t    xmlXPathNodeSetAddUnique(tmp->nodesetval,\n\t\t\t\tctxt->context->node);\n\t\t\t}\n                        valuePush(ctxt, tmp);\n                        ctxt->context->contextSize = oldset->nodeNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\t/*\n\t\t\t* Evaluate the predicate against the context node.\n\t\t\t* Can/should we optimize position() predicates\n\t\t\t* here (e.g. \"[1]\")?\n\t\t\t*/\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeNodeSet(newset);\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        /*\n                         * The result of the evaluation needs to be tested to\n                         * decide whether the filter succeeded or not\n                         */\n\t\t\t/*\n\t\t\t* OPTIMIZE TODO: Can we use\n\t\t\t* xmlXPathNodeSetAdd*Unique()* instead?\n\t\t\t*/\n                        res = valuePop(ctxt);\n                        if (xmlXPathEvaluatePredicateResult(ctxt, res)) {\n                            xmlXPathNodeSetAdd(newset, oldset->nodeTab[i]);\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            valuePop(ctxt);\n\t\t\t    xmlXPathNodeSetClear(tmp->nodesetval, 1);\n\t\t\t    /*\n\t\t\t    * Don't free the temporary nodeset\n\t\t\t    * in order to avoid massive recreation inside this\n\t\t\t    * loop.\n\t\t\t    */\n                        } else\n\t\t\t    tmp = NULL;\n                        ctxt->context->node = NULL;\n                    }\n\t\t    if (tmp != NULL)\n\t\t\txmlXPathReleaseObject(ctxt->context, tmp);\n                    /*\n                     * The result is used as the new evaluation set.\n                     */\n\t\t    xmlXPathReleaseObject(ctxt->context, obj);\n                    ctxt->context->node = NULL;\n                    ctxt->context->contextSize = -1;\n                    ctxt->context->proximityPosition = -1;\n\t\t    /* may want to move this past the '}' later */\n\t\t    ctxt->context->doc = oldDoc;\n\t\t    valuePush(ctxt,\n\t\t\txmlXPathCacheWrapNodeSet(ctxt->context, newset));\n                }\n                ctxt->context->node = oldnode;\n                return (total);\n            }\n        case XPATH_OP_SORT:\n            if (op->ch1 != -1)\n                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n\t    CHECK_ERROR0;\n            if ((ctxt->value != NULL) &&\n                (ctxt->value->type == XPATH_NODESET) &&\n                (ctxt->value->nodesetval != NULL) &&\n\t\t(ctxt->value->nodesetval->nodeNr > 1))\n\t    {\n                xmlXPathNodeSetSort(ctxt->value->nodesetval);\n\t    }\n            return (total);\n#ifdef LIBXML_XPTR_ENABLED\n        case XPATH_OP_RANGETO:{\n                xmlXPathObjectPtr range;\n                xmlXPathObjectPtr res, obj;\n                xmlXPathObjectPtr tmp;\n                xmlLocationSetPtr newlocset = NULL;\n\t\t    xmlLocationSetPtr oldlocset;\n                xmlNodeSetPtr oldset;\n                int i, j;\n\n                if (op->ch1 != -1)\n                    total +=\n                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n                if (op->ch2 == -1)\n                    return (total);\n\n                if (ctxt->value->type == XPATH_LOCATIONSET) {\n                    /*\n                     * Extract the old locset, and then evaluate the result of the\n                     * expression for all the element in the locset. use it to grow\n                     * up a new locset.\n                     */\n                    CHECK_TYPE0(XPATH_LOCATIONSET);\n                    obj = valuePop(ctxt);\n                    oldlocset = obj->user;\n\n                    if ((oldlocset == NULL) || (oldlocset->locNr == 0)) {\n\t\t        ctxt->context->node = NULL;\n                        ctxt->context->contextSize = 0;\n                        ctxt->context->proximityPosition = 0;\n                        total += xmlXPathCompOpEval(ctxt,&comp->steps[op->ch2]);\n                        res = valuePop(ctxt);\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        valuePush(ctxt, obj);\n                        CHECK_ERROR0;\n                        return (total);\n                    }\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    for (i = 0; i < oldlocset->locNr; i++) {\n                        /*\n                         * Run the evaluation with a node list made of a\n                         * single item in the nodelocset.\n                         */\n                        ctxt->context->node = oldlocset->locTab[i]->user;\n                        ctxt->context->contextSize = oldlocset->locNr;\n                        ctxt->context->proximityPosition = i + 1;\n\t\t\ttmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t    ctxt->context->node);\n                        valuePush(ctxt, tmp);\n\n                        if (op->ch2 != -1)\n                            total +=\n                                xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\tif (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    return(0);\n\t\t\t}\n\n                        res = valuePop(ctxt);\n\t\t\tif (res->type == XPATH_LOCATIONSET) {\n\t\t\t    xmlLocationSetPtr rloc =\n\t\t\t        (xmlLocationSetPtr)res->user;\n\t\t\t    for (j=0; j<rloc->locNr; j++) {\n\t\t\t        range = xmlXPtrNewRange(\n\t\t\t\t  oldlocset->locTab[i]->user,\n\t\t\t\t  oldlocset->locTab[i]->index,\n\t\t\t\t  rloc->locTab[j]->user2,\n\t\t\t\t  rloc->locTab[j]->index2);\n\t\t\t\tif (range != NULL) {\n\t\t\t\t    xmlXPtrLocationSetAdd(newlocset, range);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    range = xmlXPtrNewRangeNodeObject(\n\t\t\t\t(xmlNodePtr)oldlocset->locTab[i]->user, res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset,range);\n\t\t\t    }\n                        }\n\n                        /*\n                         * Cleanup\n                         */\n                        if (res != NULL) {\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n\t\t\t}\n                        if (ctxt->value == tmp) {\n                            res = valuePop(ctxt);\n\t\t\t    xmlXPathReleaseObject(ctxt->context, res);\n                        }\n\n                        ctxt->context->node = NULL;\n                    }\n\t\t} else {\t/* Not a location set */\n                    CHECK_TYPE0(XPATH_NODESET);\n                    obj = valuePop(ctxt);\n                    oldset = obj->nodesetval;\n                    ctxt->context->node = NULL;\n\n                    newlocset = xmlXPtrLocationSetCreate(NULL);\n\n                    if (oldset != NULL) {\n                        for (i = 0; i < oldset->nodeNr; i++) {\n                            /*\n                             * Run the evaluation with a node list made of a single item\n                             * in the nodeset.\n                             */\n                            ctxt->context->node = oldset->nodeTab[i];\n\t\t\t    /*\n\t\t\t    * OPTIMIZE TODO: Avoid recreation for every iteration.\n\t\t\t    */\n\t\t\t    tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n\t\t\t\tctxt->context->node);\n                            valuePush(ctxt, tmp);\n\n                            if (op->ch2 != -1)\n                                total +=\n                                    xmlXPathCompOpEval(ctxt,\n                                                   &comp->steps[op->ch2]);\n\t\t\t    if (ctxt->error != XPATH_EXPRESSION_OK) {\n\t\t\t\txmlXPathFreeObject(obj);\n\t\t\t\treturn(0);\n\t\t\t    }\n\n                            res = valuePop(ctxt);\n                            range =\n                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n                                                      res);\n                            if (range != NULL) {\n                                xmlXPtrLocationSetAdd(newlocset, range);\n                            }\n\n                            /*\n                             * Cleanup\n                             */\n                            if (res != NULL) {\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n\t\t\t    }\n                            if (ctxt->value == tmp) {\n                                res = valuePop(ctxt);\n\t\t\t\txmlXPathReleaseObject(ctxt->context, res);\n                            }\n\n                            ctxt->context->node = NULL;\n                        }\n                    }\n                }\n\n                /*\n                 * The result is used as the new evaluation set.\n                 */\n\t\txmlXPathReleaseObject(ctxt->context, obj);\n                ctxt->context->node = NULL;\n                ctxt->context->contextSize = -1;\n                ctxt->context->proximityPosition = -1;\n                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n                return (total);\n            }\n#endif /* LIBXML_XPTR_ENABLED */\n    }\n    xmlGenericError(xmlGenericErrorContext,\n                    \"XPath: unknown precompiled operation %d\\n\", op->op);", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": "valuePop(xmlXPathParserContextPtr ctxt)\n{\n    xmlXPathObjectPtr ret;\n\n    if ((ctxt == NULL) || (ctxt->valueNr <= 0))\n        return (NULL);\n    ctxt->valueNr--;\n    if (ctxt->valueNr > 0)\n        ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];\n    else\n        ctxt->value = NULL;\n    ret = ctxt->valueTab[ctxt->valueNr];\n    ctxt->valueTab[ctxt->valueNr] = NULL;\n    return (ret);\n}", "target": 1, "cwe": ["CWE-415"], "message": "Hardening of XPath evaluation\n\nAdd a mechanism of frame for XPath evaluation when entering a function\nor a scoped evaluation, also fix a potential problem in predicate\nevaluation."}
{"func": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n    if (s->tray_open) {\n        scsi_read_complete(r, -ENOMEDIUM);\n    }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                              scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        /* Invoke completion routine to fetch data from host.  */\n        scsi_write_complete(r, 0);\n    }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: commonize iovec creation between reads and writes\n\nAlso, consistently use qiov.size instead of iov.iov_len.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "scsi-disk: lazily allocate bounce buffer\n\nIt will not be needed for reads and writes if the HBA provides a sglist.\nIn addition, this lets scsi-disk refuse commands with an excessive\nallocation length, as well as limit memory on usual well-behaved guests.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>"}
{"func": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-120", "CWE-119", "CWE-787"], "message": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org"}
{"func": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n\n  params << net->serverEncode(bufname) << quotedReply;\n  // FIXME user proper event\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Fix core crash\n\nSome CTCP requests triggered a bug in the parser; this fixes the issue."}
{"func": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-20"], "message": "cifs: always do is_path_accessible check in cifs_mount\n\nCurrently, we skip doing the is_path_accessible check in cifs_mount if\nthere is no prefixpath. I have a report of at least one server however\nthat allows a TREE_CONNECT to a share that has a DFS referral at its\nroot. The reporter in this case was using a UNC that had no prefixpath,\nso the is_path_accessible check was not triggered and the box later hit\na BUG() because we were chasing a DFS referral on the root dentry for\nthe mount.\n\nThis patch fixes this by removing the check for a zero-length\nprefixpath.  That should make the is_path_accessible check be done in\nthis situation and should allow the client to chase the DFS referral at\nmount time instead.\n\nCc: stable@kernel.org\nReported-and-Tested-by: Yogesh Sharma <ysharma@cymer.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>"}
{"func": "static void cmd_list(char *arg1, char *arg2)\n{\n    if (!arg1)\n\targ1 = \"active\";\n    else\n\tlcase(arg1);\n\n    if (!strcmp(arg1, \"active\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"ACTIVE\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_active;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n\n\tif (group_state)\n\t    index_close(&group_state);\n    }\n    else if (!(nntp_capa & MODE_READ)) {\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\treturn;\n    }\n    else if (!nntp_userid && !allowanonymous) {\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\treturn;\n    }\n    else if (!strcmp(arg1, \"headers\")) {\n\tif (arg2 && strcmp(arg2, \"msgid\") && strcmp(arg2, \"range\")) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Header and metadata list follows:\\r\\n\");\n\tprot_printf(nntp_out, \":\\r\\n\"); /* all headers */\n\tprot_printf(nntp_out, \":bytes\\r\\n\");\n\tprot_printf(nntp_out, \":lines\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"newsgroups\")) {\n\tchar pattern[MAX_MAILBOX_BUFFER];\n\tstruct list_rock lrock;\n\tstruct enum_rock erock;\n\n\tif (!arg2) arg2 = \"*\";\n\n\terock.cmd = \"NEWSGROUPS\";\n\terock.wild = xstrdup(arg2); /* make a copy before we munge it */\n\n\tlrock.proc = do_newsgroups;\n\tlrock.wild = split_wildmats(arg2); /* split the list of wildmats */\n\n\t/* xxx better way to determine a size for this table? */\n\tconstruct_hash_table(&lrock.server_table, 10, 1);\n\n\tprot_printf(nntp_out, \"215 List of newsgroups follows:\\r\\n\");\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tlist_cb(NULL, 0, 0, NULL);\n\tmboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,\n\t\t\t list_cb, &lrock);\n\n\t/* proxy to the backends */\n\thash_enumerate(&lrock.server_table, list_proxy, &erock);\n\n\tstrcpy(pattern, newsprefix);\n\tstrcat(pattern, \"*\");\n\tannotatemore_findall(pattern, \"/comment\",\n\t\t\t     newsgroups_cb, lrock.wild, NULL);\n\n\tprot_printf(nntp_out, \".\\r\\n\");\n\n\t/* free the hash table */\n\tfree_hash_table(&lrock.server_table, NULL);\n\n\t/* free the wildmats */\n\tfree_wildmats(lrock.wild);\n\tfree(erock.wild);\n    }\n    else if (!strcmp(arg1, \"overview.fmt\")) {\n\tif (arg2) {\n\t    prot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\t    return;\n\t}\n\n\tprot_printf(nntp_out, \"215 Order of overview fields follows:\\r\\n\");\n\tprot_printf(nntp_out, \"Subject:\\r\\n\");\n\tprot_printf(nntp_out, \"From:\\r\\n\");\n\tprot_printf(nntp_out, \"Date:\\r\\n\");\n\tprot_printf(nntp_out, \"Message-ID:\\r\\n\");\n\tprot_printf(nntp_out, \"References:\\r\\n\");\n\tif (did_capabilities) {\n\t    /* new OVER format */\n\t    prot_printf(nntp_out, \":bytes\\r\\n\");\n\t    prot_printf(nntp_out, \":lines\\r\\n\");\n\t} else {\n\t    /* old XOVER format */\n\t    prot_printf(nntp_out, \"Bytes:\\r\\n\");\n\t    prot_printf(nntp_out, \"Lines:\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"Xref:full\\r\\n\");\n\tprot_printf(nntp_out, \".\\r\\n\");\n    }\n    else if (!strcmp(arg1, \"active.times\") || !strcmp(arg1, \"distributions\") ||\n\t     !strcmp(arg1, \"distrib.pats\")) {\n\tprot_printf(nntp_out, \"503 Unsupported LIST command\\r\\n\");\n    }\n    else {\n\tprot_printf(nntp_out, \"501 Unrecognized LIST command\\r\\n\");\n    }\n    prot_flush(nntp_out);\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static int deliver(message_data_t *msg)\n{\n    int n, r = 0, myrights;\n    char *rcpt = NULL, *local_rcpt = NULL, *server, *acl;\n    unsigned long uid;\n    struct body *body = NULL;\n    struct dest *dlist = NULL;\n    duplicate_key_t dkey = {msg->id, NULL, msg->date};\n\n    /* check ACLs of all mailboxes */\n    for (n = 0; n < msg->rcpt_num; n++) {\n\trcpt = msg->rcpt[n];\n\n\t/* look it up */\n\tr = mlookup(rcpt, &server, &acl, NULL);\n\tdkey.to = rcpt;\n\tif (r) return IMAP_MAILBOX_NONEXISTENT;\n\n\tif (!(acl && (myrights = cyrus_acl_myrights(nntp_authstate, acl)) &&\n\t      (myrights & ACL_POST)))\n\t    return IMAP_PERMISSION_DENIED;\n\n\tif (server) {\n\t    /* remote group */\n\t    proxy_adddest(&dlist, NULL, 0, server, \"\");\n\t}\n\telse {\n\t    /* local group */\n\t    struct appendstate as;\n\n\t    if (msg->id && \n\t\tduplicate_check(&dkey)) {\n\t\t/* duplicate message */\n\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\tcontinue;\n\t    }\n\n\t    r = append_setup(&as, rcpt, nntp_userid, nntp_authstate, ACL_POST, 0);\n\n\t    if (!r) {\n\t\tprot_rewind(msg->data);\n\t\tif (stage) {\n\t\t    r = append_fromstage(&as, &body, stage, 0,\n\t\t\t\t\t (const char **) NULL, 0, !singleinstance);\n\t\t} else {\n\t\t    /* XXX should never get here */\n\t\t    r = append_fromstream(&as, &body, msg->data, msg->size, 0,\n\t\t\t\t\t  (const char **) NULL, 0);\n\t\t}\n\t\tif (r || ( msg->id && duplicate_check(&dkey) ) ) {    \n\t\t    append_abort(&as);\n                   \n\t\t    if (!r) {\n\t\t\t/* duplicate message */\n\t\t\tduplicate_log(&dkey, \"nntp delivery\");\n\t\t\tcontinue;\n\t\t    }            \n\t\t}                \n\t\telse {           \n\t\t    r = append_commit(&as, 0, NULL, &uid, NULL, NULL);\n\t\t}\n\t    }\n\n\t    if (!r && msg->id)\n\t\tduplicate_mark(&dkey, time(NULL), uid);\n\n\t    if (r) return r;\n\n\t    local_rcpt = rcpt;\n\t}\n    }\n\n    if (body) {\n\tmessage_free_body(body);\n\tfree(body);\n    }\n\n    if (dlist) {\n\tstruct dest *d;\n\n\t/* run the txns */\n\tr = deliver_remote(msg, dlist);\n\n\t/* free the destination list */\n\td = dlist;\n\twhile (d) {\n\t    struct dest *nextd = d->next;\n\t    free(d);\n\t    d = nextd;\n\t}\n    }\n\n    return r;\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static void cmdloop(void)\n{\n    int c, r = 0, mode;\n    static struct buf cmd, arg1, arg2, arg3, arg4;\n    char *p, *result, buf[1024];\n    const char *err;\n    uint32_t uid, last;\n    struct backend *be;\n    char curgroup[MAX_MAILBOX_BUFFER] = \"\";\n\n    allowanonymous = config_getswitch(IMAPOPT_ALLOWANONYMOUSLOGIN);\n\n    for (;;) {\n\t/* Flush any buffered output */\n\tprot_flush(nntp_out);\n\tif (backend_current) prot_flush(backend_current->out);\n\n\t/* Check for shutdown file */\n\tif (shutdown_file(buf, sizeof(buf)) ||\n\t    (nntp_userid &&\n\t     userdeny(nntp_userid, config_ident, buf, sizeof(buf)))) {\n\t    prot_printf(nntp_out, \"400 %s\\r\\n\", buf);\n\t    shut_down(0);\n\t}\n\n\tsignals_poll();\n\n\tif (!proxy_check_input(protin, nntp_in, nntp_out,\n\t\t\t       backend_current ? backend_current->in : NULL,\n\t\t\t       NULL, 0)) {\n\t    /* No input from client */\n\t    continue;\n\t}\n\n\tif (group_state &&\n\t    config_getswitch(IMAPOPT_DISCONNECT_ON_VANISHED_MAILBOX)) {\n\t    if (group_state->mailbox->i.options & OPT_MAILBOX_DELETED) {\n\t\t/* Mailbox has been (re)moved */\n\t\tsyslog(LOG_WARNING,\n\t\t       \"Newsgroup %s has been (re)moved out from under client\",\n\t\t       group_state->mailbox->name);\n\t\tprot_printf(nntp_out,\n\t\t\t    \"400 Newsgroup has been (re)moved\\r\\n\");\n\t\tshut_down(0);\n\t    }\n\t}\n\n\t/* Parse command name */\n\tc = getword(nntp_in, &cmd);\n\tif (c == EOF) {\n\t    if ((err = prot_error(nntp_in)) != NULL\n\t\t && strcmp(err, PROT_EOF_STRING)) {\n\t\tsyslog(LOG_WARNING, \"%s, closing connection\", err);\n\t\tprot_printf(nntp_out, \"400 %s\\r\\n\", err);\n\t    }\n\t    return;\n\t}\n\tif (!cmd.s[0]) {\n\t    prot_printf(nntp_out, \"501 Empty command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t    continue;\n\t}\n\tif (Uislower(cmd.s[0])) \n\t    cmd.s[0] = toupper((unsigned char) cmd.s[0]);\n\tfor (p = &cmd.s[1]; *p; p++) {\n\t    if (Uisupper(*p)) *p = tolower((unsigned char) *p);\n\t}\n\n\t/* Ihave/Takethis only allowed for feeders */\n\tif (!(nntp_capa & MODE_FEED) &&\n\t    strchr(\"IT\", cmd.s[0])) goto noperm;\n    \n\t/* Body/Date/Group/Newgroups/Newnews/Next/Over/Post/Xhdr/Xover/Xpat\n\t   only allowed for readers */\n\tif (!(nntp_capa & MODE_READ) &&\n\t    strchr(\"BDGNOPX\", cmd.s[0])) goto noperm;\n    \n\t/* Only Authinfo/Capabilities/Check/Head/Help/Ihave/List Active/\n\t   Mode/Quit/Starttls/Stat/Takethis allowed when not logged in */\n\tif (!nntp_userid && !allowanonymous &&\n\t    !strchr(\"ACHILMQST\", cmd.s[0])) goto nologin;\n\n\t/* In case a [LIST]GROUP fails or\n\t   a retrieval by msgid makes us switch groups */\n\tstrcpy(curgroup, group_state ? group_state->mailbox->name : \"\");\n\n\tswitch (cmd.s[0]) {\n\tcase 'A':\n\t    if (!strcmp(cmd.s, \"Authinfo\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* subcommand */\n\t\tif (c == EOF) goto missingargs;\n\n\t\tlcase(arg1.s);\n\n\t\tif (!strcmp(arg1.s, \"user\") || !strcmp(arg1.s, \"pass\")) {\n\t\t    if (c != ' ') goto missingargs;\n\t\t    c = getuserpass(nntp_in, &arg2); /* user/pass */\n\t\t    if (c == EOF) goto missingargs;\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    if (arg1.s[0] == 'u')\n\t\t\tcmd_authinfo_user(arg2.s);\n\t\t    else\n\t\t\tcmd_authinfo_pass(arg2.s);\n\t\t}\n\t\telse if (!strcmp(arg1.s, \"sasl\") || !strcmp(arg1.s, \"generic\")) {\n\t\t    arg2.len = arg3.len = 0;\n\n\t\t    /* mech name required for SASL but not GENERIC */\n\t\t    if ((arg1.s[0] == 's') && (c != ' ')) goto missingargs;\n\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* mech name */\n\t\t\tif (c == EOF) goto missingargs;\n\n\t\t\tif (c == ' ') {\n\t\t\t    c = getword(nntp_in, &arg3); /* init response */\n\t\t\t    if (c == EOF) goto missingargs;\n\t\t\t}\n\t\t    }\n\n\t\t    if (c == '\\r') c = prot_getc(nntp_in);\n\t\t    if (c != '\\n') goto extraargs;\n\n\t\t    cmd_authinfo_sasl(arg1.s, arg2.len ? arg2.s : NULL,\n\t\t\t\t      arg3.len ? arg3.s : NULL);\n\t\t}\n\t\telse\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"501 Unrecognized AUTHINFO command\\r\\n\");\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Article\")) {\n\t\tchar *msgid;\n\n\t\tmode = ARTICLE_ALL;\n\n\t      article:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* number/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg1.s, &uid, NULL, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2) &&\n\t\t\t\tmode != ARTICLE_STAT) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_article(mode, msgid, uid);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'B':\n\t    if (!strcmp(cmd.s, \"Body\")) {\n\t\tmode = ARTICLE_BODY;\n\t\tgoto article;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'C':\n\t    if (!strcmp(cmd.s, \"Capabilities\")) {\n\t\targ1.len = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* keyword (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_capabilities(arg1.s);\n\t    }\n\t    else if (!(nntp_capa & MODE_FEED)) goto noperm;\n\t    else if (!strcmp(cmd.s, \"Check\")) {\n\t\tmode = POST_CHECK;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'D':\n\t    if (!strcmp(cmd.s, \"Date\")) {\n\t\ttime_t now = time(NULL);\n\t\tstruct tm *my_tm = gmtime(&now);\n\t\tchar buf[15];\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tstrftime(buf, sizeof(buf), \"%Y%m%d%H%M%S\", my_tm);\n\t\tprot_printf(nntp_out, \"111 %s\\r\\n\", buf);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'G':\n\t    if (!strcmp(cmd.s, \"Group\")) {\n\t\targ2.len = 0; /* GROUP command (no range) */\n\n\t      group:\n#define LISTGROUP (arg2.len)\n\n\t\tif (!LISTGROUP && c != ' ') goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* group */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (LISTGROUP && c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tbe = backend_current;\n\t\tif (arg1.len &&\n\t\t    (!is_newsgroup(arg1.s) ||\n\t\t     (r = open_group(arg1.s, 1, &be, NULL)))) goto nogroup;\n\t\telse if (be) {\n\t\t    prot_printf(be->out, \"%s\", cmd.s);\n\t\t    if (arg1.len) {\n\t\t\tprot_printf(be->out, \" %s\", arg1.s);\n\t\t\t  if (LISTGROUP) prot_printf(be->out, \" %s\", arg2.s);\n\t\t    }\n\t\t    prot_printf(be->out, \"\\r\\n\");\n\n\t\t    r = read_response(be, 0, &result);\n\t\t    if (r) goto nogroup;\n\n\t\t    prot_printf(nntp_out, \"%s\", result);\n\n\t\t    if (!strncmp(result, \"211\", 3)) {\n\t\t\tif (LISTGROUP) pipe_to_end_of_response(be, 0);\n\n\t\t\tif (backend_current && backend_current != be) {\n\t\t\t    /* remove backend_current from the protgroup */\n\t\t\t    protgroup_delete(protin, backend_current->in);\n\t\t\t}\n\t\t\tbackend_current = be;\n\n\t\t\t/* add backend_current to the protgroup */\n\t\t\tprotgroup_insert(protin, backend_current->in);\n\t\t    }\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (LISTGROUP &&\n\t\t\t parserange(arg2.s, &uid, &last, NULL, NULL) != 0) {\n\t\t    /* parserange() will handle error code -- do nothing */\n\t\t}\n\t\telse {\n\t\t    if (backend_current) {\n\t\t\t/* remove backend_current from the protgroup */\n\t\t\tprotgroup_delete(protin, backend_current->in);\n\t\t    }\n\t\t    backend_current = NULL;\n\n\t\t    nntp_exists = group_state->exists;\n\t\t    nntp_current = nntp_exists > 0;\n\n\t\t    prot_printf(nntp_out, \"211 %u %lu %lu %s\\r\\n\",\n\t\t\t\tnntp_exists,\n\t\t\t\tnntp_exists ? index_getuid(group_state, 1) :\n\t\t\t\tgroup_state->last_uid+1,\n\t\t\t\tnntp_exists ? index_getuid(group_state, nntp_exists) :\n\t\t\t\tgroup_state->last_uid,\n\t\t\t\tgroup_state->mailbox->name + strlen(newsprefix));\n\n\t\t    if (LISTGROUP) {\n\t\t\tint msgno, last_msgno;\n\n\t\t\tmsgno = index_finduid(group_state, uid);\n\t\t\tif (!msgno || index_getuid(group_state, msgno) != uid) {\n\t\t\t    msgno++;\n\t\t\t}\n\t\t\tlast_msgno = index_finduid(group_state, last);\n\n\t\t\tfor (; msgno <= last_msgno; msgno++) {\n\t\t\t    prot_printf(nntp_out, \"%u\\r\\n\",\n\t\t\t\t\tindex_getuid(group_state, msgno));\n\t\t\t}\n\t\t\tprot_printf(nntp_out, \".\\r\\n\");\n\t\t    }\n\t\t}\n#undef LISTGROUP\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'H':\n\t    if (!strcmp(cmd.s, \"Head\")) {\n\t\tmode = ARTICLE_HEAD;\n\t\tgoto article;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Help\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_help();\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Hdr\")) {\n\t\tchar *msgid;\n\n\t      hdr:\n\t\tif (arg2.s) *arg2.s = 0;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg2); /* range (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg2.s && *arg2.s)\n\t\t\t    prot_printf(be->out, \"%s %s %s\\r\\n\",\n\t\t\t\t\tcmd.s, arg1.s, arg2.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"22\", 2)) { /* 221 or 225 */\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, NULL, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'I':\n\t    if (!strcmp(cmd.s, \"Ihave\")) {\n\t\tmode = POST_IHAVE;\n\n\t      ihave:\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* msgid */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(arg1.s, mode);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'L':\n\t    if (!strcmp(cmd.s, \"List\")) {\n\t\targ1.len = arg2.len = 0;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* subcommand (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t    if (c == ' ') {\n\t\t\tc = getword(nntp_in, &arg2); /* argument (optional) */\n\t\t\tif (c == EOF) goto missingargs;\n\t\t    }\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_list(arg1.len ? arg1.s : NULL, arg2.len ? arg2.s : NULL);\n\n\t\tgoto prevgroup;  /* In case we did LIST [ACTIVE] */\n\t    }\n\t    else if (!(nntp_capa & MODE_READ)) goto noperm;\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Last\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"LAST\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == 1) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"422 No previous article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, --nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else if (!strcmp(cmd.s, \"Listgroup\")) {\n\t\targ1.len = 0;   \t   /* group is optional */\n\t\tbuf_setcstr(&arg2, \"1-\");  /* default range is all */\n\t\tbuf_cstring(&arg2);\t   /* appends a '\\0' */\n\t\tgoto group;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'M':\n\t    if (!strcmp(cmd.s, \"Mode\")) {\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* mode */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_mode(arg1.s);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'N':\n\t    if (!strcmp(cmd.s, \"Newgroups\")) {\n\t\ttime_t tstamp;\n\n\t\targ3.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg3); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg1.s, arg2.s,\n\t\t\t\t\t     arg3.len ? arg3.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newgroups(tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Newnews\")) {\n\t\ttime_t tstamp;\n\n\t\tif (!config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t\t    goto cmddisabled;\n\n\t\targ4.len = 0;\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* wildmat */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg2); /* date */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* time */\n\t\tif (c == EOF) goto missingargs;\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg4); /* \"GMT\" (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif ((tstamp = parse_datetime(arg2.s, arg3.s,\n\t\t\t\t\t     arg4.len ? arg4.s : NULL)) < 0)\n\t\t    goto baddatetime;\n\n\t\tcmd_newnews(arg1.s, tstamp);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Next\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (backend_current) {\n\t\t    prot_printf(backend_current->out, \"NEXT\\r\\n\");\n\t\t}\n\t\telse if (!group_state) goto noopengroup;\n\t\telse if (!nntp_current) goto nocurrent;\n\t\telse if (nntp_current == nntp_exists) {\n\t\t    prot_printf(nntp_out,\n\t\t\t\t\"421 No next article in this group\\r\\n\");\n\t\t}\n\t\telse {\n\t\t    char *msgid = index_get_msgid(group_state, ++nntp_current);\n\n\t\t    prot_printf(nntp_out, \"223 %u %s\\r\\n\",\n\t\t\t\tindex_getuid(group_state, nntp_current),\n\t\t\t\tmsgid ? msgid : \"<0>\");\n\n\t\t    if (msgid) free(msgid);\n\t\t}\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'O':\n\t    if (!strcmp(cmd.s, \"Over\")) {\n\t\tchar *msgid;\n\n\t      over:\n\t\tif (arg1.s) *arg1.s = 0;\n\n\t\tif (c == ' ') {\n\t\t    c = getword(nntp_in, &arg1); /* range/msgid (optional) */\n\t\t    if (c == EOF) goto missingargs;\n\t\t}\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tmsgid = NULL;\n\t\tif (parserange(arg1.s, &uid, &last,\n\t\t\t       /* XOVER doesn't accept message-id */\n\t\t\t       (cmd.s[0] == 'X' ? NULL : &msgid), &be) != -1) {\n\t\t    if (be) {\n\t\t\tif (arg1.s && *arg1.s)\n\t\t\t    prot_printf(be->out, \"%s %s\\r\\n\", cmd.s, arg1.s);\n\t\t\telse\n\t\t\t    prot_printf(be->out, \"%s\\r\\n\", cmd.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"224\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_over(msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'P':\n\t    if (!strcmp(cmd.s, \"Post\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tcmd_post(NULL, POST_POST);\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'Q':\n\t    if (!strcmp(cmd.s, \"Quit\")) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"205 Connection closing\\r\\n\");\n\t\treturn;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'S':\n\t    if (!strcmp(cmd.s, \"Starttls\") && tls_enabled()) {\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\t/* XXX  discard any input pipelined after STARTTLS */\n\t\tprot_flush(nntp_in);\n\n\t\tcmd_starttls(0);\n\t    }\n\t    else if (!strcmp(cmd.s, \"Stat\")) {\n\t\tmode = ARTICLE_STAT;\n\t\tgoto article;\n\t    }\n\t    else if (!nntp_userid && !allowanonymous) goto nologin;\n\t    else if (!strcmp(cmd.s, \"Slave\")) {\t\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tprot_printf(nntp_out, \"202 Slave status noted\\r\\n\");\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'T':\n\t    if (!strcmp(cmd.s, \"Takethis\")) {\n\t\tmode = POST_TAKETHIS;\n\t\tgoto ihave;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tcase 'X':\n\t    if (!strcmp(cmd.s, \"Xhdr\")) {\n\t\tgoto hdr;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xover\")) {\n\t\tgoto over;\n\t    }\n\t    else if (!strcmp(cmd.s, \"Xpat\")) {\n\t\tchar *msgid;\n\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg1); /* header */\n\t\tif (c != ' ') goto missingargs;\n\n\t\t/* gobble extra whitespace (hack for Mozilla) */\n\t\twhile ((c = prot_getc(nntp_in)) == ' ');\n\t\tprot_ungetc(c, nntp_in);\n\n\t\tc = getword(nntp_in, &arg2); /* range */\n\t\tif (c != ' ') goto missingargs;\n\t\tc = getword(nntp_in, &arg3); /* wildmat */\n\t\tif (c == EOF) goto missingargs;\n\n\t\t/* XXX per RFC 2980, we can have multiple patterns */\n\n\t\tif (c == '\\r') c = prot_getc(nntp_in);\n\t\tif (c != '\\n') goto extraargs;\n\n\t\tif (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {\n\t\t    if (be) {\n\t\t\tprot_printf(be->out, \"%s %s %s %s\\r\\n\",\n\t\t\t\t    cmd.s, arg1.s, arg2.s, arg3.s);\n\n\t\t\tif (be != backend_current) {\n\t\t\t    r = read_response(be, 0, &result);\n\t\t\t    if (r) goto noopengroup;\n\n\t\t\t    prot_printf(nntp_out, \"%s\", result);\n\t\t\t    if (!strncmp(result, \"221\", 3)) {\n\t\t\t\tpipe_to_end_of_response(be, 0);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tcmd_hdr(cmd.s, arg1.s, arg3.s, msgid, uid, last);\n\t\t}\n\n\t\tif (msgid) goto prevgroup;\n\t    }\n\t    else goto badcmd;\n\t    break;\n\n\tdefault:\n\t  badcmd:\n\t    prot_printf(nntp_out, \"500 Unrecognized command\\r\\n\");\n\t    eatline(nntp_in, c);\n\t}\n\n\tcontinue;\n\n      noperm:\n\tprot_printf(nntp_out, \"502 Permission denied\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      nologin:\n\tprot_printf(nntp_out, \"480 Authentication required\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      cmddisabled:\n\tprot_printf(nntp_out, \"503 \\\"%s\\\" disabled\\r\\n\", cmd.s);\n\teatline(nntp_in, c);\n\tcontinue;\n\n      extraargs:\n\tprot_printf(nntp_out, \"501 Unexpected extra argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      missingargs:\n\tprot_printf(nntp_out, \"501 Missing argument\\r\\n\");\n\teatline(nntp_in, c);\n\tcontinue;\n\n      baddatetime:\n\tprot_printf(nntp_out, \"501 Bad date/time\\r\\n\");\n\tcontinue;\n\n      nogroup:\n\tprot_printf(nntp_out, \"411 No such newsgroup (%s)\\r\\n\",\n\t\t    error_message(r));\n\n      prevgroup:\n\t/* Return to previously selected group */\n\tif (*curgroup &&\n\t    (!group_state || strcmp(curgroup, group_state->mailbox->name))) {\n\t    open_group(curgroup, 1, NULL, NULL);\n\t}\n\n\tcontinue;\n\n      noopengroup:\n\tprot_printf(nntp_out, \"412 No newsgroup selected\\r\\n\");\n\tcontinue;\n\n      nocurrent:\n\tprot_printf(nntp_out, \"420 Current article number is invalid\\r\\n\");\n\tcontinue;\n    }\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static void cmd_capabilities(char *keyword __attribute__((unused)))\n{\n    const char *mechlist;\n    int mechcount = 0;\n\n    prot_printf(nntp_out, \"101 Capability list follows:\\r\\n\");\n    prot_printf(nntp_out, \"VERSION 2\\r\\n\");\n    if (nntp_authstate || (config_serverinfo == IMAP_ENUM_SERVERINFO_ON)) {\n\tprot_printf(nntp_out,\n\t\t    \"IMPLEMENTATION Cyrus NNTP%s %s\\r\\n\",\n\t\t    config_mupdate_server ? \" Murder\" : \"\", cyrus_version());\n    }\n\n    /* add STARTTLS */\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate)\n\tprot_printf(nntp_out, \"STARTTLS\\r\\n\");\n\n    /* check for SASL mechs */\n    sasl_listmech(nntp_saslconn, NULL, \"SASL \", \" \", \"\\r\\n\",\n\t\t  &mechlist, NULL, &mechcount);\n\n    /* add the AUTHINFO variants */\n    if (!nntp_authstate) {\n\tprot_printf(nntp_out, \"AUTHINFO%s%s\\r\\n\",\n\t\t    (nntp_starttls_done || (extprops_ssf > 1) ||\n\t\t     config_getswitch(IMAPOPT_ALLOWPLAINTEXT)) ?\n\t\t    \" USER\" : \"\", mechcount ? \" SASL\" : \"\");\n    }\n\n    /* add the SASL mechs */\n    if (mechcount) prot_printf(nntp_out, \"%s\", mechlist);\n\n    /* add the reader capabilities/extensions */\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"READER\\r\\n\");\n\tprot_printf(nntp_out, \"POST\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"NEWNEWS\\r\\n\");\n\tprot_printf(nntp_out, \"HDR\\r\\n\");\n\tprot_printf(nntp_out, \"OVER\\r\\n\");\n\tprot_printf(nntp_out, \"XPAT\\r\\n\");\n    }\n\n    /* add the feeder capabilities/extensions */\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"IHAVE\\r\\n\");\n\tprot_printf(nntp_out, \"STREAMING\\r\\n\");\n    }\n\n    /* add the LIST variants */\n    prot_printf(nntp_out, \"LIST ACTIVE%s\\r\\n\",\n\t\t((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) ?\n\t\t\" HEADERS NEWSGROUPS OVERVIEW.FMT\" : \"\");\n\n    prot_printf(nntp_out, \".\\r\\n\");\n\n    did_capabilities = 1;\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static int open_group(char *name, int has_prefix, struct backend **ret,\n\t\t      int *postable /* used for LIST ACTIVE only */)\n{\n    char mailboxname[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    char *acl, *newserver;\n    struct backend *backend_next = NULL;\n\n    /* close local group */\n    if (group_state) \n\tindex_close(&group_state);\n\n    if (!has_prefix) {\n\tsnprintf(mailboxname, sizeof(mailboxname), \"%s%s\", newsprefix, name);\n\tname = mailboxname;\n    }\n\n    if (!r) r = mlookup(name, &newserver, &acl, NULL);\n\n    if (!r && acl) {\n\tint myrights = cyrus_acl_myrights(nntp_authstate, acl);\n\n\tif (postable) *postable = myrights & ACL_POST;\n\tif (!postable && /* allow limited 'r' for LIST ACTIVE */\n\t    !(myrights & ACL_READ)) {\n\t    r = (myrights & ACL_LOOKUP) ?\n\t\tIMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n\t}\n    }\n\n    if (r) return r;\n\n    if (newserver) {\n\t/* remote group */\n\tbackend_next = proxy_findserver(newserver, &nntp_protocol,\n\t\t\t\t\tnntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t\t\t&backend_cached, &backend_current,\n\t\t\t\t\tNULL, nntp_in);\n\tif (!backend_next) return IMAP_SERVER_UNAVAILABLE;\n\n\t*ret = backend_next;\n    }\n    else {\n\t/* local group */\n\tstruct index_init init;\n\tmemset(&init, 0, sizeof(struct index_init));\n\tinit.userid = nntp_userid;\n\tinit.authstate = nntp_authstate;\n\tr = index_open(name, &init, &group_state);\n\tif (r) return r;\n\n\tif (ret) *ret = NULL;\n    }\n\n    syslog(LOG_DEBUG, \"open: user %s opened %s\",\n\t   nntp_userid ? nntp_userid : \"anonymous\", name);\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static void cmd_help(void)\n{\n    prot_printf(nntp_out, \"100 Supported commands:\\r\\n\");\n\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tARTICLE [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve entirety of the specified article.\\r\\n\");\n    }\n    if (!nntp_authstate) {\n\tif (!nntp_userid) {\n\t    prot_printf(nntp_out, \"\\tAUTHINFO SASL mechanism [initial-response]\\r\\n\"\n\t\t\t\"\\t\\tPerform an authentication exchange using the specified\\r\\n\"\n\t\t\t\"\\t\\tSASL mechanism.\\r\\n\");\n\t    prot_printf(nntp_out, \"\\tAUTHINFO USER username\\r\\n\"\n\t\t\t\"\\t\\tPresent username for authentication.\\r\\n\");\n\t}\n\tprot_printf(nntp_out, \"\\tAUTHINFO PASS password\\r\\n\"\n\t\t    \"\\t\\tPresent clear-text password for authentication.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tBODY [ message-id | number ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve body of the specified article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tCAPABILITIES\\r\\n\"\n\t\t\"\\t\\tList the current server capabilities.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tCHECK message-id\\r\\n\"\n\t\t    \"\\t\\tCheck if the server wants the specified article.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tDATE\\r\\n\"\n\t\t    \"\\t\\tRequest the current server UTC date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tGROUP group\\r\\n\"\n\t\t    \"\\t\\tSelect a newsgroup for article retrieval.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tHDR header [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the specified header/metadata from the\\r\\n\"\n\t\t    \"\\t\\tspecified article(s).\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tHEAD [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tRetrieve the headers of the specified article.\\r\\n\");\n    prot_printf(nntp_out, \"\\tHELP\\r\\n\"\n\t\t\"\\t\\tRequest command summary (this text).\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tIHAVE message-id\\r\\n\"\n\t\t    \"\\t\\tPresent/transfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLAST\\r\\n\"\n\t\t    \"\\t\\tSelect the previous article.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tLIST [ ACTIVE wildmat ]\\r\\n\"\n\t\t\"\\t\\tList the (subset of) valid newsgroups.\\r\\n\");\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tLIST HEADERS [ MSGID | RANGE ]\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via HDR.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST NEWSGROUPS [wildmat]\\r\\n\"\n\t\t    \"\\t\\tList the descriptions of the specified newsgroups.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLIST OVERVIEW.FMT\\r\\n\"\n\t\t    \"\\t\\tList the headers and metadata items available via OVER.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tLISTGROUP [group [range]]\\r\\n\"\n\t\t    \"\\t\\tList the article numbers in the specified newsgroup.\\r\\n\");\n\tif (config_getswitch(IMAPOPT_ALLOWNEWNEWS))\n\t    prot_printf(nntp_out, \"\\tNEWNEWS wildmat date time [GMT]\\r\\n\"\n\t\t\t\"\\t\\tList the newly arrived articles in the specified newsgroup(s)\\r\\n\"\n\t\t\t\"\\t\\tsince the specified date and time.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tNEXT\\r\\n\"\n\t\t    \"\\t\\tSelect the next article.\\r\\n\");\n\tprot_printf(nntp_out, \"\\tOVER [ message-id | range ]\\r\\n\"\n\t\t    \"\\t\\tRetrieve the overview information for the specified article(s).\\r\\n\");\n\tprot_printf(nntp_out, \"\\tPOST\\r\\n\"\n\t\t    \"\\t\\tPost an article to the server.\\r\\n\");\n    }\n\n    prot_printf(nntp_out, \"\\tQUIT\\r\\n\"\n\t\t\"\\t\\tTerminate the session.\\r\\n\");\n    if (tls_enabled() && !nntp_starttls_done && !nntp_authstate) {\n\tprot_printf(nntp_out, \"\\tSTARTTLS\\r\\n\"\n\t\t    \"\\t\\tStart a TLS negotiation.\\r\\n\");\n    }\n    prot_printf(nntp_out, \"\\tSTAT [ message-id | number ]\\r\\n\"\n\t\t\"\\t\\tCheck if the specified article exists.\\r\\n\");\n    if (nntp_capa & MODE_FEED) {\n\tprot_printf(nntp_out, \"\\tTAKETHIS message-id\\r\\n\"\n\t\t    \"\\t\\tTransfer the specified article to the server.\\r\\n\");\n    }\n    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {\n\tprot_printf(nntp_out, \"\\tXPAT header message-id|range wildmat\\r\\n\"\n\t\t    \"\\t\\tList the specified article(s) in which the contents\\r\\n\"\n\t\t    \"\\t\\tof the specified header/metadata matches the wildmat.\\r\\n\");\n    }\n    prot_printf(nntp_out, \".\\r\\n\");\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "void list_proxy(char *server, void *data __attribute__((unused)), void *rock)\n{\n    struct enum_rock *erock = (struct enum_rock *) rock;\n    struct backend *be;\n    int r;\n    char *result;\n\n    be = proxy_findserver(server, &nntp_protocol,\n\t\t\t  nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t  &backend_cached, &backend_current, NULL, nntp_in);\n    if (!be) return;\n\n    prot_printf(be->out, \"LIST %s %s\\r\\n\", erock->cmd, erock->wild);\n\n    r = read_response(be, 0, &result);\n    if (!r && !strncmp(result, \"215 \", 4)) {\n\twhile (!(r = read_response(be, 0, &result)) && result[0] != '.') {\n\t    prot_printf(nntp_out, \"%s\", result);\n\t}\n    }\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "static int deliver_remote(message_data_t *msg, struct dest *dlist)\n{\n    struct dest *d;\n\n    /* run the txns */\n    for (d = dlist; d; d = d->next) {\n\tstruct backend *be;\n\tchar buf[4096];\n\n\tbe = proxy_findserver(d->server, &nntp_protocol,\n\t\t\t      nntp_userid ? nntp_userid : \"anonymous\",\n\t\t\t      &backend_cached, &backend_current,\n\t\t\t      NULL, nntp_in);\n\tif (!be) return IMAP_SERVER_UNAVAILABLE;\n\n\t/* tell the backend about our new article */\n\tprot_printf(be->out, \"IHAVE %s\\r\\n\", msg->id);\n\tprot_flush(be->out);\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"335\", buf, 3)) {\n\t    syslog(LOG_NOTICE, \"backend doesn't want article %s\", msg->id);\n\t    continue;\n\t}\n\n\t/* send the article */\n\trewind(msg->f);\n\twhile (fgets(buf, sizeof(buf), msg->f)) {\n\t    if (buf[0] == '.') prot_putc('.', be->out);\n\t    do {\n\t\tprot_printf(be->out, \"%s\", buf);\n\t    } while (buf[strlen(buf)-1] != '\\n' &&\n\t\t     fgets(buf, sizeof(buf), msg->f));\n\t}\n\n\t/* Protect against messages not ending in CRLF */\n\tif (buf[strlen(buf)-1] != '\\n') prot_printf(be->out, \"\\r\\n\");\n\n\tprot_printf(be->out, \".\\r\\n\");\n\n\tif (!prot_fgets(buf, sizeof(buf), be->in) ||\n\t    strncmp(\"235\", buf, 3)) {\n\t    syslog(LOG_WARNING, \"article %s transfer to backend failed\",\n\t\t   msg->id);\n\t    return NNTP_FAIL_TRANSFER;\n\t}\n    }\n\n    return 0;\n}", "target": 1, "cwe": ["CWE-287"], "message": "Secunia SA46093 - make sure nntp authentication completes\n\nDiscovered by Stefan Cornelius, Secunia Research\n\nThe vulnerability is caused due to the access restriction for certain\ncommands only checking whether or not variable \"nntp_userid\" is non-NULL,\nwithout performing additional checks to verify that a complete, successful\nauthentication actually took place. The variable \"nntp_userid\" can be set to\npoint to a string holding the username (changing it to a non-NULL, thus\nallowing attackers to bypass the checks) by sending an \"AUTHINFO USER\"\ncommand. The variable is not reset to NULL until e.g. a wrong \"AUTHINFO\nPASS\" command is received. This can be exploited to bypass the\nauthentication mechanism and allows access to e.g. the \"NEWNEWS\" or the\n\"LIST NEWSGROUPS\" commands by sending an \"AUTHINFO USER\" command without a\nfollowing \"AUTHINFO PASS\" command."}
{"func": "httpSpecialDoSide(HTTPRequestPtr requestor)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    if(client->reqlen - client->reqbegin >= client->bodylen) {\n        AtomPtr data;\n        data = internAtomN(client->reqbuf + client->reqbegin,\n                           client->reqlen - client->reqbegin);\n        client->reqbegin = 0;\n        client->reqlen = 0;\n        if(data == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate data.\\n\");\n            httpClientError(requestor, 500,\n                            internAtom(\"Couldn't allocate data\"));\n            return 1;\n        }\n        httpSpecialDoSideFinish(data, requestor);\n        return 1;\n    }\n\n    if(client->reqlen - client->reqbegin >= CHUNK_SIZE) {\n        httpClientError(requestor, 500, internAtom(\"POST too large\"));\n        return 1;\n    }\n\n    if(client->reqbegin > 0 && client->reqlen > client->reqbegin) {\n        memmove(client->reqbuf, client->reqbuf + client->reqbegin,\n                client->reqlen - client->reqbegin);\n    }\n    client->reqlen -= client->reqbegin;\n    client->reqbegin = 0;\n\n    do_stream(IO_READ | IO_NOTNOW, client->fd,\n              client->reqlen, client->reqbuf, CHUNK_SIZE,\n              httpSpecialClientSideHandler, client);\n    return 1;\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "httpSpecialClientSideHandler(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    int push;\n\n    if((request->object->flags & OBJECT_ABORTED) || \n       !(request->object->flags & OBJECT_INPROGRESS)) {\n        httpClientDiscardBody(connection);\n        httpClientError(request, 503, internAtom(\"Post aborted\"));\n        return 1;\n    }\n        \n    if(status < 0) {\n        do_log_error(L_ERROR, -status, \"Reading from client\");\n        if(status == -EDOGRACEFUL)\n            httpClientFinish(connection, 1);\n        else\n            httpClientFinish(connection, 2);\n        return 1;\n    }\n\n    push = MIN(srequest->offset - connection->reqlen,\n               connection->bodylen - connection->reqoffset);\n    if(push > 0) {\n        connection->reqlen += push;\n        httpSpecialDoSide(request);\n    }\n\n    do_log(L_ERROR, \"Incomplete client request.\\n\");\n    connection->flags &= ~CONN_READER;\n    httpClientRawError(connection, 502,\n                       internAtom(\"Incomplete client request\"), 1);\n    return 1;\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "httpSpecialSideRequest(ObjectPtr object, int method, int from, int to,\n                       HTTPRequestPtr requestor, void *closure)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    assert(client->request == requestor);\n\n    if(method != METHOD_POST) {\n        httpClientError(requestor, 405, internAtom(\"Method not allowed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    return httpSpecialDoSide(requestor);\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "httpLocalRequest(ObjectPtr object, int method, int from, int to,\n                 HTTPRequestPtr requestor, void *closure)\n{\n    if(object->requestor == NULL)\n        object->requestor = requestor;\n\n    if(!disableLocalInterface && urlIsSpecial(object->key, object->key_size))\n        return httpSpecialRequest(object, method, from, to, \n                                  requestor, closure);\n\n    if(method >= METHOD_POST) {\n        httpClientError(requestor, 405, internAtom(\"Method not allowed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    /* objectFillFromDisk already did the real work but we have to\n       make sure we don't get into an infinite loop. */\n    if(object->flags & OBJECT_INITIAL) {\n        abortObject(object, 404, internAtom(\"Not found\"));\n    }\n    object->age = current_time.tv_sec;\n    object->date = current_time.tv_sec;\n\n    object->flags &= ~OBJECT_VALIDATING;\n    notifyObject(object);\n    return 1;\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "httpClientDiscardBody(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n\n    assert(connection->reqoffset == 0);\n    assert(connection->flags & CONN_READER);\n\n    if(connection->reqte != TE_IDENTITY)\n        goto fail;\n\n    if(connection->bodylen < 0)\n        goto fail;\n\n    if(connection->bodylen < connection->reqlen - connection->reqbegin) {\n        connection->reqbegin += connection->bodylen;\n        connection->bodylen = 0;\n    } else {\n        connection->bodylen -= connection->reqlen - connection->reqbegin;\n        connection->reqbegin = 0;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n    }\n    connection->reqte = TE_UNKNOWN;\n\n    if(connection->bodylen > 0) {\n        httpSetTimeout(connection, clientTimeout);\n        do_stream_buf(IO_READ | IO_NOTNOW,\n                      connection->fd, connection->reqlen,\n                      &connection->reqbuf, CHUNK_SIZE,\n                      httpClientDiscardHandler, connection);\n        return 1;\n    }\n\n    if(connection->reqlen > connection->reqbegin &&\n       (connection->reqlen - connection->reqbegin) > 0) {\n        memmove(connection->reqbuf, connection->reqbuf + connection->reqbegin,\n                connection->reqlen - connection->reqbegin);\n        connection->reqlen -= connection->reqbegin;\n        connection->reqbegin = 0;\n    } else {\n        connection->reqlen = 0;\n        connection->reqbegin = 0;\n    }\n\n    httpSetTimeout(connection, clientTimeout);\n    /* We need to delay in order to make sure the previous request\n       gets queued on the server side.  IO_NOTNOW isn't strong enough\n       for that due to IO_IMMEDIATE. */\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        goto fail;\n    }\n    return 1;\n\n fail:\n    connection->reqlen = 0;\n    connection->reqbegin = 0;\n    connection->bodylen = 0;\n    connection->reqte = TE_UNKNOWN;\n    shutdown(connection->fd, 2);\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        connection->flags &= ~CONN_READER;\n    }\n    return 1;\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "httpSpecialDoSideFinish(AtomPtr data, HTTPRequestPtr requestor)\n{\n    ObjectPtr object = requestor->object;\n\n    if(matchUrl(\"/polipo/config\", object)) {\n        AtomListPtr list = NULL;\n        int i, rc;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse variable to set\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            rc = parseConfigLine(list->list[i]->string, NULL, 0, 1);\n            if(rc < 0) {\n                abortObject(object, 400,\n                            rc == -1 ?\n                            internAtom(\"Couldn't parse variable to set\") :\n                            internAtom(\"Variable is not settable\"));\n                destroyAtomList(list);\n                goto out;\n            }\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/config?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else if(matchUrl(\"/polipo/status\", object)) {\n        AtomListPtr list = NULL;\n        int i;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse action\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            char *equals = \n                memchr(list->list[i]->string, '=', list->list[i]->length);\n            AtomPtr name = \n                equals ? \n                internAtomN(list->list[i]->string, \n                            equals - list->list[i]->string) :\n                retainAtom(list->list[i]);\n            if(name == atomInitForbidden)\n                initForbidden();\n            else if(name == atomReopenLog)\n                reopenLog();\n            else if(name == atomDiscardObjects)\n                discardObjects(1, 0);\n            else if(name == atomWriteoutObjects)\n                writeoutObjects(1);\n            else if(name == atomFreeChunkArenas)\n                free_chunk_arenas();\n            else {\n                abortObject(object, 400, internAtomF(\"Unknown action %s\",\n                                                     name->string));\n                releaseAtom(name);\n                destroyAtomList(list);\n                goto out;\n            }\n            releaseAtom(name);\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/status?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else {\n        abortObject(object, 405, internAtom(\"Method not allowed\"));\n    }\n\n out:\n    releaseAtom(data);\n    notifyObject(object);\n    requestor->connection->flags &= ~CONN_READER;\n    return 1;\n}", "target": 1, "cwe": ["CWE-617"], "message": "Try to read POST requests to local configuration interface correctly."}
{"func": "static char *getusername(void)\n{\n\tchar *username = NULL;\n\tstruct passwd *password = getpwuid(getuid());\n\n\tif (password)\n\t\tusername = password->pw_name;\n\treturn username;\n}", "target": 1, "cwe": ["CWE-362"], "message": "mount.cifs: guard against signals by unprivileged users\n\nIf mount.cifs is setuid root, then the unprivileged user who runs the\nprogram can send the mount.cifs process a signal and kill it. This is\nnot a huge problem unless we happen to be updating the mtab at the\ntime, in which case the mtab lockfiles might not get cleaned up.\n\nTo remedy this, have the privileged mount.cifs process set its real\nuid to the effective uid (usually, root). This prevents unprivileged\nusers from being able to signal the process.\n\nWhile we're at it, also mask off signals while we're updating the\nmtab. This leaves a SIGKILL by root as the only way to interrupt the\nmtab update, but there's really nothing we can do about that.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "assemble_mountinfo(struct parsed_mount_info *parsed_info,\n\t\t   const char *thisprogram, const char *mountpoint,\n\t\t   const char *orig_dev, char *orgoptions)\n{\n\tint rc;\n\n\trc = drop_child_privs();\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, orig_dev,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tparsed_info->flags |= CIFS_SETUID_FLAGS;\n\t}\n\n\trc = get_pw_from_env(parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (orgoptions) {\n\t\trc = parse_options(orgoptions, parsed_info);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\tif (getuid()) {\n\t\tif (!(parsed_info->flags & (MS_USERS | MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t}\n\n\tparsed_info->flags &= ~(MS_USERS | MS_USER);\n\n\trc = parse_unc(orig_dev, parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\trc = resolve_host(parsed_info);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (!parsed_info->got_user) {\n\t\t/*\n\t\t * Note that the password will not be retrieved from the\n\t\t * USER env variable (ie user%password form) as there is\n\t\t * already a PASSWD environment varaible\n\t\t */\n\t\tif (getenv(\"USER\"))\n\t\t\tstrlcpy(parsed_info->username, getenv(\"USER\"),\n\t\t\t\tsizeof(parsed_info->username));\n\t\telse\n\t\t\tstrlcpy(parsed_info->username, getusername(),\n\t\t\t\tsizeof(parsed_info->username));\n\t\tparsed_info->got_user = 1;\n\t}\n\n\tif (!parsed_info->got_password) {\n\t\t/* getpass is obsolete, but there's apparently nothing that replaces it */\n\t\tchar *tmp_pass = getpass(\"Password: \");\n\t\tif (!tmp_pass) {\n\t\t\tfprintf(stderr, \"Error reading password, exiting\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t\trc = set_password(parsed_info, tmp_pass);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\t/* copy in ver= string. It's not really needed, but what the hell */\n\tstrlcat(parsed_info->options, \",ver=\", sizeof(parsed_info->options));\n\tstrlcat(parsed_info->options, OPTIONS_VERSION, sizeof(parsed_info->options));\n\n\t/* copy in user= string */\n\tif (parsed_info->got_user) {\n\t\tstrlcat(parsed_info->options, \",user=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->username,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\n\tif (*parsed_info->domain) {\n\t\tstrlcat(parsed_info->options, \",domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->domain,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\nassemble_exit:\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-362"], "message": "mount.cifs: guard against signals by unprivileged users\n\nIf mount.cifs is setuid root, then the unprivileged user who runs the\nprogram can send the mount.cifs process a signal and kill it. This is\nnot a huge problem unless we happen to be updating the mtab at the\ntime, in which case the mtab lockfiles might not get cleaned up.\n\nTo remedy this, have the privileged mount.cifs process set its real\nuid to the effective uid (usually, root). This prevents unprivileged\nusers from being able to signal the process.\n\nWhile we're at it, also mask off signals while we're updating the\nmtab. This leaves a SIGKILL by root as the only way to interrupt the\nmtab update, but there's really nothing we can do about that.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "add_mtab(char *devname, char *mountpoint, unsigned long flags)\n{\n\tint rc = 0;\n\tchar *mount_user;\n\tstruct mntent mountent;\n\tFILE *pmntfile;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (getuid() != 0) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tmount_user = getusername();\n\t\t\tif (mount_user)\n\t\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\trc = EX_FILEIO;\n\t}\n\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-362"], "message": "mount.cifs: guard against signals by unprivileged users\n\nIf mount.cifs is setuid root, then the unprivileged user who runs the\nprogram can send the mount.cifs process a signal and kill it. This is\nnot a huge problem unless we happen to be updating the mtab at the\ntime, in which case the mtab lockfiles might not get cleaned up.\n\nTo remedy this, have the privileged mount.cifs process set its real\nuid to the effective uid (usually, root). This prevents unprivileged\nusers from being able to signal the process.\n\nWhile we're at it, also mask off signals while we're updating the\nmtab. This leaves a SIGKILL by root as the only way to interrupt the\nmtab update, but there's really nothing we can do about that.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>"}
{"func": "process_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tint offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2)) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "In process_ra() ND_OPT_DNSSL_INFORMATION option parsing \"label_len\"\nis not checked for negativeness;  it leads to \"suffix\" buffer overflow,\nwhich leads to privilege escalation (at least with -fno-stack-protector,\nI didn't discover whether it's possible with -fstack-protector)."}
{"func": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-22"], "message": "set_interface_var() doesn't check interface name and blindly does\nfopen(path \"/\" ifname, \"w\") on it.  As \"ifname\" is an untrusted input, it\nshould be checked for \"..\" and/or \"/\" in it.  Otherwise, an infected\nunprivileged daemon may overwrite contents of file named \"mtu\",\n\"hoplimit\", etc. in arbitrary location with arbitrary 32-bit value in\ndecimal representation (\"%d\").  If an attacker has a local account or\nmay create arbitrary symlinks with these names in any location (e.g.\n/tmp), any file may be overwritten with a decimal value."}
{"func": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tflog(LOG_WARNING, \"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "main() must fail on privsep_init() errors, it must not run\nwithout privilege separation as privsep is expected."}
{"func": "privsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "cwe": ["CWE-20"], "message": "privsep_read_loop() should return on unprivileged daemon death /\nsocket close(), not loop forever with polling read() getting -1."}
{"func": "main(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "message": "Really exit on privsep init failure."}
{"func": "process_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tunsigned int offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * 1) must not overflow int: label + 2, offset + label_len\n\t\t\t\t * 2) last byte of dnssli_suffix must not overflow opt_str + len\n\t\t\t\t */\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2) ||\n\t\t\t\t    label_len > label_len + 2 ||\n\t\t\t\t    &dnsslinfo->nd_opt_dnssli_suffixes[offset+label_len] - (char*)opt_str >= len ||\n\t\t\t\t    offset + label_len < offset) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "process_ra() has numerous missed len checks.  It leads to buffer\noverreads."}
{"func": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\n\t/* validation */\n\tlen -= sizeof(struct nd_router_solicit);\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\n\tif (iface->UnicastOnly) {\n\t\tdlog(LOG_DEBUG, 5, \"random mdelay for %s: %g seconds.\", iface->Name, delay/1000.0);\n\t\tmdelay(delay);\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\t/* last RA was sent only a few moments ago, don't send another immediately. */\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\t/* no RA sent in a while, send a multicast reply */\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}", "target": 1, "cwe": ["CWE-20"], "message": "removing mdelay in unicast only case"}
{"func": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n\n    /* loop broken with a 'break' when a non-'\\\\n' ended line is read */\n\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    /* Overflow */\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\t/* Incomplete read */\n\t\treturn -1;\n\t    } else {\n\t\t/* EOF */\n\t\treturn 0;\n\t    }\n\t}\n\n\t/* skip leading spaces --- line may be blank */\n\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\n\t    /*\n\t     * we are only interested in characters before the first '#'\n\t     * character\n\t     */\n\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                /* the line has been read */\n\t    }\n\n\t    s = os;\n\n\t    /*\n\t     * Check for backslash by scanning back from the end of\n\t     * the entered line, the '\\n' has been included since\n\t     * normally a line is terminated with this\n\t     * character. fgets() should only return one though!\n\t     */\n\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\n\t    /* check if it ends with a backslash */\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              /* truncate the line here */\n\t\tused += strlen(os);\n\t\tp = s;                  /* there is more ... */\n\t    } else {\n\t\t/* End of the line! */\n\t\tused += strlen(os);\n\t\tbreak;                  /* this is the complete line */\n\t    }\n\n\t} else {\n\t    /* Nothing in this line */\n\t    /* Don't move p         */\n\t}\n    }\n\n    return used;\n}", "target": 1, "cwe": ["CWE-119"], "message": "pam_env: correctly count leading whitespace when parsing environment file\n\n* modules/pam_env/pam_env.c (_assemble_line): Correctly count leading\nwhitespace.\nFixes CVE-2011-3148.\nBug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/pam/+bug/874469"}
{"func": "static int _expand_arg(pam_handle_t *pamh, char **value)\n{\n  const char *orig=*value, *tmpptr=NULL;\n  char *ptr;       /*\n\t\t    * Sure would be nice to use tmpptr but it needs to be\n\t\t    * a constant so that the compiler will shut up when I\n\t\t    * call pam_getenv and _pam_get_item_byname -- sigh\n\t\t    */\n\n  /* No unexpanded variable can be bigger than BUF_SIZE */\n  char type, tmpval[BUF_SIZE];\n\n  /* I know this shouldn't be hard-coded but it's so much easier this way */\n  char tmp[MAX_ENV];\n\n  D((\"Remember to initialize tmp!\"));\n  memset(tmp, 0, MAX_ENV);\n\n  /*\n   * (possibly non-existent) environment variables can be used as values\n   * by prepending a \"$\" and wrapping in {} (ie: ${HOST}), can escape with \"\\\"\n   * (possibly non-existent) PAM items can be used as values\n   * by prepending a \"@\" and wrapping in {} (ie: @{PAM_RHOST}, can escape\n   *\n   */\n  D((\"Expanding <%s>\",orig));\n  while (*orig) {     /* while there is some input to deal with */\n    if ('\\\\' == *orig) {\n      ++orig;\n      if ('$' != *orig && '@' != *orig) {\n\tD((\"Unrecognized escaped character: <%c> - ignoring\", *orig));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Unrecognized escaped character: <%c> - ignoring\",\n\t\t   *orig);\n      } else if ((strlen(tmp) + 1) < MAX_ENV) {\n\ttmp[strlen(tmp)] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog (pamh, LOG_ERR, \"Variable buffer overflow: <%s> + <%s>\",\n\t\t tmp, tmpptr);\n      }\n      continue;\n    }\n    if ('$' == *orig || '@' == *orig) {\n      if ('{' != *(orig+1)) {\n\tD((\"Expandable variables must be wrapped in {}\"\n\t   \" <%s> - ignoring\", orig));\n\tpam_syslog(pamh, LOG_ERR, \"Expandable variables must be wrapped in {}\"\n\t\t \" <%s> - ignoring\", orig);\n\tif ((strlen(tmp) + 1) < MAX_ENV) {\n\t  tmp[strlen(tmp)] = *orig++;        /* Note the increment */\n\t}\n\tcontinue;\n      } else {\n\tD((\"Expandable argument: <%s>\", orig));\n\ttype = *orig;\n\torig+=2;     /* skip the ${ or @{ characters */\n\tptr = strchr(orig, '}');\n\tif (ptr) {\n\t  *ptr++ = '\\0';\n\t} else {\n\t  D((\"Unterminated expandable variable: <%s>\", orig-2));\n\t  pam_syslog(pamh, LOG_ERR,\n\t\t     \"Unterminated expandable variable: <%s>\", orig-2);\n\t  return PAM_ABORT;\n\t}\n\tstrncpy(tmpval, orig, sizeof(tmpval));\n\ttmpval[sizeof(tmpval)-1] = '\\0';\n\torig=ptr;\n\t/*\n\t * so, we know we need to expand tmpval, it is either\n\t * an environment variable or a PAM_ITEM. type will tell us which\n\t */\n\tswitch (type) {\n\n\tcase '$':\n\t  D((\"Expanding env var: <%s>\",tmpval));\n\t  tmpptr = pam_getenv(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tcase '@':\n\t  D((\"Expanding pam item: <%s>\",tmpval));\n\t  tmpptr = _pam_get_item_byname(pamh, tmpval);\n\t  D((\"Expanded to <%s>\", tmpptr));\n\t  break;\n\n\tdefault:\n\t  D((\"Impossible error, type == <%c>\", type));\n\t  pam_syslog(pamh, LOG_CRIT, \"Impossible error, type == <%c>\", type);\n\t  return PAM_ABORT;\n\t}         /* switch */\n\n\tif (tmpptr) {\n\t  if ((strlen(tmp) + strlen(tmpptr)) < MAX_ENV) {\n\t    strcat(tmp, tmpptr);\n\t  } else {\n\t    /* is it really a good idea to try to log this? */\n\t    D((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n\t  }\n\t}\n      }           /* if ('{' != *orig++) */\n    } else {      /* if ( '$' == *orig || '@' == *orig) */\n      if ((strlen(tmp) + 1) < MAX_ENV) {\n\ttmp[strlen(tmp)] = *orig++;        /* Note the increment */\n      } else {\n\t/* is it really a good idea to try to log this? */\n\tD((\"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr));\n\tpam_syslog(pamh, LOG_ERR,\n\t\t   \"Variable buffer overflow: <%s> + <%s>\", tmp, tmpptr);\n      }\n    }\n  }              /* for (;*orig;) */\n\n  if (strlen(tmp) > strlen(*value)) {\n    free(*value);\n    if ((*value = malloc(strlen(tmp) +1)) == NULL) {\n      D((\"Couldn't malloc %d bytes for expanded var\", strlen(tmp)+1));\n      pam_syslog (pamh, LOG_ERR, \"Couldn't malloc %lu bytes for expanded var\",\n\t       (unsigned long)strlen(tmp)+1);\n      return PAM_BUF_ERR;\n    }\n  }\n  strcpy(*value, tmp);\n  memset(tmp,'\\0',sizeof(tmp));\n  D((\"Exit.\"));\n\n  return PAM_SUCCESS;\n}", "target": 1, "cwe": ["CWE-119"], "message": "pam_env: abort when encountering an overflowed environment variable expansion\n\n* modules/pam_env/pam_env.c (_expand_arg): Abort when encountering an\noverflowed environment variable expansion.\nFixes CVE-2011-3149.\nBug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/pam/+bug/874565"}
{"func": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}", "target": 1, "cwe": ["CWE-189"], "message": "fix recursion level crash (bb #3706).\n\nThanks to Stephane Chazelas for the analysis."}
{"func": "int cli_bytecode_runhook(cli_ctx *cctx, const struct cl_engine *engine, struct cli_bc_ctx *ctx,\n\t\t\t unsigned id, fmap_t *map, const char **virname)\n{\n    const unsigned *hooks = engine->hooks[id - _BC_START_HOOKS];\n    unsigned i, hooks_cnt = engine->hooks_cnt[id - _BC_START_HOOKS];\n    int ret;\n    unsigned executed = 0, breakflag = 0, errorflag = 0;\n\n    cli_dbgmsg(\"Bytecode executing hook id %u (%u hooks)\\n\", id, hooks_cnt);\n    /* restore match counts */\n    cli_bytecode_context_setfile(ctx, map);\n    ctx->hooks.match_counts = ctx->lsigcnt;\n    ctx->hooks.match_offsets = ctx->lsigoff;\n    for (i=0;i < hooks_cnt;i++) {\n\tconst struct cli_bc *bc = &engine->bcs.all_bcs[hooks[i]];\n\tif (bc->lsig) {\n\t    if (!cctx->hook_lsig_matches ||\n\t\t!cli_bitset_test(cctx->hook_lsig_matches, bc->hook_lsig_id-1))\n\t\tcontinue;\n\t    cli_dbgmsg(\"Bytecode: executing bytecode %u (lsig matched)\\n\" , bc->id);\n\t}\n\tcli_bytecode_context_setfuncid(ctx, bc, 0);\n\tret = cli_bytecode_run(&engine->bcs, bc, ctx);\n\texecuted++;\n\tif (ret != CL_SUCCESS) {\n\t    cli_warnmsg(\"Bytecode %u failed to run: %s\\n\", bc->id, cl_strerror(ret));\n\t    errorflag = 1;\n\t    continue;\n\t}\n\tif (ctx->virname) {\n\t    cli_dbgmsg(\"Bytecode found virus: %s\\n\", ctx->virname);\n\t    if (virname)\n\t\t*virname = ctx->virname;\n\t    cli_bytecode_context_clear(ctx);\n\t    return CL_VIRUS;\n\t}\n\tret = cli_bytecode_context_getresult_int(ctx);\n\t/* TODO: use prefix here */\n\tcli_dbgmsg(\"Bytecode %u returned %u\\n\", bc->id, ret);\n\tif (ret == 0xcea5e) {\n\t    cli_dbgmsg(\"Bytecode set BREAK flag in hook!\\n\");\n\t    breakflag = 1;\n\t}\n\tif (!ret) {\n\t    char *tempfile;\n\t    int fd = cli_bytecode_context_getresult_file(ctx, &tempfile);\n\t    if (fd && fd != -1) {\n\t\tif (cctx && cctx->engine->keeptmp)\n\t\t    cli_dbgmsg(\"Bytecode %u unpacked file saved in %s\\n\",\n\t\t\t       bc->id, tempfile);\n\t\telse\n\t\t    cli_dbgmsg(\"Bytecode %u unpacked file\\n\", bc->id);\n\t\tlseek(fd, 0, SEEK_SET);\n\t\tcli_dbgmsg(\"***** Scanning unpacked file ******\\n\");\n\t\tret = cli_magic_scandesc(fd, cctx);\n\t\tif (!cctx || !cctx->engine->keeptmp)\n\t\t    if (ftruncate(fd, 0) == -1)\n\t\t\tcli_dbgmsg(\"ftruncate failed on %d\\n\", fd);\n\t\tclose(fd);\n\t\tif (!cctx || !cctx->engine->keeptmp) {\n\t\t    if (tempfile && cli_unlink(tempfile))\n\t\t\tret = CL_EUNLINK;\n\t\t}\n\t\tfree(tempfile);\n\t\tif (ret != CL_CLEAN) {\n\t\t    if (ret == CL_VIRUS)\n\t\t\tcli_dbgmsg(\"Scanning unpacked file by bytecode %u found a virus\\n\", bc->id);\n\t\t    cli_bytecode_context_clear(ctx);\n\t\t    return ret;\n\t\t}\n\t\tcli_bytecode_context_reset(ctx);\n\t\tcontinue;\n\t    }\n\t}\n\tcli_bytecode_context_reset(ctx);\n    }\n    if (executed)\n\tcli_dbgmsg(\"Bytecode: executed %u bytecodes for this hook\\n\", executed);\n    else\n\tcli_dbgmsg(\"Bytecode: no logical signature matched, no bytecode executed\\n\");\n    if (errorflag && cctx && cctx->engine->bytecode_mode == CL_BYTECODE_MODE_TEST)\n\treturn CL_EBYTECODE_TESTFAIL;\n    return breakflag ? CL_BREAK : CL_CLEAN;\n}", "target": 1, "cwe": ["CWE-189"], "message": "fix recursion level crash (bb #3706).\n\nThanks to Stephane Chazelas for the analysis."}
{"func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_string_free (message_classes, TRUE);\n}", "target": 1, "cwe": ["CWE-79"], "message": "theme_adium_append_message: escape alias before displaying it\n\nNot doing so can lead to nasty HTML injection from hostile users.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=662035"}
{"func": "static int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tjpc_cox_destroycompparms(compparms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n/* Sigh.  This bit should be in the same field in both COC and COD mrk segs. */\ncompparms->csty |= JPC_COX_PRT;\n\t} else {\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Incorporated changes from patch\njasper-1.900.3-CVE-2011-4516-CVE-2011-4517-CERT-VU-887409.patch"}
{"func": "static int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Incorporated changes from patch\njasper-1.900.3-CVE-2011-4516-CVE-2011-4517-CERT-VU-887409.patch"}
{"func": "theme_adium_append_message (EmpathyChatView *view,\n\t\t\t    EmpathyMessage  *msg)\n{\n\tEmpathyThemeAdium     *theme = EMPATHY_THEME_ADIUM (view);\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tEmpathyContact        *sender;\n\tTpMessage             *tp_msg;\n\tTpAccount             *account;\n\tgchar                 *body_escaped, *name_escaped;\n\tconst gchar           *name;\n\tconst gchar           *contact_id;\n\tEmpathyAvatar         *avatar;\n\tconst gchar           *avatar_filename = NULL;\n\tgint64                 timestamp;\n\tconst gchar           *html = NULL;\n\tconst gchar           *func;\n\tconst gchar           *service_name;\n\tGString               *message_classes = NULL;\n\tgboolean               is_backlog;\n\tgboolean               consecutive;\n\tgboolean               action;\n\n\tif (priv->pages_loading != 0) {\n\t\tqueue_item (&priv->message_queue, QUEUED_MESSAGE, msg, NULL);\n\t\treturn;\n\t}\n\n\t/* Get information */\n\tsender = empathy_message_get_sender (msg);\n\taccount = empathy_contact_get_account (sender);\n\tservice_name = empathy_protocol_name_to_display_name\n\t\t(tp_account_get_protocol (account));\n\tif (service_name == NULL)\n\t\tservice_name = tp_account_get_protocol (account);\n\ttimestamp = empathy_message_get_timestamp (msg);\n\tbody_escaped = theme_adium_parse_body (theme,\n\t\tempathy_message_get_body (msg),\n\t\tempathy_message_get_token (msg));\n\tname = empathy_contact_get_logged_alias (sender);\n\tcontact_id = empathy_contact_get_id (sender);\n\taction = (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION);\n\n\t/* If this is a /me probably */\n\tif (action) {\n\t\tgchar *str;\n\n\t\tif (priv->data->version >= 4 || !priv->data->custom_template) {\n\t\t\tstr = g_strdup_printf (\"<span class='actionMessageUserName'>%s</span>\"\n\t\t\t\t\t       \"<span class='actionMessageBody'>%s</span>\",\n\t\t\t\t\t       name, body_escaped);\n\t\t} else {\n\t\t\tstr = g_strdup_printf (\"*%s*\", body_escaped);\n\t\t}\n\t\tg_free (body_escaped);\n\t\tbody_escaped = str;\n\t}\n\n\t/* Get the avatar filename, or a fallback */\n\tavatar = empathy_contact_get_avatar (sender);\n\tif (avatar) {\n\t\tavatar_filename = avatar->filename;\n\t}\n\tif (!avatar_filename) {\n\t\tif (empathy_contact_is_user (sender)) {\n\t\t\tavatar_filename = priv->data->default_outgoing_avatar_filename;\n\t\t} else {\n\t\t\tavatar_filename = priv->data->default_incoming_avatar_filename;\n\t\t}\n\t\tif (!avatar_filename) {\n\t\t\tif (!priv->data->default_avatar_filename) {\n\t\t\t\tpriv->data->default_avatar_filename =\n\t\t\t\t\tempathy_filename_from_icon_name (EMPATHY_IMAGE_AVATAR_DEFAULT,\n\t\t\t\t\t\t\t\t\t GTK_ICON_SIZE_DIALOG);\n\t\t\t}\n\t\t\tavatar_filename = priv->data->default_avatar_filename;\n\t\t}\n\t}\n\n\t/* We want to join this message with the last one if\n\t * - senders are the same contact,\n\t * - last message was recieved recently,\n\t * - last message and this message both are/aren't backlog, and\n\t * - DisableCombineConsecutive is not set in theme's settings */\n\tis_backlog = empathy_message_is_backlog (msg);\n\tconsecutive = empathy_contact_equal (priv->last_contact, sender) &&\n\t\t(timestamp - priv->last_timestamp < MESSAGE_JOIN_PERIOD) &&\n\t\t(is_backlog == priv->last_is_backlog) &&\n\t\t!tp_asv_get_boolean (priv->data->info,\n\t\t\t\t     \"DisableCombineConsecutive\", NULL);\n\n\t/* Define message classes */\n\tmessage_classes = g_string_new (\"message\");\n\tif (!priv->has_focus && !is_backlog) {\n\t\tif (!priv->has_unread_message) {\n\t\t\tg_string_append (message_classes, \" firstFocus\");\n\t\t\tpriv->has_unread_message = TRUE;\n\t\t}\n\t\tg_string_append (message_classes, \" focus\");\n\t}\n\tif (is_backlog) {\n\t\tg_string_append (message_classes, \" history\");\n\t}\n\tif (consecutive) {\n\t\tg_string_append (message_classes, \" consecutive\");\n\t}\n\tif (empathy_contact_is_user (sender)) {\n\t\tg_string_append (message_classes, \" outgoing\");\n\t} else {\n\t\tg_string_append (message_classes, \" incoming\");\n\t}\n\tif (empathy_message_should_highlight (msg)) {\n\t\tg_string_append (message_classes, \" mention\");\n\t}\n\tif (empathy_message_get_tptype (msg) == TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY) {\n\t\tg_string_append (message_classes, \" autoreply\");\n\t}\n\tif (action) {\n\t\tg_string_append (message_classes, \" action\");\n\t}\n\t/* FIXME: other classes:\n\t * status - the message is a status change\n\t * event - the message is a notification of something happening\n\t *         (for example, encryption being turned on)\n\t * %status% - See %status% in theme_adium_append_html ()\n\t */\n\n\t/* This is slightly a hack, but it's the only way to add\n\t * arbitrary data to messages in the HTML. We add another\n\t * class called \"x-empathy-message-id-*\" to the message. This\n\t * way, we can remove the unread marker for this specific\n\t * message later. */\n\ttp_msg = empathy_message_get_tp_message (msg);\n\tif (tp_msg != NULL) {\n\t\tguint32 id;\n\t\tgboolean valid;\n\n\t\tid = tp_message_get_pending_message_id (tp_msg, &valid);\n\t\tif (valid) {\n\t\t\tg_string_append_printf (message_classes,\n\t\t\t    \" x-empathy-message-id-%u\", id);\n\t\t}\n\t}\n\n\t/* Define javascript function to use */\n\tif (consecutive) {\n\t\tfunc = priv->allow_scrolling ? \"appendNextMessage\" : \"appendNextMessageNoScroll\";\n\t} else {\n\t\tfunc = priv->allow_scrolling ? \"appendMessage\" : \"appendMessageNoScroll\";\n\t}\n\n\tif (empathy_contact_is_user (sender)) {\n\t\t/* out */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->out_nextcontext_html : priv->data->out_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->out_nextcontent_html : priv->data->out_content_html;\n\t\t}\n\n\t\t/* remove all the unread marks when we are sending a message */\n\t\ttheme_adium_remove_all_focus_marks (theme);\n\t} else {\n\t\t/* in */\n\t\tif (is_backlog) {\n\t\t\t/* context */\n\t\t\thtml = consecutive ? priv->data->in_nextcontext_html : priv->data->in_context_html;\n\t\t} else {\n\t\t\t/* content */\n\t\t\thtml = consecutive ? priv->data->in_nextcontent_html : priv->data->in_content_html;\n\t\t}\n\t}\n\n\tname_escaped = g_markup_escape_text (name, -1);\n\n\ttheme_adium_append_html (theme, func, html, body_escaped,\n\t\t\t\t avatar_filename, name_escaped, contact_id,\n\t\t\t\t service_name, message_classes->str,\n\t\t\t\t timestamp, is_backlog, empathy_contact_is_user (sender));\n\n\t/* Keep the sender of the last displayed message */\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t}\n\tpriv->last_contact = g_object_ref (sender);\n\tpriv->last_timestamp = timestamp;\n\tpriv->last_is_backlog = is_backlog;\n\n\tg_free (body_escaped);\n\tg_free (name_escaped);\n\tg_string_free (message_classes, TRUE);\n}", "target": 1, "cwe": ["CWE-79"], "message": "theme-adium: escape the name in actions as well"}
{"func": "tor_tls_context_init_one(tor_tls_context_t **ppcontext,\n                         crypto_pk_env_t *identity,\n                         unsigned int key_lifetime)\n{\n  tor_tls_context_t *new_ctx = tor_tls_context_new(identity,\n                                                   key_lifetime);\n  tor_tls_context_t *old_ctx = *ppcontext;\n\n  if (new_ctx != NULL) {\n    *ppcontext = new_ctx;\n\n    /* Free the old context if one existed. */\n    if (old_ctx != NULL) {\n      /* This is safe even if there are open connections: we reference-\n       * count tor_tls_context_t objects. */\n      tor_tls_context_decref(old_ctx);\n    }\n  }\n\n  return ((new_ctx != NULL) ? 0 : -1);\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't send a certificate chain on outgoing TLS connections from non-relays"}
{"func": "tor_tls_context_new(crypto_pk_env_t *identity, unsigned int key_lifetime)\n{\n  crypto_pk_env_t *rsa = NULL;\n  EVP_PKEY *pkey = NULL;\n  tor_tls_context_t *result = NULL;\n  X509 *cert = NULL, *idcert = NULL;\n  char *nickname = NULL, *nn2 = NULL;\n\n  tor_tls_init();\n  nickname = crypto_random_hostname(8, 20, \"www.\", \".net\");\n  nn2 = crypto_random_hostname(8, 20, \"www.\", \".net\");\n\n  /* Generate short-term RSA key. */\n  if (!(rsa = crypto_new_pk_env()))\n    goto error;\n  if (crypto_pk_generate_key(rsa)<0)\n    goto error;\n  /* Create certificate signed by identity key. */\n  cert = tor_tls_create_certificate(rsa, identity, nickname, nn2,\n                                    key_lifetime);\n  /* Create self-signed certificate for identity key. */\n  idcert = tor_tls_create_certificate(identity, identity, nn2, nn2,\n                                      IDENTITY_CERT_LIFETIME);\n  if (!cert || !idcert) {\n    log(LOG_WARN, LD_CRYPTO, \"Error creating certificate\");\n    goto error;\n  }\n\n  result = tor_malloc_zero(sizeof(tor_tls_context_t));\n  result->refcnt = 1;\n  result->my_cert = X509_dup(cert);\n  result->my_id_cert = X509_dup(idcert);\n  result->key = crypto_pk_dup_key(rsa);\n\n#ifdef EVERYONE_HAS_AES\n  /* Tell OpenSSL to only use TLS1 */\n  if (!(result->ctx = SSL_CTX_new(TLSv1_method())))\n    goto error;\n#else\n  /* Tell OpenSSL to use SSL3 or TLS1 but not SSL2. */\n  if (!(result->ctx = SSL_CTX_new(SSLv23_method())))\n    goto error;\n  SSL_CTX_set_options(result->ctx, SSL_OP_NO_SSLv2);\n#endif\n  SSL_CTX_set_options(result->ctx, SSL_OP_SINGLE_DH_USE);\n\n#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n  SSL_CTX_set_options(result->ctx,\n                      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n#endif\n  /* Yes, we know what we are doing here.  No, we do not treat a renegotiation\n   * as authenticating any earlier-received data.\n   */\n  if (use_unsafe_renegotiation_op) {\n    SSL_CTX_set_options(result->ctx,\n                        SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n  }\n  /* Don't actually allow compression; it uses ram and time, but the data\n   * we transmit is all encrypted anyway. */\n  if (result->ctx->comp_methods)\n    result->ctx->comp_methods = NULL;\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(result->ctx, SSL_MODE_RELEASE_BUFFERS);\n#endif\n  if (cert && !SSL_CTX_use_certificate(result->ctx,cert))\n    goto error;\n  X509_free(cert); /* We just added a reference to cert. */\n  cert=NULL;\n  if (idcert) {\n    X509_STORE *s = SSL_CTX_get_cert_store(result->ctx);\n    tor_assert(s);\n    X509_STORE_add_cert(s, idcert);\n    X509_free(idcert); /* The context now owns the reference to idcert */\n    idcert = NULL;\n  }\n  SSL_CTX_set_session_cache_mode(result->ctx, SSL_SESS_CACHE_OFF);\n  tor_assert(rsa);\n  if (!(pkey = _crypto_pk_env_get_evp_pkey(rsa,1)))\n    goto error;\n  if (!SSL_CTX_use_PrivateKey(result->ctx, pkey))\n    goto error;\n  EVP_PKEY_free(pkey);\n  pkey = NULL;\n  if (!SSL_CTX_check_private_key(result->ctx))\n    goto error;\n  {\n    crypto_dh_env_t *dh = crypto_dh_new(DH_TYPE_TLS);\n    SSL_CTX_set_tmp_dh(result->ctx, _crypto_dh_env_get_dh(dh));\n    crypto_dh_free(dh);\n  }\n  SSL_CTX_set_verify(result->ctx, SSL_VERIFY_PEER,\n                     always_accept_verify_cb);\n  /* let us realloc bufs that we're writing from */\n  SSL_CTX_set_mode(result->ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n\n  if (rsa)\n    crypto_free_pk_env(rsa);\n  tor_free(nickname);\n  tor_free(nn2);\n  return result;\n\n error:\n  tls_log_errors(NULL, LOG_WARN, \"creating TLS context\");\n  tor_free(nickname);\n  tor_free(nn2);\n  if (pkey)\n    EVP_PKEY_free(pkey);\n  if (rsa)\n    crypto_free_pk_env(rsa);\n  if (result)\n    tor_tls_context_decref(result);\n  if (cert)\n    X509_free(cert);\n  if (idcert)\n    X509_free(idcert);\n  return NULL;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't send a certificate chain on outgoing TLS connections from non-relays"}
{"func": "tor_tls_context_init(int is_public_server,\n                     crypto_pk_env_t *client_identity,\n                     crypto_pk_env_t *server_identity,\n                     unsigned int key_lifetime)\n{\n  int rv1 = 0;\n  int rv2 = 0;\n\n  if (is_public_server) {\n    tor_tls_context_t *new_ctx;\n    tor_tls_context_t *old_ctx;\n\n    tor_assert(server_identity != NULL);\n\n    rv1 = tor_tls_context_init_one(&server_tls_context,\n                                   server_identity,\n                                   key_lifetime);\n\n    if (rv1 >= 0) {\n      new_ctx = server_tls_context;\n      tor_tls_context_incref(new_ctx);\n      old_ctx = client_tls_context;\n      client_tls_context = new_ctx;\n\n      if (old_ctx != NULL) {\n        tor_tls_context_decref(old_ctx);\n      }\n    }\n  } else {\n    if (server_identity != NULL) {\n      rv1 = tor_tls_context_init_one(&server_tls_context,\n                                     server_identity,\n                                     key_lifetime);\n    } else {\n      tor_tls_context_t *old_ctx = server_tls_context;\n      server_tls_context = NULL;\n\n      if (old_ctx != NULL) {\n        tor_tls_context_decref(old_ctx);\n      }\n    }\n\n    rv2 = tor_tls_context_init_one(&client_tls_context,\n                                   client_identity,\n                                   key_lifetime);\n  }\n\n  return rv1 < rv2 ? rv1 : rv2;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't send a certificate chain on outgoing TLS connections from non-relays"}
{"func": "set_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits))) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Don't give the Guard flag to relays without the CVE-2011-2768 fix"}
{"func": "set_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits)) &&\n      is_router_version_good_for_possible_guard(ri->platform)) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}", "target": 1, "cwe": ["CWE-264"], "message": "Add option to give guard flag to relays without the CVE-2011-2768 fix\n\nThis way, all of the DA operators can upgrade immediately, without nuking\nevery client's set of entry guards as soon as a majority of them upgrade.\n\nUntil enough guards have upgraded, a majority of dirauths should set this\nconfig option so that there are still enough guards in the network. After\na few days pass, all dirauths should use the default."}
{"func": "command_process_create_cell(cell_t *cell, or_connection_t *conn)\n{\n  or_circuit_t *circ;\n  int id_is_high;\n\n  if (we_are_hibernating()) {\n    log_info(LD_OR,\n             \"Received create cell but we're shutting down. Sending back \"\n             \"destroy.\");\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_HIBERNATING);\n    return;\n  }\n\n  if (!server_mode(get_options())) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell (type %d) from %s:%d, but we're a client. \"\n           \"Sending back a destroy.\",\n           (int)cell->command, conn->_base.address, conn->_base.port);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  /* If the high bit of the circuit ID is not as expected, close the\n   * circ. */\n  id_is_high = cell->circ_id & (1<<15);\n  if ((id_is_high && conn->circ_id_type == CIRC_ID_TYPE_HIGHER) ||\n      (!id_is_high && conn->circ_id_type == CIRC_ID_TYPE_LOWER)) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell with unexpected circ_id %d. Closing.\",\n           cell->circ_id);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  if (circuit_id_in_use_on_orconn(cell->circ_id, conn)) {\n    routerinfo_t *router = router_get_by_digest(conn->identity_digest);\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received CREATE cell (circID %d) for known circ. \"\n           \"Dropping (age %d).\",\n           cell->circ_id, (int)(time(NULL) - conn->_base.timestamp_created));\n    if (router)\n      log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n             \"Details: nickname \\\"%s\\\", platform %s.\",\n             router->nickname, escaped(router->platform));\n    return;\n  }\n\n  circ = or_circuit_new(cell->circ_id, conn);\n  circ->_base.purpose = CIRCUIT_PURPOSE_OR;\n  circuit_set_state(TO_CIRCUIT(circ), CIRCUIT_STATE_ONIONSKIN_PENDING);\n  if (cell->command == CELL_CREATE) {\n    char *onionskin = tor_malloc(ONIONSKIN_CHALLENGE_LEN);\n    memcpy(onionskin, cell->payload, ONIONSKIN_CHALLENGE_LEN);\n\n    /* hand it off to the cpuworkers, and then return. */\n    if (assign_onionskin_to_cpuworker(NULL, circ, onionskin) < 0) {\n      log_warn(LD_GENERAL,\"Failed to hand off onionskin. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    log_debug(LD_OR,\"success: handed off onionskin.\");\n  } else {\n    /* This is a CREATE_FAST cell; we can handle it immediately without using\n     * a CPU worker. */\n    char keys[CPATH_KEY_MATERIAL_LEN];\n    char reply[DIGEST_LEN*2];\n\n    tor_assert(cell->command == CELL_CREATE_FAST);\n\n    /* Make sure we never try to use the OR connection on which we\n     * received this cell to satisfy an EXTEND request,  */\n    conn->is_connection_with_client = 1;\n\n    if (fast_server_handshake(cell->payload, (uint8_t*)reply,\n                              (uint8_t*)keys, sizeof(keys))<0) {\n      log_warn(LD_OR,\"Failed to generate key material. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    if (onionskin_answer(circ, CELL_CREATED_FAST, reply, keys)<0) {\n      log_warn(LD_OR,\"Failed to reply to CREATE_FAST cell. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n  }\n}", "target": 1, "cwe": ["CWE-264"], "message": "Reject create cells on outgoing OR connections from bridges"}
{"func": "genrand_int32(void)\n{\n    unsigned long y;\n\n    if (--left == 0) next_state();\n    y = *next++;\n\n    /* Tempering */\n    y ^= (y >> 11);\n    y ^= (y << 7) & 0x9d2c5680UL;\n    y ^= (y << 15) & 0xefc60000UL;\n    y ^= (y >> 18);\n\n    return y;\n}", "target": 1, "cwe": ["CWE-20"], "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e"}
{"func": "genrand_real(void) \n{ \n    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; \n    return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} ", "target": 1, "cwe": ["CWE-20"], "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e"}
{"func": "limited_rand(unsigned long limit)\n{\n    unsigned long mask = make_mask(limit);\n    int i;\n    unsigned long val;\n\n  retry:\n    val = 0;\n    for (i = SIZEOF_LONG/4-1; 0 <= i; i--) {\n        if (mask >> (i * 32)) {\n            val |= genrand_int32() << (i * 32);\n            val &= mask;\n            if (limit < val)\n                goto retry;\n        }\n    }\n    return val;\n}", "target": 1, "cwe": ["CWE-20"], "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e"}
{"func": "limited_big_rand(struct RBignum *limit)\n{\n    unsigned long mask, lim, rnd;\n    struct RBignum *val;\n    int i, len, boundary;\n\n    len = (limit->len * SIZEOF_BDIGITS + 3) / 4;\n    val = (struct RBignum *)rb_big_clone((VALUE)limit);\n    val->sign = 1;\n#if SIZEOF_BDIGITS == 2\n# define BIG_GET32(big,i) (((BDIGIT *)(big)->digits)[(i)*2] | \\\n                           ((i)*2+1 < (big)->len ? (((BDIGIT *)(big)->digits)[(i)*2+1] << 16) \\\n                                                 : 0))\n# define BIG_SET32(big,i,d) ((((BDIGIT *)(big)->digits)[(i)*2] = (d) & 0xffff), \\\n                             ((i)*2+1 < (big)->len ? (((BDIGIT *)(big)->digits)[(i)*2+1] = (d) >> 16) \\\n                                                   : 0))\n#else\n    /* SIZEOF_BDIGITS == 4 */\n# define BIG_GET32(big,i) (((BDIGIT *)(big)->digits)[i])\n# define BIG_SET32(big,i,d) (((BDIGIT *)(big)->digits)[i] = (d))\n#endif\n  retry:\n    mask = 0;\n    boundary = 1;\n    for (i = len-1; 0 <= i; i--) {\n        lim = BIG_GET32(limit, i);\n        mask = mask ? 0xffffffff : make_mask(lim);\n        if (mask) {\n            rnd = genrand_int32() & mask;\n            if (boundary) {\n                if (lim < rnd)\n                    goto retry;\n                if (rnd < lim)\n                    boundary = 0;\n            }\n        }\n        else {\n            rnd = 0;\n        }\n        BIG_SET32(val, i, rnd);\n    }\n    return rb_big_norm((VALUE)val);\n}", "target": 1, "cwe": ["CWE-20"], "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e"}
{"func": "rb_f_rand(argc, argv, obj)\n    int argc;\n    VALUE *argv;\n    VALUE obj;\n{\n    VALUE vmax;\n    long val, max;\n\n    rb_scan_args(argc, argv, \"01\", &vmax);\n    if (first) {\n\trand_init(random_seed());\n    }\n    switch (TYPE(vmax)) {\n      case T_FLOAT:\n\tif (RFLOAT(vmax)->value <= LONG_MAX && RFLOAT(vmax)->value >= LONG_MIN) {\n\t    max = (long)RFLOAT(vmax)->value;\n\t    break;\n\t}\n        if (RFLOAT(vmax)->value < 0)\n            vmax = rb_dbl2big(-RFLOAT(vmax)->value);\n        else\n            vmax = rb_dbl2big(RFLOAT(vmax)->value);\n\t/* fall through */\n      case T_BIGNUM:\n      bignum:\n        {\n            struct RBignum *limit = (struct RBignum *)vmax;\n            if (!limit->sign) {\n                limit = (struct RBignum *)rb_big_clone(vmax);\n                limit->sign = 1;\n            }\n            limit = (struct RBignum *)rb_big_minus((VALUE)limit, INT2FIX(1));\n            if (FIXNUM_P((VALUE)limit)) {\n                if (FIX2LONG((VALUE)limit) == -1)\n                    return rb_float_new(genrand_real());\n                return LONG2NUM(limited_rand(FIX2LONG((VALUE)limit)));\n            }\n            return limited_big_rand(limit);\n\t}\n      case T_NIL:\n\tmax = 0;\n\tbreak;\n      default:\n\tvmax = rb_Integer(vmax);\n\tif (TYPE(vmax) == T_BIGNUM) goto bignum;\n\t/* fall through */\n      case T_FIXNUM:\n\tmax = FIX2LONG(vmax);\n\tbreak;\n    }\n\n    if (max == 0) {\n\treturn rb_float_new(genrand_real());\n    }\n    if (max < 0) max = -max;\n    val = limited_rand(max-1);\n    return LONG2NUM(val);\n}", "target": 1, "cwe": ["CWE-20"], "message": "* random.c (rb_genrand_int32, rb_genrand_real), intern.h: Export.\n\n* string.c (rb_str_tmp_new), intern.h: New function.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_8@16014 b2dd03c8-39d4-4d8f-98ff-823fe69b080e"}
{"func": "int user_update(struct key *key, const void *data, size_t datalen)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data;\n\t\trcu_assign_pointer(key->payload.data, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "KEYS: Fix a NULL pointer deref in the user-defined key type\n\nFix a NULL pointer deref in the user-defined key type whereby updating a\nnegative key into a fully instantiated key will cause an oops to occur\nwhen the code attempts to free the non-existent old payload.\n\nThis results in an oops that looks something like the following:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000008\n  IP: [<ffffffff81085fa1>] __call_rcu+0x11/0x13e\n  PGD 3391d067 PUD 3894a067 PMD 0\n  Oops: 0002 [#1] SMP\n  CPU 1\n  Pid: 4354, comm: keyctl Not tainted 3.1.0-fsdevel+ #1140                  /DG965RY\n  RIP: 0010:[<ffffffff81085fa1>]  [<ffffffff81085fa1>] __call_rcu+0x11/0x13e\n  RSP: 0018:ffff88003d591df8  EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000000000006e\n  RDX: ffffffff8161d0c0 RSI: 0000000000000000 RDI: 0000000000000000\n  RBP: ffff88003d591e18 R08: 0000000000000000 R09: ffffffff8152fa6c\n  R10: 0000000000000000 R11: 0000000000000300 R12: ffff88003b8f9538\n  R13: ffffffff8161d0c0 R14: ffff88003b8f9d50 R15: ffff88003c69f908\n  FS:  00007f97eb18c720(0000) GS:ffff88003bd00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000008 CR3: 000000003d47a000 CR4: 00000000000006e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n  Process keyctl (pid: 4354, threadinfo ffff88003d590000, task ffff88003c78a040)\n  Stack:\n   ffff88003e0ffde0 ffff88003b8f9538 0000000000000001 ffff88003b8f9d50\n   ffff88003d591e28 ffffffff810860f0 ffff88003d591e68 ffffffff8117bfea\n   ffff88003d591e68 ffffffff00000000 ffff88003e0ffde1 ffff88003e0ffde0\n  Call Trace:\n   [<ffffffff810860f0>] call_rcu_sched+0x10/0x12\n   [<ffffffff8117bfea>] user_update+0x8d/0xa2\n   [<ffffffff8117723a>] key_create_or_update+0x236/0x270\n   [<ffffffff811789b1>] sys_add_key+0x123/0x17e\n   [<ffffffff813b84bb>] system_call_fastpath+0x16/0x1b\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Jeff Layton <jlayton@redhat.com>\nAcked-by: Neil Horman <nhorman@redhat.com>\nAcked-by: Steve Dickson <steved@redhat.com>\nAcked-by: James Morris <jmorris@namei.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n  *session_data_size = psession.size;\n\n  if (psession.size > *session_data_size)\n    {\n      ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n      goto error;\n    }\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "gnutls_session_get_data: fix possible buffer overflow\n\nThe test to avoid the buffer overflow was always false because\nsession_data_size was set at the wrong place. This problem has been introduced\nby this commit:\n\n|commit ad4ed44c65e753e6d3a00104c049dd81826ccbf3\n|Author: Nikos Mavrogiannopoulos <nmav@gnutls.org>\n|Date:   Mon Nov 7 22:24:48 2005 +0000\n|\n|    This is the initial commit in the 1.3 branch. Ported from the PSK branch:\n|    * PSK ciphersuites have been added.\n|    * The session resumption data are now system independent.\n\nSigned-off-by: Nikos Mavrogiannopoulos <nmav@gnutls.org>"}
{"func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  if (psession.size > *session_data_size)\n    {\n      ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n      goto error;\n    }\n  *session_data_size = psession.size;\n\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "bug fix in gnutls_session_get_data()."}
{"func": "xmlParsePI(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int cur, l;\n    const xmlChar *target;\n    xmlParserInputState state;\n    int count = 0;\n\n    if ((RAW == '<') && (NXT(1) == '?')) {\n\txmlParserInputPtr input = ctxt->input;\n\tstate = ctxt->instate;\n        ctxt->instate = XML_PARSER_PI;\n\t/*\n\t * this is a Processing Instruction.\n\t */\n\tSKIP(2);\n\tSHRINK;\n\n\t/*\n\t * Parse the target name and check for special support like\n\t * namespace.\n\t */\n        target = xmlParsePITarget(ctxt);\n\tif (target != NULL) {\n\t    if ((RAW == '?') && (NXT(1) == '>')) {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n\t    if (buf == NULL) {\n\t\txmlErrMemory(ctxt, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    cur = CUR;\n\t    if (!IS_BLANK(cur)) {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t  \"ParsePI: PI %s space expected\\n\", target);\n\t    }\n            SKIP_BLANKS;\n\t    cur = CUR_CHAR(l);\n\t    while (IS_CHAR(cur) && /* checked */\n\t\t   ((cur != '?') || (NXT(1) != '>'))) {\n\t\tif (len + 5 >= size) {\n\t\t    xmlChar *tmp;\n\n\t\t    size *= 2;\n\t\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t\t    if (tmp == NULL) {\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\txmlFree(buf);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = tmp;\n\t\t}\n\t\tcount++;\n\t\tif (count > 50) {\n\t\t    GROW;\n\t\t    count = 0;\n\t\t}\n\t\tCOPY_BUF(l,buf,len,cur);\n\t\tNEXTL(l);\n\t\tcur = CUR_CHAR(l);\n\t\tif (cur == 0) {\n\t\t    SHRINK;\n\t\t    GROW;\n\t\t    cur = CUR_CHAR(l);\n\t\t}\n\t    }\n\t    buf[len] = 0;\n\t    if (cur != '?') {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n\t\t      \"ParsePI: PI %s never end ...\\n\", target);\n\t    } else {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n#ifdef LIBXML_CATALOG_ENABLED\n\t\tif (((state == XML_PARSER_MISC) ||\n\t             (state == XML_PARSER_START)) &&\n\t\t    (xmlStrEqual(target, XML_CATALOG_PI))) {\n\t\t    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n\t\t    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n\t\t\t(allow == XML_CATA_ALLOW_ALL))\n\t\t\txmlParseCatalogPI(ctxt, buf);\n\t\t}\n#endif\n\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, buf);\n\t    }\n\t    xmlFree(buf);\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n\t}\n\tctxt->instate = state;\n    }\n}", "target": 1, "cwe": ["CWE-125"], "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"}
{"func": "xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {\n    int ret = 0;\n    int avail, tlen;\n    xmlChar cur, next;\n    const xmlChar *lastlt, *lastgt;\n\n    if (ctxt->input == NULL)\n        return(0);\n\n#ifdef DEBUG_PUSH\n    switch (ctxt->instate) {\n\tcase XML_PARSER_EOF:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EOF\\n\"); break;\n\tcase XML_PARSER_START:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START\\n\"); break;\n\tcase XML_PARSER_MISC:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try MISC\\n\");break;\n\tcase XML_PARSER_COMMENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try COMMENT\\n\");break;\n\tcase XML_PARSER_PROLOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PROLOG\\n\");break;\n\tcase XML_PARSER_START_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START_TAG\\n\");break;\n\tcase XML_PARSER_CONTENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CONTENT\\n\");break;\n\tcase XML_PARSER_CDATA_SECTION:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CDATA_SECTION\\n\");break;\n\tcase XML_PARSER_END_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try END_TAG\\n\");break;\n\tcase XML_PARSER_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_DECL\\n\");break;\n\tcase XML_PARSER_ENTITY_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_VALUE\\n\");break;\n\tcase XML_PARSER_ATTRIBUTE_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n\tcase XML_PARSER_DTD:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try DTD\\n\");break;\n\tcase XML_PARSER_EPILOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EPILOG\\n\");break;\n\tcase XML_PARSER_PI:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PI\\n\");break;\n        case XML_PARSER_IGNORE:\n            xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try IGNORE\\n\");break;\n    }\n#endif\n\n    if ((ctxt->input != NULL) &&\n        (ctxt->input->cur - ctxt->input->base > 4096)) {\n\txmlSHRINK(ctxt);\n\tctxt->checkIndex = 0;\n    }\n    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n\n    while (1) {\n\tif ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n\t    return(0);\n\n        \n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\n\tif (ctxt->input == NULL) break;\n\tif (ctxt->input->buf == NULL)\n\t    avail = ctxt->input->length -\n\t            (ctxt->input->cur - ctxt->input->base);\n\telse {\n\t    /*\n\t     * If we are operating on converted input, try to flush\n\t     * remainng chars to avoid them stalling in the non-converted\n\t     * buffer.\n\t     */\n\t    if ((ctxt->input->buf->raw != NULL) &&\n\t\t(ctxt->input->buf->raw->use > 0)) {\n\t\tint base = ctxt->input->base -\n\t\t           ctxt->input->buf->buffer->content;\n\t\tint current = ctxt->input->cur - ctxt->input->base;\n\n\t\txmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n\t\tctxt->input->base = ctxt->input->buf->buffer->content + base;\n\t\tctxt->input->cur = ctxt->input->base + current;\n\t\tctxt->input->end =\n\t\t    &ctxt->input->buf->buffer->content[\n\t\t                       ctxt->input->buf->buffer->use];\n\t    }\n\t    avail = ctxt->input->buf->buffer->use -\n\t\t    (ctxt->input->cur - ctxt->input->base);\n\t}\n        if (avail < 1)\n\t    goto done;\n        switch (ctxt->instate) {\n            case XML_PARSER_EOF:\n\t        /*\n\t\t * Document parsing is done !\n\t\t */\n\t        goto done;\n            case XML_PARSER_START:\n\t\tif (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n\t\t    xmlChar start[4];\n\t\t    xmlCharEncoding enc;\n\n\t\t    /*\n\t\t     * Very first chars read from the document flow.\n\t\t     */\n\t\t    if (avail < 4)\n\t\t\tgoto done;\n\n\t\t    /* \n\t\t     * Get the 4 first bytes and decode the charset\n\t\t     * if enc != XML_CHAR_ENCODING_NONE\n\t\t     * plug some encoding conversion routines,\n\t\t     * else xmlSwitchEncoding will set to (default)\n\t\t     * UTF8.\n\t\t     */\n\t\t    start[0] = RAW;\n\t\t    start[1] = NXT(1);\n\t\t    start[2] = NXT(2);\n\t\t    start[3] = NXT(3);\n\t\t    enc = xmlDetectCharEncoding(start, 4);\n\t\t    xmlSwitchEncoding(ctxt, enc);\n\t\t    break;\n\t\t}\n\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t\tif (cur == 0) {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    /* PI or XML decl */\n\t\t    if (avail < 5) return(ret);\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\treturn(ret);\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    if ((ctxt->input->cur[2] == 'x') &&\n\t\t\t(ctxt->input->cur[3] == 'm') &&\n\t\t\t(ctxt->input->cur[4] == 'l') &&\n\t\t\t(IS_BLANK_CH(ctxt->input->cur[5]))) {\n\t\t\tret += 5;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: Parsing XML Decl\\n\");\n#endif\n\t\t\txmlParseXMLDecl(ctxt);\n\t\t\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t\t    /*\n\t\t\t     * The XML REC instructs us to stop parsing right\n\t\t\t     * here\n\t\t\t     */\n\t\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tctxt->standalone = ctxt->input->standalone;\n\t\t\tif ((ctxt->encoding == NULL) &&\n\t\t\t    (ctxt->input->encoding != NULL))\n\t\t\t    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    } else {\n\t\t\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    }\n\t\t} else {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t    if (ctxt->version == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\t    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t        (!ctxt->disableSAX))\n\t\t\tctxt->sax->startDocument(ctxt->userData);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering MISC\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_START_TAG: {\n\t        const xmlChar *name;\n\t\tconst xmlChar *prefix = NULL;\n\t\tconst xmlChar *URI = NULL;\n\t\tint nsNr = ctxt->nsNr;\n\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t        if (cur != '<') {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->spaceNr == 0)\n\t\t    spacePush(ctxt, -1);\n\t\telse if (*ctxt->space == -2)\n\t\t    spacePush(ctxt, -1);\n\t\telse\n\t\t    spacePush(ctxt, *ctxt->space);\n#ifdef LIBXML_SAX1_ENABLED\n\t\tif (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    name = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (name == NULL) {\n\t\t    spacePop(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n#ifdef LIBXML_VALID_ENABLED\n\t\t/*\n\t\t * [ VC: Root Element Type ]\n\t\t * The Name in the document type declaration must match\n\t\t * the element type of the root element. \n\t\t */\n\t\tif (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n\t\t    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n\t\t    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n\t\t/*\n\t\t * Check for an Empty Element.\n\t\t */\n\t\tif ((RAW == '/') && (NXT(1) == '>')) {\n\t\t    SKIP(2);\n\n\t\t    if (ctxt->sax2) {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElementNs != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElementNs(ctxt->userData, name,\n\t\t\t                            prefix, URI);\n\t\t\tif (ctxt->nsNr - nsNr > 0)\n\t\t\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\t    } else {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElement != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    }\n\t\t    spacePop(ctxt);\n\t\t    if (ctxt->nameNr == 0) {\n\t\t\tctxt->instate = XML_PARSER_EPILOG;\n\t\t    } else {\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (RAW == '>') {\n\t\t    NEXT;\n\t\t} else {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t\t\t\t \"Couldn't find end of Start Tag %s\\n\",\n\t\t\t\t\t name);\n\t\t    nodePop(ctxt);\n\t\t    spacePop(ctxt);\n\t\t}\n\t\tif (ctxt->sax2)\n\t\t    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    namePush(ctxt, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\n\t\tctxt->instate = XML_PARSER_CONTENT;\n                break;\n\t    }\n            case XML_PARSER_CONTENT: {\n\t\tconst xmlChar *test;\n\t\tunsigned int cons;\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\n\t\ttest = CUR_PTR;\n\t        cons = ctxt->input->consumed;\n\t\tif ((cur == '<') && (next == '/')) {\n\t\t    ctxt->instate = XML_PARSER_END_TAG;\n\t\t    break;\n\t        } else if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next != '!')) {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (ctxt->input->cur[2] == '-') &&\n\t\t\t   (ctxt->input->cur[3] == '-')) {\n\t\t    int term;\n\n\t            if (avail < 4)\n\t\t        goto done;\n\t\t    ctxt->input->cur += 4;\n\t\t    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n\t\t    ctxt->input->cur -= 4;\n\t\t    if ((!terminate) && (term < 0))\n\t\t\tgoto done;\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n\t\t    (ctxt->input->cur[2] == '[') &&\n\t\t    (ctxt->input->cur[3] == 'C') &&\n\t\t    (ctxt->input->cur[4] == 'D') &&\n\t\t    (ctxt->input->cur[5] == 'A') &&\n\t\t    (ctxt->input->cur[6] == 'T') &&\n\t\t    (ctxt->input->cur[7] == 'A') &&\n\t\t    (ctxt->input->cur[8] == '[')) {\n\t\t    SKIP(9);\n\t\t    ctxt->instate = XML_PARSER_CDATA_SECTION;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else if (cur == '&') {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParseReference(ctxt);\n\t\t} else {\n\t\t    /* TODO Avoid the extra copy, handle directly !!! */\n\t\t    /*\n\t\t     * Goal of the following test is:\n\t\t     *  - minimize calls to the SAX 'character' callback\n\t\t     *    when they are mergeable\n\t\t     *  - handle an problem for isBlank when we only parse\n\t\t     *    a sequence of blank chars and the next one is\n\t\t     *    not available to check against '<' presence.\n\t\t     *  - tries to homogenize the differences in SAX\n\t\t     *    callbacks between the push and pull versions\n\t\t     *    of the parser.\n\t\t     */\n\t\t    if ((ctxt->inputNr == 1) &&\n\t\t        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n\t\t\tif (!terminate) {\n\t\t\t    if (ctxt->progressive) {\n\t\t\t\tif ((lastlt == NULL) ||\n\t\t\t\t    (ctxt->input->cur > lastlt))\n\t\t\t\t    goto done;\n\t\t\t    } else if (xmlParseLookupSequence(ctxt,\n\t\t\t                                      '<', 0, 0) < 0) {\n\t\t\t\tgoto done;\n\t\t\t    }\n\t\t\t}\n                    }\n\t\t    ctxt->checkIndex = 0;\n\t\t    xmlParseCharData(ctxt, 0);\n\t\t}\n\t\t/*\n\t\t * Pop-up of finished entities.\n\t\t */\n\t\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t\t    xmlPopInput(ctxt);\n\t\tif ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n\t\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t                \"detected an error in element content\\n\");\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    break;\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_END_TAG:\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->sax2) {\n\t\t    xmlParseEndTag2(ctxt,\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,\n\t\t       (int) (long) ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);\n\t\t    nameNsPop(ctxt);\n\t\t}\n#ifdef LIBXML_SAX1_ENABLED\n\t\t  else\n\t\t    xmlParseEndTag1(ctxt, 0);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\tif (ctxt->nameNr == 0) {\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_CDATA_SECTION: {\n\t        /*\n\t\t * The Push mode need to have the SAX callback for \n\t\t * cdataBlock merge back contiguous callbacks.\n\t\t */\n\t\tint base;\n\n\t\tbase = xmlParseLookupSequence(ctxt, ']', ']', '>');\n\t\tif (base < 0) {\n\t\t    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n\t\t        int tmp;\n\n\t\t\ttmp = xmlCheckCdataPush(ctxt->input->cur, \n\t\t\t                        XML_PARSER_BIG_BUFFER_SIZE);\n\t\t\tif (tmp < 0) {\n\t\t\t    tmp = -tmp;\n\t\t\t    ctxt->input->cur += tmp;\n\t\t\t    goto encoding_error;\n\t\t\t}\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\t\t    if (ctxt->sax->cdataBlock != NULL)\n\t\t\t\tctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t    else if (ctxt->sax->characters != NULL)\n\t\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t}\n\t\t\tSKIPL(tmp);\n\t\t\tctxt->checkIndex = 0;\n\t\t    }\n\t\t    goto done;\n\t\t} else {\n\t\t    int tmp;\n\n\t\t    tmp = xmlCheckCdataPush(ctxt->input->cur, base);\n\t\t    if ((tmp < 0) || (tmp != base)) {\n\t\t\ttmp = -tmp;\n\t\t\tctxt->input->cur += tmp;\n\t\t\tgoto encoding_error;\n\t\t    }\n\t\t    if ((ctxt->sax != NULL) && (base == 0) &&\n\t\t        (ctxt->sax->cdataBlock != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\t/*\n\t\t\t * Special case to provide identical behaviour\n\t\t\t * between pull and push parsers on enpty CDATA\n\t\t\t * sections\n\t\t\t */\n\t\t\t if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n\t\t\t     (!strncmp((const char *)&ctxt->input->cur[-9],\n\t\t\t               \"<![CDATA[\", 9)))\n\t\t\t     ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t                           BAD_CAST \"\", 0);\n\t\t    } else if ((ctxt->sax != NULL) && (base > 0) &&\n\t\t\t(!ctxt->disableSAX)) {\n\t\t\tif (ctxt->sax->cdataBlock != NULL)\n\t\t\t    ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t\telse if (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t    }\n\t\t    SKIPL(base + 3);\n\t\t    ctxt->checkIndex = 0;\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering CONTENT\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_MISC:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') &&\n\t\t    (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == 'D') &&\n\t\t    (ctxt->input->cur[3] == 'O') &&\n\t\t    (ctxt->input->cur[4] == 'C') &&\n\t\t    (ctxt->input->cur[5] == 'T') &&\n\t\t    (ctxt->input->cur[6] == 'Y') &&\n\t\t    (ctxt->input->cur[7] == 'P') &&\n\t\t    (ctxt->input->cur[8] == 'E')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing internal subset\\n\");\n#endif\n\t\t    ctxt->inSubset = 1;\n\t\t    xmlParseDocTypeDecl(ctxt);\n\t\t    if (RAW == '[') {\n\t\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Create and update the external subset.\n\t\t\t */\n\t\t\tctxt->inSubset = 2;\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t\t    ctxt->sax->externalSubset(ctxt->userData,\n\t\t\t\t    ctxt->intSubName, ctxt->extSubSystem,\n\t\t\t\t    ctxt->extSubURI);\n\t\t\tctxt->inSubset = 0;\n\t\t\txmlCleanSpecialAttr(ctxt);\n\t\t\tctxt->instate = XML_PARSER_PROLOG;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n\t\t    }\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    ctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_PROLOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2) \n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_PROLOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    if (ctxt->progressive == 0)\n\t\t\tctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_EPILOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_DTD: {\n\t        /*\n\t\t * Sorry but progressive parsing of the internal subset\n\t\t * is not expected to be supported. We first check that\n\t\t * the full content of the internal subset is available and\n\t\t * the parsing is launched only at that point.\n\t\t * Internal subset ends up with \"']' S? '>'\" in an unescaped\n\t\t * section and not in a ']]>' sequence which are conditional\n\t\t * sections (whoever argued to keep that crap in XML deserve\n\t\t * a place in hell !).\n\t\t */\n\t\tint base, i;\n\t\txmlChar *buf;\n\t        xmlChar quote = 0;\n\n\t\tbase = ctxt->input->cur - ctxt->input->base;\n\t\tif (base < 0) return(0);\n\t\tif (ctxt->checkIndex > base)\n\t\t    base = ctxt->checkIndex;\n\t\tbuf = ctxt->input->buf->buffer->content;\n\t\tfor (;(unsigned int) base < ctxt->input->buf->buffer->use;\n\t\t     base++) {\n\t\t    if (quote != 0) {\n\t\t        if (buf[base] == quote)\n\t\t\t    quote = 0;\n\t\t\tcontinue;    \n\t\t    }\n\t\t    if ((quote == 0) && (buf[base] == '<')) {\n\t\t        int found  = 0;\n\t\t\t/* special handling of comments */\n\t\t        if (((unsigned int) base + 4 <\n\t\t\t     ctxt->input->buf->buffer->use) &&\n\t\t\t    (buf[base + 1] == '!') &&\n\t\t\t    (buf[base + 2] == '-') &&\n\t\t\t    (buf[base + 3] == '-')) {\n\t\t\t    for (;(unsigned int) base + 3 <\n\t\t\t          ctxt->input->buf->buffer->use; base++) {\n\t\t\t\tif ((buf[base] == '-') &&\n\t\t\t\t    (buf[base + 1] == '-') &&\n\t\t\t\t    (buf[base + 2] == '>')) {\n\t\t\t\t    found = 1;\n\t\t\t\t    base += 2;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t            }\n\t\t\t    if (!found) {\n#if 0\n\t\t\t        fprintf(stderr, \"unfinished comment\\n\");\n#endif\n\t\t\t        break; /* for */\n\t\t            }\n\t\t            continue;\n\t\t\t}\n\t\t    }\n\t\t    if (buf[base] == '\"') {\n\t\t        quote = '\"';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == '\\'') {\n\t\t        quote = '\\'';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == ']') {\n#if 0\n\t\t        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n\t\t\t        buf[base + 1], buf[base + 2], buf[base + 3]);\n#endif\n\t\t        if ((unsigned int) base +1 >=\n\t\t            ctxt->input->buf->buffer->use)\n\t\t\t    break;\n\t\t\tif (buf[base + 1] == ']') {\n\t\t\t    /* conditional crap, skip both ']' ! */\n\t\t\t    base++;\n\t\t\t    continue;\n\t\t\t}\n\t\t        for (i = 1;\n\t\t     (unsigned int) base + i < ctxt->input->buf->buffer->use;\n\t\t             i++) {\n\t\t\t    if (buf[base + i] == '>') {\n#if 0\n\t\t\t        fprintf(stderr, \"found\\n\");\n#endif\n\t\t\t        goto found_end_int_subset;\n\t\t\t    }\n\t\t\t    if (!IS_BLANK_CH(buf[base + i])) {\n#if 0\n\t\t\t        fprintf(stderr, \"not found\\n\");\n#endif\n\t\t\t        goto not_end_of_int_subset;\n\t\t\t    }\n\t\t\t}\n#if 0\n\t\t\tfprintf(stderr, \"end of stream\\n\");\n#endif\n\t\t        break;\n                        \n\t\t    }\nnot_end_of_int_subset:\n                    continue; /* for */\n\t\t}\n\t\t/*\n\t\t * We didn't found the end of the Internal subset\n\t\t */\n#ifdef DEBUG_PUSH\n\t\tif (next == 0)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: lookup of int subset end filed\\n\");\n#endif\n\t        goto done;\n\nfound_end_int_subset:\n\t\txmlParseInternalSubset(ctxt);\n\t\tctxt->inSubset = 2;\n\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t\t\t    ctxt->extSubSystem, ctxt->extSubURI);\n\t\tctxt->inSubset = 0;\n\t\txmlCleanSpecialAttr(ctxt);\n\t\tctxt->instate = XML_PARSER_PROLOG;\n\t\tctxt->checkIndex = 0;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n                break;\n\t    }\n            case XML_PARSER_COMMENT:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == COMMENT\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_IGNORE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == IGNORE\");\n\t        ctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t        break;\n            case XML_PARSER_PI:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PI\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_DECL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_DECL\\n\");\n\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ATTRIBUTE_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_SYSTEM_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == SYSTEM_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_PUBLIC_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PUBLIC_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n\t}\n    }\ndone:    \n#ifdef DEBUG_PUSH\n    xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\n#endif\n    return(ret);\nencoding_error:\n    {\n        char buffer[150];\n\n\tsnprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\tctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\tctxt->input->cur[2], ctxt->input->cur[3]);\n\t__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n    return(0);\n}", "target": 1, "cwe": ["CWE-125"], "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"}
{"func": "xmlParseElement(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    const xmlChar *prefix = NULL;\n    const xmlChar *URI = NULL;\n    xmlParserNodeInfo node_info;\n    int line, tlen;\n    xmlNodePtr ret;\n    int nsNr = ctxt->nsNr;\n\n    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n\txmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n\t\t\t  xmlParserMaxDepth);\n\tctxt->instate = XML_PARSER_EOF;\n\treturn;\n    }\n\n    /* Capture start position */\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    if (ctxt->spaceNr == 0)\n\tspacePush(ctxt, -1);\n    else if (*ctxt->space == -2)\n\tspacePush(ctxt, -1);\n    else\n\tspacePush(ctxt, *ctxt->space);\n\n    line = ctxt->input->line;\n#ifdef LIBXML_SAX1_ENABLED\n    if (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n        name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\tname = xmlParseStartTag(ctxt);\n#endif /* LIBXML_SAX1_ENABLED */\n    if (name == NULL) {\n\tspacePop(ctxt);\n        return;\n    }\n    namePush(ctxt, name);\n    ret = ctxt->node;\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * [ VC: Root Element Type ]\n     * The Name in the document type declaration must match the element\n     * type of the root element. \n     */\n    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n        ctxt->node && (ctxt->node == ctxt->myDoc->children))\n        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Check for an Empty Element.\n     */\n    if ((RAW == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif (ctxt->sax2) {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n#ifdef LIBXML_SAX1_ENABLED\n\t} else {\n\t    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n\t\t(!ctxt->disableSAX))\n\t\tctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t}\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n    if (RAW == '>') {\n        NEXT1;\n    } else {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t     \"Couldn't find end of Start Tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\n\t/*\n\t * Capture end position and add node\n\t */\n\tif ( ret != NULL && ctxt->record_info ) {\n\t   node_info.end_pos = ctxt->input->consumed +\n\t\t\t      (CUR_PTR - ctxt->input->base);\n\t   node_info.end_line = ctxt->input->line;\n\t   node_info.node = ret;\n\t   xmlParserAddNodeInfo(ctxt, &node_info);\n\t}\n\treturn;\n    }\n\n    /*\n     * Parse the content of the element:\n     */\n    xmlParseContent(ctxt);\n    if (!IS_BYTE_CHAR(RAW)) {\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n\t \"Premature end of data in tag %s line %d\\n\",\n\t\t                name, line, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tnodePop(ctxt);\n\tnamePop(ctxt);\n\tspacePop(ctxt);\n\tif (nsNr != ctxt->nsNr)\n\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n\treturn;\n    }\n\n    /*\n     * parse the end of tag: '</' should be here.\n     */\n    if (ctxt->sax2) {\n\txmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n      else\n\txmlParseEndTag1(ctxt, line);\n#endif /* LIBXML_SAX1_ENABLED */\n\n    /*\n     * Capture end position and add node\n     */\n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 1, "cwe": ["CWE-125"], "message": "Make sure the parser returns when getting a Stop order\n\npatch backported from chromiun bug fixes, assuming author is Chris"}
{"func": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}", "target": 1, "cwe": ["CWE-119"], "message": "batman-adv: Only write requested number of byte to user buffer\n\nDon't write more than the requested number of bytes of an batman-adv icmp\npacket to the userspace buffer. Otherwise unrelated userspace memory might get\noverridden by the kernel.\n\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nSigned-off-by: Marek Lindner <lindner_marek@yahoo.de>"}
{"func": "rsCStrExtendBuf(cstr_t *pThis, size_t iMinNeeded)\n{\n\tuchar *pNewBuf;\n\tunsigned short iNewSize;\n\tDEFiRet;\n\n\t/* first compute the new size needed */\n\tif(iMinNeeded > RS_STRINGBUF_ALLOC_INCREMENT) {\n\t\t/* we allocate \"n\" ALLOC_INCREMENTs. Usually, that should\n\t\t * leave some room after the absolutely needed one. It also\n\t\t * reduces memory fragmentation. Note that all of this are\n\t\t * integer operations (very important to understand what is\n\t\t * going on)! Parenthesis are for better readibility.\n\t\t */\n\t\tiNewSize = (iMinNeeded / RS_STRINGBUF_ALLOC_INCREMENT + 1) * RS_STRINGBUF_ALLOC_INCREMENT;\n\t} else {\n\t\tiNewSize = pThis->iBufSize + RS_STRINGBUF_ALLOC_INCREMENT;\n\t}\n\tiNewSize += pThis->iBufSize; /* add current size */\n\n\t/* DEV debugging only: dbgprintf(\"extending string buffer, old %d, new %d\\n\", pThis->iBufSize, iNewSize); */\n\tCHKmalloc(pNewBuf = (uchar*) realloc(pThis->pBuf, iNewSize * sizeof(uchar)));\n\tpThis->iBufSize = iNewSize;\n\tpThis->pBuf = pNewBuf;\n\nfinalize_it:\n\tRETiRet;\n}", "target": 1, "cwe": ["CWE-189"], "message": "bugfix: abort if imfile reads file line of more than 64KiB\n\nThanks to Peter Eisentraut for reporting and analysing this problem.\nbug tracker: http://bugzilla.adiscon.com/show_bug.cgi?id=221"}
{"func": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\n\tif (flags & MS_KERNMOUNT)\n\t\tns = (struct pid_namespace *)data;\n\telse\n\t\tns = current->nsproxy->pid_ns;\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}", "target": 1, "cwe": [], "message": "procfs: parse mount options\n\nAdd support for procfs mount options.  Actual mount options are coming in\nthe next patches.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Randy Dunlap <rdunlap@xenotime.net>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Greg KH <greg@kroah.com>\nCc: Theodore Tso <tytso@MIT.EDU>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: James Morris <jmorris@namei.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int proc_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "procfs: add hidepid= and gid= mount options\n\nAdd support for mount options to restrict access to /proc/PID/\ndirectories.  The default backward-compatible \"relaxed\" behaviour is left\nuntouched.\n\nThe first mount option is called \"hidepid\" and its value defines how much\ninfo about processes we want to be available for non-owners:\n\nhidepid=0 (default) means the old behavior - anybody may read all\nworld-readable /proc/PID/* files.\n\nhidepid=1 means users may not access any /proc/<pid>/ directories, but\ntheir own.  Sensitive files like cmdline, sched*, status are now protected\nagainst other users.  As permission checking done in proc_pid_permission()\nand files' permissions are left untouched, programs expecting specific\nfiles' modes are not confused.\n\nhidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other\nusers.  It doesn't mean that it hides whether a process exists (it can be\nlearned by other means, e.g.  by kill -0 $PID), but it hides process' euid\nand egid.  It compicates intruder's task of gathering info about running\nprocesses, whether some daemon runs with elevated privileges, whether\nanother user runs some sensitive program, whether other users run any\nprogram at all, etc.\n\ngid=XXX defines a group that will be able to gather all processes' info\n(as in hidepid=0 mode).  This group should be used instead of putting\nnonroot user in sudoers file or something.  However, untrusted users (like\ndaemons, etc.) which are not supposed to monitor the tasks in the whole\nsystem should not be added to the group.\n\nhidepid=1 or higher is designed to restrict access to procfs files, which\nmight reveal some sensitive private information like precise keystrokes\ntimings:\n\nhttp://www.openwall.com/lists/oss-security/2011/11/05/3\n\nhidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and\nconky gracefully handle EPERM/ENOENT and behave as if the current user is\nthe only user running processes.  pstree shows the process subtree which\ncontains \"pstree\" process.\n\nNote: the patch doesn't deal with setuid/setgid issues of keeping\npreopened descriptors of procfs files (like\nhttps://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked\ninformation like the scheduling counters of setuid apps doesn't threaten\nanybody's privacy - only the user started the setuid program may read the\ncounters.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Randy Dunlap <rdunlap@xenotime.net>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Greg KH <greg@kroah.com>\nCc: Theodore Tso <tytso@MIT.EDU>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: James Morris <jmorris@namei.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Hugh Dickins <hughd@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "procfs: add hidepid= and gid= mount options\n\nAdd support for mount options to restrict access to /proc/PID/\ndirectories.  The default backward-compatible \"relaxed\" behaviour is left\nuntouched.\n\nThe first mount option is called \"hidepid\" and its value defines how much\ninfo about processes we want to be available for non-owners:\n\nhidepid=0 (default) means the old behavior - anybody may read all\nworld-readable /proc/PID/* files.\n\nhidepid=1 means users may not access any /proc/<pid>/ directories, but\ntheir own.  Sensitive files like cmdline, sched*, status are now protected\nagainst other users.  As permission checking done in proc_pid_permission()\nand files' permissions are left untouched, programs expecting specific\nfiles' modes are not confused.\n\nhidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other\nusers.  It doesn't mean that it hides whether a process exists (it can be\nlearned by other means, e.g.  by kill -0 $PID), but it hides process' euid\nand egid.  It compicates intruder's task of gathering info about running\nprocesses, whether some daemon runs with elevated privileges, whether\nanother user runs some sensitive program, whether other users run any\nprogram at all, etc.\n\ngid=XXX defines a group that will be able to gather all processes' info\n(as in hidepid=0 mode).  This group should be used instead of putting\nnonroot user in sudoers file or something.  However, untrusted users (like\ndaemons, etc.) which are not supposed to monitor the tasks in the whole\nsystem should not be added to the group.\n\nhidepid=1 or higher is designed to restrict access to procfs files, which\nmight reveal some sensitive private information like precise keystrokes\ntimings:\n\nhttp://www.openwall.com/lists/oss-security/2011/11/05/3\n\nhidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and\nconky gracefully handle EPERM/ENOENT and behave as if the current user is\nthe only user running processes.  pstree shows the process subtree which\ncontains \"pstree\" process.\n\nNote: the patch doesn't deal with setuid/setgid issues of keeping\npreopened descriptors of procfs files (like\nhttps://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked\ninformation like the scheduling counters of setuid apps doesn't threaten\nanybody's privacy - only the user started the setuid program may read the\ncounters.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Randy Dunlap <rdunlap@xenotime.net>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Greg KH <greg@kroah.com>\nCc: Theodore Tso <tytso@MIT.EDU>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: James Morris <jmorris@namei.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Hugh Dickins <hughd@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tpr_debug(\"proc: options = %s\\n\", options);\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = 0;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}", "target": 1, "cwe": [], "message": "procfs: add hidepid= and gid= mount options\n\nAdd support for mount options to restrict access to /proc/PID/\ndirectories.  The default backward-compatible \"relaxed\" behaviour is left\nuntouched.\n\nThe first mount option is called \"hidepid\" and its value defines how much\ninfo about processes we want to be available for non-owners:\n\nhidepid=0 (default) means the old behavior - anybody may read all\nworld-readable /proc/PID/* files.\n\nhidepid=1 means users may not access any /proc/<pid>/ directories, but\ntheir own.  Sensitive files like cmdline, sched*, status are now protected\nagainst other users.  As permission checking done in proc_pid_permission()\nand files' permissions are left untouched, programs expecting specific\nfiles' modes are not confused.\n\nhidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other\nusers.  It doesn't mean that it hides whether a process exists (it can be\nlearned by other means, e.g.  by kill -0 $PID), but it hides process' euid\nand egid.  It compicates intruder's task of gathering info about running\nprocesses, whether some daemon runs with elevated privileges, whether\nanother user runs some sensitive program, whether other users run any\nprogram at all, etc.\n\ngid=XXX defines a group that will be able to gather all processes' info\n(as in hidepid=0 mode).  This group should be used instead of putting\nnonroot user in sudoers file or something.  However, untrusted users (like\ndaemons, etc.) which are not supposed to monitor the tasks in the whole\nsystem should not be added to the group.\n\nhidepid=1 or higher is designed to restrict access to procfs files, which\nmight reveal some sensitive private information like precise keystrokes\ntimings:\n\nhttp://www.openwall.com/lists/oss-security/2011/11/05/3\n\nhidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and\nconky gracefully handle EPERM/ENOENT and behave as if the current user is\nthe only user running processes.  pstree shows the process subtree which\ncontains \"pstree\" process.\n\nNote: the patch doesn't deal with setuid/setgid issues of keeping\npreopened descriptors of procfs files (like\nhttps://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked\ninformation like the scheduling counters of setuid apps doesn't threaten\nanybody's privacy - only the user started the setuid program may read the\ncounters.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Randy Dunlap <rdunlap@xenotime.net>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Greg KH <greg@kroah.com>\nCc: Theodore Tso <tytso@MIT.EDU>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: James Morris <jmorris@namei.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Hugh Dickins <hughd@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "procfs: add hidepid= and gid= mount options\n\nAdd support for mount options to restrict access to /proc/PID/\ndirectories.  The default backward-compatible \"relaxed\" behaviour is left\nuntouched.\n\nThe first mount option is called \"hidepid\" and its value defines how much\ninfo about processes we want to be available for non-owners:\n\nhidepid=0 (default) means the old behavior - anybody may read all\nworld-readable /proc/PID/* files.\n\nhidepid=1 means users may not access any /proc/<pid>/ directories, but\ntheir own.  Sensitive files like cmdline, sched*, status are now protected\nagainst other users.  As permission checking done in proc_pid_permission()\nand files' permissions are left untouched, programs expecting specific\nfiles' modes are not confused.\n\nhidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other\nusers.  It doesn't mean that it hides whether a process exists (it can be\nlearned by other means, e.g.  by kill -0 $PID), but it hides process' euid\nand egid.  It compicates intruder's task of gathering info about running\nprocesses, whether some daemon runs with elevated privileges, whether\nanother user runs some sensitive program, whether other users run any\nprogram at all, etc.\n\ngid=XXX defines a group that will be able to gather all processes' info\n(as in hidepid=0 mode).  This group should be used instead of putting\nnonroot user in sudoers file or something.  However, untrusted users (like\ndaemons, etc.) which are not supposed to monitor the tasks in the whole\nsystem should not be added to the group.\n\nhidepid=1 or higher is designed to restrict access to procfs files, which\nmight reveal some sensitive private information like precise keystrokes\ntimings:\n\nhttp://www.openwall.com/lists/oss-security/2011/11/05/3\n\nhidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and\nconky gracefully handle EPERM/ENOENT and behave as if the current user is\nthe only user running processes.  pstree shows the process subtree which\ncontains \"pstree\" process.\n\nNote: the patch doesn't deal with setuid/setgid issues of keeping\npreopened descriptors of procfs files (like\nhttps://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked\ninformation like the scheduling counters of setuid apps doesn't threaten\nanybody's privacy - only the user started the setuid program may read the\ncounters.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Randy Dunlap <rdunlap@xenotime.net>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Greg KH <greg@kroah.com>\nCc: Theodore Tso <tytso@MIT.EDU>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nCc: James Morris <jmorris@namei.org>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Hugh Dickins <hughd@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}", "target": 1, "cwe": [], "message": "proc: fix null pointer deref in proc_pid_permission()\n\nget_proc_task() can fail to search the task and return NULL,\nput_task_struct() will then bomb the kernel with following oops:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n  IP: [<ffffffff81217d34>] proc_pid_permission+0x64/0xe0\n  PGD 112075067 PUD 112814067 PMD 0\n  Oops: 0002 [#1] PREEMPT SMP\n\nThis is a regression introduced by commit 0499680a (\"procfs: add hidepid=\nand gid= mount options\").  The kernel should return -ESRCH if\nget_proc_task() failed.\n\nSigned-off-by: Xiaotian Feng <dannyfeng@tencent.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Vasiliy Kulikov <segoon@openwall.com>\nCc: Stephen Wilson <wilsons@start.ca>\nAcked-by: David Rientjes <rientjes@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tstruct proc_inode *ei;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = current->nsproxy->pid_ns;\n\t\toptions = data;\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tsb->s_flags = flags;\n\t\tif (!proc_parse_options(options, ns)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\tei = PROC_I(sb->s_root->d_inode);\n\tif (!ei->pid) {\n\t\trcu_read_lock();\n\t\tei->pid = get_pid(find_pid_ns(1, ns));\n\t\trcu_read_unlock();\n\t}\n\n\treturn dget(sb->s_root);\n}", "target": 1, "cwe": [], "message": "proc: fix mount -t proc -o AAA\n\nThe proc_parse_options() call from proc_mount() runs only once at boot\ntime.  So on any later mount attempt, any mount options are ignored\nbecause ->s_root is already initialized.\n\nAs a consequence, \"mount -o <options>\" will ignore the options.  The\nonly way to change mount options is \"mount -o remount,<options>\".\n\nTo fix this, parse the mount options unconditionally.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nReported-by: Arkadiusz Miskiewicz <a.miskiewicz@gmail.com>\nTested-by: Arkadiusz Miskiewicz <a.miskiewicz@gmail.com>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    int buffer_size = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n    int nbchars = 0;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {\n\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    xmlLoadEntityContent(ctxt, ent);\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t      growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-787"], "message": "Fix an allocation error when copying entities"}
{"func": "ciphertext_to_compressed (gnutls_session_t session,\n                          gnutls_datum_t *ciphertext, \n                          opaque * compress_data,\n                          int compress_size,\n                          uint8_t type, record_parameters_st * params, \n                          uint64* sequence)\n{\n  uint8_t tag[MAX_HASH_SIZE];\n  uint8_t pad;\n  int length, length_to_decrypt;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      /* The way AEAD ciphers are defined in RFC5246, it allows\n       * only stream ciphers.\n       */\n      if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n        {\n          uint8_t nonce[blocksize];\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->read.IV.data == NULL || params->read.IV.size != 4)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n          \n          if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n          memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n          \n          _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n\n          ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n          ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n          \n          length_to_decrypt = ciphertext->size - tag_size;\n        }\n      else\n        {\n          if (ciphertext->size < tag_size)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n  \n          length_to_decrypt = ciphertext->size;\n        }\n\n      length = ciphertext->size - tag_size;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n\n      if ((ret =\n           _gnutls_auth_cipher_decrypt (&params->read.cipher_state,\n             ciphertext->data, length_to_decrypt)) < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    case CIPHER_BLOCK:\n      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n        return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n      /* ignore the IV in TLS 1.1+\n       */\n      if (explicit_iv)\n        {\n          _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n            ciphertext->data, blocksize);\n\n          ciphertext->size -= blocksize;\n          ciphertext->data += blocksize;\n\n          if (ciphertext->size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      /* we don't use the auth_cipher interface here, since\n       * TLS with block ciphers is impossible to be used under such\n       * an API. (the length of plaintext is required to calculate\n       * auth_data, but it is not available before decryption).\n       */\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext->size - tag_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext->size, tag_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          pad %= blocksize;\n        }\n\n      length = ciphertext->size - tag_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver != GNUTLS_SSL3)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext->data[ciphertext->size - i] !=\n                ciphertext->data[ciphertext->size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n\n      if (length < 0)\n        length = 0;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n\n      break;\n    default:\n      return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  /* HMAC was not the same. \n   */\n  if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n    return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n\n  if (compress_data != ciphertext->data)\n    memcpy (compress_data, ciphertext->data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "message": "provide less timing information when decoding packets. Patch by Nadhem Alfardan."}
{"func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    int   fd;\n    FILE *fp = NULL, *augorig_canon_fp = NULL;\n    char *augtemp = NULL, *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL, *augdest = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    if (access(augorig_canon, R_OK) == 0) {\n        augorig_canon_fp = fopen(augorig_canon, \"r\");\n        text = xfread_file(augorig_canon_fp);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    /* Figure out where to put the .augnew and temp file. If no .augnew file\n       then put the temp file next to augorig_canon, else next to .augnew. */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n        augdest = augnew;\n    } else {\n        augdest = augorig_canon;\n    }\n\n    if (xasprintf(&augtemp, \"%s.XXXXXX\", augdest) < 0) {\n        err_status = \"augtemp_oom\";\n        goto done;\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fd = mkstemp(augtemp);\n    if (fd < 0) {\n        err_status = \"mk_augtemp\";\n        goto done;\n    }\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augtemp\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon_fp, fp, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augtemp\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augtemp\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augtemp\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augtemp\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augtemp);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augtemp);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augtemp\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augtemp);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augtemp);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = xasprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n    }\n\n    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails, 0);\n    if (r != 0) {\n        dyn_err_status = strappend(err_status, \"_augtemp\");\n        goto done;\n    }\n\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augtemp);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    if (augorig_canon_fp != NULL)\n        fclose(augorig_canon_fp);\n    return result;\n}", "target": 1, "cwe": [], "message": "Fix regression in permissions of created files\n\nCommit 16387744 changed temporary file creation to use mkstemp, resulting in\nnew files being created with 0600 permissions.  For brand new files created\nthrough Augeas, their permissions stayed at 0600 rather than being set by the\numask as before.\n\n  * src/transform.c (transform_save): chmod after creating new files to\n    permissions implied by the umask"}
{"func": "char* xread_file(const char *path) {\n    FILE *fp;\n    char *result;\n\n    fp = fopen(path, \"r\");\n    result = xfread_file(fp);\n    fclose (fp);\n\n    return result;\n}", "target": 1, "cwe": [], "message": "* src/transform.c (xread_file): catch failed fopen, e.g. EACCES"}
{"func": "static struct augeas *setup_writable_hosts(CuTest *tc) {\n    char *etcdir, *build_root;\n    struct augeas *aug = NULL;\n    int r;\n\n    if (asprintf(&build_root, \"%s/build/test-load/%s\",\n                 abs_top_builddir, tc->name) < 0) {\n        CuFail(tc, \"failed to set build_root\");\n    }\n\n    if (asprintf(&etcdir, \"%s/etc\", build_root) < 0)\n        CuFail(tc, \"asprintf etcdir failed\");\n\n    run(tc, \"test -d %s && chmod -R u+w %s || :\", build_root, build_root);\n    run(tc, \"rm -rf %s\", build_root);\n    run(tc, \"mkdir -p %s\", etcdir);\n    run(tc, \"cp -pr %s/etc/hosts %s\", root, etcdir);\n    run(tc, \"chmod -R u+w %s\", build_root);\n\n    aug = aug_init(build_root, loadpath, AUG_NO_MODL_AUTOLOAD);\n    CuAssertPtrNotNull(tc, aug);\n\n    r = aug_set(aug, \"/augeas/load/Hosts/lens\", \"Hosts.lns\");\n    CuAssertRetSuccess(tc, r);\n\n    r = aug_set(aug, \"/augeas/load/Hosts/incl\", \"/etc/hosts\");\n    CuAssertRetSuccess(tc, r);\n\n    free(build_root);\n    free(etcdir);\n    return aug;\n}", "target": 1, "cwe": [], "message": "* src/transform.c (xread_file): catch failed fopen, e.g. EACCES"}
{"func": "int main(void) {\n    char *output = NULL;\n    CuSuite* suite = CuSuiteNew();\n    CuSuiteSetup(suite, NULL, NULL);\n    SUITE_ADD_TEST(suite, testDefault);\n    SUITE_ADD_TEST(suite, testNoLoad);\n    SUITE_ADD_TEST(suite, testNoAutoload);\n    SUITE_ADD_TEST(suite, testInvalidLens);\n    SUITE_ADD_TEST(suite, testLoadSave);\n    SUITE_ADD_TEST(suite, testLoadDefined);\n    SUITE_ADD_TEST(suite, testDefvarExpr);\n    SUITE_ADD_TEST(suite, testReloadChanged);\n    SUITE_ADD_TEST(suite, testReloadDirty);\n    SUITE_ADD_TEST(suite, testReloadDeleted);\n    SUITE_ADD_TEST(suite, testReloadDeletedMeta);\n    SUITE_ADD_TEST(suite, testReloadExternalMod);\n    SUITE_ADD_TEST(suite, testReloadAfterSaveNewfile);\n    SUITE_ADD_TEST(suite, testParseErrorReported);\n    SUITE_ADD_TEST(suite, testLoadExclWithRoot);\n    SUITE_ADD_TEST(suite, testLoadTrailingExcl);\n\n    abs_top_srcdir = getenv(\"abs_top_srcdir\");\n    if (abs_top_srcdir == NULL)\n        die(\"env var abs_top_srcdir must be set\");\n\n    abs_top_builddir = getenv(\"abs_top_builddir\");\n    if (abs_top_builddir == NULL)\n        die(\"env var abs_top_builddir must be set\");\n\n    if (asprintf(&root, \"%s/tests/root\", abs_top_srcdir) < 0) {\n        die(\"failed to set root\");\n    }\n\n    if (asprintf(&loadpath, \"%s/lenses\", abs_top_srcdir) < 0) {\n        die(\"failed to set loadpath\");\n    }\n\n    CuSuiteRun(suite);\n    CuSuiteSummary(suite, &output);\n    CuSuiteDetails(suite, &output);\n    printf(\"%s\\n\", output);\n    free(output);\n    return suite->failCount;\n}", "target": 1, "cwe": [], "message": "* src/transform.c (xread_file): catch failed fopen, e.g. EACCES"}
{"func": "static int transfer_file_attrs(const char *from, const char *to,\n                               const char **err_status) {\n    struct stat st;\n    int ret = 0;\n    int selinux_enabled = (is_selinux_enabled() > 0);\n    security_context_t con = NULL;\n\n    ret = lstat(from, &st);\n    if (ret < 0) {\n        *err_status = \"replace_stat\";\n        return -1;\n    }\n    if (selinux_enabled) {\n        if (lgetfilecon(from, &con) < 0 && errno != ENOTSUP) {\n            *err_status = \"replace_getfilecon\";\n            return -1;\n        }\n    }\n\n    if (lchown(to, st.st_uid, st.st_gid) < 0) {\n        *err_status = \"replace_chown\";\n        return -1;\n    }\n    if (chmod(to, st.st_mode) < 0) {\n        *err_status = \"replace_chmod\";\n        return -1;\n    }\n    if (selinux_enabled && con != NULL) {\n        if (lsetfilecon(to, con) < 0 && errno != ENOTSUP) {\n            *err_status = \"replace_setfilecon\";\n            return -1;\n        }\n        freecon(con);\n    }\n    return 0;\n}", "target": 1, "cwe": [], "message": "Prevent symlink attacks via .augnew during saving\n\nInstead of saving into a predictable PATH.augnew file, save into a securely\ncreated PATH.augnew.XXXXXX\n\n* src/transform.c (transform_save):\n    write changes to a temporary file in the same directory as the destination\n    (either the file's canonical path or the path of .augnew), before renaming\n\n* src/transform.c (transfer_file_attrs):\n    use fchown, fchmod etc. on the same file handles to ensure consistent\n    permission changes\n\n* bootstrap: add mkstemp gnulib module\n* tests/\n    test-put-symlink-augnew.sh: test symlink attack when writing .augnew\n    test-put-symlink-augsave.sh: test symlink attack when writing .augsave\n    test-put-symlink-augtemp.sh: test symlink attack via temp .augnew\n    test-put-symlink.sh: also test file modification\n\nFixes BZ 772257"}
{"func": "static int clone_file(const char *from, const char *to,\n                      const char **err_status, int copy_if_rename_fails) {\n    FILE *from_fp = NULL, *to_fp = NULL;\n    char buf[BUFSIZ];\n    size_t len;\n    int result = -1;\n\n    if (rename(from, to) == 0)\n        return 0;\n    if ((errno != EXDEV && errno != EBUSY) || !copy_if_rename_fails) {\n        *err_status = \"rename\";\n        return -1;\n    }\n\n    /* rename not possible, copy file contents */\n    if (!(from_fp = fopen(from, \"r\"))) {\n        *err_status = \"clone_open_src\";\n        goto done;\n    }\n\n    if (!(to_fp = fopen(to, \"w\"))) {\n        *err_status = \"clone_open_dst\";\n        goto done;\n    }\n\n    if (transfer_file_attrs(from, to, err_status) < 0)\n        goto done;\n\n    while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n        if (fwrite(buf, 1, len, to_fp) != len) {\n            *err_status = \"clone_write\";\n            goto done;\n        }\n    }\n    if (ferror(from_fp)) {\n        *err_status = \"clone_read\";\n        goto done;\n    }\n    if (fflush(to_fp) != 0) {\n        *err_status = \"clone_flush\";\n        goto done;\n    }\n    if (fsync(fileno(to_fp)) < 0) {\n        *err_status = \"clone_sync\";\n        goto done;\n    }\n    result = 0;\n done:\n    if (from_fp != NULL)\n        fclose(from_fp);\n    if (to_fp != NULL && fclose(to_fp) != 0)\n        result = -1;\n    if (result != 0)\n        unlink(to);\n    if (result == 0)\n        unlink(from);\n    return result;\n}", "target": 1, "cwe": [], "message": "Prevent symlink attacks via .augnew during saving\n\nInstead of saving into a predictable PATH.augnew file, save into a securely\ncreated PATH.augnew.XXXXXX\n\n* src/transform.c (transform_save):\n    write changes to a temporary file in the same directory as the destination\n    (either the file's canonical path or the path of .augnew), before renaming\n\n* src/transform.c (transfer_file_attrs):\n    use fchown, fchmod etc. on the same file handles to ensure consistent\n    permission changes\n\n* bootstrap: add mkstemp gnulib module\n* tests/\n    test-put-symlink-augnew.sh: test symlink attack when writing .augnew\n    test-put-symlink-augsave.sh: test symlink attack when writing .augsave\n    test-put-symlink-augtemp.sh: test symlink attack via temp .augnew\n    test-put-symlink.sh: also test file modification\n\nFixes BZ 772257"}
{"func": "char* xread_file(const char *path) {\n    FILE *fp = fopen(path, \"r\");\n    char *result;\n    size_t len;\n\n    if (!fp)\n        return NULL;\n\n    result = fread_file_lim(fp, MAX_READ_LEN, &len);\n    fclose (fp);\n\n    if (result != NULL\n        && len <= MAX_READ_LEN\n        && (int) len == len)\n        return result;\n\n    free(result);\n    return NULL;\n}", "target": 1, "cwe": [], "message": "Prevent symlink attacks via .augnew during saving\n\nInstead of saving into a predictable PATH.augnew file, save into a securely\ncreated PATH.augnew.XXXXXX\n\n* src/transform.c (transform_save):\n    write changes to a temporary file in the same directory as the destination\n    (either the file's canonical path or the path of .augnew), before renaming\n\n* src/transform.c (transfer_file_attrs):\n    use fchown, fchmod etc. on the same file handles to ensure consistent\n    permission changes\n\n* bootstrap: add mkstemp gnulib module\n* tests/\n    test-put-symlink-augnew.sh: test symlink attack when writing .augnew\n    test-put-symlink-augsave.sh: test symlink attack when writing .augsave\n    test-put-symlink-augtemp.sh: test symlink attack via temp .augnew\n    test-put-symlink.sh: also test file modification\n\nFixes BZ 772257"}
{"func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    FILE *fp = NULL;\n    char *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    if (access(augorig, R_OK) == 0) {\n        text = xread_file(augorig);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    /* Figure out where to put the .augnew file. If we need to rename it\n       later on, put it next to augorig_canon */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n    } else {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig_canon) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fp = fopen(augnew, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augnew\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon, augnew, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augnew\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augnew\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augnew\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augnew\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augnew);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augnew);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augnew\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augnew);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augnew);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = asprintf(&augsave, \"%s%s\" EXT_AUGSAVE, aug->root, filename);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n        r = clone_file(augnew, augorig_canon, &err_status,\n                       copy_if_rename_fails);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augnew\");\n            goto done;\n        }\n    }\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    return result;\n}", "target": 1, "cwe": [], "message": "Prevent symlink attacks via .augnew during saving\n\nInstead of saving into a predictable PATH.augnew file, save into a securely\ncreated PATH.augnew.XXXXXX\n\n* src/transform.c (transform_save):\n    write changes to a temporary file in the same directory as the destination\n    (either the file's canonical path or the path of .augnew), before renaming\n\n* src/transform.c (transfer_file_attrs):\n    use fchown, fchmod etc. on the same file handles to ensure consistent\n    permission changes\n\n* bootstrap: add mkstemp gnulib module\n* tests/\n    test-put-symlink-augnew.sh: test symlink attack when writing .augnew\n    test-put-symlink-augsave.sh: test symlink attack when writing .augsave\n    test-put-symlink-augtemp.sh: test symlink attack via temp .augnew\n    test-put-symlink.sh: also test file modification\n\nFixes BZ 772257"}
{"func": "static int clone_file(const char *from, const char *to,\n                      const char **err_status, int copy_if_rename_fails) {\n    FILE *from_fp = NULL, *to_fp = NULL;\n    char buf[BUFSIZ];\n    size_t len;\n    int result = -1;\n\n    if (rename(from, to) == 0)\n        return 0;\n    if ((errno != EXDEV && errno != EBUSY) || !copy_if_rename_fails) {\n        *err_status = \"rename\";\n        return -1;\n    }\n\n    /* rename not possible, copy file contents */\n    if (!(from_fp = fopen(from, \"r\"))) {\n        *err_status = \"clone_open_src\";\n        goto done;\n    }\n\n    if (!(to_fp = fopen(to, \"w\"))) {\n        *err_status = \"clone_open_dst\";\n        goto done;\n    }\n\n    if (transfer_file_attrs(from_fp, to_fp, err_status) < 0)\n        goto done;\n\n    while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n        if (fwrite(buf, 1, len, to_fp) != len) {\n            *err_status = \"clone_write\";\n            goto done;\n        }\n    }\n    if (ferror(from_fp)) {\n        *err_status = \"clone_read\";\n        goto done;\n    }\n    if (fflush(to_fp) != 0) {\n        *err_status = \"clone_flush\";\n        goto done;\n    }\n    if (fsync(fileno(to_fp)) < 0) {\n        *err_status = \"clone_sync\";\n        goto done;\n    }\n    result = 0;\n done:\n    if (from_fp != NULL)\n        fclose(from_fp);\n    if (to_fp != NULL && fclose(to_fp) != 0)\n        result = -1;\n    if (result != 0)\n        unlink(to);\n    if (result == 0)\n        unlink(from);\n    return result;\n}", "target": 1, "cwe": [], "message": "Prevent cross-mountpoint attacks via .augsave during saving\n\nPreviously Augeas would open PATH.augsave for writing if a rename from PATH to\nPATH.augsave failed, then write the file contents in.  Now if the rename fails,\nit tries to unlink PATH.augsave and open it with O_EXCL first.\n\nMountpoints remain permitted at either PATH or PATH.augnew provided\n/augeas/save/copy_if_rename_fails exists.\n\n* src/transform.c (clone_file):\n    add argument to perform unlink and O_EXCL on destination filename after a\n    rename failure to prevent PATH.augsave being a mountpoint\n* src/transform.c (transform_save, remove_file):\n    always try to unlink PATH.augsave if rename fails, only allowing PATH to be\n    a mountpoint; allow PATH or PATH.augnew to be mountpoints\n* tests/\n    test-put-mount: check PATH being a mountpoint is supported\n    test-put-mount-augnew.sh: check PATH.augnew being a mountpoint is supported\n    test-put-mount-augsave.sh: check unlink error when PATH.augsave is a mount\n\nFixes BZ 772261"}
{"func": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        /* Move file to one with extension .augsave */\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n\n        r = clone_file(augorig_canon, augsave, &err_status, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        /* Unlink file */\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 1, "cwe": [], "message": "Prevent cross-mountpoint attacks via .augsave during saving\n\nPreviously Augeas would open PATH.augsave for writing if a rename from PATH to\nPATH.augsave failed, then write the file contents in.  Now if the rename fails,\nit tries to unlink PATH.augsave and open it with O_EXCL first.\n\nMountpoints remain permitted at either PATH or PATH.augnew provided\n/augeas/save/copy_if_rename_fails exists.\n\n* src/transform.c (clone_file):\n    add argument to perform unlink and O_EXCL on destination filename after a\n    rename failure to prevent PATH.augsave being a mountpoint\n* src/transform.c (transform_save, remove_file):\n    always try to unlink PATH.augsave if rename fails, only allowing PATH to be\n    a mountpoint; allow PATH or PATH.augnew to be mountpoints\n* tests/\n    test-put-mount: check PATH being a mountpoint is supported\n    test-put-mount-augnew.sh: check PATH.augnew being a mountpoint is supported\n    test-put-mount-augsave.sh: check unlink error when PATH.augsave is a mount\n\nFixes BZ 772261"}
{"func": "int transform_save(struct augeas *aug, struct tree *xfm,\n                   const char *path, struct tree *tree) {\n    int   fd;\n    FILE *fp = NULL, *augorig_canon_fp = NULL;\n    char *augtemp = NULL, *augnew = NULL, *augorig = NULL, *augsave = NULL;\n    char *augorig_canon = NULL, *augdest = NULL;\n    int   augorig_exists;\n    int   copy_if_rename_fails = 0;\n    char *text = NULL;\n    const char *filename = path + strlen(AUGEAS_FILES_TREE) + 1;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    struct lns_error *err = NULL;\n    const char *lens_name;\n    struct lens *lens = xfm_lens(aug, xfm, &lens_name);\n    int result = -1, r;\n    bool force_reload;\n\n    errno = 0;\n\n    if (lens == NULL) {\n        err_status = \"lens_name\";\n        goto done;\n    }\n\n    copy_if_rename_fails =\n        aug_get(aug, AUGEAS_COPY_IF_RENAME_FAILS, NULL) == 1;\n\n    if (asprintf(&augorig, \"%s%s\", aug->root, filename) == -1) {\n        augorig = NULL;\n        goto done;\n    }\n\n    augorig_canon = canonicalize_file_name(augorig);\n    augorig_exists = 1;\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            augorig_canon = augorig;\n            augorig_exists = 0;\n        } else {\n            err_status = \"canon_augorig\";\n            goto done;\n        }\n    }\n\n    if (access(augorig_canon, R_OK) == 0) {\n        augorig_canon_fp = fopen(augorig_canon, \"r\");\n        text = xfread_file(augorig_canon_fp);\n    } else {\n        text = strdup(\"\");\n    }\n\n    if (text == NULL) {\n        err_status = \"put_read\";\n        goto done;\n    }\n\n    text = append_newline(text, strlen(text));\n\n    /* Figure out where to put the .augnew and temp file. If no .augnew file\n       then put the temp file next to augorig_canon, else next to .augnew. */\n    if (aug->flags & AUG_SAVE_NEWFILE) {\n        if (xasprintf(&augnew, \"%s\" EXT_AUGNEW, augorig) < 0) {\n            err_status = \"augnew_oom\";\n            goto done;\n        }\n        augdest = augnew;\n    } else {\n        augdest = augorig_canon;\n    }\n\n    if (xasprintf(&augtemp, \"%s.XXXXXX\", augdest) < 0) {\n        err_status = \"augtemp_oom\";\n        goto done;\n    }\n\n    // FIXME: We might have to create intermediate directories\n    // to be able to write augnew, but we have no idea what permissions\n    // etc. they should get. Just the process default ?\n    fd = mkstemp(augtemp);\n    if (fd < 0) {\n        err_status = \"mk_augtemp\";\n        goto done;\n    }\n    fp = fdopen(fd, \"w\");\n    if (fp == NULL) {\n        err_status = \"open_augtemp\";\n        goto done;\n    }\n\n    if (augorig_exists) {\n        if (transfer_file_attrs(augorig_canon_fp, fp, &err_status) != 0) {\n            err_status = \"xfer_attrs\";\n            goto done;\n        }\n    }\n\n    if (tree != NULL)\n        lns_put(fp, lens, tree->children, text, &err);\n\n    if (ferror(fp)) {\n        err_status = \"error_augtemp\";\n        goto done;\n    }\n\n    if (fflush(fp) != 0) {\n        err_status = \"flush_augtemp\";\n        goto done;\n    }\n\n    if (fsync(fileno(fp)) < 0) {\n        err_status = \"sync_augtemp\";\n        goto done;\n    }\n\n    if (fclose(fp) != 0) {\n        err_status = \"close_augtemp\";\n        fp = NULL;\n        goto done;\n    }\n\n    fp = NULL;\n\n    if (err != NULL) {\n        err_status = err->pos >= 0 ? \"parse_skel_failed\" : \"put_failed\";\n        unlink(augtemp);\n        goto done;\n    }\n\n    {\n        char *new_text = xread_file(augtemp);\n        int same = 0;\n        if (new_text == NULL) {\n            err_status = \"read_augtemp\";\n            goto done;\n        }\n        same = STREQ(text, new_text);\n        FREE(new_text);\n        if (same) {\n            result = 0;\n            unlink(augtemp);\n            goto done;\n        } else if (aug->flags & AUG_SAVE_NOOP) {\n            result = 1;\n            unlink(augtemp);\n            goto done;\n        }\n    }\n\n    if (!(aug->flags & AUG_SAVE_NEWFILE)) {\n        if (augorig_exists && (aug->flags & AUG_SAVE_BACKUP)) {\n            r = xasprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig);\n            if (r == -1) {\n                augsave = NULL;\n                goto done;\n            }\n\n            r = clone_file(augorig_canon, augsave, &err_status, 1);\n            if (r != 0) {\n                dyn_err_status = strappend(err_status, \"_augsave\");\n                goto done;\n            }\n        }\n    }\n\n    r = clone_file(augtemp, augdest, &err_status, copy_if_rename_fails);\n    if (r != 0) {\n        dyn_err_status = strappend(err_status, \"_augtemp\");\n        goto done;\n    }\n\n    result = 1;\n\n done:\n    force_reload = aug->flags & AUG_SAVE_NEWFILE;\n    r = add_file_info(aug, path, lens, lens_name, augorig, force_reload);\n    if (r < 0) {\n        err_status = \"file_info\";\n        result = -1;\n    }\n    if (result > 0) {\n        r = file_saved_event(aug, path);\n        if (r < 0) {\n            err_status = \"saved_event\";\n            result = -1;\n        }\n    }\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, err, text);\n    }\n    free(dyn_err_status);\n    lens_release(lens);\n    free(text);\n    free(augtemp);\n    free(augnew);\n    if (augorig_canon != augorig)\n        free(augorig_canon);\n    free(augorig);\n    free(augsave);\n    free_lns_error(err);\n\n    if (fp != NULL)\n        fclose(fp);\n    if (augorig_canon_fp != NULL)\n        fclose(augorig_canon_fp);\n    return result;\n}", "target": 1, "cwe": [], "message": "Prevent cross-mountpoint attacks via .augsave during saving\n\nPreviously Augeas would open PATH.augsave for writing if a rename from PATH to\nPATH.augsave failed, then write the file contents in.  Now if the rename fails,\nit tries to unlink PATH.augsave and open it with O_EXCL first.\n\nMountpoints remain permitted at either PATH or PATH.augnew provided\n/augeas/save/copy_if_rename_fails exists.\n\n* src/transform.c (clone_file):\n    add argument to perform unlink and O_EXCL on destination filename after a\n    rename failure to prevent PATH.augsave being a mountpoint\n* src/transform.c (transform_save, remove_file):\n    always try to unlink PATH.augsave if rename fails, only allowing PATH to be\n    a mountpoint; allow PATH or PATH.augnew to be mountpoints\n* tests/\n    test-put-mount: check PATH being a mountpoint is supported\n    test-put-mount-augnew.sh: check PATH.augnew being a mountpoint is supported\n    test-put-mount-augsave.sh: check unlink error when PATH.augsave is a mount\n\nFixes BZ 772261"}
{"func": "\tvirtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {\n\t\tif (sMessage.Equals(\"DCC \", false, 4) && m_pUser->IsUserAttached()) {\n\t\t\t// DCC CHAT chat 2453612361 44592\n\t\t\tCString sType = sMessage.Token(1);\n\t\t\tCString sFile = sMessage.Token(2);\n\t\t\tunsigned long uLongIP = sMessage.Token(3).ToULong();\n\t\t\tunsigned short uPort = sMessage.Token(4).ToUShort();\n\t\t\tunsigned long uFileSize = sMessage.Token(5).ToULong();\n\n\t\t\tif (sType.Equals(\"CHAT\")) {\n\t\t\t\tCNick FromNick(Nick.GetNickMask());\n\t\t\t\tunsigned short uBNCPort = CDCCBounce::DCCRequest(FromNick.GetNick(), uLongIP, uPort, \"\", true, this, CUtils::GetIP(uLongIP));\n\t\t\t\tif (uBNCPort) {\n\t\t\t\t\tCString sIP = GetLocalDCCIP();\n\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC CHAT chat \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \"\\001\");\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"SEND\")) {\n\t\t\t\t// DCC SEND readme.txt 403120438 5550 1104\n\t\t\t\tunsigned short uBNCPort = CDCCBounce::DCCRequest(Nick.GetNick(), uLongIP, uPort, sFile, false, this, CUtils::GetIP(uLongIP));\n\t\t\t\tif (uBNCPort) {\n\t\t\t\t\tCString sIP = GetLocalDCCIP();\n\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC SEND \" + sFile + \" \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \" \" + CString(uFileSize) + \"\\001\");\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"RESUME\")) {\n\t\t\t\t// Need to lookup the connection by port, filter the port, and forward to the user\n\t\t\t\tunsigned short uResumePort = sMessage.Token(3).ToUShort();\n\n\t\t\t\tset<CSocket*>::const_iterator it;\n\t\t\t\tfor (it = BeginSockets(); it != EndSockets(); ++it) {\n\t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n\n\t\t\t\t\tif (pSock->GetLocalPort() == uResumePort) {\n\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetUserPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sType.Equals(\"ACCEPT\")) {\n\t\t\t\t// Need to lookup the connection by port, filter the port, and forward to the user\n\t\t\t\tset<CSocket*>::const_iterator it;\n\t\t\t\tfor (it = BeginSockets(); it != EndSockets(); ++it) {\n\t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n\n\t\t\t\t\tif (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {\n\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetLocalPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn HALTCORE;\n\t\t}\n\n\t\treturn CONTINUE;\n\t}", "target": 1, "cwe": ["CWE-399"], "message": "Fix crash in bouncedcc module.\n\nIt happens when DCC RESUME is received.\nAffected ZNC versions: 0.200, 0.202.\n\nThanks to howeyc for reporting this and providing the patch."}
{"func": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}", "target": 1, "cwe": [], "message": "KVM: x86: fix missing checks in syscall emulation\n\nOn hosts without this patch, 32bit guests will crash (and 64bit guests\nmay behave in a wrong way) for example by simply executing following\nnasm-demo-application:\n\n    [bits 32]\n    global _start\n    SECTION .text\n    _start: syscall\n\n(I tested it with winxp and linux - both always crashed)\n\n    Disassembly of section .text:\n\n    00000000 <_start>:\n       0:   0f 05                   syscall\n\nThe reason seems a missing \"invalid opcode\"-trap (int6) for the\nsyscall opcode \"0f05\", which is not available on Intel CPUs\nwithin non-longmodes, as also on some AMD CPUs within legacy-mode.\n(depending on CPU vendor, MSR_EFER and cpuid)\n\nBecause previous mentioned OSs may not engage corresponding\nsyscall target-registers (STAR, LSTAR, CSTAR), they remain\nNULL and (non trapping) syscalls are leading to multiple\nfaults and finally crashs.\n\nDepending on the architecture (AMD or Intel) pretended by\nguests, various checks according to vendor's documentation\nare implemented to overcome the current issue and behave\nlike the CPUs physical counterparts.\n\n[mtosatti: cleanup/beautify code]\n\nSigned-off-by: Stephan Baerwolf <stephan.baerwolf@tu-ilmenau.de>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "setup_listen(void)\n{\n  char port[256];\n  int error = 0;\n\n  if (g_lis_trans != 0)\n  {\n    trans_delete(g_lis_trans);\n  }\n  if (g_use_unix_socket)\n  {\n    g_lis_trans = trans_create(2, 8192, 8192);\n    g_snprintf(port, 255, \"/tmp/xrdp_chansrv_socket_%d\", 7200 + g_display_num);\n  }\n  else\n  {\n    g_lis_trans = trans_create(1, 8192, 8192);\n    g_snprintf(port, 255, \"%d\", 7200 + g_display_num);\n  }\n  g_lis_trans->trans_conn_in = my_trans_conn_in;\n  error = trans_listen(g_lis_trans, port);\n  if (error != 0)\n  {\n    LOG(0, (\"setup_listen: trans_listen failed for port %s\", port));\n    return 1;\n  }\n  return 0;\n}", "target": 1, "cwe": [], "message": "move temp files from /tmp to /tmp/.xrdp"}
{"func": "int main(int argc, char** argv)\n{\n  int sck;\n  int dis;\n  struct sockaddr_un sa;\n  size_t len;\n  char* p;\n  char* display;\n\n  if (argc != 1)\n  {\n    printf(\"xrdp disconnect utility\\n\");\n    printf(\"run with no parameters to disconnect you xrdp session\\n\");\n    return 0;\n  }\n\n  display = getenv(\"DISPLAY\");\n  if (display == 0)\n  {\n    printf(\"display not set\\n\");\n    return 1;\n  }\n  dis = strtol(display + 1, &p, 10);\n  memset(&sa, 0, sizeof(sa));\n  sa.sun_family = AF_UNIX;\n  sprintf(sa.sun_path, \"/tmp/xrdp_disconnect_display_%d\", dis);\n  if (access(sa.sun_path, F_OK) != 0)\n  {\n    printf(\"not in an xrdp session\\n\");\n    return 1;\n  }\n  sck = socket(PF_UNIX, SOCK_DGRAM, 0);\n  len = sizeof(sa);\n  if (sendto(sck, \"sig\", 4, 0, (struct sockaddr*)&sa, len) > 0)\n  {\n    printf(\"message sent ok\\n\");\n  }\n  return 0;\n}", "target": 1, "cwe": [], "message": "move temp files from /tmp to /tmp/.xrdp"}
{"func": "chansrv_cleanup(int pid)\n{\n  char text[256];\n\n  g_snprintf(text, 255, \"/tmp/xrdp_chansrv_%8.8x_main_term\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  g_snprintf(text, 255, \"/tmp/xrdp_chansrv_%8.8x_thread_done\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  return 0;\n}", "target": 1, "cwe": [], "message": "move temp files from /tmp to /tmp/.xrdp"}
{"func": "g_init(const char* app_name)\n{\n#if defined(_WIN32)\n  WSADATA wsadata;\n\n  WSAStartup(2, &wsadata);\n#endif\n  setlocale(LC_CTYPE, \"\");\n  if (app_name != 0)\n  {\n    if (app_name[0] != 0)\n    {\n      snprintf(g_temp_base, sizeof(g_temp_base), \"/tmp/%s-XXXXXX\", app_name);\n      if (mkdtemp(g_temp_base) == 0)\n      {\n        printf(\"g_init: mkdtemp failed [%s]\\n\", g_temp_base);\n      }\n    }\n  }\n}", "target": 1, "cwe": [], "message": "move temp files from /tmp to /tmp/.xrdp"}
{"func": "xrdp_mm_process_login_response(struct xrdp_mm* self, struct stream* s)\n{\n  int ok;\n  int display;\n  int rv;\n  int index;\n  int uid;\n  int gid;\n  char text[256];\n  char ip[256];\n  char port[256];\n\n  g_memset(text,0,sizeof(char) * 256);\n  g_memset(ip,0,sizeof(char) * 256);\n  g_memset(port,0,sizeof(char) * 256);\n  rv = 0;\n  in_uint16_be(s, ok);\n  in_uint16_be(s, display);\n  if (ok)\n  {\n    self->display = display;\n    g_snprintf(text, 255, \"xrdp_mm_process_login_response: login successful \"\n                          \"for display %d\", display);\n    xrdp_wm_log_msg(self->wm, text);\n    if (xrdp_mm_setup_mod1(self) == 0)\n    {\n      if (xrdp_mm_setup_mod2(self) == 0)\n      {\n        xrdp_mm_get_value(self, \"ip\", ip, 255);\n        xrdp_wm_set_login_mode(self->wm, 10);\n        self->wm->dragging = 0;\n        /* connect channel redir */\n        if (strcmp(ip, \"127.0.0.1\") == 0)\n        {\n          /* unix socket */\n          self->chan_trans = trans_create(TRANS_MODE_UNIX, 8192, 8192);\n          g_snprintf(port, 255, \"/tmp/xrdp_chansrv_socket_%d\", 7200 + display);\n        }\n        else\n        {\n          /* tcp */\n          self->chan_trans = trans_create(TRANS_MODE_TCP, 8192, 8192);\n          g_snprintf(port, 255, \"%d\", 7200 + display);\n        }\n        self->chan_trans->trans_data_in = xrdp_mm_chan_data_in;\n        self->chan_trans->header_size = 8;\n        self->chan_trans->callback_data = self;\n        /* try to connect up to 4 times */\n        for (index = 0; index < 4; index++)\n        {\n          if (trans_connect(self->chan_trans, ip, port, 3000) == 0)\n          {\n            self->chan_trans_up = 1;\n            break;\n          }\n          g_sleep(1000);\n          g_writeln(\"xrdp_mm_process_login_response: connect failed \"\n                    \"trying again...\");\n        }\n        if (!(self->chan_trans_up))\n        {\n          g_writeln(\"xrdp_mm_process_login_response: error in trans_connect \"\n                    \"chan\");\n        }\n        if (self->chan_trans_up)\n        {\n          if (xrdp_mm_chan_send_init(self) != 0)\n          {\n            g_writeln(\"xrdp_mm_process_login_response: error in \"\n                      \"xrdp_mm_chan_send_init\");\n          }\n        }\n      }\n    }\n  }\n  else\n  {\n    xrdp_wm_log_msg(self->wm, \"xrdp_mm_process_login_response: \"\n                              \"login failed\");\n  }\n  self->delete_sesman_trans = 1;\n  self->connected_state = 0;\n  if (self->wm->login_mode != 10)\n  {\n    xrdp_wm_set_login_mode(self->wm, 11);\n    xrdp_mm_module_cleanup(self);\n  }\n\n  return rv;\n}", "target": 1, "cwe": [], "message": "move temp files from /tmp to /tmp/.xrdp"}
{"func": "g_init(const char* app_name)\n{\n#if defined(_WIN32)\n  WSADATA wsadata;\n\n  WSAStartup(2, &wsadata);\n#endif\n  setlocale(LC_CTYPE, \"\");\n  if (app_name != 0)\n  {\n    if (app_name[0] != 0)\n    {\n      if (!g_directory_exist(\"/tmp/.xrdp\"))\n      {\n        g_create_dir(\"/tmp/.xrdp\");\n        g_chmod_hex(\"/tmp/.xrdp\", 0x1777);\n      }\n      snprintf(g_temp_base, sizeof(g_temp_base),\n               \"/tmp/.xrdp/%s-XXXXXX\", app_name);\n      snprintf(g_temp_base_org, sizeof(g_temp_base_org),\n               \"/tmp/.xrdp/%s-XXXXXX\", app_name);\n      if (mkdtemp(g_temp_base) == 0)\n      {\n        printf(\"g_init: mkdtemp failed [%s]\\n\", g_temp_base);\n      }\n    }\n  }\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "g_execvp(const char* p1, char* args[])\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  return execvp(p1, args);\n#endif\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "g_fork(void)\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  int rv;\n\n  rv = fork();\n  if (rv == 0) /* child */\n  {\n    g_strncpy(g_temp_base, g_temp_base_org, 127);\n    if (mkdtemp(g_temp_base) == 0)\n    {\n      printf(\"g_fork: mkdtemp failed [%s]\\n\", g_temp_base);\n    }\n  }\n  return rv;\n#endif\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "main(int argc, char** argv)\n{\n  int ret = 0;\n  int chansrv_pid = 0;\n  int wm_pid = 0;\n  int x_pid = 0;\n  int lerror = 0;\n  char exe_path[262];\n\n  g_init(\"xrdp-sessvc\");\n  g_memset(exe_path,0,sizeof(exe_path));\n\n  if (argc < 3)\n  {\n    g_writeln(\"xrdp-sessvc: exiting, not enough parameters\");\n    return 1;\n  }\n  g_signal_kill(term_signal_handler); /* SIGKILL */\n  g_signal_terminate(term_signal_handler); /* SIGTERM */\n  g_signal_user_interrupt(term_signal_handler); /* SIGINT */\n  g_signal_pipe(nil_signal_handler); /* SIGPIPE */\n  x_pid = g_atoi(argv[1]);\n  wm_pid = g_atoi(argv[2]);\n  g_writeln(\"xrdp-sessvc: waiting for X (pid %d) and WM (pid %d)\",\n             x_pid, wm_pid);\n  /* run xrdp-chansrv as a seperate process */\n  chansrv_pid = g_fork();\n  if (chansrv_pid == -1)\n  {\n    g_writeln(\"xrdp-sessvc: fork error\");\n    return 1;\n  }\n  else if (chansrv_pid == 0) /* child */\n  {\n    g_set_current_dir(XRDP_SBIN_PATH);\n    g_snprintf(exe_path, 261, \"%s/xrdp-chansrv\", XRDP_SBIN_PATH);\n    g_execlp3(exe_path, \"xrdp-chansrv\", 0);\n    /* should not get here */\n    g_writeln(\"xrdp-sessvc: g_execlp3() failed\");\n    return 1;\n  }\n  lerror = 0;\n  /* wait for window manager to get done */\n  ret = g_waitpid(wm_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(wm_pid);\n    g_sleep(1);\n  }\n  if (ret < 0)\n  {\n    lerror = g_get_errno();\n  }\n  g_writeln(\"xrdp-sessvc: WM is dead (waitpid said %d, errno is %d) \"\n            \"exiting...\", ret, lerror);\n  /* kill channel server */\n  g_writeln(\"xrdp-sessvc: stopping channel server\");\n  g_sigterm(chansrv_pid);\n  ret = g_waitpid(chansrv_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(chansrv_pid);\n    g_sleep(1);\n  }\n  chansrv_cleanup(chansrv_pid);\n  /* kill X server */\n  g_writeln(\"xrdp-sessvc: stopping X server\");\n  g_sigterm(x_pid);\n  ret = g_waitpid(x_pid);\n  while ((ret == 0) && !g_term)\n  {\n    ret = g_waitpid(x_pid);\n    g_sleep(1);\n  }\n  g_writeln(\"xrdp-sessvc: clean exit\");\n  g_deinit();\n  return 0;\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "env_set_user(char* username, char* passwd_file, int display)\n{\n  int error;\n  int pw_uid;\n  int pw_gid;\n  int uid;\n  char pw_shell[256];\n  char pw_dir[256];\n  char pw_gecos[256];\n  char text[256];\n\n  error = g_getuser_info(username, &pw_gid, &pw_uid, pw_shell, pw_dir,\n                         pw_gecos);\n  if (error == 0)\n  {\n    error = g_setgid(pw_gid);\n    if (error == 0)\n    {\n      error = g_initgroups(username, pw_gid);\n    }\n    if (error == 0)\n    {\n      uid = pw_uid;\n      error = g_setuid(uid);\n    }\n    if (error == 0)\n    {\n      g_clearenv();\n      g_setenv(\"SHELL\", pw_shell, 1);\n      g_setenv(\"PATH\", \"/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin\", 1);\n      g_setenv(\"USER\", username, 1);\n      g_sprintf(text, \"%d\", uid);\n      g_setenv(\"UID\", text, 1);\n      g_setenv(\"HOME\", pw_dir, 1);\n      g_set_current_dir(pw_dir);\n      g_sprintf(text, \":%d.0\", display);\n      g_setenv(\"DISPLAY\", text, 1);\n      if (passwd_file != 0)\n      {\n        if (0 == g_cfg->auth_file_path)\n        {\n          /* if no auth_file_path is set, then we go for\n             $HOME/.vnc/sesman_username_passwd */\n          g_mkdir(\".vnc\");\n          g_sprintf(passwd_file, \"%s/.vnc/sesman_%s_passwd\", pw_dir, username);\n        }\n        else\n        {\n          /* we use auth_file_path as requested */\n          g_sprintf(passwd_file, g_cfg->auth_file_path, username);\n        }\n        LOG_DBG(&(g_cfg->log), \"pass file: %s\", passwd_file);\n      }\n    }\n  }\n  else\n  {\n    log_message(&(g_cfg->log), LOG_LEVEL_ERROR,\n                \"error getting user info for user %s\", username);\n  }\n  return error;\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "g_execlp3(const char* a1, const char* a2, const char* a3)\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  return execlp(a1, a2, a3, (void*)0);\n#endif\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "g_deinit(void)\n{\n#if defined(_WIN32)\n  WSACleanup();\n#endif\n  g_remove_dir(g_temp_base);\n}", "target": 1, "cwe": [], "message": "/tmp cleanup"}
{"func": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\t\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)"}
{"func": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\t\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\t\n\t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fixed stack based buffer overflow in transparent cookie encryption (see separate advisory)"}
{"func": "xmlDictComputeFastKey(const xmlChar *name, int namelen) {\n    unsigned long value = 0L;\n\n    if (name == NULL) return(0);\n    value = *name;\n    value <<= 5;\n    if (namelen > 10) {\n        value += name[namelen - 1];\n        namelen = 10;\n    }\n    switch (namelen) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        default: break;\n    }\n    return(value);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlHashComputeQKey(xmlHashTablePtr table,\n\t\t   const xmlChar *prefix, const xmlChar *name,\n\t\t   const xmlChar *prefix2, const xmlChar *name2,\n\t\t   const xmlChar *prefix3, const xmlChar *name3) {\n    unsigned long value = 0L;\n    char ch;\n    \n    if (prefix != NULL)\n\tvalue += 30 * (*prefix);\n    else\n\tvalue += 30 * (*name);\n\n    if (prefix != NULL) {\n\twhile ((ch = *prefix++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name != NULL) {\n\twhile ((ch = *name++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (prefix2 != NULL) {\n\twhile ((ch = *prefix2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name2 != NULL) {\n\twhile ((ch = *name2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (prefix3 != NULL) {\n\twhile ((ch = *prefix3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n\tvalue = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n    }\n    if (name3 != NULL) {\n\twhile ((ch = *name3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    return (value % table->size);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "static int xmlInitializeDict(void) {\n    if (xmlDictInitialized)\n        return(1);\n\n    if ((xmlDictMutex = xmlNewRMutex()) == NULL)\n        return(0);\n\n    xmlDictInitialized = 1;\n    return(1);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlHashComputeKey(xmlHashTablePtr table, const xmlChar *name,\n\t          const xmlChar *name2, const xmlChar *name3) {\n    unsigned long value = 0L;\n    char ch;\n    \n    if (name != NULL) {\n\tvalue += 30 * (*name);\n\twhile ((ch = *name++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (name2 != NULL) {\n\twhile ((ch = *name2++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    if (name3 != NULL) {\n\twhile ((ch = *name3++) != 0) {\n\t    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n\t}\n    }\n    return (value % table->size);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlHashCreate(int size) {\n    xmlHashTablePtr table;\n  \n    if (size <= 0)\n        size = 256;\n  \n    table = xmlMalloc(sizeof(xmlHashTable));\n    if (table) {\n        table->dict = NULL;\n        table->size = size;\n\ttable->nbElems = 0;\n        table->table = xmlMalloc(size * sizeof(xmlHashEntry));\n        if (table->table) {\n  \t    memset(table->table, 0, size * sizeof(xmlHashEntry));\n  \t    return(table);\n        }\n        xmlFree(table);\n    }\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlDictCreateSub(xmlDictPtr sub) {\n    xmlDictPtr dict = xmlDictCreate();\n\n    if ((dict != NULL) && (sub != NULL)) {\n#ifdef DICT_DEBUG_PATTERNS\n        fprintf(stderr, \"R\");\n#endif\n        dict->subdict = sub;\n\txmlDictReference(dict->subdict);\n    }\n    return(dict);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlDictComputeBigQKey(const xmlChar *prefix, int plen,\n                      const xmlChar *name, int len)\n{\n    uint32_t hash;\n    int i;\n\n    hash = 0;\n\n    for (i = 0;i < plen; i++) {\n        hash += prefix[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += ':';\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    for (i = 0;i < len; i++) {\n        hash += name[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len)\n{\n    unsigned long value = 0L;\n\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlDictCreate(void) {\n    xmlDictPtr dict;\n\n    if (!xmlDictInitialized)\n        if (!xmlInitializeDict())\n            return(NULL);\n\n#ifdef DICT_DEBUG_PATTERNS\n    fprintf(stderr, \"C\");\n#endif\n\n    dict = xmlMalloc(sizeof(xmlDict));\n    if (dict) {\n        dict->ref_counter = 1;\n\n        dict->size = MIN_DICT_SIZE;\n\tdict->nbElems = 0;\n        dict->dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));\n\tdict->strings = NULL;\n\tdict->subdict = NULL;\n        if (dict->dict) {\n\t    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n\t    return(dict);\n        }\n        xmlFree(dict);\n    }\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xmlDictComputeBigKey(const xmlChar* data, int namelen) {\n    uint32_t hash;\n    int i;\n\n    if (namelen <= 0 || data == NULL) return(0);\n\n    hash = 0;\n\n    for (i = 0;i < namelen; i++) {\n        hash += data[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Add hash randomization to hash and dict structures\n\nFollowing http://www.ocert.org/advisories/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables"}
{"func": "xsltCompilePatternInternal(const xmlChar *pattern, xmlDocPtr doc,\n\t           xmlNodePtr node, xsltStylesheetPtr style,\n\t\t   xsltTransformContextPtr runtime, int novar) {\n    xsltParserContextPtr ctxt = NULL;\n    xsltCompMatchPtr element, first = NULL, previous = NULL;\n    int current, start, end, level, j;\n\n    if (pattern == NULL) {\n\txsltTransformError(NULL, NULL, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\treturn(NULL);\n    }\n\n    ctxt = xsltNewParserContext(style, runtime);\n    if (ctxt == NULL)\n\treturn(NULL);\n    ctxt->doc = doc;\n    ctxt->elem = node;\n    current = end = 0;\n    while (pattern[current] != 0) {\n\tstart = current;\n\twhile (IS_BLANK_CH(pattern[current]))\n\t    current++;\n\tend = current;\n\tlevel = 0;\n\twhile ((pattern[end] != 0) && ((pattern[end] != '|') || (level != 0))) {\n\t    if (pattern[end] == '[')\n\t\tlevel++;\n\t    else if (pattern[end] == ']')\n\t\tlevel--;\n\t    else if (pattern[end] == '\\'') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\\''))\n\t\t    end++;\n\t    } else if (pattern[end] == '\"') {\n\t\tend++;\n\t\twhile ((pattern[end] != 0) && (pattern[end] != '\"'))\n\t\t    end++;\n\t    }\n\t    end++;\n\t}\n\tif (current == end) {\n\t    xsltTransformError(NULL, NULL, node,\n\t\t\t     \"xsltCompilePattern : NULL pattern\\n\");\n\t    goto error;\n\t}\n\telement = xsltNewCompMatch();\n\tif (element == NULL) {\n\t    goto error;\n\t}\n\tif (first == NULL)\n\t    first = element;\n\telse if (previous != NULL)\n\t    previous->next = element;\n\tprevious = element;\n\n\tctxt->comp = element;\n\tctxt->base = xmlStrndup(&pattern[start], end - start);\n\tif (ctxt->base == NULL)\n\t    goto error;\n\tctxt->cur = &(ctxt->base)[current - start];\n\telement->pattern = ctxt->base;\n\telement->nsList = xmlGetNsList(doc, node);\n\tj = 0;\n\tif (element->nsList != NULL) {\n\t    while (element->nsList[j] != NULL)\n\t\tj++;\n\t}\n\telement->nsNr = j;\n\n\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"xsltCompilePattern : parsing '%s'\\n\",\n\t\t\t element->pattern);\n#endif\n\t/*\n\t Preset default priority to be zero.\n\t This may be changed by xsltCompileLocationPathPattern.\n\t */\n\telement->priority = 0;\n\txsltCompileLocationPathPattern(ctxt, novar);\n\tif (ctxt->error) {\n\t    xsltTransformError(NULL, style, node,\n\t\t\t     \"xsltCompilePattern : failed to compile '%s'\\n\",\n\t\t\t     element->pattern);\n\t    if (style != NULL) style->errors++;\n\t    goto error;\n\t}\n\n\t/*\n\t * Reverse for faster interpretation.\n\t */\n\txsltReverseCompMatch(ctxt, element);\n\n\t/*\n\t * Set-up the priority\n\t */\n\tif (element->priority == 0) {\t/* if not yet determined */\n\t    if (((element->steps[0].op == XSLT_OP_ELEM) ||\n\t\t (element->steps[0].op == XSLT_OP_ATTR) ||\n\t\t (element->steps[0].op == XSLT_OP_PI)) &&\n\t\t(element->steps[0].value != NULL) &&\n\t\t(element->steps[1].op == XSLT_OP_END)) {\n\t\t;\t/* previously preset */\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value2 != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_NS) &&\n\t\t       (element->steps[0].value != NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.25;\n\t    } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n\t\t       (element->steps[0].value == NULL) &&\n\t\t       (element->steps[0].value2 == NULL) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else if (((element->steps[0].op == XSLT_OP_PI) ||\n\t\t       (element->steps[0].op == XSLT_OP_TEXT) ||\n\t\t       (element->steps[0].op == XSLT_OP_ALL) ||\n\t\t       (element->steps[0].op == XSLT_OP_NODE) ||\n\t\t       (element->steps[0].op == XSLT_OP_COMMENT)) &&\n\t\t       (element->steps[1].op == XSLT_OP_END)) {\n\t\t\telement->priority = -0.5;\n\t    } else {\n\t\telement->priority = 0.5;\n\t    }\n\t}\n#ifdef WITH_XSLT_DEBUG_PATTERN\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCompilePattern : parsed %s, default priority %f\\n\",\n\t\t\t element->pattern, element->priority);\n#endif\n\tif (pattern[end] == '|')\n\t    end++;\n\tcurrent = end;\n    }\n    if (end == 0) {\n\txsltTransformError(NULL, style, node,\n\t\t\t \"xsltCompilePattern : NULL pattern\\n\");\n\tif (style != NULL) style->errors++;\n\tgoto error;\n    }\n\n    xsltFreeParserContext(ctxt);\n    return(first);\n\nerror:\n    if (ctxt != NULL)\n\txsltFreeParserContext(ctxt);\n    if (first != NULL)\n\txsltFreeCompMatchList(first);\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-125"], "message": "Fix some case of pattern parsing errors\n\nWe could accidentally hit an off by one string array access\ndue to improper loop exit when parsing patterns"}
{"func": "void OverlaySettings::save(QSettings* settings_ptr) {\n\tOverlaySettings def;\n\n\tSAVELOAD(bEnable, \"enable\");\n\n\tSAVELOAD(osShow, \"show\");\n\tSAVELOAD(bAlwaysSelf, \"alwaysself\");\n\tSAVELOAD(uiActiveTime, \"activetime\");\n\tSAVELOAD(osSort, \"sort\");\n\tSAVELOAD(fX, \"x\");\n\tSAVELOAD(fY, \"y\");\n\tSAVELOAD(fZoom, \"zoom\");\n\tSAVELOAD(uiColumns, \"columns\");\n\n\tsettings_ptr->beginReadArray(QLatin1String(\"states\"));\n\tfor (int i=0; i<4; ++i) {\n\t\tsettings_ptr->setArrayIndex(i);\n\t\tSAVELOAD(qcUserName[i], \"color\");\n\t\tSAVELOAD(fUser[i], \"opacity\");\n\t}\n\tsettings_ptr->endArray();\n\n\tSAVELOAD(qfUserName, \"userfont\");\n\tSAVELOAD(qfChannel, \"channelfont\");\n\tSAVELOAD(qcChannel, \"channelcolor\");\n\tSAVELOAD(qfFps, \"fpsfont\");\n\tSAVELOAD(qcFps, \"fpscolor\");\n\n\tSAVELOAD(fBoxPad, \"padding\");\n\tSAVELOAD(fBoxPenWidth, \"penwidth\");\n\tSAVELOAD(qcBoxPen, \"pencolor\");\n\tSAVELOAD(qcBoxFill, \"fillcolor\");\n\n\tSAVELOAD(bUserName, \"usershow\");\n\tSAVELOAD(bChannel, \"channelshow\");\n\tSAVELOAD(bMutedDeafened, \"mutedshow\");\n\tSAVELOAD(bAvatar, \"avatarshow\");\n\tSAVELOAD(bBox, \"boxshow\");\n\tSAVELOAD(bFps, \"fpsshow\");\n\n\tSAVELOAD(fUserName, \"useropacity\");\n\tSAVELOAD(fChannel, \"channelopacity\");\n\tSAVELOAD(fMutedDeafened, \"mutedopacity\");\n\tSAVELOAD(fAvatar, \"avataropacity\");\n\tSAVELOAD(fFps, \"fpsopacity\");\n\n\tSAVELOAD(qrfUserName, \"userrect\");\n\tSAVELOAD(qrfChannel, \"channelrect\");\n\tSAVELOAD(qrfMutedDeafened, \"mutedrect\");\n\tSAVELOAD(qrfAvatar, \"avatarrect\");\n\tSAVELOAD(qrfFps, \"fpsrect\");\n\n\tSAVEFLAG(qaUserName, \"useralign\");\n\tSAVEFLAG(qaChannel, \"channelalign\");\n\tSAVEFLAG(qaMutedDeafened, \"mutedalign\");\n\tSAVEFLAG(qaAvatar, \"avataralign\");\n\n\tsettings_ptr->setValue(QLatin1String(\"usewhitelist\"), bUseWhitelist);\n\tsettings_ptr->setValue(QLatin1String(\"blacklist\"), qslBlacklist);\n\tsettings_ptr->setValue(QLatin1String(\"whitelist\"), qslWhitelist);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Explicitly remove file permissions for settings and DB"}
{"func": "Database::Database() {\n\tQSqlDatabase db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"));\n\tQSettings qs;\n\tQStringList datapaths;\n\tint i;\n\n\tdatapaths << g.qdBasePath.absolutePath();\n\tdatapaths << QDesktopServices::storageLocation(QDesktopServices::DataLocation);\n#if defined(Q_OS_UNIX) && ! defined(Q_OS_MAC)\n\tdatapaths << QDir::homePath() + QLatin1String(\"/.config/Mumble\");\n#endif\n\tdatapaths << QDir::homePath();\n\tdatapaths << QDir::currentPath();\n\tdatapaths << qApp->applicationDirPath();\n\tdatapaths << qs.value(QLatin1String(\"InstPath\")).toString();\n\tbool found = false;\n\n\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\tif (!datapaths[i].isEmpty()) {\n\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n\t\t\tif (f.exists()) {\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\n\t\t\tQFile f2(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n\t\t\tif (f2.exists()) {\n\t\t\t\tdb.setDatabaseName(f2.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\t\tif (!datapaths[i].isEmpty()) {\n\t\t\t\tQDir::root().mkpath(datapaths[i]);\n#ifdef Q_OS_WIN\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n#else\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n#endif\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"Mumble failed to initialize a database in any\\nof the possible locations.\"), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqFatal(\"Database: Failed initialization\");\n\t}\n\n\tQFileInfo fi(db.databaseName());\n\n\tif (! fi.isWritable()) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"The database '%1' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem.\").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqWarning(\"Database: Database is read-only\");\n\t}\n\n\tQSqlQuery query;\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT \" MUMTEXT(DEFAULT_MUMBLE_PORT) \", `username` TEXT, `password` TEXT)\"));\n\tquery.exec(QLatin1String(\"ALTER TABLE `servers` ADD COLUMN `url` TEXT\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `comments` (`who` TEXT, `comment` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `comments_comment` ON `comments`(`who`, `comment`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `comments_seen` ON `comments`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `blobs` (`hash` TEXT, `data` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `blobs_hash` ON `blobs`(`hash`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `blobs_seen` ON `blobs`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `tokens` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `token` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `tokens_host_port` ON `tokens`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `shortcut` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `shortcut` BLOB, `target` BLOB, `suppress` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `shortcut_host_port` ON `shortcut`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `udp` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `udp_host_port` ON `udp`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `cert` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `digest` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `cert_host_port` ON `cert`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `friends` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_name` ON `friends`(`name`)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_hash` ON `friends`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `muted` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `muted_hash` ON `muted`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `pingcache` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `ping` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `pingcache_host_port` ON `pingcache`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"DELETE FROM `comments` WHERE `seen` < datetime('now', '-1 years')\"));\n\tquery.exec(QLatin1String(\"DELETE FROM `blobs` WHERE `seen` < datetime('now', '-1 months')\"));\n\n\tquery.exec(QLatin1String(\"VACUUM\"));\n\n\tquery.exec(QLatin1String(\"PRAGMA synchronous = OFF\"));\n\tquery.exec(QLatin1String(\"PRAGMA journal_mode = TRUNCATE\"));\n\n\tquery.exec(QLatin1String(\"SELECT sqlite_version()\"));\n\twhile (query.next())\n\t\tqWarning() << \"Database SQLite:\" << query.value(0).toString();\n}", "target": 1, "cwe": ["CWE-310"], "message": "Explicitly remove file permissions for settings and DB"}
{"func": "force_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-400"], "message": "signal/x86: Delay calling signals in atomic\n\nOn x86_64 we must disable preemption before we enable interrupts\nfor stack faults, int3 and debugging, because the current task is using\na per CPU debug stack defined by the IST. If we schedule out, another task\ncan come in and use the same stack and cause the stack to be corrupted\nand crash the kernel on return.\n\nWhen CONFIG_PREEMPT_RT_FULL is enabled, spin_locks become mutexes, and\none of these is the spin lock used in signal handling.\n\nSome of the debug code (int3) causes do_trap() to send a signal.\nThis function calls a spin lock that has been converted to a mutex\nand has the possibility to sleep. If this happens, the above issues with\nthe corrupted stack is possible.\n\nInstead of calling the signal right away, for PREEMPT_RT and x86_64,\nthe signal information is stored on the stacks task_struct and\nTIF_NOTIFY_RESUME is set. Then on exit of the trap, the signal resume\ncode will send the signal when preemption is enabled.\n\n[ rostedt: Switched from #ifdef CONFIG_PREEMPT_RT_FULL to\n  ARCH_RT_DELAYS_SIGNAL_SEND and added comments to the code. ]\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "do_notify_resume(struct pt_regs *regs, void *unused, __u32 thread_info_flags)\n{\n#ifdef CONFIG_X86_MCE\n\t/* notify userspace of pending MCEs */\n\tif (thread_info_flags & _TIF_MCE_NOTIFY)\n\t\tmce_notify_process();\n#endif /* CONFIG_X86_64 && CONFIG_X86_MCE */\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\tif (current->replacement_session_keyring)\n\t\t\tkey_replace_session_keyring();\n\t}\n\tif (thread_info_flags & _TIF_USER_RETURN_NOTIFY)\n\t\tfire_user_return_notifiers();\n\n#ifdef CONFIG_X86_32\n\tclear_thread_flag(TIF_IRET);\n#endif /* CONFIG_X86_32 */\n}", "target": 1, "cwe": ["CWE-400"], "message": "signal/x86: Delay calling signals in atomic\n\nOn x86_64 we must disable preemption before we enable interrupts\nfor stack faults, int3 and debugging, because the current task is using\na per CPU debug stack defined by the IST. If we schedule out, another task\ncan come in and use the same stack and cause the stack to be corrupted\nand crash the kernel on return.\n\nWhen CONFIG_PREEMPT_RT_FULL is enabled, spin_locks become mutexes, and\none of these is the spin lock used in signal handling.\n\nSome of the debug code (int3) causes do_trap() to send a signal.\nThis function calls a spin lock that has been converted to a mutex\nand has the possibility to sleep. If this happens, the above issues with\nthe corrupted stack is possible.\n\nInstead of calling the signal right away, for PREEMPT_RT and x86_64,\nthe signal information is stored on the stacks task_struct and\nTIF_NOTIFY_RESUME is set. Then on exit of the trap, the signal resume\ncode will send the signal when preemption is enabled.\n\n[ rostedt: Switched from #ifdef CONFIG_PREEMPT_RT_FULL to\n  ARCH_RT_DELAYS_SIGNAL_SEND and added comments to the code. ]\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)\n{\n\tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,\n\t\t\t12, SIGBUS) == NOTIFY_STOP)\n\t\treturn;\n\tpreempt_conditional_sti(regs);\n\tdo_trap(12, SIGBUS, \"stack segment\", regs, error_code, NULL);\n\tpreempt_conditional_cli(regs);\n}", "target": 1, "cwe": ["CWE-400"], "message": "x86: Do not disable preemption in int3 on 32bit\n\nPreemption must be disabled before enabling interrupts in do_trap\non x86_64 because the stack in use for int3 and debug is a per CPU\nstack set by th IST. But 32bit does not have an IST and the stack\nstill belongs to the current task and there is no problem in scheduling\nout the task.\n\nKeep preemption enabled on X86_32 when enabling interrupts for\ndo_trap().\n\nThe name of the function is changed from preempt_conditional_sti/cli()\nto conditional_sti/cli_ist(), to annotate that this function is used\nwhen the stack is on the IST.\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk = current;\n\tint user_icebp = 0;\n\tunsigned long dr6;\n\tint si_code;\n\n\tget_debugreg(dr6, 6);\n\n\t/* Filter out all the reserved bits which are preset to 1 */\n\tdr6 &= ~DR6_RESERVED;\n\n\t/*\n\t * If dr6 has no reason to give us about the origin of this trap,\n\t * then it's very likely the result of an icebp/int01 trap.\n\t * User wants a sigtrap for that.\n\t */\n\tif (!dr6 && user_mode(regs))\n\t\tuser_icebp = 1;\n\n\t/* Catch kmemcheck conditions first of all! */\n\tif ((dr6 & DR_STEP) && kmemcheck_trap(regs))\n\t\treturn;\n\n\t/* DR6 may or may not be cleared by the CPU */\n\tset_debugreg(0, 6);\n\n\t/*\n\t * The processor cleared BTF, so don't mark that we need it set.\n\t */\n\tclear_tsk_thread_flag(tsk, TIF_BLOCKSTEP);\n\n\t/* Store the virtualized DR6 value */\n\ttsk->thread.debugreg6 = dr6;\n\n\tif (notify_die(DIE_DEBUG, \"debug\", regs, PTR_ERR(&dr6), error_code,\n\t\t\t\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* It's safe to allow irq's after DR6 has been saved */\n\tpreempt_conditional_sti(regs);\n\n\tif (regs->flags & X86_VM_MASK) {\n\t\thandle_vm86_trap((struct kernel_vm86_regs *) regs,\n\t\t\t\terror_code, 1);\n\t\tpreempt_conditional_cli(regs);\n\t\treturn;\n\t}\n\n\t/*\n\t * Single-stepping through system calls: ignore any exceptions in\n\t * kernel space, but re-enable TF when returning to user mode.\n\t *\n\t * We already checked v86 mode above, so we can check for kernel mode\n\t * by just checking the CPL of CS.\n\t */\n\tif ((dr6 & DR_STEP) && !user_mode(regs)) {\n\t\ttsk->thread.debugreg6 &= ~DR_STEP;\n\t\tset_tsk_thread_flag(tsk, TIF_SINGLESTEP);\n\t\tregs->flags &= ~X86_EFLAGS_TF;\n\t}\n\tsi_code = get_si_code(tsk->thread.debugreg6);\n\tif (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)\n\t\tsend_sigtrap(tsk, regs, error_code, si_code);\n\tpreempt_conditional_cli(regs);\n\n\treturn;\n}", "target": 1, "cwe": ["CWE-400"], "message": "x86: Do not disable preemption in int3 on 32bit\n\nPreemption must be disabled before enabling interrupts in do_trap\non x86_64 because the stack in use for int3 and debug is a per CPU\nstack set by th IST. But 32bit does not have an IST and the stack\nstill belongs to the current task and there is no problem in scheduling\nout the task.\n\nKeep preemption enabled on X86_32 when enabling interrupts for\ndo_trap().\n\nThe name of the function is changed from preempt_conditional_sti/cli()\nto conditional_sti/cli_ist(), to annotate that this function is used\nwhen the stack is on the IST.\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "static inline void preempt_conditional_sti(struct pt_regs *regs)\n{\n\tinc_preempt_count();\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n}", "target": 1, "cwe": ["CWE-400"], "message": "x86: Do not disable preemption in int3 on 32bit\n\nPreemption must be disabled before enabling interrupts in do_trap\non x86_64 because the stack in use for int3 and debug is a per CPU\nstack set by th IST. But 32bit does not have an IST and the stack\nstill belongs to the current task and there is no problem in scheduling\nout the task.\n\nKeep preemption enabled on X86_32 when enabling interrupts for\ndo_trap().\n\nThe name of the function is changed from preempt_conditional_sti/cli()\nto conditional_sti/cli_ist(), to annotate that this function is used\nwhen the stack is on the IST.\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "dotraplinkage void __kprobes do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */\n#ifdef CONFIG_KPROBES\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#else\n\tif (notify_die(DIE_TRAP, \"int3\", regs, error_code, 3, SIGTRAP)\n\t\t\t== NOTIFY_STOP)\n\t\treturn;\n#endif\n\n\tpreempt_conditional_sti(regs);\n\tdo_trap(3, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tpreempt_conditional_cli(regs);\n}", "target": 1, "cwe": ["CWE-400"], "message": "x86: Do not disable preemption in int3 on 32bit\n\nPreemption must be disabled before enabling interrupts in do_trap\non x86_64 because the stack in use for int3 and debug is a per CPU\nstack set by th IST. But 32bit does not have an IST and the stack\nstill belongs to the current task and there is no problem in scheduling\nout the task.\n\nKeep preemption enabled on X86_32 when enabling interrupts for\ndo_trap().\n\nThe name of the function is changed from preempt_conditional_sti/cli()\nto conditional_sti/cli_ist(), to annotate that this function is used\nwhen the stack is on the IST.\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "static inline void preempt_conditional_cli(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n\tdec_preempt_count();\n}", "target": 1, "cwe": ["CWE-400"], "message": "x86: Do not disable preemption in int3 on 32bit\n\nPreemption must be disabled before enabling interrupts in do_trap\non x86_64 because the stack in use for int3 and debug is a per CPU\nstack set by th IST. But 32bit does not have an IST and the stack\nstill belongs to the current task and there is no problem in scheduling\nout the task.\n\nKeep preemption enabled on X86_32 when enabling interrupts for\ndo_trap().\n\nThe name of the function is changed from preempt_conditional_sti/cli()\nto conditional_sti/cli_ist(), to annotate that this function is used\nwhen the stack is on the IST.\n\nCc: stable-rt@vger.kernel.org\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>"}
{"func": "void APE::Properties::analyzeCurrent()\n{\n  // Read the descriptor\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  // Read the header\n  ByteVector header = d->file->readBlock(24);\n\n  // Get the APE info\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  //d->compressionLevel =\n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}", "target": 1, "cwe": [], "message": "Make sure to not try dividing by zero"}
{"func": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}", "target": 1, "cwe": ["CWE-20"], "message": "Don't store the output of ByteVector::toUInt() in int, use uint instead"}
{"func": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find(\"=\");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}", "target": 1, "cwe": ["CWE-20"], "message": "Be more careful when parsing Vorbis Comments"}
{"func": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t/* input unicode or string object */\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t/* optional direction */\n\tconst char *encoding = \"utf-8\";\t/* optional input string encoding */\n\tint clean = 0; /* optional flag to clean the string */\n\tint reordernsm = 1; /* optional flag to allow reordering of non spacing marks*/\n\n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\n\t/* Validate base */\n\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\n\t/* Check object type and delegate to one of the log2vis functions */\n\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1, "cwe": ["CWE-119"], "message": "refactor pyfribidi.c module\n\npyfribidi.c is now compiled as _pyfribidi. This module only handles\nunicode internally and doesn't use the fribidi_utf8_to_unicode\nfunction (which can't handle 4 byte utf-8 sequences). This fixes the\nbuffer overflow in issue #2.\n\nThe code is now also much simpler: pyfribidi.c is down from 280 to 130\nlines of code.\n\nWe now ship a pure python pyfribidi that handles the case when\nnon-unicode strings are passed in.\n\nWe now also adapt the size of the output string if clean=True is\npassed."}
{"func": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* input string encoded in utf-8 */\n\tPyObject *visual = NULL;\t/* output string encoded in utf-8 */\n\tPyObject *result = NULL;\t/* unicode output string */\n\n\tint length = PyUnicode_GET_SIZE (unicode);\n\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\n\treturn result;\n}", "target": 1, "cwe": ["CWE-119"], "message": "refactor pyfribidi.c module\n\npyfribidi.c is now compiled as _pyfribidi. This module only handles\nunicode internally and doesn't use the fribidi_utf8_to_unicode\nfunction (which can't handle 4 byte utf-8 sequences). This fixes the\nbuffer overflow in issue #2.\n\nThe code is now also much simpler: pyfribidi.c is down from 280 to 130\nlines of code.\n\nWe now ship a pure python pyfribidi that handles the case when\nnon-unicode strings are passed in.\n\nWe now also adapt the size of the output string if clean=True is\npassed."}
{"func": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* logical unicode object */\n\tPyObject *result = NULL;\t/* output string object */\n\n\t/* Always needed for the string length */\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\t/* Shortcut for utf8 strings (little faster) */\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\t/* Invoke log2vis_unicode and encode back to encoding */\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}", "target": 1, "cwe": ["CWE-119"], "message": "refactor pyfribidi.c module\n\npyfribidi.c is now compiled as _pyfribidi. This module only handles\nunicode internally and doesn't use the fribidi_utf8_to_unicode\nfunction (which can't handle 4 byte utf-8 sequences). This fixes the\nbuffer overflow in issue #2.\n\nThe code is now also much simpler: pyfribidi.c is down from 280 to 130\nlines of code.\n\nWe now ship a pure python pyfribidi that handles the case when\nnon-unicode strings are passed in.\n\nWe now also adapt the size of the output string if clean=True is\npassed."}
{"func": "initpyfribidi (void)\n{\n\tPyObject *module;\n\n\t/* XXX What should be done if we fail here? */\n\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1, "cwe": ["CWE-119"], "message": "refactor pyfribidi.c module\n\npyfribidi.c is now compiled as _pyfribidi. This module only handles\nunicode internally and doesn't use the fribidi_utf8_to_unicode\nfunction (which can't handle 4 byte utf-8 sequences). This fixes the\nbuffer overflow in issue #2.\n\nThe code is now also much simpler: pyfribidi.c is down from 280 to 130\nlines of code.\n\nWe now ship a pure python pyfribidi that handles the case when\nnon-unicode strings are passed in.\n\nWe now also adapt the size of the output string if clean=True is\npassed."}
{"func": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; /* input fribidi unicode buffer */\n\tFriBidiChar *visual = NULL;\t /* output fribidi unicode buffer */\n\tchar *visual_utf8 = NULL;    /* output fribidi UTF-8 buffer */\n\tFriBidiStrIndex new_len = 0; /* length of the UTF-8 buffer */\n\tPyObject *result = NULL;\t /* failure */\n\n\t/* Allocate fribidi unicode buffers */\n\n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Convert to unicode and order visually */\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Cleanup the string if requested */\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\n\t/* Allocate fribidi UTF-8 buffer */\n\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Encode the reordered string  and create result string */\n\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\t/* XXX does it raise any error? */\n\t\tgoto cleanup;\n\n      cleanup:\n\t/* Delete unicode buffers */\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\n\treturn result;\n}", "target": 1, "cwe": ["CWE-119"], "message": "refactor pyfribidi.c module\n\npyfribidi.c is now compiled as _pyfribidi. This module only handles\nunicode internally and doesn't use the fribidi_utf8_to_unicode\nfunction (which can't handle 4 byte utf-8 sequences). This fixes the\nbuffer overflow in issue #2.\n\nThe code is now also much simpler: pyfribidi.c is down from 280 to 130\nlines of code.\n\nWe now ship a pure python pyfribidi that handles the case when\nnon-unicode strings are passed in.\n\nWe now also adapt the size of the output string if clean=True is\npassed."}
{"func": "bgp_capability_as4 (struct peer *peer, struct capability_header *hdr)\n{\n  as_t as4 = stream_getl (BGP_INPUT(peer));\n  \n  if (BGP_DEBUG (as4, AS4))\n    zlog_debug (\"%s [AS4] about to set cap PEER_CAP_AS4_RCV, got as4 %u\",\n                peer->host, as4);\n  SET_FLAG (peer->cap, PEER_CAP_AS4_RCV);\n  \n  return as4;\n}", "target": 1, "cwe": ["CWE-119"], "message": "bgpd: Open option parse errors don't NOTIFY, resulting in abort & DoS\n\n* bgp_packet.c: (bgp_open_receive) Errors from bgp_open_option_parse are\n  detected, and the code will stop processing the OPEN and return.  However\n  it does so without calling bgp_notify_send to send a NOTIFY - which means\n  the peer FSM doesn't get stopped, and bgp_read will be called again later.\n  Because it returns, it doesn't go through the code near the end of the\n  function that removes the current message from the peer input streaam.\n  Thus the next call to bgp_read will try to parse a half-parsed stream as\n  if it were a new BGP message, leading to an assert later in the code when\n  it tries to read stuff that isn't there. Add the required call to\n  bgp_notify_send before returning.\n* bgp_open.c: (bgp_capability_as4) Be a bit stricter, check the length field\n  corresponds to the only value it can be, which is the amount we're going to\n  read off the stream. And make sure the capability flag gets set, so\n  callers can know this capability was read, regardless.\n  (peek_for_as4_capability) Let bgp_capability_as4 do the length check."}
{"func": "peek_for_as4_capability (struct peer *peer, u_char length)\n{\n  struct stream *s = BGP_INPUT (peer);\n  size_t orig_getp = stream_get_getp (s);\n  size_t end = orig_getp + length;\n  as_t as4 = 0;\n  \n  /* The full capability parser will better flag the error.. */\n  if (STREAM_READABLE(s) < length)\n    return 0;\n\n  if (BGP_DEBUG (as4, AS4))\n    zlog_info (\"%s [AS4] rcv OPEN w/ OPTION parameter len: %u,\"\n                \" peeking for as4\",\n\t        peer->host, length);\n  /* the error cases we DONT handle, we ONLY try to read as4 out of\n   * correctly formatted options.\n   */\n  while (stream_get_getp(s) < end) \n    {\n      u_char opt_type;\n      u_char opt_length;\n      \n      /* Check the length. */\n      if (stream_get_getp (s) + 2 > end)\n        goto end;\n      \n      /* Fetch option type and length. */\n      opt_type = stream_getc (s);\n      opt_length = stream_getc (s);\n      \n      /* Option length check. */\n      if (stream_get_getp (s) + opt_length > end)\n        goto end;\n      \n      if (opt_type == BGP_OPEN_OPT_CAP)\n        {\n          unsigned long capd_start = stream_get_getp (s);\n          unsigned long capd_end = capd_start + opt_length;\n          \n          assert (capd_end <= end);\n          \n\t  while (stream_get_getp (s) < capd_end)\n\t    {\n\t      struct capability_header hdr;\n\t      \n\t      if (stream_get_getp (s) + 2 > capd_end)\n                goto end;\n              \n              hdr.code = stream_getc (s);\n              hdr.length = stream_getc (s);\n              \n\t      if ((stream_get_getp(s) +  hdr.length) > capd_end)\n\t\tgoto end;\n\n\t      if (hdr.code == CAPABILITY_CODE_AS4)\n\t        {\n\t          if (hdr.length != CAPABILITY_CODE_AS4_LEN)\n\t            goto end;\n                  \n\t          if (BGP_DEBUG (as4, AS4))\n\t            zlog_info (\"[AS4] found AS4 capability, about to parse\");\n\t          as4 = bgp_capability_as4 (peer, &hdr);\n\t          \n\t          goto end;\n                }\n              stream_forward_getp (s, hdr.length);\n\t    }\n\t}\n    }\n\nend:\n  stream_set_getp (s, orig_getp);\n  return as4;\n}", "target": 1, "cwe": ["CWE-119"], "message": "bgpd: Open option parse errors don't NOTIFY, resulting in abort & DoS\n\n* bgp_packet.c: (bgp_open_receive) Errors from bgp_open_option_parse are\n  detected, and the code will stop processing the OPEN and return.  However\n  it does so without calling bgp_notify_send to send a NOTIFY - which means\n  the peer FSM doesn't get stopped, and bgp_read will be called again later.\n  Because it returns, it doesn't go through the code near the end of the\n  function that removes the current message from the peer input streaam.\n  Thus the next call to bgp_read will try to parse a half-parsed stream as\n  if it were a new BGP message, leading to an assert later in the code when\n  it tries to read stuff that isn't there. Add the required call to\n  bgp_notify_send before returning.\n* bgp_open.c: (bgp_capability_as4) Be a bit stricter, check the length field\n  corresponds to the only value it can be, which is the amount we're going to\n  read off the stream. And make sure the capability flag gets set, so\n  callers can know this capability was read, regardless.\n  (peek_for_as4_capability) Let bgp_capability_as4 do the length check."}
{"func": "bgp_open_receive (struct peer *peer, bgp_size_t size)\n{\n  int ret;\n  u_char version;\n  u_char optlen;\n  u_int16_t holdtime;\n  u_int16_t send_holdtime;\n  as_t remote_as;\n  as_t as4 = 0;\n  struct peer *realpeer;\n  struct in_addr remote_id;\n  int capability;\n  u_int8_t notify_data_remote_as[2];\n  u_int8_t notify_data_remote_id[4];\n\n  realpeer = NULL;\n  \n  /* Parse open packet. */\n  version = stream_getc (peer->ibuf);\n  memcpy (notify_data_remote_as, stream_pnt (peer->ibuf), 2);\n  remote_as  = stream_getw (peer->ibuf);\n  holdtime = stream_getw (peer->ibuf);\n  memcpy (notify_data_remote_id, stream_pnt (peer->ibuf), 4);\n  remote_id.s_addr = stream_get_ipv4 (peer->ibuf);\n\n  /* Receive OPEN message log  */\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv OPEN, version %d, remote-as (in open) %u,\"\n                \" holdtime %d, id %s\",\n\t        peer->host, version, remote_as, holdtime,\n\t        inet_ntoa (remote_id));\n  \n  /* BEGIN to read the capability here, but dont do it yet */\n  capability = 0;\n  optlen = stream_getc (peer->ibuf);\n  \n  if (optlen != 0)\n    {\n      /* We need the as4 capability value *right now* because\n       * if it is there, we have not got the remote_as yet, and without\n       * that we do not know which peer is connecting to us now.\n       */ \n      as4 = peek_for_as4_capability (peer, optlen);\n    }\n  \n  /* Just in case we have a silly peer who sends AS4 capability set to 0 */\n  if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV) && !as4)\n    {\n      zlog_err (\"%s bad OPEN, got AS4 capability, but AS4 set to 0\",\n                peer->host);\n      bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n                       BGP_NOTIFY_OPEN_BAD_PEER_AS);\n      return -1;\n    }\n  \n  if (remote_as == BGP_AS_TRANS)\n    {\n\t  /* Take the AS4 from the capability.  We must have received the\n\t   * capability now!  Otherwise we have a asn16 peer who uses\n\t   * BGP_AS_TRANS, for some unknown reason.\n\t   */\n      if (as4 == BGP_AS_TRANS)\n        {\n          zlog_err (\"%s [AS4] NEW speaker using AS_TRANS for AS4, not allowed\",\n                    peer->host);\n          bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n                 BGP_NOTIFY_OPEN_BAD_PEER_AS);\n          return -1;\n        }\n      \n      if (!as4 && BGP_DEBUG (as4, AS4))\n        zlog_debug (\"%s [AS4] OPEN remote_as is AS_TRANS, but no AS4.\"\n                    \" Odd, but proceeding.\", peer->host);\n      else if (as4 < BGP_AS_MAX && BGP_DEBUG (as4, AS4))\n        zlog_debug (\"%s [AS4] OPEN remote_as is AS_TRANS, but AS4 (%u) fits \"\n                    \"in 2-bytes, very odd peer.\", peer->host, as4);\n      if (as4)\n        remote_as = as4;\n    } \n  else \n    {\n      /* We may have a partner with AS4 who has an asno < BGP_AS_MAX */\n      /* If we have got the capability, peer->as4cap must match remote_as */\n      if (CHECK_FLAG (peer->cap, PEER_CAP_AS4_RCV)\n          && as4 != remote_as)\n        {\n\t  /* raise error, log this, close session */\n\t  zlog_err (\"%s bad OPEN, got AS4 capability, but remote_as %u\"\n\t            \" mismatch with 16bit 'myasn' %u in open\",\n\t            peer->host, as4, remote_as);\n\t  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t   BGP_NOTIFY_OPEN_BAD_PEER_AS);\n\t  return -1;\n\t}\n    }\n\n  /* Lookup peer from Open packet. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n      int as = 0;\n\n      realpeer = peer_lookup_with_open (&peer->su, remote_as, &remote_id, &as);\n\n      if (! realpeer)\n\t{\n\t  /* Peer's source IP address is check in bgp_accept(), so this\n\t     must be AS number mismatch or remote-id configuration\n\t     mismatch. */\n\t  if (as)\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t\t    peer->host, inet_ntoa (remote_id));\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t\t notify_data_remote_id, 4);\n\t    }\n\t  else\n\t    {\n\t      if (BGP_DEBUG (normal, NORMAL))\n\t\tzlog_debug (\"%s bad OPEN, remote AS is %u, expected %u\",\n\t\t\t    peer->host, remote_as, peer->as);\n\t      bgp_notify_send_with_data (peer, BGP_NOTIFY_OPEN_ERR,\n\t\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t\t notify_data_remote_as, 2);\n\t    }\n\t  return -1;\n\t}\n    }\n\n  /* When collision is detected and this peer is closed.  Retrun\n     immidiately. */\n  ret = bgp_collision_detect (peer, remote_id);\n  if (ret < 0)\n    return ret;\n\n  /* Hack part. */\n  if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))\n    {\n\tif (realpeer->status == Established\n\t    && CHECK_FLAG (realpeer->sflags, PEER_STATUS_NSF_MODE))\n\t{\n\t  realpeer->last_reset = PEER_DOWN_NSF_CLOSE_SESSION;\n\t  SET_FLAG (realpeer->sflags, PEER_STATUS_NSF_WAIT);\n\t}\n\telse if (ret == 0 && realpeer->status != Active\n\t         && realpeer->status != OpenSent\n\t\t && realpeer->status != OpenConfirm\n\t\t && realpeer->status != Connect)\n \t{\n \t  /* XXX: This is an awful problem.. \n \t   *\n \t   * According to the RFC we should just let this connection (of the\n \t   * accepted 'peer') continue on to Established if the other\n \t   * connection (the 'realpeer' one) is in state Connect, and deal\n \t   * with the more larval FSM as/when it gets far enough to receive\n \t   * an Open. We don't do that though, we instead close the (more\n \t   * developed) accepted connection.\n \t   *\n \t   * This means there's a race, which if hit, can loop:\n \t   *\n \t   *       FSM for A                        FSM for B\n \t   *  realpeer     accept-peer       realpeer     accept-peer\n \t   *\n \t   *  Connect                        Connect\n \t   *               Active\n \t   *               OpenSent          OpenSent\n \t   *               <arrive here,\n \t   *               Notify, delete>   \n \t   *                                 Idle         Active\n \t   *   OpenSent                                   OpenSent\n \t   *                                              <arrive here,\n \t   *                                              Notify, delete>\n \t   *   Idle\n \t   *   <wait>                        <wait>\n \t   *   Connect                       Connect\n \t   *\n           *\n \t   * If both sides are Quagga, they're almost certain to wait for\n \t   * the same amount of time of course (which doesn't preclude other\n \t   * implementations also waiting for same time). The race is\n \t   * exacerbated by high-latency (in bgpd and/or the network).\n \t   *\n \t   * The reason we do this is because our FSM is tied to our peer\n \t   * structure, which carries our configuration information, etc. \n \t   * I.e. we can't let the accepted-peer FSM continue on as it is,\n \t   * cause it's not associated with any actual peer configuration -\n \t   * it's just a dummy.\n \t   *\n \t   * It's possible we could hack-fix this by just bgp_stop'ing the\n \t   * realpeer and continueing on with the 'transfer FSM' below. \n \t   * Ideally, we need to seperate FSMs from struct peer.\n \t   *\n \t   * Setting one side to passive avoids the race, as a workaround.\n \t   */\n \t  if (BGP_DEBUG (events, EVENTS))\n\t    zlog_debug (\"%s peer status is %s close connection\",\n\t\t\trealpeer->host, LOOKUP (bgp_status_msg,\n\t\t\trealpeer->status));\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE,\n\t\t\t   BGP_NOTIFY_CEASE_CONNECT_REJECT);\n\n \t  return -1;\n \t}\n\n      if (BGP_DEBUG (events, EVENTS))\n\tzlog_debug (\"%s [Event] Transfer accept BGP peer to real (state %s)\",\n\t\t   peer->host, \n\t\t   LOOKUP (bgp_status_msg, realpeer->status));\n\n      bgp_stop (realpeer);\n      \n      /* Transfer file descriptor. */\n      realpeer->fd = peer->fd;\n      peer->fd = -1;\n\n      /* Transfer input buffer. */\n      stream_free (realpeer->ibuf);\n      realpeer->ibuf = peer->ibuf;\n      realpeer->packet_size = peer->packet_size;\n      peer->ibuf = NULL;\n\n      /* Transfer status. */\n      realpeer->status = peer->status;\n      bgp_stop (peer);\n      \n      /* peer pointer change. Open packet send to neighbor. */\n      peer = realpeer;\n      bgp_open_send (peer);\n      if (peer->fd < 0)\n\t{\n\t  zlog_err (\"bgp_open_receive peer's fd is negative value %d\",\n\t\t    peer->fd);\n\t  return -1;\n\t}\n      BGP_READ_ON (peer->t_read, bgp_read, peer->fd);\n    }\n\n  /* remote router-id check. */\n  if (remote_id.s_addr == 0\n      || IPV4_CLASS_DE (ntohl (remote_id.s_addr))\n      || ntohl (peer->local_id.s_addr) == ntohl (remote_id.s_addr))\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, wrong router identifier %s\",\n\t\t   peer->host, inet_ntoa (remote_id));\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_BGP_IDENT,\n\t\t\t\t notify_data_remote_id, 4);\n      return -1;\n    }\n\n  /* Set remote router-id */\n  peer->remote_id = remote_id;\n\n  /* Peer BGP version check. */\n  if (version != BGP_VERSION_4)\n    {\n      u_int8_t maxver = BGP_VERSION_4;\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad protocol version, remote requested %d, local request %d\",\n\t\t   peer->host, version, BGP_VERSION_4);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_UNSUP_VERSION,\n\t\t\t\t &maxver, 1);\n      return -1;\n    }\n\n  /* Check neighbor as number. */\n  if (remote_as != peer->as)\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s bad OPEN, remote AS is %u, expected %u\",\n\t\t   peer->host, remote_as, peer->as);\n      bgp_notify_send_with_data (peer, \n\t\t\t\t BGP_NOTIFY_OPEN_ERR, \n\t\t\t\t BGP_NOTIFY_OPEN_BAD_PEER_AS,\n\t\t\t\t notify_data_remote_as, 2);\n      return -1;\n    }\n\n  /* From the rfc: Upon receipt of an OPEN message, a BGP speaker MUST\n     calculate the value of the Hold Timer by using the smaller of its\n     configured Hold Time and the Hold Time received in the OPEN message.\n     The Hold Time MUST be either zero or at least three seconds.  An\n     implementation may reject connections on the basis of the Hold Time. */\n\n  if (holdtime < 3 && holdtime != 0)\n    {\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_OPEN_ERR, \n\t\t       BGP_NOTIFY_OPEN_UNACEP_HOLDTIME);\n      return -1;\n    }\n    \n  /* From the rfc: A reasonable maximum time between KEEPALIVE messages\n     would be one third of the Hold Time interval.  KEEPALIVE messages\n     MUST NOT be sent more frequently than one per second.  An\n     implementation MAY adjust the rate at which it sends KEEPALIVE\n     messages as a function of the Hold Time interval. */\n\n  if (CHECK_FLAG (peer->config, PEER_CONFIG_TIMER))\n    send_holdtime = peer->holdtime;\n  else\n    send_holdtime = peer->bgp->default_holdtime;\n\n  if (holdtime < send_holdtime)\n    peer->v_holdtime = holdtime;\n  else\n    peer->v_holdtime = send_holdtime;\n\n  peer->v_keepalive = peer->v_holdtime / 3;\n\n  /* Open option part parse. */\n  if (optlen != 0) \n    {\n      ret = bgp_open_option_parse (peer, optlen, &capability);\n      if (ret < 0)\n\treturn ret;\n    }\n  else\n    {\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s rcvd OPEN w/ OPTION parameter len: 0\",\n\t\t   peer->host);\n    }\n\n  /* Override capability. */\n  if (! capability || CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n    {\n      peer->afc_nego[AFI_IP][SAFI_UNICAST] = peer->afc[AFI_IP][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP][SAFI_MULTICAST] = peer->afc[AFI_IP][SAFI_MULTICAST];\n      peer->afc_nego[AFI_IP6][SAFI_UNICAST] = peer->afc[AFI_IP6][SAFI_UNICAST];\n      peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = peer->afc[AFI_IP6][SAFI_MULTICAST];\n    }\n\n  /* Get sockname. */\n  bgp_getsockname (peer);\n\n  BGP_EVENT_ADD (peer, Receive_OPEN_message);\n\n  peer->packet_size = 0;\n  if (peer->ibuf)\n    stream_reset (peer->ibuf);\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "bgpd: Open option parse errors don't NOTIFY, resulting in abort & DoS\n\n* bgp_packet.c: (bgp_open_receive) Errors from bgp_open_option_parse are\n  detected, and the code will stop processing the OPEN and return.  However\n  it does so without calling bgp_notify_send to send a NOTIFY - which means\n  the peer FSM doesn't get stopped, and bgp_read will be called again later.\n  Because it returns, it doesn't go through the code near the end of the\n  function that removes the current message from the peer input streaam.\n  Thus the next call to bgp_read will try to parse a half-parsed stream as\n  if it were a new BGP message, leading to an assert later in the code when\n  it tries to read stuff that isn't there. Add the required call to\n  bgp_notify_send before returning.\n* bgp_open.c: (bgp_capability_as4) Be a bit stricter, check the length field\n  corresponds to the only value it can be, which is the amount we're going to\n  read off the stream. And make sure the capability flag gets set, so\n  callers can know this capability was read, regardless.\n  (peek_for_as4_capability) Let bgp_capability_as4 do the length check."}
{"func": "int gnutls_pcert_import_openpgp (gnutls_pcert_st* pcert,\n\tgnutls_openpgp_crt_t crt, unsigned int flags)\n{\nint ret;\nsize_t sz;\n\n  memset(pcert, 0, sizeof(*pcert));\n\n  pcert->type = GNUTLS_CRT_OPENPGP;\n  pcert->cert.data = NULL;\n\n  sz = 0;\n  ret = gnutls_openpgp_crt_export(crt, GNUTLS_OPENPGP_FMT_RAW, NULL, &sz);\n  if (ret < 0 && ret != GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  pcert->cert.data = gnutls_malloc(sz);\n  if (pcert->cert.data == NULL)\n    {\n      ret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n      goto cleanup;\n    }\n\n  ret = gnutls_openpgp_crt_export(crt, GNUTLS_X509_FMT_DER, pcert->cert.data, &sz);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n  pcert->cert.size = sz;\n\n  ret = gnutls_pubkey_init(&pcert->pubkey);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  ret = gnutls_pubkey_import_openpgp(pcert->pubkey, crt, 0);\n  if (ret < 0)\n    {\n      gnutls_pubkey_deinit(pcert->pubkey);\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  return 0;\n\ncleanup:\n  gnutls_free(pcert->cert.data);\n\n  return ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Deinitialize the correct number of certificates. Reported by Remi Gacogne."}
{"func": "_gnutls_proc_x509_server_certificate (gnutls_session_t session,\n                                      uint8_t * data, size_t data_size)\n{\n  int size, len, ret;\n  uint8_t *p = data;\n  cert_auth_info_t info;\n  gnutls_certificate_credentials_t cred;\n  ssize_t dsize = data_size;\n  int i;\n  gnutls_pcert_st *peer_certificate_list;\n  size_t peer_certificate_list_size = 0, j, x;\n  gnutls_datum_t tmp;\n\n  cred = (gnutls_certificate_credentials_t)\n    _gnutls_get_cred (session->key, GNUTLS_CRD_CERTIFICATE, NULL);\n  if (cred == NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n    }\n\n\n  if ((ret =\n       _gnutls_auth_info_set (session, GNUTLS_CRD_CERTIFICATE,\n                              sizeof (cert_auth_info_st), 1)) < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  info = _gnutls_get_auth_info (session);\n\n  if (data == NULL || data_size == 0)\n    {\n      gnutls_assert ();\n      /* no certificate was sent */\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  DECR_LEN (dsize, 3);\n  size = _gnutls_read_uint24 (p);\n  p += 3;\n\n  /* some implementations send 0B 00 00 06 00 00 03 00 00 00\n   * instead of just 0B 00 00 03 00 00 00 as an empty certificate message.\n   */\n  if (size == 0 || size == 3)\n    {\n      gnutls_assert ();\n      /* no certificate was sent */\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  i = dsize;\n  while (i > 0)\n    {\n      DECR_LEN (dsize, 3);\n      len = _gnutls_read_uint24 (p);\n      p += 3;\n      DECR_LEN (dsize, len);\n      peer_certificate_list_size++;\n      p += len;\n      i -= len + 3;\n    }\n\n  if (peer_certificate_list_size == 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_NO_CERTIFICATE_FOUND;\n    }\n\n  /* Ok we now allocate the memory to hold the\n   * certificate list \n   */\n\n  peer_certificate_list =\n    gnutls_calloc (1,\n                   sizeof (gnutls_pcert_st) * (peer_certificate_list_size));\n  if (peer_certificate_list == NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_MEMORY_ERROR;\n    }\n\n  p = data + 3;\n\n  /* Now we start parsing the list (again).\n   * We don't use DECR_LEN since the list has\n   * been parsed before.\n   */\n\n  for (j = 0; j < peer_certificate_list_size; j++)\n    {\n      len = _gnutls_read_uint24 (p);\n      p += 3;\n\n      tmp.size = len;\n      tmp.data = p;\n\n      ret =\n        gnutls_pcert_import_x509_raw (&peer_certificate_list\n                                      [j], &tmp, GNUTLS_X509_FMT_DER, 0);\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          goto cleanup;\n        }\n\n      p += len;\n    }\n\n\n  if ((ret =\n       _gnutls_copy_certificate_auth_info (info,\n                                           peer_certificate_list,\n                                           peer_certificate_list_size, 0,\n                                           NULL)) < 0)\n    {\n      gnutls_assert ();\n      goto cleanup;\n    }\n\n  if ((ret =\n       _gnutls_check_key_usage (&peer_certificate_list[0],\n                                gnutls_kx_get (session))) < 0)\n    {\n      gnutls_assert ();\n      goto cleanup;\n    }\n\n  ret = 0;\n\ncleanup:\n  CLEAR_CERTS;\n  gnutls_free (peer_certificate_list);\n  return ret;\n\n}", "target": 1, "cwe": ["CWE-399"], "message": "Deinitialize the correct number of certificates. Reported by Remi Gacogne."}
{"func": "gnutls_pcert_deinit (gnutls_pcert_st *pcert)\n{\n  gnutls_pubkey_deinit(pcert->pubkey);\n  pcert->pubkey = NULL;\n  gnutls_free(pcert->cert.data);\n  pcert->cert.data = NULL;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Deinitialize the correct number of certificates. Reported by Remi Gacogne."}
{"func": "int gnutls_pcert_import_x509 (gnutls_pcert_st* pcert,\n\tgnutls_x509_crt_t crt, unsigned int flags)\n{\nint ret;\nsize_t sz;\n\n  memset(pcert, 0, sizeof(*pcert));\n\n  pcert->type = GNUTLS_CRT_X509;\n  pcert->cert.data = NULL;\n\n  sz = 0;\n  ret = gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_DER, NULL, &sz);\n  if (ret < 0 && ret != GNUTLS_E_SHORT_MEMORY_BUFFER)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  pcert->cert.data = gnutls_malloc(sz);\n  if (pcert->cert.data == NULL)\n    {\n      ret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n      goto cleanup;\n    }\n\n  ret = gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_DER, pcert->cert.data, &sz);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n  pcert->cert.size = sz;\n\n  ret = gnutls_pubkey_init(&pcert->pubkey);\n  if (ret < 0)\n    {\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  ret = gnutls_pubkey_import_x509(pcert->pubkey, crt, 0);\n  if (ret < 0)\n    {\n      gnutls_pubkey_deinit(pcert->pubkey);\n      ret = gnutls_assert_val(ret);\n      goto cleanup;\n    }\n\n  return 0;\n\ncleanup:\n  gnutls_free(pcert->cert.data);\n\n  return ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Deinitialize the correct number of certificates. Reported by Remi Gacogne."}
{"func": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}", "target": 1, "cwe": ["CWE-20"], "message": "core: Validate SSL certificates for all connections\n\nThis prevents MitM attacks which use spoofed SSL certificates.\n\nNote that this bumps our libsoup requirement to 2.37.91.\n\nCloses: https://bugzilla.gnome.org/show_bug.cgi?id=671535"}
{"func": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif /* HAVE_GNOME */\n\n\t/* Log all libsoup traffic if debugging's turned on */\n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\n\t\tg_object_unref (logger);\n\t}\n\n\treturn session;\n}", "target": 1, "cwe": ["CWE-20"], "message": "core: Validate SSL certificates for all connections\n\nThis prevents MitM attacks which use spoofed SSL certificates.\n\nCloses: https://bugzilla.gnome.org/show_bug.cgi?id=671535"}
{"func": "GnashImage::GnashImage(size_t width, size_t height, ImageType type,\n        ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height)\n{\n    const size_t max = std::numeric_limits<boost::int32_t>::max();\n    if (size() > max) {\n        throw std::bad_alloc();\n    }\n    _data.reset(new value_type[size()]);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix crash in GnashImage.cpp"}
{"func": "GnashImage::GnashImage(iterator data, size_t width, size_t height,\n        ImageType type, ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height),\n    _data(data)\n{\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix crash in GnashImage.cpp"}
{"func": "static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma;\n\tstruct pagemapread *pm = walk->private;\n\tpte_t *pte;\n\tint err = 0;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\t/* find the first VMA at or above 'addr' */\n\tvma = find_vma(walk->mm, addr);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tu64 pfn = PM_NOT_PRESENT;\n\n\t\t/* check to see if we've left 'vma' behind\n\t\t * and need a new, higher one */\n\t\tif (vma && (addr >= vma->vm_end))\n\t\t\tvma = find_vma(walk->mm, addr);\n\n\t\t/* check that 'vma' actually covers this address,\n\t\t * and that it isn't a huge page vma */\n\t\tif (vma && (vma->vm_start <= addr) &&\n\t\t    !is_vm_hugetlb_page(vma)) {\n\t\t\tpte = pte_offset_map(pmd, addr);\n\t\t\tpfn = pte_to_pagemap_entry(*pte);\n\t\t\t/* unmap before userspace copy */\n\t\t\tpte_unmap(pte);\n\t\t}\n\t\terr = add_to_pagemap(addr, pfn, pm);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcond_resched();\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * This implies that each ->pmd_entry() handler\n\t\t * needs to know about pmd_trans_huge() pmds\n\t\t */\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this here so we only break down trans_huge\n\t\t * pages when we _need_ to\n\t\t */\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_page_pmd(walk->mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\tunsigned long addr, unsigned long end,\n\t\tconst nodemask_t *nodes, unsigned long flags,\n\t\tvoid *private)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n\t\t\t\t    flags, private))\n\t\t\treturn -EIO;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void mark_screen_rdonly(struct mm_struct *mm)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tint i;\n\n\tpgd = pgd_offset(mm, 0xA0000);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\tgoto out;\n\tpud = pud_offset(pgd, 0xA0000);\n\tif (pud_none_or_clear_bad(pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, 0xA0000);\n\tsplit_huge_page_pmd(mm, pmd);\n\tif (pmd_none_or_clear_bad(pmd))\n\t\tgoto out;\n\tpte = pte_offset_map_lock(mm, pmd, 0xA0000, &ptl);\n\tfor (i = 0; i < 32; i++) {\n\t\tif (pte_present(*pte))\n\t\t\tset_pte(pte, pte_wrprotect(*pte));\n\t\tpte++;\n\t}\n\tpte_unmap_unlock(pte, ptl);\nout:\n\tflush_tlb();\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   struct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = mss->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tspin_lock(&walk->mm->page_table_lock);\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (pmd_trans_splitting(*pmd)) {\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\twait_split_huge_page(vma->anon_vma, pmd);\n\t\t} else {\n\t\t\tsmaps_pte_entry(*(pte_t *)pmd, addr,\n\t\t\t\t\tHPAGE_PMD_SIZE, walk);\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tspin_unlock(&walk->mm->page_table_lock);\n\t}\n\t/*\n\t * The mmap_sem held all the way back in m_start() is what\n\t * keeps khugepaged out of here and from collapsing things\n\t * in here.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tsmaps_pte_entry(*pte, addr, PAGE_SIZE, walk);\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned char *vec)\n{\n\tunsigned long next;\n\tpmd_t *pmd;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (mincore_huge_pmd(vma, pmd, addr, next, vec)) {\n\t\t\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tmincore_unmapped_range(vma, addr, next, vec);\n\t\telse\n\t\t\tmincore_pte_range(vma, pmd, addr, next, vec);\n\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t} while (pmd++, addr = next, addr != end);\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tswp_entry_t entry, struct page *page)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint ret;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (unlikely(pmd_trans_huge(*pmd)))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tunion mc_target target;\n\t\tint type;\n\t\tstruct page *page;\n\t\tstruct page_cgroup *pc;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\ttype = is_target_pte_for_mc(vma, addr, ptent, &target);\n\t\tswitch (type) {\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\tif (isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tpc = lookup_page_cgroup(page);\n\t\t\tif (!mem_cgroup_move_account(page, 1, pc,\n\t\t\t\t\t\t     mc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tputback_lru_page(page);\nput:\t\t\t/* is_target_pte_for_mc() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent,\n\t\t\t\t\t\tmc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (is_target_pte_for_mc(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, pud_t *pud,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn addr;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tmd = walk->private;\n\tspin_lock(&walk->mm->page_table_lock);\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (pmd_trans_splitting(*pmd)) {\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\twait_split_huge_page(md->vma->anon_vma, pmd);\n\t\t} else {\n\t\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\t\tstruct page *page;\n\n\t\t\tpage = can_gather_numa_stats(huge_pte, md->vma, addr);\n\t\t\tif (page)\n\t\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t\t\tHPAGE_PMD_SIZE/PAGE_SIZE);\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tspin_unlock(&walk->mm->page_table_lock);\n\t}\n\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "add more check found by cert's fuzzer."}
{"func": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1, "cwe": ["CWE-119"], "message": "add more check found by cert's fuzzer."}
{"func": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1, "cwe": ["CWE-119"], "message": "add more check found by cert's fuzzer."}
{"func": "cdf_dump_sat(const char *prefix, const cdf_sat_t *sat, size_t size)\n{\n\tsize_t i, j, s = size / sizeof(cdf_secid_t);\n\n\tfor (i = 0; i < sat->sat_len; i++) {\n\t\t(void)fprintf(stderr, \"%s[%\" SIZE_T_FORMAT \"u]:\\n%.6d: \",\n\t\t    prefix, i, i * s);\n\t\tfor (j = 0; j < s; j++) {\n\t\t\t(void)fprintf(stderr, \"%5d, \",\n\t\t\t    CDF_TOLE4(sat->sat_tab[s * i + j]));\n\t\t\tif ((j + 1) % 10 == 0)\n\t\t\t\t(void)fprintf(stderr, \"\\n%.6d: \",\n\t\t\t\t    i * s + j + 1);\n\t\t}\n\t\t(void)fprintf(stderr, \"\\n\");\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)\n{\n\tsize_t i, j, k;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t *msa, mid, sec;\n\tsize_t nsatpersec = (ss / sizeof(mid)) - 1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n\t\t\tbreak;\n\n#define CDF_SEC_LIMIT (UINT32_MAX / (4 * ss))\n\tif ((nsatpersec > 0 &&\n\t    h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||\n\t    i > CDF_SEC_LIMIT) {\n\t\tDPRINTF((\"Number of sectors in master SAT too big %u %\"\n\t\t    SIZE_T_FORMAT \"u\\n\", h->h_num_sectors_in_master_sat, i));\n\t\terrno = EFTYPE;\n\t\treturn -1;\n\t}\n\n\tsat->sat_len = h->h_num_sectors_in_master_sat * nsatpersec + i;\n\tDPRINTF((\"sat_len = %\" SIZE_T_FORMAT \"u ss = %\" SIZE_T_FORMAT \"u\\n\",\n\t    sat->sat_len, ss));\n\tif ((sat->sat_tab = CAST(cdf_secid_t *, calloc(sat->sat_len, ss)))\n\t    == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n\t\tif (h->h_master_sat[i] < 0)\n\t\t\tbreak;\n\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t    h->h_master_sat[i]) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading sector %d\", h->h_master_sat[i]));\n\t\t\tgoto out1;\n\t\t}\n\t}\n\n\tif ((msa = CAST(cdf_secid_t *, calloc(1, ss))) == NULL)\n\t\tgoto out1;\n\n\tmid = h->h_secid_first_sector_in_master_sat;\n\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n\t\tif (mid < 0)\n\t\t\tgoto out;\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Reading master sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out2;\n\t\t}\n\t\tif (cdf_read_sector(info, msa, 0, ss, h, mid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading master sector %d\", mid));\n\t\t\tgoto out2;\n\t\t}\n\t\tfor (k = 0; k < nsatpersec; k++, i++) {\n\t\t\tsec = CDF_TOLE4((uint32_t)msa[k]);\n\t\t\tif (sec < 0)\n\t\t\t\tgoto out;\n\t\t\tif (i >= sat->sat_len) {\n\t\t\t    DPRINTF((\"Out of bounds reading MSA %u >= %u\",\n\t\t\t\ti, sat->sat_len));\n\t\t\t    errno = EFTYPE;\n\t\t\t    goto out2;\n\t\t\t}\n\t\t\tif (cdf_read_sector(info, sat->sat_tab, ss * i, ss, h,\n\t\t\t    sec) != (ssize_t)ss) {\n\t\t\t\tDPRINTF((\"Reading sector %d\",\n\t\t\t\t    CDF_TOLE4(msa[k])));\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\t\tmid = CDF_TOLE4((uint32_t)msa[nsatpersec]);\n\t}\nout:\n\tsat->sat_len = i;\n\tfree(msa);\n\treturn 0;\nout2:\n\tfree(msa);\nout1:\n\tfree(sat->sat_tab);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;\n                        break;\n                case CDF_SIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %d\", buf,\n                            info[i].pi_s32) == -1)\n                                return -1;\n                        break;\n                case CDF_UNSIGNED32:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %u\", buf,\n                            info[i].pi_u32) == -1)\n                                return -1;\n                        break;\n                case CDF_LENGTH32_STRING:\n                case CDF_LENGTH32_WSTRING:\n                        len = info[i].pi_str.s_len;\n                        if (len > 1) {\n                                char vbuf[1024];\n                                size_t j, k = 1;\n\n                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)\n                                    k++;\n                                s = info[i].pi_str.s_buf;\n                                for (j = 0; j < sizeof(vbuf) && len--;\n                                    j++, s += k) {\n                                        if (*s == '\\0')\n                                                break;\n                                        if (isprint((unsigned char)*s))\n                                                vbuf[j] = *s;\n                                }\n                                if (j == sizeof(vbuf))\n                                        --j;\n                                vbuf[j] = '\\0';\n                                if (NOTMIME(ms)) {\n                                        if (vbuf[0]) {\n                                                if (file_printf(ms, \", %s: %s\",\n                                                    buf, vbuf) == -1)\n                                                        return -1;\n                                        }\n                                } else if (info[i].pi_id ==\n                                        CDF_PROPERTY_NAME_OF_APPLICATION) {\n                                        if (strstr(vbuf, \"Word\"))\n                                                str = \"msword\";\n                                        else if (strstr(vbuf, \"Excel\"))\n                                                str = \"vnd.ms-excel\";\n                                        else if (strstr(vbuf, \"Powerpoint\"))\n                                                str = \"vnd.ms-powerpoint\";\n                                        else if (strstr(vbuf,\n                                            \"Crystal Reports\"))\n                                                str = \"x-rpt\";\n                                }\n                        }\n                        break;\n                case CDF_FILETIME:\n                        tp = info[i].pi_tp;\n                        if (tp != 0) {\n                                if (tp < 1000000000000000LL) {\n                                        char tbuf[64];\n                                        cdf_print_elapsed_time(tbuf,\n                                            sizeof(tbuf), tp);\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, tbuf) == -1)\n                                                return -1;\n                                } else {\n                                        char *c, *ec;\n                                        cdf_timestamp_to_timespec(&ts, tp);\n                                        c = cdf_ctime(&ts.tv_sec);\n                                        if ((ec = strchr(c, '\\n')) != NULL)\n                                                *ec = '\\0';\n\n                                        if (NOTMIME(ms) && file_printf(ms,\n                                            \", %s: %s\", buf, c) == -1)\n                                                return -1;\n                                }\n                        }\n                        break;\n                case CDF_CLIPBOARD:\n                        break;\n                default:\n                        return -1;\n                }\n        }\n        if (!NOTMIME(ms)) {\n\t\tif (str == NULL)\n\t\t\treturn 0;\n                if (file_printf(ms, \"application/%s\", str) == -1)\n                        return -1;\n        }\n        return 1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n{\n\tcdf_timestamp_t tp;\n\tstruct timespec ts;\n\tchar buf[64];\n\tsize_t i, j;\n\n\tfor (i = 0; i < count; i++) {\n\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n\t\t(void)fprintf(stderr, \"%\" SIZE_T_FORMAT \"u) %s: \", i, buf);\n\t\tswitch (info[i].pi_type) {\n\t\tcase CDF_NULL:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\t(void)fprintf(stderr, \"signed 16 [%hd]\\n\",\n\t\t\t    info[i].pi_s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\t(void)fprintf(stderr, \"signed 32 [%d]\\n\",\n\t\t\t    info[i].pi_s32);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED32:\n\t\t\t(void)fprintf(stderr, \"unsigned 32 [%u]\\n\",\n\t\t\t    info[i].pi_u32);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\t\t(void)fprintf(stderr, \"string %u [%.*s]\\n\",\n\t\t\t    info[i].pi_str.s_len,\n\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\t(void)fprintf(stderr, \"string %u [\",\n\t\t\t    info[i].pi_str.s_len);\n\t\t\tfor (j = 0; j < info[i].pi_str.s_len - 1; j++)\n\t\t\t    (void)fputc(info[i].pi_str.s_buf[j << 1], stderr);\n\t\t\t(void)fprintf(stderr, \"]\\n\");\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\ttp = info[i].pi_tp;\n\t\t\tif (tp < 1000000000000000LL) {\n\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\\n\", buf);\n\t\t\t} else {\n\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n\t\t\t\t(void)fprintf(stderr, \"timestamp %s\",\n\t\t\t\t    cdf_ctime(&ts.tv_sec));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\t(void)fprintf(stderr, \"CLIPBOARD %u\\n\", info[i].pi_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    info[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4x: \", abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_long_sector_chain(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tssize_t nr;\n\tscn->sst_len = cdf_count_chain(sat, sid, ss);\n\tscn->sst_dirlen = len;\n\n\tif (scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read long sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading long sector chain \"\n\t\t\t    \"%u > %u\\n\", i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((nr = cdf_read_sector(info, scn->sst_tab, i * ss, ss, h,\n\t\t    sid)) != (ssize_t)ss) {\n\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n\t\t\t\t/* Last sector might be truncated */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tDPRINTF((\"Reading long sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%u > %u\\n\", i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\n\tssat->sat_len = cdf_count_chain(sat, sid, CDF_SEC_SIZE(h));\n\tif (ssat->sat_len == (size_t)-1)\n\t\treturn -1;\n\n\tssat->sat_tab = CAST(cdf_secid_t *, calloc(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%u > %u\\n\", i, ssat->sat_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (sst->sst_len < (size_t)id) {\n\t\tDPRINTF((\"bad sector id %d > %d\\n\", id, sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n\t\t\t\to += l >> 2;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "- add float and double types\n- fix debug printf formats\n- fix short stream sizes\n- don't fail if we don't know about a type"}
{"func": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(scn->sst_tab);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix bounds checks again."}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\", i,\n\t\t    inp[i].pi_id, inp[i].pi_type, q - p,\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix bounds checks again."}
{"func": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > ss * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, ss * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix bounds checks again."}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n\n          if (ciphertext.size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext.size, hash_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] !=\n                ciphertext.data[ciphertext.size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    {\n      gnutls_assert ();\n      return pad_failed;\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "message": "better check decrypted data."}
{"func": "ciphertext_to_compressed (gnutls_session_t session,\n                          gnutls_datum_t *ciphertext, \n                          uint8_t * compress_data,\n                          int compress_size,\n                          uint8_t type, record_parameters_st * params, \n                          uint64* sequence)\n{\n  uint8_t tag[MAX_HASH_SIZE];\n  uint8_t pad;\n  int length, length_to_decrypt;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  unsigned int preamble_size;\n  unsigned int ver = gnutls_protocol_get_version (session);\n  unsigned int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n  unsigned int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      /* The way AEAD ciphers are defined in RFC5246, it allows\n       * only stream ciphers.\n       */\n      if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n        {\n          uint8_t nonce[blocksize];\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->read.IV.data == NULL || params->read.IV.size != 4)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n          \n          if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n          memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n          \n          _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n\n          ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n          ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n          \n          length_to_decrypt = ciphertext->size - tag_size;\n        }\n      else\n        {\n          if (ciphertext->size < tag_size)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n  \n          length_to_decrypt = ciphertext->size;\n        }\n\n      length = ciphertext->size - tag_size;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      if ((ret =\n           _gnutls_auth_cipher_decrypt2 (&params->read.cipher_state,\n             ciphertext->data, length_to_decrypt,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    case CIPHER_BLOCK:\n      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n        return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n      /* ignore the IV in TLS 1.1+\n       */\n      if (explicit_iv)\n        {\n          _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n            ciphertext->data, blocksize);\n\n          ciphertext->size -= blocksize;\n          ciphertext->data += blocksize;\n\n          if (ciphertext->size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      /* we don't use the auth_cipher interface here, since\n       * TLS with block ciphers is impossible to be used under such\n       * an API. (the length of plaintext is required to calculate\n       * auth_data, but it is not available before decryption).\n       */\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext->size - tag_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext->size, tag_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          pad %= blocksize;\n        }\n\n      length = ciphertext->size - tag_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver != GNUTLS_SSL3)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext->data[ciphertext->size - i] !=\n                ciphertext->data[ciphertext->size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n\n      if (length < 0)\n        {\n          /* Setting a proper length to prevent timing differences in\n           * processing of records with invalid encryption.\n           */\n          length = ciphertext->size - tag_size;\n        }\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    default:\n      return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  /* HMAC was not the same. \n   */\n  if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n    return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n\n  if (compress_data != ciphertext->data)\n    memcpy (compress_data, ciphertext->data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "message": "changes in packet parsing."}
{"func": "compressed_to_ciphertext (gnutls_session_t session,\n                               uint8_t * cipher_data, int cipher_size,\n                               gnutls_datum_t *compressed,\n                               content_type_t type, \n                               record_parameters_st * params)\n{\n  uint8_t * tag_ptr = NULL;\n  uint8_t pad;\n  int length, length_to_encrypt, ret;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->write.cipher_state);\n  int blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n  unsigned block_algo =\n    _gnutls_cipher_is_block (params->cipher_algorithm);\n  uint8_t *data_ptr;\n  int ver = gnutls_protocol_get_version (session);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n  int auth_cipher = _gnutls_auth_cipher_is_aead(&params->write.cipher_state);\n  int random_pad;\n  \n  /* We don't use long padding if requested or if we are in DTLS.\n   */\n  if (session->internals.priorities.no_padding == 0 && (!IS_DTLS(session)))\n    random_pad = 1;\n  else\n    random_pad = 0;\n  \n  _gnutls_hard_log(\"ENC[%p]: cipher: %s, MAC: %s, Epoch: %u\\n\",\n    session, gnutls_cipher_get_name(params->cipher_algorithm), gnutls_mac_get_name(params->mac_algorithm),\n    (unsigned int)params->epoch);\n\n  preamble_size =\n    make_preamble (UINT64DATA\n                   (params->write.sequence_number),\n                   type, compressed->size, ver, preamble);\n\n  /* Calculate the encrypted length (padding etc.)\n   */\n  length_to_encrypt = length =\n    calc_enc_length (session, compressed->size, tag_size, &pad,\n                     random_pad, block_algo, auth_cipher, blocksize);\n  if (length < 0)\n    {\n      return gnutls_assert_val(length);\n    }\n\n  /* copy the encrypted data to cipher_data.\n   */\n  if (cipher_size < length)\n    {\n      return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n    }\n\n  data_ptr = cipher_data;\n\n  if (explicit_iv)\n    {\n\n      if (block_algo == CIPHER_BLOCK)\n        {\n          /* copy the random IV.\n           */\n          ret = _gnutls_rnd (GNUTLS_RND_NONCE, data_ptr, blocksize);\n          if (ret < 0)\n            return gnutls_assert_val(ret);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, data_ptr, blocksize);\n\n          data_ptr += blocksize;\n          cipher_data += blocksize;\n          length_to_encrypt -= blocksize;\n        }\n      else if (auth_cipher)\n        {\n          uint8_t nonce[blocksize];\n\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->write.IV.data == NULL || params->write.IV.size != AEAD_IMPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n          /* Instead of generating a new nonce on every packet, we use the\n           * write.sequence_number (It is a MAY on RFC 5288).\n           */\n          memcpy(nonce, params->write.IV.data, params->write.IV.size);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], UINT64DATA(params->write.sequence_number), 8);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, nonce, AEAD_IMPLICIT_DATA_SIZE+AEAD_EXPLICIT_DATA_SIZE);\n\n          /* copy the explicit part */\n          memcpy(data_ptr, &nonce[AEAD_IMPLICIT_DATA_SIZE], AEAD_EXPLICIT_DATA_SIZE);\n\n          data_ptr += AEAD_EXPLICIT_DATA_SIZE;\n          cipher_data += AEAD_EXPLICIT_DATA_SIZE;\n          /* In AEAD ciphers we don't encrypt the tag \n           */\n          length_to_encrypt -= AEAD_EXPLICIT_DATA_SIZE + tag_size;\n        }\n    }\n  else\n    {\n      /* AEAD ciphers have an explicit IV. Shouldn't be used otherwise.\n       */\n      if (auth_cipher) return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  memcpy (data_ptr, compressed->data, compressed->size);\n  data_ptr += compressed->size;\n\n  if (tag_size > 0)\n    {\n      tag_ptr = data_ptr;\n      data_ptr += tag_size;\n    }\n  if (block_algo == CIPHER_BLOCK && pad > 0)\n    {\n      memset (data_ptr, pad - 1, pad);\n    }\n\n  /* add the authenticate data */\n  ret = _gnutls_auth_cipher_add_auth(&params->write.cipher_state, preamble, preamble_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* Actual encryption (inplace).\n   */\n  ret =\n    _gnutls_auth_cipher_encrypt2_tag (&params->write.cipher_state,\n        cipher_data, length_to_encrypt, \n        cipher_data, cipher_size,\n        tag_ptr, tag_size, compressed->size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-310"], "message": "changes in packet parsing."}
{"func": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 1, "cwe": ["CWE-399"], "message": "KVM: Ensure all vcpus are consistent with in-kernel irqchip settings\n\nIf some vcpus are created before KVM_CREATE_IRQCHIP, then\nirqchip_in_kernel() and vcpu->arch.apic will be inconsistent, leading\nto potential NULL pointer dereferences.\n\nFix by:\n- ensuring that no vcpus are installed when KVM_CREATE_IRQCHIP is called\n- ensuring that a vcpu has an apic if it is installed after KVM_CREATE_IRQCHIP\n\nThis is somewhat long winded because vcpu->arch.apic is created without\nkvm->lock held.\n\nBased on earlier patch by Michael Ellerman.\n\nSigned-off-by: Michael Ellerman <michael@ellerman.id.au>\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "long kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof ident_addr))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tstruct kvm_pic *vpic;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpic)\n\t\t\tgoto create_irqchip_unlock;\n\t\tr = -ENOMEM;\n\t\tvpic = kvm_create_pic(kvm);\n\t\tif (vpic) {\n\t\t\tr = kvm_ioapic_init(kvm);\n\t\t\tif (r) {\n\t\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_master);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_slave);\n\t\t\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t\t\t  &vpic->dev_eclr);\n\t\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\t\tkfree(vpic);\n\t\t\t\tgoto create_irqchip_unlock;\n\t\t\t}\n\t\t} else\n\t\t\tgoto create_irqchip_unlock;\n\t\tsmp_wmb();\n\t\tkvm->arch.vpic = vpic;\n\t\tsmp_wmb();\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tmutex_lock(&kvm->irq_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_destroy_pic(kvm);\n\t\t\tmutex_unlock(&kvm->irq_lock);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t}\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tbreak;\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof irq_event))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (irqchip_in_kernel(kvm)) {\n\t\t\t__s32 status;\n\t\t\tstatus = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event.irq, irq_event.level);\n\t\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tirq_event.status = status;\n\t\t\t\tif (copy_to_user(argp, &irq_event,\n\t\t\t\t\t\t\tsizeof irq_event))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tr = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof *chip))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto set_irqchip_out;\n\t\tr = 0;\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof u.ps))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm->arch.xen_hvm_config, argp,\n\t\t\t\t   sizeof(struct kvm_xen_hvm_config)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (kvm->arch.xen_hvm_config.flags)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\t\ts64 delta;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&user_ns, argp, sizeof(user_ns)))\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tif (user_ns.flags)\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tdelta = user_ns.clock - now_ns;\n\t\tlocal_irq_enable();\n\t\tkvm->arch.kvmclock_offset = delta;\n\t\tbreak;\n\t}\n\tcase KVM_GET_CLOCK: {\n\t\tstruct kvm_clock_data user_ns;\n\t\tu64 now_ns;\n\n\t\tlocal_irq_disable();\n\t\tnow_ns = get_kernel_ns();\n\t\tuser_ns.clock = kvm->arch.kvmclock_offset + now_ns;\n\t\tlocal_irq_enable();\n\t\tuser_ns.flags = 0;\n\t\tmemset(&user_ns.pad, 0, sizeof(user_ns.pad));\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &user_ns, sizeof(user_ns)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}", "target": 1, "cwe": ["CWE-399"], "message": "KVM: Ensure all vcpus are consistent with in-kernel irqchip settings\n\nIf some vcpus are created before KVM_CREATE_IRQCHIP, then\nirqchip_in_kernel() and vcpu->arch.apic will be inconsistent, leading\nto potential NULL pointer dereferences.\n\nFix by:\n- ensuring that no vcpus are installed when KVM_CREATE_IRQCHIP is called\n- ensuring that a vcpu has an apic if it is installed after KVM_CREATE_IRQCHIP\n\nThis is somewhat long winded because vcpu->arch.apic is created without\nkvm->lock held.\n\nBased on earlier patch by Michael Ellerman.\n\nSigned-off-by: Michael Ellerman <michael@ellerman.id.au>\nSigned-off-by: Avi Kivity <avi@redhat.com>"}
{"func": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n\n  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n\n  return v;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Avoid uint overflow in case the length + index is over UINT_MAX"}
{"func": "int __kvm_set_memory_region(struct kvm *kvm,\n\t\t\t    struct kvm_userspace_memory_region *mem,\n\t\t\t    int user_alloc)\n{\n\tint r;\n\tgfn_t base_gfn;\n\tunsigned long npages;\n\tunsigned long i;\n\tstruct kvm_memory_slot *memslot;\n\tstruct kvm_memory_slot old, new;\n\tstruct kvm_memslots *slots, *old_memslots;\n\n\tr = -EINVAL;\n\t/* General sanity checks */\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\t/* We can read the guest memory with __xxx_user() later on. */\n\tif (user_alloc &&\n\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t     !access_ok(VERIFY_WRITE,\n\t\t\t(void __user *)(unsigned long)mem->userspace_addr,\n\t\t\tmem->memory_size)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEM_SLOTS_NUM)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;\n\n\tmemslot = id_to_memslot(kvm->memslots, mem->slot);\n\tbase_gfn = mem->guest_phys_addr >> PAGE_SHIFT;\n\tnpages = mem->memory_size >> PAGE_SHIFT;\n\n\tr = -EINVAL;\n\tif (npages > KVM_MEM_MAX_NR_PAGES)\n\t\tgoto out;\n\n\tif (!npages)\n\t\tmem->flags &= ~KVM_MEM_LOG_DIRTY_PAGES;\n\n\tnew = old = *memslot;\n\n\tnew.id = mem->slot;\n\tnew.base_gfn = base_gfn;\n\tnew.npages = npages;\n\tnew.flags = mem->flags;\n\n\t/* Disallow changing a memory slot's size. */\n\tr = -EINVAL;\n\tif (npages && old.npages && npages != old.npages)\n\t\tgoto out_free;\n\n\t/* Check for overlaps */\n\tr = -EEXIST;\n\tfor (i = 0; i < KVM_MEMORY_SLOTS; ++i) {\n\t\tstruct kvm_memory_slot *s = &kvm->memslots->memslots[i];\n\n\t\tif (s == memslot || !s->npages)\n\t\t\tcontinue;\n\t\tif (!((base_gfn + npages <= s->base_gfn) ||\n\t\t      (base_gfn >= s->base_gfn + s->npages)))\n\t\t\tgoto out_free;\n\t}\n\n\t/* Free page dirty bitmap if unneeded */\n\tif (!(new.flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tnew.dirty_bitmap = NULL;\n\n\tr = -ENOMEM;\n\n\t/* Allocate if a slot is being created */\n\tif (npages && !old.npages) {\n\t\tnew.user_alloc = user_alloc;\n\t\tnew.userspace_addr = mem->userspace_addr;\n#ifndef CONFIG_S390\n\t\tnew.rmap = vzalloc(npages * sizeof(*new.rmap));\n\t\tif (!new.rmap)\n\t\t\tgoto out_free;\n#endif /* not defined CONFIG_S390 */\n\t\tif (kvm_arch_create_memslot(&new, npages))\n\t\t\tgoto out_free;\n\t}\n\n\t/* Allocate page dirty bitmap if needed */\n\tif ((new.flags & KVM_MEM_LOG_DIRTY_PAGES) && !new.dirty_bitmap) {\n\t\tif (kvm_create_dirty_bitmap(&new) < 0)\n\t\t\tgoto out_free;\n\t\t/* destroy any largepage mappings for dirty tracking */\n\t}\n\n\tif (!npages) {\n\t\tstruct kvm_memory_slot *slot;\n\n\t\tr = -ENOMEM;\n\t\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* From this point no new shadow pages pointing to a deleted\n\t\t * memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t */\n\t\tkvm_arch_flush_shadow(kvm);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\t/* map the pages in iommu page table */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.rmap = NULL;\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\t/*\n\t * If the new memory slot is created, we need to clear all\n\t * mmio sptes.\n\t */\n\tif (npages && old.base_gfn != mem->guest_phys_addr >> PAGE_SHIFT)\n\t\tkvm_arch_flush_shadow(kvm);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}", "target": 1, "cwe": ["CWE-264"], "message": "KVM: unmap pages from the iommu when slots are removed\n\nWe've been adding new mappings, but not destroying old mappings.\nThis can lead to a page leak as pages are pinned using\nget_user_pages, but only unpinned with put_page if they still\nexist in the memslots list on vm shutdown.  A memslot that is\ndestroyed while an iommu domain is enabled for the guest will\ntherefore result in an elevated page reference count that is\nnever cleared.\n\nAdditionally, without this fix, the iommu is only programmed\nwith the first translation for a gpa.  This can result in\npeer-to-peer errors if a mapping is destroyed and replaced by a\nnew mapping at the same gpa as the iommu will still be pointing\nto the original, pinned memory address.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_put_pages(kvm, memslot->base_gfn, memslot->npages);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "KVM: unmap pages from the iommu when slots are removed\n\nWe've been adding new mappings, but not destroying old mappings.\nThis can lead to a page leak as pages are pinned using\nget_user_pages, but only unpinned with put_page if they still\nexist in the memslots list on vm shutdown.  A memslot that is\ndestroyed while an iommu domain is enabled for the guest will\ntherefore result in an elevated page reference count that is\nnever cleared.\n\nAdditionally, without this fix, the iommu is only programmed\nwith the first translation for a gpa.  This can result in\npeer-to-peer errors if a mapping is destroyed and replaced by a\nnew mapping at the same gpa as the iommu will still be pointing\nto the original, pinned memory address.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "int kvm_iommu_unmap_guest(struct kvm *kvm)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tkvm_iommu_unmap_memslots(kvm);\n\tiommu_domain_free(domain);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "message": "KVM: lock slots_lock around device assignment\n\nAs pointed out by Jason Baron, when assigning a device to a guest\nwe first set the iommu domain pointer, which enables mapping\nand unmapping of memory slots to the iommu.  This leaves a window\nwhere this path is enabled, but we haven't synchronized the iommu\nmappings to the existing memory slots.  Thus a slot being removed\nat that point could send us down unexpected code paths removing\nnon-existent pinnings and iommu mappings.  Take the slots_lock\naround creating the iommu domain and initial mappings as well as\naround iommu teardown to avoid this race.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "int kvm_iommu_map_guest(struct kvm *kvm)\n{\n\tint r;\n\n\tif (!iommu_present(&pci_bus_type)) {\n\t\tprintk(KERN_ERR \"%s: iommu not found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tkvm->arch.iommu_domain = iommu_domain_alloc(&pci_bus_type);\n\tif (!kvm->arch.iommu_domain)\n\t\treturn -ENOMEM;\n\n\tif (!allow_unsafe_assigned_interrupts &&\n\t    !iommu_domain_has_cap(kvm->arch.iommu_domain,\n\t\t\t\t  IOMMU_CAP_INTR_REMAP)) {\n\t\tprintk(KERN_WARNING \"%s: No interrupt remapping support,\"\n\t\t       \" disallowing device assignment.\"\n\t\t       \" Re-enble with \\\"allow_unsafe_assigned_interrupts=1\\\"\"\n\t\t       \" module option.\\n\", __func__);\n\t\tiommu_domain_free(kvm->arch.iommu_domain);\n\t\tkvm->arch.iommu_domain = NULL;\n\t\treturn -EPERM;\n\t}\n\n\tr = kvm_iommu_map_memslots(kvm);\n\tif (r)\n\t\tgoto out_unmap;\n\n\treturn 0;\n\nout_unmap:\n\tkvm_iommu_unmap_memslots(kvm);\n\treturn r;\n}", "target": 1, "cwe": ["CWE-264"], "message": "KVM: lock slots_lock around device assignment\n\nAs pointed out by Jason Baron, when assigning a device to a guest\nwe first set the iommu domain pointer, which enables mapping\nand unmapping of memory slots to the iommu.  This leaves a window\nwhere this path is enabled, but we haven't synchronized the iommu\nmappings to the existing memory slots.  Thus a slot being removed\nat that point could send us down unexpected code paths removing\nnon-existent pinnings and iommu mappings.  Take the slots_lock\naround creating the iommu domain and initial mappings as well as\naround iommu teardown to avoid this race.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "_crypt_extended_r(const char *key, const char *setting,\n\tstruct php_crypt_extended_data *data)\n{\n\tint\t\ti;\n\tuint32_t\tcount, salt, l, r0, r1, keybuf[2];\n\tu_char\t\t*p, *q;\n\n\tif (!data->initialized)\n\t\tdes_init_local(data);\n\n\t/*\n\t * Copy the key, shifting each character up by one bit\n\t * and padding with zeros.\n\t */\n\tq = (u_char *) keybuf;\n\twhile (q - (u_char *) keybuf < sizeof(keybuf)) {\n\t\tif ((*q++ = *key << 1))\n\t\t\tkey++;\n\t}\n\tif (des_setkey((u_char *) keybuf, data))\n\t\treturn(NULL);\n\n\tif (*setting == _PASSWORD_EFMT1) {\n\t\t/*\n\t\t * \"new\"-style:\n\t\t *\tsetting - underscore, 4 chars of count, 4 chars of salt\n\t\t *\tkey - unlimited characters\n\t\t */\n\t\tfor (i = 1, count = 0; i < 5; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tcount |= value << (i - 1) * 6;\n\t\t}\n\t\tif (!count)\n\t\t\treturn(NULL);\n\n\t\tfor (i = 5, salt = 0; i < 9; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tsalt |= value << (i - 5) * 6;\n\t\t}\n\n\t\twhile (*key) {\n\t\t\t/*\n\t\t\t * Encrypt the key with itself.\n\t\t\t */\n\t\t\tif (des_cipher((u_char *) keybuf, (u_char *) keybuf,\n\t\t\t    0, 1, data))\n\t\t\t\treturn(NULL);\n\t\t\t/*\n\t\t\t * And XOR with the next 8 characters of the key.\n\t\t\t */\n\t\t\tq = (u_char *) keybuf;\n\t\t\twhile (q - (u_char *) keybuf < sizeof(keybuf) && *key)\n\t\t\t\t*q++ ^= *key++ << 1;\n\n\t\t\tif (des_setkey((u_char *) keybuf, data))\n\t\t\t\treturn(NULL);\n\t\t}\n\t\tmemcpy(data->output, setting, 9);\n\t\tdata->output[9] = '\\0';\n\t\tp = (u_char *) data->output + 9;\n\t} else {\n\t\t/*\n\t\t * \"old\"-style:\n\t\t *\tsetting - 2 chars of salt\n\t\t *\tkey - up to 8 characters\n\t\t */\n\t\tcount = 25;\n\n\t\tif (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))\n\t\t\treturn(NULL);\n\n\t\tsalt = (ascii_to_bin(setting[1]) << 6)\n\t\t     |  ascii_to_bin(setting[0]);\n\n\t\tdata->output[0] = setting[0];\n\t\tdata->output[1] = setting[1];\n\t\tp = (u_char *) data->output + 2;\n\t}\n\tsetup_salt(salt, data);\n\t/*\n\t * Do it.\n\t */\n\tif (do_des(0, 0, &r0, &r1, count, data))\n\t\treturn(NULL);\n\t/*\n\t * Now encode the result...\n\t */\n\tl = (r0 >> 8);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = (r0 << 16) | ((r1 >> 16) & 0xffff);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = r1 << 2;\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\t*p = 0;\n\n\treturn(data->output);\n}", "target": 1, "cwe": ["CWE-310"], "message": "fix CVE-2012-2143"}
{"func": "bgp_capability_orf_entry (struct peer *peer, struct capability_header *hdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  struct capability_orf_entry entry;\n  afi_t afi;\n  safi_t safi;\n  u_char type;\n  u_char mode;\n  u_int16_t sm_cap = 0; /* capability send-mode receive */\n  u_int16_t rm_cap = 0; /* capability receive-mode receive */ \n  int i;\n\n  /* ORF Entry header */\n  bgp_capability_mp_data (s, &entry.mpc);\n  entry.num = stream_getc (s);\n  afi = entry.mpc.afi;\n  safi = entry.mpc.safi;\n  \n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s ORF Cap entry for afi/safi: %u/%u\",\n\t        peer->host, entry.mpc.afi, entry.mpc.safi);\n\n  /* Check AFI and SAFI. */\n  if (!bgp_afi_safi_valid_indices (entry.mpc.afi, &safi))\n    {\n      zlog_info (\"%s Addr-family %d/%d not supported.\"\n                 \" Ignoring the ORF capability\",\n                 peer->host, entry.mpc.afi, entry.mpc.safi);\n      return 0;\n    }\n  \n  /* validate number field */\n  if (sizeof (struct capability_orf_entry) + (entry.num * 2) > hdr->length)\n    {\n      zlog_info (\"%s ORF Capability entry length error,\"\n                 \" Cap length %u, num %u\",\n                 peer->host, hdr->length, entry.num);\n      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n      return -1;\n    }\n\n  for (i = 0 ; i < entry.num ; i++)\n    {\n      type = stream_getc(s);\n      mode = stream_getc(s);\n      \n      /* ORF Mode error check */\n      switch (mode)\n        {\n          case ORF_MODE_BOTH:\n          case ORF_MODE_SEND:\n          case ORF_MODE_RECEIVE:\n            break;\n          default:\n\t    bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t    continue;\n\t}\n      /* ORF Type and afi/safi error checks */\n      /* capcode versus type */\n      switch (hdr->code)\n        {\n          case CAPABILITY_CODE_ORF:\n            switch (type)\n              {\n                case ORF_TYPE_PREFIX:\n                  break;\n                default:\n                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n                  continue;\n              }\n            break;\n          case CAPABILITY_CODE_ORF_OLD:\n            switch (type)\n              {\n                case ORF_TYPE_PREFIX_OLD:\n                  break;\n                default:\n                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n                  continue;\n              }\n            break;\n          default:\n            bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n            continue;\n        }\n                \n      /* AFI vs SAFI */\n      if (!((afi == AFI_IP && safi == SAFI_UNICAST)\n            || (afi == AFI_IP && safi == SAFI_MULTICAST)\n            || (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n        {\n          bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n          continue;\n        }\n      \n      if (BGP_DEBUG (normal, NORMAL))\n        zlog_debug (\"%s OPEN has %s ORF capability\"\n                    \" as %s for afi/safi: %d/%d\",\n                    peer->host, LOOKUP (orf_type_str, type),\n                    LOOKUP (orf_mode_str, mode),\n                    entry.mpc.afi, safi);\n\n      if (hdr->code == CAPABILITY_CODE_ORF)\n\t{\n          sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n          rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n\t}\n      else if (hdr->code == CAPABILITY_CODE_ORF_OLD)\n\t{\n          sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n          rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n\t}\n      else\n\t{\n\t  bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n\t  continue;\n\t}\n\n      switch (mode)\n\t{\n\t  case ORF_MODE_BOTH:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t  case ORF_MODE_SEND:\n\t    SET_FLAG (peer->af_cap[afi][safi], sm_cap);\n\t    break;\n\t  case ORF_MODE_RECEIVE:\n\t    SET_FLAG (peer->af_cap[afi][safi], rm_cap);\n\t    break;\n\t}\n    }\n  return 0;\n}", "target": 1, "cwe": [], "message": "bgpd: CVE-2012-1820, DoS in bgp_capability_orf()\n\nAn ORF (code 3) capability TLV is defined to contain exactly one\nAFI/SAFI block. Function bgp_capability_orf(), which parses ORF\ncapability TLV, uses do-while cycle to call its helper function\nbgp_capability_orf_entry(), which actually processes the AFI/SAFI data\nblock. The call is made at least once and repeated as long as the input\nbuffer has enough data for the next call.\n\nThe helper function, bgp_capability_orf_entry(), uses \"Number of ORFs\"\nfield of the provided AFI/SAFI block to verify, if it fits the input\nbuffer. However, the check is made based on the total length of the ORF\nTLV regardless of the data already consumed by the previous helper\nfunction call(s). This way, the check condition is only valid for the\nfirst AFI/SAFI block inside an ORF capability TLV.\n\nFor the subsequent calls of the helper function, if any are made, the\ncheck condition may erroneously tell, that the current \"Number of ORFs\"\nfield fits the buffer boundary, where in fact it does not. This makes it\npossible to trigger an assertion by feeding an OPEN message with a\nspecially-crafted malformed ORF capability TLV.\n\nThis commit fixes the vulnerability by making the implementation follow\nthe spec."}
{"func": "bgp_capability_parse (struct peer *peer, size_t length, int *mp_capability,\n\t\t      u_char **error)\n{\n  int ret;\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + length;\n  \n  assert (STREAM_READABLE (s) >= length);\n  \n  while (stream_get_getp (s) < end)\n    {\n      size_t start;\n      u_char *sp = stream_pnt (s);\n      struct capability_header caphdr;\n      \n      /* We need at least capability code and capability length. */\n      if (stream_get_getp(s) + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      caphdr.code = stream_getc (s);\n      caphdr.length = stream_getc (s);\n      start = stream_get_getp (s);\n      \n      /* Capability length check sanity check. */\n      if (start + caphdr.length > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< length)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n\t\t   peer->host,\n\t\t   LOOKUP (capcode_str, caphdr.code),\n\t\t   caphdr.code, caphdr.length);\n      \n      /* Length sanity check, type-specific, for known capabilities */\n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n          case CAPABILITY_CODE_RESTART:\n          case CAPABILITY_CODE_AS4:\n          case CAPABILITY_CODE_DYNAMIC:\n              /* Check length. */\n              if (caphdr.length < cap_minsizes[caphdr.code])\n                {\n                  zlog_info (\"%s %s Capability length error: got %u,\"\n                             \" expected at least %u\",\n                             peer->host, \n                             LOOKUP (capcode_str, caphdr.code),\n                             caphdr.length, \n\t\t\t     (unsigned) cap_minsizes[caphdr.code]);\n                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n                  return -1;\n                }\n          /* we deliberately ignore unknown codes, see below */\n          default:\n            break;\n        }\n      \n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n            {\n\t      *mp_capability = 1;\n\n              /* Ignore capability when override-capability is set. */\n              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n                {\n                  /* Set negotiated value. */\n                  ret = bgp_capability_mp (peer, &caphdr);\n\n                  /* Unsupported Capability. */\n                  if (ret < 0)\n                    {\n                      /* Store return data. */\n                      memcpy (*error, sp, caphdr.length + 2);\n                      *error += caphdr.length + 2;\n                    }\n                }\n            }\n            break;\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n            {\n              /* BGP refresh capability */\n              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n              else\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n            }\n            break;\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n            if (bgp_capability_orf (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_RESTART:\n            if (bgp_capability_restart (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_DYNAMIC:\n            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n            break;\n          case CAPABILITY_CODE_AS4:\n              /* Already handled as a special-case parsing of the capabilities\n               * at the beginning of OPEN processing. So we care not a jot\n               * for the value really, only error case.\n               */\n              if (!bgp_capability_as4 (peer, &caphdr))\n                return -1;\n              break;            \n          default:\n            if (caphdr.code > 128)\n              {\n                /* We don't send Notification for unknown vendor specific\n                   capabilities.  It seems reasonable for now...  */\n                zlog_warn (\"%s Vendor specific capability %d\",\n                           peer->host, caphdr.code);\n              }\n            else\n              {\n                zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                           peer->host, caphdr.code);\n                memcpy (*error, sp, caphdr.length + 2);\n                *error += caphdr.length + 2;\n              }\n          }\n      if (stream_get_getp(s) != (start + caphdr.length))\n        {\n          if (stream_get_getp(s) > (start + caphdr.length))\n            zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\",\n                       peer->host, LOOKUP (capcode_str, caphdr.code),\n                       caphdr.length);\n          stream_set_getp (s, start + caphdr.length);\n        }\n    }\n  return 0;\n}", "target": 1, "cwe": [], "message": "bgpd: CVE-2012-1820, DoS in bgp_capability_orf()\n\nAn ORF (code 3) capability TLV is defined to contain exactly one\nAFI/SAFI block. Function bgp_capability_orf(), which parses ORF\ncapability TLV, uses do-while cycle to call its helper function\nbgp_capability_orf_entry(), which actually processes the AFI/SAFI data\nblock. The call is made at least once and repeated as long as the input\nbuffer has enough data for the next call.\n\nThe helper function, bgp_capability_orf_entry(), uses \"Number of ORFs\"\nfield of the provided AFI/SAFI block to verify, if it fits the input\nbuffer. However, the check is made based on the total length of the ORF\nTLV regardless of the data already consumed by the previous helper\nfunction call(s). This way, the check condition is only valid for the\nfirst AFI/SAFI block inside an ORF capability TLV.\n\nFor the subsequent calls of the helper function, if any are made, the\ncheck condition may erroneously tell, that the current \"Number of ORFs\"\nfield fits the buffer boundary, where in fact it does not. This makes it\npossible to trigger an assertion by feeding an OPEN message with a\nspecially-crafted malformed ORF capability TLV.\n\nThis commit fixes the vulnerability by making the implementation follow\nthe spec."}
{"func": "bgp_capability_orf (struct peer *peer, struct capability_header *hdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + hdr->length;\n  \n  assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);\n  \n  /* We must have at least one ORF entry, as the caller has already done\n   * minimum length validation for the capability code - for ORF there must\n   * at least one ORF entry (header and unknown number of pairs of bytes).\n   */\n  do\n    {\n      if (bgp_capability_orf_entry (peer, hdr) == -1)\n        return -1;\n    } \n  while (stream_get_getp(s) + sizeof(struct capability_orf_entry) < end);\n  \n  return 0;\n}", "target": 1, "cwe": [], "message": "bgpd: CVE-2012-1820, DoS in bgp_capability_orf()\n\nAn ORF (code 3) capability TLV is defined to contain exactly one\nAFI/SAFI block. Function bgp_capability_orf(), which parses ORF\ncapability TLV, uses do-while cycle to call its helper function\nbgp_capability_orf_entry(), which actually processes the AFI/SAFI data\nblock. The call is made at least once and repeated as long as the input\nbuffer has enough data for the next call.\n\nThe helper function, bgp_capability_orf_entry(), uses \"Number of ORFs\"\nfield of the provided AFI/SAFI block to verify, if it fits the input\nbuffer. However, the check is made based on the total length of the ORF\nTLV regardless of the data already consumed by the previous helper\nfunction call(s). This way, the check condition is only valid for the\nfirst AFI/SAFI block inside an ORF capability TLV.\n\nFor the subsequent calls of the helper function, if any are made, the\ncheck condition may erroneously tell, that the current \"Number of ORFs\"\nfield fits the buffer boundary, where in fact it does not. This makes it\npossible to trigger an assertion by feeding an OPEN message with a\nspecially-crafted malformed ORF capability TLV.\n\nThis commit fixes the vulnerability by making the implementation follow\nthe spec."}
{"func": "MP4::Properties::Properties(File *file, MP4::Atoms *atoms, ReadStyle style)\n  : AudioProperties(style)\n{\n  d = new PropertiesPrivate;\n\n  MP4::Atom *moov = atoms->find(\"moov\");\n  if(!moov) {\n    debug(\"MP4: Atom 'moov' not found\");\n    return;\n  }\n\n  MP4::Atom *trak = 0;\n  ByteVector data;\n\n  MP4::AtomList trakList = moov->findall(\"trak\");\n  for (unsigned int i = 0; i < trakList.size(); i++) {\n    trak = trakList[i];\n    MP4::Atom *hdlr = trak->find(\"mdia\", \"hdlr\");\n    if(!hdlr) {\n      debug(\"MP4: Atom 'trak.mdia.hdlr' not found\");\n      return;\n    }\n    file->seek(hdlr->offset);\n    data = file->readBlock(hdlr->length);\n    if(data.mid(16, 4) == \"soun\") {\n      break;\n    }\n    trak = 0;\n  }\n  if (!trak) {\n    debug(\"MP4: No audio tracks\");\n    return;\n  }\n\n  MP4::Atom *mdhd = trak->find(\"mdia\", \"mdhd\");\n  if(!mdhd) {\n    debug(\"MP4: Atom 'trak.mdia.mdhd' not found\");\n    return;\n  }\n\n  file->seek(mdhd->offset);\n  data = file->readBlock(mdhd->length);\n  if(data[8] == 0) {\n    unsigned int unit = data.mid(20, 4).toUInt();\n    unsigned int length = data.mid(24, 4).toUInt();\n    d->length = length / unit;\n  }\n  else {\n    long long unit = data.mid(28, 8).toLongLong();\n    long long length = data.mid(36, 8).toLongLong();\n    d->length = int(length / unit);\n  }\n\n  MP4::Atom *atom = trak->find(\"mdia\", \"minf\", \"stbl\", \"stsd\");\n  if(!atom) {\n    return;\n  }\n\n  file->seek(atom->offset);\n  data = file->readBlock(atom->length);\n  if(data.mid(20, 4) == \"mp4a\") {\n    d->channels = data.mid(40, 2).toShort();\n    d->bitsPerSample = data.mid(42, 2).toShort();\n    d->sampleRate = data.mid(46, 4).toUInt();\n    if(data.mid(56, 4) == \"esds\" && data[64] == 0x03) {\n      long pos = 65;\n      if(data.mid(pos, 3) == \"\\x80\\x80\\x80\") {\n        pos += 3;\n      }\n      pos += 4;\n      if(data[pos] == 0x04) {\n        pos += 1;\n        if(data.mid(pos, 3) == \"\\x80\\x80\\x80\") {\n          pos += 3;\n        }\n        pos += 10;\n        d->bitrate = (data.mid(pos, 4).toUInt() + 500) / 1000;\n      }\n    }\n  }\n}", "target": 1, "cwe": [], "message": "Reverse the version check, similarly to what mp4v2 does"}
{"func": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\tdprint(DBG_CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "message": "hfsplus: Fix potential buffer overflows\n\nCommit ec81aecb2966 (\"hfs: fix a potential buffer overflow\") fixed a few\npotential buffer overflows in the hfs filesystem.  But as Timo Warns\npointed out, these changes also need to be made on the hfsplus\nfilesystem as well.\n\nReported-by: Timo Warns <warns@pre-sense.de>\nAcked-by: WANG Cong <amwang@redhat.com>\nCc: Alexey Khoroshilov <khoroshilov@ispras.ru>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Sage Weil <sage@newdream.net>\nCc: Eugene Teo <eteo@redhat.com>\nCc: Roman Zippel <zippel@linux-m68k.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Dave Anderson <anderson@redhat.com>\nCc: stable <stable@vger.kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-264"], "message": "hfsplus: Fix potential buffer overflows\n\nCommit ec81aecb2966 (\"hfs: fix a potential buffer overflow\") fixed a few\npotential buffer overflows in the hfs filesystem.  But as Timo Warns\npointed out, these changes also need to be made on the hfsplus\nfilesystem as well.\n\nReported-by: Timo Warns <warns@pre-sense.de>\nAcked-by: WANG Cong <amwang@redhat.com>\nCc: Alexey Khoroshilov <khoroshilov@ispras.ru>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Sage Weil <sage@newdream.net>\nCc: Eugene Teo <eteo@redhat.com>\nCc: Roman Zippel <zippel@linux-m68k.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Dave Anderson <anderson@redhat.com>\nCc: stable <stable@vger.kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n\n\tif (msg_flags & MSG_OOB)\n\t\tgoto out;\n\n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = inc->i_hdr.h_sport;\n\t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "rds: set correct msg_namelen\n\nJay Fenlason (fenlason@redhat.com) found a bug,\nthat recvfrom() on an RDS socket can return the contents of random kernel\nmemory to userspace if it was called with a address length larger than\nsizeof(struct sockaddr_in).\nrds_recvmsg() also fails to set the addr_len paramater properly before\nreturning, but that's just a bug.\nThere are also a number of cases wher recvfrom() can return an entirely bogus\naddress. Anything in rds_recvmsg() that returns a non-negative value but does\nnot go through the \"sin = (struct sockaddr_in *)msg->msg_name;\" code path\nat the end of the while(1) loop will return up to 128 bytes of kernel memory\nto userspace.\n\nAnd I write two test programs to reproduce this bug, you will see that in\nrds_server, fromAddr will be overwritten and the following sock_fd will be\ndestroyed.\nYes, it is the programmer's fault to set msg_namelen incorrectly, but it is\nbetter to make the kernel copy the real length of address to user space in\nsuch case.\n\nHow to run the test programs ?\nI test them on 32bit x86 system, 3.5.0-rc7.\n\n1 compile\ngcc -o rds_client rds_client.c\ngcc -o rds_server rds_server.c\n\n2 run ./rds_server on one console\n\n3 run ./rds_client on another console\n\n4 you will see something like:\nserver is waiting to receive data...\nold socket fd=3\nserver received data from client:data from client\nmsg.msg_namelen=32\nnew socket fd=-1067277685\nsendmsg()\n: Bad file descriptor\n\n/***************** rds_client.c ********************/\n\nint main(void)\n{\n\tint sock_fd;\n\tstruct sockaddr_in serverAddr;\n\tstruct sockaddr_in toAddr;\n\tchar recvBuffer[128] = \"data from client\";\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\n\tsock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);\n\tif (sock_fd < 0) {\n\t\tperror(\"create socket error\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&serverAddr, 0, sizeof(serverAddr));\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tserverAddr.sin_port = htons(4001);\n\n\tif (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"bind() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tmemset(&toAddr, 0, sizeof(toAddr));\n\ttoAddr.sin_family = AF_INET;\n\ttoAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\ttoAddr.sin_port = htons(4000);\n\tmsg.msg_name = &toAddr;\n\tmsg.msg_namelen = sizeof(toAddr);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = strlen(recvBuffer) + 1;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\tif (sendmsg(sock_fd, &msg, 0) == -1) {\n\t\tperror(\"sendto() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"client send data:%s\\n\", recvBuffer);\n\n\tmemset(recvBuffer, '\\0', 128);\n\n\tmsg.msg_name = &toAddr;\n\tmsg.msg_namelen = sizeof(toAddr);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = 128;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\tif (recvmsg(sock_fd, &msg, 0) == -1) {\n\t\tperror(\"recvmsg() error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"receive data from server:%s\\n\", recvBuffer);\n\n\tclose(sock_fd);\n\n\treturn 0;\n}\n\n/***************** rds_server.c ********************/\n\nint main(void)\n{\n\tstruct sockaddr_in fromAddr;\n\tint sock_fd;\n\tstruct sockaddr_in serverAddr;\n\tunsigned int addrLen;\n\tchar recvBuffer[128];\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\n\tsock_fd = socket(AF_RDS, SOCK_SEQPACKET, 0);\n\tif(sock_fd < 0) {\n\t\tperror(\"create socket error\\n\");\n\t\texit(0);\n\t}\n\n\tmemset(&serverAddr, 0, sizeof(serverAddr));\n\tserverAddr.sin_family = AF_INET;\n\tserverAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tserverAddr.sin_port = htons(4000);\n\tif (bind(sock_fd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {\n\t\tperror(\"bind error\\n\");\n\t\tclose(sock_fd);\n\t\texit(1);\n\t}\n\n\tprintf(\"server is waiting to receive data...\\n\");\n\tmsg.msg_name = &fromAddr;\n\n\t/*\n\t * I add 16 to sizeof(fromAddr), ie 32,\n\t * and pay attention to the definition of fromAddr,\n\t * recvmsg() will overwrite sock_fd,\n\t * since kernel will copy 32 bytes to userspace.\n\t *\n\t * If you just use sizeof(fromAddr), it works fine.\n\t * */\n\tmsg.msg_namelen = sizeof(fromAddr) + 16;\n\t/* msg.msg_namelen = sizeof(fromAddr); */\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov->iov_base = recvBuffer;\n\tmsg.msg_iov->iov_len = 128;\n\tmsg.msg_control = 0;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\twhile (1) {\n\t\tprintf(\"old socket fd=%d\\n\", sock_fd);\n\t\tif (recvmsg(sock_fd, &msg, 0) == -1) {\n\t\t\tperror(\"recvmsg() error\\n\");\n\t\t\tclose(sock_fd);\n\t\t\texit(1);\n\t\t}\n\t\tprintf(\"server received data from client:%s\\n\", recvBuffer);\n\t\tprintf(\"msg.msg_namelen=%d\\n\", msg.msg_namelen);\n\t\tprintf(\"new socket fd=%d\\n\", sock_fd);\n\t\tstrcat(recvBuffer, \"--data from server\");\n\t\tif (sendmsg(sock_fd, &msg, 0) == -1) {\n\t\t\tperror(\"sendmsg()\\n\");\n\t\t\tclose(sock_fd);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tclose(sock_fd);\n\treturn 0;\n}\n\nSigned-off-by: Weiping Pan <wpan@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {\n    xmlChar *buffer, *cur;\n    int len;\n    int level;\n\n    if (name == NULL)\n    name = xmlXPathParseName(ctxt);\n    if (name == NULL)\n\tXP_ERROR(XPATH_EXPR_ERROR);\n\n    if (CUR != '(')\n\tXP_ERROR(XPATH_EXPR_ERROR);\n    NEXT;\n    level = 1;\n\n    len = xmlStrlen(ctxt->cur);\n    len++;\n    buffer = (xmlChar *) xmlMallocAtomic(len * sizeof (xmlChar));\n    if (buffer == NULL) {\n        xmlXPtrErrMemory(\"allocating buffer\");\n\treturn;\n    }\n\n    cur = buffer;\n    while (CUR != 0) {\n\tif (CUR == ')') {\n\t    level--;\n\t    if (level == 0) {\n\t\tNEXT;\n\t\tbreak;\n\t    }\n\t    *cur++ = CUR;\n\t} else if (CUR == '(') {\n\t    level++;\n\t    *cur++ = CUR;\n\t} else if (CUR == '^') {\n\t    NEXT;\n\t    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {\n\t\t*cur++ = CUR;\n\t    } else {\n\t\t*cur++ = '^';\n\t\t*cur++ = CUR;\n\t    }\n\t} else {\n\t    *cur++ = CUR;\n\t}\n\tNEXT;\n    }\n    *cur = 0;\n\n    if ((level != 0) && (CUR == 0)) {\n\txmlFree(buffer);\n\tXP_ERROR(XPTR_SYNTAX_ERROR);\n    }\n\n    if (xmlStrEqual(name, (xmlChar *) \"xpointer\")) {\n\tconst xmlChar *left = CUR_PTR;\n\n\tCUR_PTR = buffer;\n\t/*\n\t * To evaluate an xpointer scheme element (4.3) we need:\n\t *   context initialized to the root\n\t *   context position initalized to 1\n\t *   context size initialized to 1\n\t */\n\tctxt->context->node = (xmlNodePtr)ctxt->context->doc;\n\tctxt->context->proximityPosition = 1;\n\tctxt->context->contextSize = 1;\n\txmlXPathEvalExpr(ctxt);\n\tCUR_PTR=left;\n    } else if (xmlStrEqual(name, (xmlChar *) \"element\")) {\n\tconst xmlChar *left = CUR_PTR;\n\txmlChar *name2;\n\n\tCUR_PTR = buffer;\n\tif (buffer[0] == '/') {\n\t    xmlXPathRoot(ctxt);\n\t    xmlXPtrEvalChildSeq(ctxt, NULL);\n\t} else {\n\t    name2 = xmlXPathParseName(ctxt);\n\t    if (name2 == NULL) {\n\t\tCUR_PTR = left;\n\t\txmlFree(buffer);\n\t\tXP_ERROR(XPATH_EXPR_ERROR);\n\t    }\n\t    xmlXPtrEvalChildSeq(ctxt, name2);\n\t}\n\tCUR_PTR = left;\n#ifdef XPTR_XMLNS_SCHEME\n    } else if (xmlStrEqual(name, (xmlChar *) \"xmlns\")) {\n\tconst xmlChar *left = CUR_PTR;\n\txmlChar *prefix;\n\txmlChar *URI;\n\txmlURIPtr value;\n\n\tCUR_PTR = buffer;\n        prefix = xmlXPathParseNCName(ctxt);\n\tif (prefix == NULL) {\n\t    xmlFree(buffer);\n\t    xmlFree(name);\n\t    XP_ERROR(XPTR_SYNTAX_ERROR);\n\t}\n\tSKIP_BLANKS;\n\tif (CUR != '=') {\n\t    xmlFree(prefix);\n\t    xmlFree(buffer);\n\t    xmlFree(name);\n\t    XP_ERROR(XPTR_SYNTAX_ERROR);\n\t}\n\tNEXT;\n\tSKIP_BLANKS;\n\t/* @@ check escaping in the XPointer WD */\n\n\tvalue = xmlParseURI((const char *)ctxt->cur);\n\tif (value == NULL) {\n\t    xmlFree(prefix);\n\t    xmlFree(buffer);\n\t    xmlFree(name);\n\t    XP_ERROR(XPTR_SYNTAX_ERROR);\n\t}\n\tURI = xmlSaveUri(value);\n\txmlFreeURI(value);\n\tif (URI == NULL) {\n\t    xmlFree(prefix);\n\t    xmlFree(buffer);\n\t    xmlFree(name);\n\t    XP_ERROR(XPATH_MEMORY_ERROR);\n\t}\n\t\n\txmlXPathRegisterNs(ctxt->context, prefix, URI);\n\tCUR_PTR = left;\n\txmlFree(URI);\n\txmlFree(prefix);\n#endif /* XPTR_XMLNS_SCHEME */\n    } else {\n        xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,\n\t\t   \"unsupported scheme '%s'\\n\", name);\n    }\n    xmlFree(buffer);\n    xmlFree(name);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix an off by one pointer access\n\ngetting out of the range of memory allocated for xpointer decoding"}
{"func": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type))\n\t\t\t\tww = (unsigned int) value;\n\t\t\tif (!strcmp (\"height\", type))\n\t\t\t\thh = (unsigned int) value;\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Avoid an integer overflow in the xbm loader\n\nAt the same time, reject some silly input, such as negative\nwidth or height.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=672811"}
{"func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}", "target": 1, "cwe": ["CWE-189"], "message": "fix bug #61065"}
{"func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}", "target": 1, "cwe": ["CWE-189"], "message": "fix unchecked emalloc"}
{"func": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}", "target": 1, "cwe": ["CWE-189"], "message": "fix unchecked emalloc"}
{"func": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret < 1 ) ret = defaultval;\n\n  return ret;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Cap escape sequence parameters to prevent long loops.\n\nFixes #271 github issue."}
{"func": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-189"], "message": "drm/i915: fix integer overflow in i915_gem_execbuffer2()\n\nOn 32-bit systems, a large args->buffer_count from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 8408c282 (\"drm/i915:\nFirst try a normal large kmalloc for the temporary exec buffers\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>"}
{"func": "i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-189"], "message": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>"}
{"func": "int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t  const struct tcphdr *th, unsigned int len)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint queued = 0;\n\tint res;\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tgoto discard;\n\n\tcase TCP_LISTEN:\n\t\tif (th->ack)\n\t\t\treturn 1;\n\n\t\tif (th->rst)\n\t\t\tgoto discard;\n\n\t\tif (th->syn) {\n\t\t\tif (icsk->icsk_af_ops->conn_request(sk, skb) < 0)\n\t\t\t\treturn 1;\n\n\t\t\t/* Now we have several options: In theory there is\n\t\t\t * nothing else in the frame. KA9Q has an option to\n\t\t\t * send data with the syn, BSD accepts data with the\n\t\t\t * syn up to the [to be] advertised window and\n\t\t\t * Solaris 2.1 gives you a protocol error. For now\n\t\t\t * we just ignore it, that fits the spec precisely\n\t\t\t * and avoids incompatibilities. It would be nice in\n\t\t\t * future to drop through and process the data.\n\t\t\t *\n\t\t\t * Now that TTCP is starting to be used we ought to\n\t\t\t * queue this data.\n\t\t\t * But, this leaves one open to an easy denial of\n\t\t\t * service attack, and SYN cookies can't defend\n\t\t\t * against this problem. So, we drop the data\n\t\t\t * in the interest of security over speed unless\n\t\t\t * it's still in use.\n\t\t\t */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto discard;\n\n\tcase TCP_SYN_SENT:\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t/* Do step6 onward by hand. */\n\t\ttcp_urg(sk, skb, th);\n\t\t__kfree_skb(skb);\n\t\ttcp_data_snd_check(sk);\n\t\treturn 0;\n\t}\n\n\tres = tcp_validate_incoming(sk, skb, th, 0);\n\tif (res <= 0)\n\t\treturn -res;\n\n\t/* step 5: check the ACK field */\n\tif (th->ack) {\n\t\tint acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH) > 0;\n\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_RECV:\n\t\t\tif (acceptable) {\n\t\t\t\ttp->copied_seq = tp->rcv_nxt;\n\t\t\t\tsmp_mb();\n\t\t\t\ttcp_set_state(sk, TCP_ESTABLISHED);\n\t\t\t\tsk->sk_state_change(sk);\n\n\t\t\t\t/* Note, that this wakeup is only for marginal\n\t\t\t\t * crossed SYN case. Passively open sockets\n\t\t\t\t * are not waked up, because sk->sk_sleep ==\n\t\t\t\t * NULL and sk->sk_socket == NULL.\n\t\t\t\t */\n\t\t\t\tif (sk->sk_socket)\n\t\t\t\t\tsk_wake_async(sk,\n\t\t\t\t\t\t      SOCK_WAKE_IO, POLL_OUT);\n\n\t\t\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\n\t\t\t\ttp->snd_wnd = ntohs(th->window) <<\n\t\t\t\t\t      tp->rx_opt.snd_wscale;\n\t\t\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\n\t\t\t\tif (tp->rx_opt.tstamp_ok)\n\t\t\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\n\n\t\t\t\t/* Make sure socket is routed, for\n\t\t\t\t * correct metrics.\n\t\t\t\t */\n\t\t\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\t\t\t\ttcp_init_metrics(sk);\n\n\t\t\t\ttcp_init_congestion_control(sk);\n\n\t\t\t\t/* Prevent spurious tcp_cwnd_restart() on\n\t\t\t\t * first data packet.\n\t\t\t\t */\n\t\t\t\ttp->lsndtime = tcp_time_stamp;\n\n\t\t\t\ttcp_mtup_init(sk);\n\t\t\t\ttcp_initialize_rcv_mss(sk);\n\t\t\t\ttcp_init_buffer_space(sk);\n\t\t\t\ttcp_fast_path_on(tp);\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_FIN_WAIT1:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\n\t\t\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\t\t\tdst_confirm(__sk_dst_get(sk));\n\n\t\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\t\t/* Wake up lingering close() */\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\telse {\n\t\t\t\t\tint tmo;\n\n\t\t\t\t\tif (tp->linger2 < 0 ||\n\t\t\t\t\t    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t\t\t     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {\n\t\t\t\t\t\ttcp_done(sk);\n\t\t\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmo = tcp_fin_time(sk);\n\t\t\t\t\tif (tmo > TCP_TIMEWAIT_LEN) {\n\t\t\t\t\t\tinet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\n\t\t\t\t\t} else if (th->fin || sock_owned_by_user(sk)) {\n\t\t\t\t\t\t/* Bad case. We could lose such FIN otherwise.\n\t\t\t\t\t\t * It is not a big problem, but it looks confusing\n\t\t\t\t\t\t * and not so rare event. We still can lose it now,\n\t\t\t\t\t\t * if it spins in bh_lock_sock(), but it is really\n\t\t\t\t\t\t * marginal case.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tinet_csk_reset_keepalive_timer(sk, tmo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\t\t\t\tgoto discard;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_CLOSING:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_LAST_ACK:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_update_metrics(sk);\n\t\t\t\ttcp_done(sk);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tgoto discard;\n\n\t/* step 6: check the URG bit */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\t\t/* RFC 793 says to queue data in these states,\n\t\t * RFC 1122 says we MUST send a reset.\n\t\t * BSD 4.4 also does reset.\n\t\t */\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\ttcp_reset(sk);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* Fall through */\n\tcase TCP_ESTABLISHED:\n\t\ttcp_data_queue(sk, skb);\n\t\tqueued = 1;\n\t\tbreak;\n\t}\n\n\t/* tcp_data could move socket to TIME-WAIT */\n\tif (sk->sk_state != TCP_CLOSE) {\n\t\ttcp_data_snd_check(sk);\n\t\ttcp_ack_snd_check(sk);\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "tcp: drop SYN+FIN messages\n\nDenys Fedoryshchenko reported that SYN+FIN attacks were bringing his\nlinux machines to their limits.\n\nDont call conn_request() if the TCP flags includes SYN flag\n\nReported-by: Denys Fedoryshchenko <denys@visp.net.lb>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}", "target": 1, "cwe": ["CWE-703"], "message": "Null pointer deref in kadmind [CVE-2012-1013]\n\nThe fix for #6626 could cause kadmind to dereference a null pointer if\na create-principal request contains no password but does contain the\nKRB5_KDB_DISALLOW_ALL_TIX flag (e.g. \"addprinc -randkey -allow_tix\nname\").  Only clients authorized to create principals can trigger the\nbug.  Fix the bug by testing for a null password in check_1_6_dummy.\n\nCVSSv2 vector: AV:N/AC:M/Au:S/C:N/I:N/A:P/E:H/RL:O/RC:C\n\n[ghudson@mit.edu: Minor style change and commit message]\n\nticket: 7152\ntarget_version: 1.10.2\ntags: pullup"}
{"func": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n        GC_bool init;\n        lg = ROUNDED_UP_GRANULES(lb);\n        lb_rounded = GRANULES_TO_BYTES(lg);\n        n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n        init = GC_obj_kinds[k].ok_init;\n        LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                            */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix allocation size overflows due to rounding.\n\n* malloc.c (GC_generic_malloc): Check if the allocation size is\nrounded to a smaller value.\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise."}
{"func": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                          */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix allocation size overflows due to rounding.\n\n* malloc.c (GC_generic_malloc): Check if the allocation size is\nrounded to a smaller value.\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise."}
{"func": "void * calloc(size_t n, size_t lb)\n{\n#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix calloc() overflow\n\n* malloc.c (calloc): Check multiplication overflow in calloc(),\nassuming REDIRECT_MALLOC."}
{"func": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix calloc-related code to prevent SIZE_MAX redefinition in sys headers\n\n* malloc.c: Include limits.h for SIZE_MAX.\n* malloc.c (SIZE_MAX, calloc): Define GC_SIZE_MAX instead of SIZE_MAX."}
{"func": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1, "cwe": ["CWE-189"], "message": "Speedup calloc size overflow check by preventing division if small values\n\n* malloc.c (GC_SQRT_SIZE_MAX): New macro.\n* malloc.c (calloc): Add fast initial size overflow check to avoid\ninteger division for reasonably small values passed."}
{"func": "krb5_verify_init_creds(krb5_context context, krb5_creds *creds,\n                       krb5_principal server, krb5_keytab keytab,\n                       krb5_ccache *ccache,\n                       krb5_verify_init_creds_opt *options)\n{\n    krb5_error_code ret;\n    krb5_principal *host_princs = NULL;\n    krb5_keytab defkeytab = NULL;\n    krb5_keytab_entry kte;\n    krb5_boolean have_keys = FALSE;\n    size_t i;\n\n    if (keytab == NULL) {\n        ret = krb5_kt_default(context, &defkeytab);\n        if (ret)\n            goto cleanup;\n        keytab = defkeytab;\n    }\n\n    if (server != NULL) {\n        /* Check if server exists in keytab first. */\n        ret = krb5_kt_get_entry(context, keytab, server, 0, 0, &kte);\n        if (ret)\n            goto cleanup;\n        krb5_kt_free_entry(context, &kte);\n        have_keys = TRUE;\n        ret = get_vfy_cred(context, creds, server, keytab, ccache);\n    } else {\n        /* Try using the host service principals from the keytab. */\n        if (keytab->ops->start_seq_get == NULL) {\n            ret = EINVAL;\n            goto cleanup;\n        }\n        ret = get_host_princs_from_keytab(context, keytab, &host_princs);\n        if (ret)\n            goto cleanup;\n        if (host_princs == NULL) {\n            ret = KRB5_KT_NOTFOUND;\n            goto cleanup;\n        }\n        have_keys = TRUE;\n\n        /* Try all host principals until one succeeds or they all fail. */\n        for (i = 0; host_princs[i] != NULL; i++) {\n            ret = get_vfy_cred(context, creds, host_princs[i], keytab, ccache);\n            if (ret == 0)\n                break;\n        }\n    }\n\ncleanup:\n    /* If we have no key to verify with, pretend to succeed unless\n     * configuration directs otherwise. */\n    if (!have_keys && !nofail(context, options, creds))\n        ret = 0;\n\n    if (defkeytab != NULL)\n        krb5_kt_close(context, defkeytab);\n    krb5_free_principal(context, server);\n    free_princ_list(context, host_princs);\n\n    return ret;\n}", "target": 1, "cwe": [], "message": "Don't free caller's principal in vfy_increds\n\n#7125 took out the copy of the krb5_verify_init_creds server argument\nbut left in the corresponding free, so it was freeing a caller-owned\nprincipal.  Reported by Russ Allbery.\n\nticket: 7162"}
{"func": "static char *Sys_PIDFileName( void )\n{\n\treturn va( \"%s/%s\", Sys_TempPath( ), PID_FILENAME );\n}", "target": 1, "cwe": ["CWE-59"], "message": "CVE-2012-3345"}
{"func": "const char *Sys_TempPath( void )\n{\n\tconst char *TMPDIR = getenv( \"TMPDIR\" );\n\n\tif( TMPDIR == NULL || TMPDIR[ 0 ] == '\\0' )\n\t\treturn \"/tmp\";\n\telse\n\t\treturn TMPDIR;\n}", "target": 1, "cwe": ["CWE-59"], "message": "CVE-2012-3345"}
{"func": "const char *Sys_TempPath( void )\n{\n\tstatic TCHAR path[ MAX_PATH ];\n\tDWORD length;\n\n\tlength = GetTempPath( sizeof( path ), path );\n\n\tif( length > sizeof( path ) || length == 0 )\n\t\treturn Sys_DefaultHomePath( );\n\telse\n\t\treturn path;\n}", "target": 1, "cwe": ["CWE-59"], "message": "CVE-2012-3345"}
{"func": "_vte_table_extract_numbers(GValueArray **array,\n\t\t\t   struct _vte_table_arginfo *arginfo, long increment)\n{\n\tGValue value = {0,};\n\tgssize i;\n\n\tg_value_init(&value, G_TYPE_LONG);\n\ti = 0;\n\tdo {\n\t\tlong total = 0;\n\t\tfor (; i < arginfo->length && arginfo->start[i] != ';'; i++) {\n\t\t\tgint v = g_unichar_digit_value (arginfo->start[i]);\n\t\t\ttotal *= 10;\n\t\t\ttotal += v == -1 ?  0 : v;\n\t\t}\n\t\tif (G_UNLIKELY (*array == NULL)) {\n\t\t\t*array = g_value_array_new(1);\n\t\t}\n\t\tg_value_set_long(&value, total);\n\t\tg_value_array_append(*array, &value);\n\t} while (i++ < arginfo->length);\n\tg_value_unset(&value);\n}", "target": 1, "cwe": ["CWE-119"], "message": "emulation: Limit integer arguments to 65535\n\nTo guard against malicious sequences containing excessively big numbers,\nlimit all parsed numbers to 16 bit range. Doing this here in the parsing\nroutine is a catch-all guard; this doesn't preclude enforcing\nmore stringent limits in the handlers themselves.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=676090"}
{"func": "vte_sequence_handler_multiple(VteTerminal *terminal,\n                              GValueArray *params,\n                              VteTerminalSequenceHandler handler)\n{\n        vte_sequence_handler_multiple_limited(terminal, params, handler, G_MAXLONG);\n}", "target": 1, "cwe": ["CWE-119"], "message": "emulation: Limit integer arguments to 65535\n\nTo guard against malicious sequences containing excessively big numbers,\nlimit all parsed numbers to 16 bit range. Doing this here in the parsing\nroutine is a catch-all guard; this doesn't preclude enforcing\nmore stringent limits in the handlers themselves.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=676090"}
{"func": "struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\n{\n\tstruct sk_buff *clone;\n\tstruct net_device *dev = skb->dev;\n\tstruct frag_hdr *fhdr;\n\tstruct nf_ct_frag6_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tint fhoff, nhoff;\n\tu8 prevhdr;\n\tstruct sk_buff *ret_skb = NULL;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn skb;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn skb;\n\n\tclone = skb_clone(skb, GFP_ATOMIC);\n\tif (clone == NULL) {\n\t\tpr_debug(\"Can't clone skb\\n\");\n\t\treturn skb;\n\t}\n\n\tNFCT_FRAG6_CB(clone)->orig = skb;\n\n\tif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {\n\t\tpr_debug(\"message is too short.\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tskb_set_transport_header(clone, fhoff);\n\thdr = ipv6_hdr(clone);\n\tfhdr = (struct frag_hdr *)skb_transport_header(clone);\n\n\tif (!(fhdr->frag_off & htons(0xFFF9))) {\n\t\tpr_debug(\"Invalid fragment offset\\n\");\n\t\t/* It is not a fragmented frame */\n\t\tgoto ret_orig;\n\t}\n\n\tif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)\n\t\tnf_ct_frag6_evictor();\n\n\tfq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\tgoto ret_orig;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {\n\t\tspin_unlock_bh(&fq->q.lock);\n\t\tpr_debug(\"Can't insert skb to queue\\n\");\n\t\tfq_put(fq);\n\t\tgoto ret_orig;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tret_skb = nf_ct_frag6_reasm(fq, dev);\n\t\tif (ret_skb == NULL)\n\t\t\tpr_debug(\"Can't reassemble fragmented packets\\n\");\n\t}\n\tspin_unlock_bh(&fq->q.lock);\n\n\tfq_put(fq);\n\treturn ret_skb;\n\nret_orig:\n\tkfree_skb(clone);\n\treturn skb;\n}", "target": 1, "cwe": [], "message": "netfilter: nf_conntrack_reasm: properly handle packets fragmented into a single fragment\n\nWhen an ICMPV6_PKT_TOOBIG message is received with a MTU below 1280,\nall further packets include a fragment header.\n\nUnlike regular defragmentation, conntrack also needs to \"reassemble\"\nthose fragments in order to obtain a packet without the fragment\nheader for connection tracking. Currently nf_conntrack_reasm checks\nwhether a fragment has either IP6_MF set or an offset != 0, which\nmakes it ignore those fragments.\n\nRemove the invalid check and make reassembly handle fragment queues\ncontaining only a single fragment.\n\nReported-and-tested-by: Ulrich Weber <uweber@astaro.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)\n{\n\tstruct sk_buff *fp, *op, *head = fq->q.fragments;\n\tint    payload_len;\n\n\tfq_kill(fq);\n\n\tWARN_ON(head == NULL);\n\tWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\n\n\t/* Unfragmented part is taken from the first segment. */\n\tpayload_len = ((head->data - skb_network_header(head)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN) {\n\t\tpr_debug(\"payload len is too large.\\n\");\n\t\tgoto out_oversize;\n\t}\n\n\t/* Head of list must not be cloned. */\n\tif (skb_cloned(head) && pskb_expand_head(head, 0, 0, GFP_ATOMIC)) {\n\t\tpr_debug(\"skb is cloned but can't expand head\");\n\t\tgoto out_oom;\n\t}\n\n\t/* If the first fragment is fragmented itself, we split\n\t * it to two chunks: the first with data and paged part\n\t * and the second, holding only fragments. */\n\tif (skb_has_frags(head)) {\n\t\tstruct sk_buff *clone;\n\t\tint i, plen = 0;\n\n\t\tif ((clone = alloc_skb(0, GFP_ATOMIC)) == NULL) {\n\t\t\tpr_debug(\"Can't alloc skb\\n\");\n\t\t\tgoto out_oom;\n\t\t}\n\t\tclone->next = head->next;\n\t\thead->next = clone;\n\t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n\t\tskb_frag_list_init(head);\n\t\tfor (i=0; i<skb_shinfo(head)->nr_frags; i++)\n\t\t\tplen += skb_shinfo(head)->frags[i].size;\n\t\tclone->len = clone->data_len = head->data_len - plen;\n\t\thead->data_len -= clone->len;\n\t\thead->len -= clone->len;\n\t\tclone->csum = 0;\n\t\tclone->ip_summed = head->ip_summed;\n\n\t\tNFCT_FRAG6_CB(clone)->orig = NULL;\n\t\tatomic_add(clone->truesize, &nf_init_frags.mem);\n\t}\n\n\t/* We have to remove fragment header from datagram and to relocate\n\t * header in order to calculate ICV correctly. */\n\tskb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];\n\tmemmove(head->head + sizeof(struct frag_hdr), head->head,\n\t\t(head->data - head->head) - sizeof(struct frag_hdr));\n\thead->mac_header += sizeof(struct frag_hdr);\n\thead->network_header += sizeof(struct frag_hdr);\n\n\tskb_shinfo(head)->frag_list = head->next;\n\tskb_reset_transport_header(head);\n\tskb_push(head, head->data - skb_network_header(head));\n\tatomic_sub(head->truesize, &nf_init_frags.mem);\n\n\tfor (fp=head->next; fp; fp = fp->next) {\n\t\thead->data_len += fp->len;\n\t\thead->len += fp->len;\n\t\tif (head->ip_summed != fp->ip_summed)\n\t\t\thead->ip_summed = CHECKSUM_NONE;\n\t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n\t\t\thead->csum = csum_add(head->csum, fp->csum);\n\t\thead->truesize += fp->truesize;\n\t\tatomic_sub(fp->truesize, &nf_init_frags.mem);\n\t}\n\n\thead->next = NULL;\n\thead->dev = dev;\n\thead->tstamp = fq->q.stamp;\n\tipv6_hdr(head)->payload_len = htons(payload_len);\n\n\t/* Yes, and fold redundant checksum back. 8) */\n\tif (head->ip_summed == CHECKSUM_COMPLETE)\n\t\thead->csum = csum_partial(skb_network_header(head),\n\t\t\t\t\t  skb_network_header_len(head),\n\t\t\t\t\t  head->csum);\n\n\tfq->q.fragments = NULL;\n\n\t/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */\n\tfp = skb_shinfo(head)->frag_list;\n\tif (NFCT_FRAG6_CB(fp)->orig == NULL)\n\t\t/* at above code, head skb is divided into two skbs. */\n\t\tfp = fp->next;\n\n\top = NFCT_FRAG6_CB(head)->orig;\n\tfor (; fp; fp = fp->next) {\n\t\tstruct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;\n\n\t\top->next = orig;\n\t\top = orig;\n\t\tNFCT_FRAG6_CB(fp)->orig = NULL;\n\t}\n\n\treturn head;\n\nout_oversize:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"nf_ct_frag6_reasm: no memory for reassembly\\n\");\nout_fail:\n\treturn NULL;\n}", "target": 1, "cwe": [], "message": "netfilter: nf_conntrack_reasm: properly handle packets fragmented into a single fragment\n\nWhen an ICMPV6_PKT_TOOBIG message is received with a MTU below 1280,\nall further packets include a fragment header.\n\nUnlike regular defragmentation, conntrack also needs to \"reassemble\"\nthose fragments in order to obtain a packet without the fragment\nheader for connection tracking. Currently nf_conntrack_reasm checks\nwhether a fragment has either IP6_MF set or an offset != 0, which\nmakes it ignore those fragments.\n\nRemove the invalid check and make reassembly handle fragment queues\ncontaining only a single fragment.\n\nReported-and-tested-by: Ulrich Weber <uweber@astaro.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>"}
{"func": "void security_fixup_ops(struct security_operations *ops)\n{\n\tset_to_cap_if_null(ops, ptrace_access_check);\n\tset_to_cap_if_null(ops, ptrace_traceme);\n\tset_to_cap_if_null(ops, capget);\n\tset_to_cap_if_null(ops, capset);\n\tset_to_cap_if_null(ops, acct);\n\tset_to_cap_if_null(ops, capable);\n\tset_to_cap_if_null(ops, quotactl);\n\tset_to_cap_if_null(ops, quota_on);\n\tset_to_cap_if_null(ops, sysctl);\n\tset_to_cap_if_null(ops, syslog);\n\tset_to_cap_if_null(ops, settime);\n\tset_to_cap_if_null(ops, vm_enough_memory);\n\tset_to_cap_if_null(ops, bprm_set_creds);\n\tset_to_cap_if_null(ops, bprm_committing_creds);\n\tset_to_cap_if_null(ops, bprm_committed_creds);\n\tset_to_cap_if_null(ops, bprm_check_security);\n\tset_to_cap_if_null(ops, bprm_secureexec);\n\tset_to_cap_if_null(ops, sb_alloc_security);\n\tset_to_cap_if_null(ops, sb_free_security);\n\tset_to_cap_if_null(ops, sb_copy_data);\n\tset_to_cap_if_null(ops, sb_kern_mount);\n\tset_to_cap_if_null(ops, sb_show_options);\n\tset_to_cap_if_null(ops, sb_statfs);\n\tset_to_cap_if_null(ops, sb_mount);\n\tset_to_cap_if_null(ops, sb_check_sb);\n\tset_to_cap_if_null(ops, sb_umount);\n\tset_to_cap_if_null(ops, sb_umount_close);\n\tset_to_cap_if_null(ops, sb_umount_busy);\n\tset_to_cap_if_null(ops, sb_post_remount);\n\tset_to_cap_if_null(ops, sb_post_addmount);\n\tset_to_cap_if_null(ops, sb_pivotroot);\n\tset_to_cap_if_null(ops, sb_post_pivotroot);\n\tset_to_cap_if_null(ops, sb_set_mnt_opts);\n\tset_to_cap_if_null(ops, sb_clone_mnt_opts);\n\tset_to_cap_if_null(ops, sb_parse_opts_str);\n\tset_to_cap_if_null(ops, inode_alloc_security);\n\tset_to_cap_if_null(ops, inode_free_security);\n\tset_to_cap_if_null(ops, inode_init_security);\n\tset_to_cap_if_null(ops, inode_create);\n\tset_to_cap_if_null(ops, inode_link);\n\tset_to_cap_if_null(ops, inode_unlink);\n\tset_to_cap_if_null(ops, inode_symlink);\n\tset_to_cap_if_null(ops, inode_mkdir);\n\tset_to_cap_if_null(ops, inode_rmdir);\n\tset_to_cap_if_null(ops, inode_mknod);\n\tset_to_cap_if_null(ops, inode_rename);\n\tset_to_cap_if_null(ops, inode_readlink);\n\tset_to_cap_if_null(ops, inode_follow_link);\n\tset_to_cap_if_null(ops, inode_permission);\n\tset_to_cap_if_null(ops, inode_setattr);\n\tset_to_cap_if_null(ops, inode_getattr);\n\tset_to_cap_if_null(ops, inode_delete);\n\tset_to_cap_if_null(ops, inode_setxattr);\n\tset_to_cap_if_null(ops, inode_post_setxattr);\n\tset_to_cap_if_null(ops, inode_getxattr);\n\tset_to_cap_if_null(ops, inode_listxattr);\n\tset_to_cap_if_null(ops, inode_removexattr);\n\tset_to_cap_if_null(ops, inode_need_killpriv);\n\tset_to_cap_if_null(ops, inode_killpriv);\n\tset_to_cap_if_null(ops, inode_getsecurity);\n\tset_to_cap_if_null(ops, inode_setsecurity);\n\tset_to_cap_if_null(ops, inode_listsecurity);\n\tset_to_cap_if_null(ops, inode_getsecid);\n#ifdef CONFIG_SECURITY_PATH\n\tset_to_cap_if_null(ops, path_mknod);\n\tset_to_cap_if_null(ops, path_mkdir);\n\tset_to_cap_if_null(ops, path_rmdir);\n\tset_to_cap_if_null(ops, path_unlink);\n\tset_to_cap_if_null(ops, path_symlink);\n\tset_to_cap_if_null(ops, path_link);\n\tset_to_cap_if_null(ops, path_rename);\n\tset_to_cap_if_null(ops, path_truncate);\n#endif\n\tset_to_cap_if_null(ops, file_permission);\n\tset_to_cap_if_null(ops, file_alloc_security);\n\tset_to_cap_if_null(ops, file_free_security);\n\tset_to_cap_if_null(ops, file_ioctl);\n\tset_to_cap_if_null(ops, file_mmap);\n\tset_to_cap_if_null(ops, file_mprotect);\n\tset_to_cap_if_null(ops, file_lock);\n\tset_to_cap_if_null(ops, file_fcntl);\n\tset_to_cap_if_null(ops, file_set_fowner);\n\tset_to_cap_if_null(ops, file_send_sigiotask);\n\tset_to_cap_if_null(ops, file_receive);\n\tset_to_cap_if_null(ops, dentry_open);\n\tset_to_cap_if_null(ops, task_create);\n\tset_to_cap_if_null(ops, cred_free);\n\tset_to_cap_if_null(ops, cred_prepare);\n\tset_to_cap_if_null(ops, cred_commit);\n\tset_to_cap_if_null(ops, kernel_act_as);\n\tset_to_cap_if_null(ops, kernel_create_files_as);\n\tset_to_cap_if_null(ops, kernel_module_request);\n\tset_to_cap_if_null(ops, task_setuid);\n\tset_to_cap_if_null(ops, task_fix_setuid);\n\tset_to_cap_if_null(ops, task_setgid);\n\tset_to_cap_if_null(ops, task_setpgid);\n\tset_to_cap_if_null(ops, task_getpgid);\n\tset_to_cap_if_null(ops, task_getsid);\n\tset_to_cap_if_null(ops, task_getsecid);\n\tset_to_cap_if_null(ops, task_setgroups);\n\tset_to_cap_if_null(ops, task_setnice);\n\tset_to_cap_if_null(ops, task_setioprio);\n\tset_to_cap_if_null(ops, task_getioprio);\n\tset_to_cap_if_null(ops, task_setrlimit);\n\tset_to_cap_if_null(ops, task_setscheduler);\n\tset_to_cap_if_null(ops, task_getscheduler);\n\tset_to_cap_if_null(ops, task_movememory);\n\tset_to_cap_if_null(ops, task_wait);\n\tset_to_cap_if_null(ops, task_kill);\n\tset_to_cap_if_null(ops, task_prctl);\n\tset_to_cap_if_null(ops, task_to_inode);\n\tset_to_cap_if_null(ops, ipc_permission);\n\tset_to_cap_if_null(ops, ipc_getsecid);\n\tset_to_cap_if_null(ops, msg_msg_alloc_security);\n\tset_to_cap_if_null(ops, msg_msg_free_security);\n\tset_to_cap_if_null(ops, msg_queue_alloc_security);\n\tset_to_cap_if_null(ops, msg_queue_free_security);\n\tset_to_cap_if_null(ops, msg_queue_associate);\n\tset_to_cap_if_null(ops, msg_queue_msgctl);\n\tset_to_cap_if_null(ops, msg_queue_msgsnd);\n\tset_to_cap_if_null(ops, msg_queue_msgrcv);\n\tset_to_cap_if_null(ops, shm_alloc_security);\n\tset_to_cap_if_null(ops, shm_free_security);\n\tset_to_cap_if_null(ops, shm_associate);\n\tset_to_cap_if_null(ops, shm_shmctl);\n\tset_to_cap_if_null(ops, shm_shmat);\n\tset_to_cap_if_null(ops, sem_alloc_security);\n\tset_to_cap_if_null(ops, sem_free_security);\n\tset_to_cap_if_null(ops, sem_associate);\n\tset_to_cap_if_null(ops, sem_semctl);\n\tset_to_cap_if_null(ops, sem_semop);\n\tset_to_cap_if_null(ops, netlink_send);\n\tset_to_cap_if_null(ops, netlink_recv);\n\tset_to_cap_if_null(ops, d_instantiate);\n\tset_to_cap_if_null(ops, getprocattr);\n\tset_to_cap_if_null(ops, setprocattr);\n\tset_to_cap_if_null(ops, secid_to_secctx);\n\tset_to_cap_if_null(ops, secctx_to_secid);\n\tset_to_cap_if_null(ops, release_secctx);\n#ifdef CONFIG_SECURITY_NETWORK\n\tset_to_cap_if_null(ops, unix_stream_connect);\n\tset_to_cap_if_null(ops, unix_may_send);\n\tset_to_cap_if_null(ops, socket_create);\n\tset_to_cap_if_null(ops, socket_post_create);\n\tset_to_cap_if_null(ops, socket_bind);\n\tset_to_cap_if_null(ops, socket_connect);\n\tset_to_cap_if_null(ops, socket_listen);\n\tset_to_cap_if_null(ops, socket_accept);\n\tset_to_cap_if_null(ops, socket_sendmsg);\n\tset_to_cap_if_null(ops, socket_recvmsg);\n\tset_to_cap_if_null(ops, socket_getsockname);\n\tset_to_cap_if_null(ops, socket_getpeername);\n\tset_to_cap_if_null(ops, socket_setsockopt);\n\tset_to_cap_if_null(ops, socket_getsockopt);\n\tset_to_cap_if_null(ops, socket_shutdown);\n\tset_to_cap_if_null(ops, socket_sock_rcv_skb);\n\tset_to_cap_if_null(ops, socket_getpeersec_stream);\n\tset_to_cap_if_null(ops, socket_getpeersec_dgram);\n\tset_to_cap_if_null(ops, sk_alloc_security);\n\tset_to_cap_if_null(ops, sk_free_security);\n\tset_to_cap_if_null(ops, sk_clone_security);\n\tset_to_cap_if_null(ops, sk_getsecid);\n\tset_to_cap_if_null(ops, sock_graft);\n\tset_to_cap_if_null(ops, inet_conn_request);\n\tset_to_cap_if_null(ops, inet_csk_clone);\n\tset_to_cap_if_null(ops, inet_conn_established);\n\tset_to_cap_if_null(ops, req_classify_flow);\n\tset_to_cap_if_null(ops, tun_dev_create);\n\tset_to_cap_if_null(ops, tun_dev_post_create);\n\tset_to_cap_if_null(ops, tun_dev_attach);\n#endif\t/* CONFIG_SECURITY_NETWORK */\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tset_to_cap_if_null(ops, xfrm_policy_alloc_security);\n\tset_to_cap_if_null(ops, xfrm_policy_clone_security);\n\tset_to_cap_if_null(ops, xfrm_policy_free_security);\n\tset_to_cap_if_null(ops, xfrm_policy_delete_security);\n\tset_to_cap_if_null(ops, xfrm_state_alloc_security);\n\tset_to_cap_if_null(ops, xfrm_state_free_security);\n\tset_to_cap_if_null(ops, xfrm_state_delete_security);\n\tset_to_cap_if_null(ops, xfrm_policy_lookup);\n\tset_to_cap_if_null(ops, xfrm_state_pol_flow_match);\n\tset_to_cap_if_null(ops, xfrm_decode_session);\n#endif\t/* CONFIG_SECURITY_NETWORK_XFRM */\n#ifdef CONFIG_KEYS\n\tset_to_cap_if_null(ops, key_alloc);\n\tset_to_cap_if_null(ops, key_free);\n\tset_to_cap_if_null(ops, key_permission);\n\tset_to_cap_if_null(ops, key_getsecurity);\n#endif\t/* CONFIG_KEYS */\n#ifdef CONFIG_AUDIT\n\tset_to_cap_if_null(ops, audit_rule_init);\n\tset_to_cap_if_null(ops, audit_rule_known);\n\tset_to_cap_if_null(ops, audit_rule_match);\n\tset_to_cap_if_null(ops, audit_rule_free);\n#endif\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, void *unused,\n\t__u32 thread_info_flags)\n{\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(struct pt_regs *regs)\n{\n\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\ttracehook_notify_resume(regs);\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)\n{\n\t/* Pending single-step? */\n\tif (thread_info_flags & _TIF_SINGLESTEP) {\n#ifndef CONFIG_MN10300_USING_JTAG\n\t\tregs->epsw |= EPSW_T;\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n#else\n\t\tBUG(); /* no h/w single-step if using JTAG unit */\n#endif\n\t}\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(struct pt_regs *regs, sigset_t *oldset,\n\t\t      __u32 thread_info_flags)\n{\n\t/* Pending single-step? */\n\tif (thread_info_flags & _TIF_SINGLESTEP)\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs,oldset);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n\n\tclear_thread_flag(TIF_IRET);\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(struct pt_regs *regs, long in_syscall)\n{\n\tif (test_thread_flag(TIF_SIGPENDING) ||\n\t    test_thread_flag(TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, in_syscall);\n\n\tif (test_thread_flag(TIF_NOTIFY_RESUME)) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int save_r0,\n\t\t\t\t unsigned long thread_info_flags)\n{\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs, save_r0);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(struct pt_regs *regs, unsigned long orig_i0, unsigned long thread_info_flags)\n{\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs, orig_i0);\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "do_notify_resume(struct pt_regs *regs, struct switch_stack *sw,\n\t\t unsigned long thread_info_flags,\n\t\t unsigned long r0, unsigned long r19)\n{\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, sw, r0, r19);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(__u32 thread_info_flags)\n{\n\t/* pending single-step? */\n\tif (thread_info_flags & _TIF_SINGLESTEP)\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal();\n\n\t/* deal with notification on about to resume userspace execution */\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n\n} /* end do_notify_resume() */", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)\n{\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, NULL);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, struct thread_info *ti)\n{\n\tint syscall = 0;\n\n\tif ((sysreg_read(SR) & MODE_MASK) == MODE_SUPERVISOR)\n\t\tsyscall = 1;\n\n\tif (ti->flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, &current->blocked, syscall);\n\n\tif (ti->flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "do_notify_resume_user(sigset_t *unused, struct sigscratch *scr, long in_syscall)\n{\n\tif (fsys_mode(current, &scr->pt)) {\n\t\t/*\n\t\t * defer signal-handling etc. until we return to\n\t\t * privilege-level 0.\n\t\t */\n\t\tif (!ia64_psr(&scr->pt)->lp)\n\t\t\tia64_psr(&scr->pt)->lp = 1;\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PERFMON\n\tif (current->thread.pfm_needs_checking)\n\t\t/*\n\t\t * Note: pfm_handle_work() allow us to call it with interrupts\n\t\t * disabled, and may enable interrupts within the function.\n\t\t */\n\t\tpfm_handle_work();\n#endif\n\n\t/* deal with pending signal delivery */\n\tif (test_thread_flag(TIF_SIGPENDING)) {\n\t\tlocal_irq_enable();\t/* force interrupt enable */\n\t\tia64_do_signal(scr, in_syscall);\n\t}\n\n\tif (test_thread_flag(TIF_NOTIFY_RESUME)) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(&scr->pt);\n\t}\n\n\t/* copy user rbs to kernel rbs */\n\tif (unlikely(test_thread_flag(TIF_RESTORE_RSE))) {\n\t\tlocal_irq_enable();\t/* force interrupt enable */\n\t\tia64_sync_krbs();\n\t}\n\n\tlocal_irq_disable();\t/* force interrupt disable */\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "SYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n} /* end sys_keyctl() */", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "do_notify_resume(struct pt_regs *regs, unsigned int thread_flags, int syscall)\n{\n\tif (thread_flags & _TIF_SIGPENDING)\n\t\tdo_signal(&current->blocked, regs, syscall);\n\n\tif (thread_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "do_notify_resume(struct pt_regs *regs, void *unused, __u32 thread_info_flags)\n{\n#ifdef CONFIG_X86_NEW_MCE\n\t/* notify userspace of pending MCEs */\n\tif (thread_info_flags & _TIF_MCE_NOTIFY)\n\t\tmce_notify_process();\n#endif /* CONFIG_X86_64 && CONFIG_X86_MCE */\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n\n#ifdef CONFIG_X86_32\n\tclear_thread_flag(TIF_IRET);\n#endif /* CONFIG_X86_32 */\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage long compat_sys_keyctl(u32 option,\n\t\t\t\t  u32 arg2, u32 arg3, u32 arg4, u32 arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID(arg2, arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring(compat_ptr(arg2));\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key(arg2, compat_ptr(arg3), arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key(arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key(arg2, compat_ptr(arg3), arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear(arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link(arg2, arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink(arg2, arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search(arg2, compat_ptr(arg3),\n\t\t\t\t\t     compat_ptr(arg4), arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key(arg2, compat_ptr(arg3), arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key(arg2, arg3, arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key(arg2, arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key(arg2, compat_ptr(arg3), arg4,\n\t\t\t\t\t      arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key(arg2, arg3, arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout(arg2, arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority(arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security(arg2, compat_ptr(arg3), arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n} /* end compat_sys_keyctl() */", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(struct pt_regs *regs, unsigned long orig_i0,\n\t\t      unsigned long thread_info_flags)\n{\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs, orig_i0);\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(regs, 0);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "void do_notify_resume(int canrestart, struct pt_regs *regs,\n\t\t      __u32 thread_info_flags)\n{\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & _TIF_SIGPENDING)\n\t\tdo_signal(canrestart,regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t}\n}", "target": 1, "cwe": [], "message": "KEYS: Add a keyctl to install a process's session keyring on its parent [try #6]\n\nAdd a keyctl to install a process's session keyring onto its parent.  This\nreplaces the parent's session keyring.  Because the COW credential code does\nnot permit one process to change another process's credentials directly, the\nchange is deferred until userspace next starts executing again.  Normally this\nwill be after a wait*() syscall.\n\nTo support this, three new security hooks have been provided:\ncred_alloc_blank() to allocate unset security creds, cred_transfer() to fill in\nthe blank security creds and key_session_to_parent() - which asks the LSM if\nthe process may replace its parent's session keyring.\n\nThe replacement may only happen if the process has the same ownership details\nas its parent, and the process has LINK permission on the session keyring, and\nthe session keyring is owned by the process, and the LSM permits it.\n\nNote that this requires alteration to each architecture's notify_resume path.\nThis has been done for all arches barring blackfin, m68k* and xtensa, all of\nwhich need assembly alteration to support TIF_NOTIFY_RESUME.  This allows the\nreplacement to be performed at the point the parent process resumes userspace\nexecution.\n\nThis allows the userspace AFS pioctl emulation to fully emulate newpag() and\nthe VIOCSETTOK and VIOCSETTOK2 pioctls, all of which require the ability to\nalter the parent process's PAG membership.  However, since kAFS doesn't use\nPAGs per se, but rather dumps the keys into the session keyring, the session\nkeyring of the parent must be replaced if, for example, VIOCSETTOK is passed\nthe newpag flag.\n\nThis can be tested with the following program:\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <keyutils.h>\n\n\t#define KEYCTL_SESSION_TO_PARENT\t18\n\n\t#define OSERROR(X, S) do { if ((long)(X) == -1) { perror(S); exit(1); } } while(0)\n\n\tint main(int argc, char **argv)\n\t{\n\t\tkey_serial_t keyring, key;\n\t\tlong ret;\n\n\t\tkeyring = keyctl_join_session_keyring(argv[1]);\n\t\tOSERROR(keyring, \"keyctl_join_session_keyring\");\n\n\t\tkey = add_key(\"user\", \"a\", \"b\", 1, keyring);\n\t\tOSERROR(key, \"add_key\");\n\n\t\tret = keyctl(KEYCTL_SESSION_TO_PARENT);\n\t\tOSERROR(ret, \"KEYCTL_SESSION_TO_PARENT\");\n\n\t\treturn 0;\n\t}\n\nCompiled and linked with -lkeyutils, you should see something like:\n\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t355907932 --alswrv   4043    -1   \\_ keyring: _uid.4043\n\t[dhowells@andromeda ~]$ /tmp/newpag\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: _ses\n\t1055658746 --alswrv   4043  4043   \\_ user: a\n\t[dhowells@andromeda ~]$ /tmp/newpag hello\n\t[dhowells@andromeda ~]$ keyctl show\n\tSession Keyring\n\t       -3 --alswrv   4043  4043  keyring: hello\n\t340417692 --alswrv   4043  4043   \\_ user: a\n\nWhere the test program creates a new session keyring, sticks a user key named\n'a' into it and then installs it on its parent.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <jmorris@namei.org>"}
{"func": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119"], "message": "cred: copy_process() should clear child->replacement_session_keyring\n\nkeyctl_session_to_parent(task) sets ->replacement_session_keyring,\nit should be processed and cleared by key_replace_session_keyring().\n\nHowever, this task can fork before it notices TIF_NOTIFY_RESUME and\nthe new child gets the bogus ->replacement_session_keyring copied by\ndup_task_struct(). This is obviously wrong and, if nothing else, this\nleads to put_cred(already_freed_cred).\n\nchange copy_creds() to clear this member. If copy_process() fails\nbefore this point the wrong ->replacement_session_keyring doesn't\nmatter, exit_creds() won't be called.\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\"fits_decode_header: Not enough memory\", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \"SIMPLE  \", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \"XTENSION\", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \"XTENSION\"), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \"NAXIS\", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \"BITPIX\", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \"fits_decode_header: Invalid BITPIX-value\");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \"GCOUNT\", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \"PCOUNT\", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"GROUPS\", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \"EXTEND\", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \"fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \"NAXIS%-3d\", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \"fits_decode_header: Negative value in NAXISn\");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \"fits_decode_header: Random groups with NAXIS1 != 0\");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \"fits_decode_card: Not enough NAXISn-cards\");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \"BLANK\", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \"DATAMIN\", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"DATAMAX\", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \"BZERO\", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \"BSCALE\", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \"IMAGE\", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \"fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \"fits_decode_header: missing/invalid %s card\", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}", "target": 1, "cwe": ["CWE-476"], "message": "Bug 676804 - file handling DoS for fit file format\n\nApply patch from joe@reactionis.co.uk which fixes a buffer overflow on\nbroken/malicious fits files."}
{"func": "xmlParserEntityCheck(xmlParserCtxtPtr ctxt, unsigned long size,\n                     xmlEntityPtr ent)\n{\n    unsigned long consumed = 0;\n\n    if ((ctxt == NULL) || (ctxt->options & XML_PARSE_HUGE))\n        return (0);\n    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n        return (1);\n    if (size != 0) {\n        /*\n         * Do the check based on the replacement size of the entity\n         */\n        if (size < XML_PARSER_BIG_ENTITY)\n\t    return(0);\n\n        /*\n         * A limit on the amount of text data reasonably used\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        if ((size < XML_PARSER_NON_LINEAR * consumed) &&\n\t    (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n            return (0);\n    } else if (ent != NULL) {\n        /*\n         * use the number of parsed entities in the replacement\n         */\n        size = ent->checked;\n\n        /*\n         * The amount of data parsed counting entities size only once\n         */\n        if (ctxt->input != NULL) {\n            consumed = ctxt->input->consumed +\n                (ctxt->input->cur - ctxt->input->base);\n        }\n        consumed += ctxt->sizeentities;\n\n        /*\n         * Check the density of entities for the amount of data\n\t * knowing an entity reference will take at least 3 bytes\n         */\n        if (size * 3 < consumed * XML_PARSER_NON_LINEAR)\n            return (0);\n    } else {\n        /*\n         * strange we got no data for checking just return\n         */\n        return (0);\n    }\n\n    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n    return (1);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix parser local buffers size problems"}
{"func": "xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    int buffer_size = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n    int nbchars = 0;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {\n\t\t    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    xmlLoadEntityContent(ctxt, ent);\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t      growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix parser local buffers size problems"}
{"func": "xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n    xmlChar limit = 0;\n    xmlChar *buf = NULL;\n    xmlChar *rep = NULL;\n    int len = 0;\n    int buf_size = 0;\n    int c, l, in_space = 0;\n    xmlChar *current = NULL;\n    xmlEntityPtr ent;\n\n    if (NXT(0) == '\"') {\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\tlimit = '\"';\n        NEXT;\n    } else if (NXT(0) == '\\'') {\n\tlimit = '\\'';\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n        NEXT;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buf_size = XML_PARSER_BUFFER_SIZE;\n    buf = (xmlChar *) xmlMallocAtomic(buf_size * sizeof(xmlChar));\n    if (buf == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     */\n    c = CUR_CHAR(l);\n    while ((NXT(0) != limit) && /* checked */\n           (IS_CHAR(c)) && (c != '<')) {\n\tif (c == 0) break;\n\tif (c == '&') {\n\t    in_space = 0;\n\t    if (NXT(1) == '#') {\n\t\tint val = xmlParseCharRef(ctxt);\n\n\t\tif (val == '&') {\n\t\t    if (ctxt->replaceEntities) {\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t    } else {\n\t\t\t/*\n\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n\t\t\t * called by the attribute() function in SAX.c\n\t\t\t */\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    }\n\t\t} else if (val != 0) {\n\t\t    if (len > buf_size - 10) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    len += xmlCopyChar(0, &buf[len], val);\n\t\t}\n\t    } else {\n\t\tent = xmlParseEntityRef(ctxt);\n\t\tctxt->nbentities++;\n\t\tif (ent != NULL)\n\t\t    ctxt->nbentities += ent->owner;\n\t\tif ((ent != NULL) &&\n\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\t    if (len > buf_size - 10) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    if ((ctxt->replaceEntities == 0) &&\n\t\t        (ent->content[0] == '&')) {\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    } else {\n\t\t\tbuf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if ((ent != NULL) && \n\t\t           (ctxt->replaceEntities != 0)) {\n\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n\t\t\t\t\t\t      0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    current = rep;\n\t\t\t    while (*current != 0) { /* non input consuming */\n                                if ((*current == 0xD) || (*current == 0xA) ||\n                                    (*current == 0x9)) {\n                                    buf[len++] = 0x20;\n                                    current++;\n                                } else\n                                    buf[len++] = *current++;\n\t\t\t\tif (len > buf_size - 10) {\n\t\t\t\t    growBuffer(buf, 10);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tif (ent->content != NULL)\n\t\t\t    buf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if (ent != NULL) {\n\t\t    int i = xmlStrlen(ent->name);\n\t\t    const xmlChar *cur = ent->name;\n\n\t\t    /*\n\t\t     * This may look absurd but is needed to detect\n\t\t     * entities problems\n\t\t     */\n\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t\t\t(ent->content != NULL)) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Just output the reference\n\t\t     */\n\t\t    buf[len++] = '&';\n\t\t    while (len > buf_size - i - 10) {\n\t\t\tgrowBuffer(buf, i + 10);\n\t\t    }\n\t\t    for (;i > 0;i--)\n\t\t\tbuf[len++] = *cur++;\n\t\t    buf[len++] = ';';\n\t\t}\n\t    }\n\t} else {\n\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n\t        if ((len != 0) || (!normalize)) {\n\t\t    if ((!normalize) || (!in_space)) {\n\t\t\tCOPY_BUF(l,buf,len,0x20);\n\t\t\twhile (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t    }\n\t\t    in_space = 1;\n\t\t}\n\t    } else {\n\t        in_space = 0;\n\t\tCOPY_BUF(l,buf,len,c);\n\t\tif (len > buf_size - 10) {\n\t\t    growBuffer(buf, 10);\n\t\t}\n\t    }\n\t    NEXTL(l);\n\t}\n\tGROW;\n\tc = CUR_CHAR(l);\n    }\n    if ((in_space) && (normalize)) {\n        while (buf[len - 1] == 0x20) len--;\n    }\n    buf[len] = 0;\n    if (RAW == '<') {\n\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n    } else if (RAW != limit) {\n\tif ((c != 0) && (!IS_CHAR(c))) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n\t\t\t   \"invalid character in attribute value\\n\");\n\t} else {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n\t\t\t   \"AttValue: ' expected\\n\");\n        }\n    } else\n\tNEXT;\n    if (attlen != NULL) *attlen = len;\n    return(buf);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\n    if (buf != NULL)\n        xmlFree(buf);\n    if (rep != NULL)\n        xmlFree(rep);\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix parser local buffers size problems"}
{"func": "xmlEncodeSpecialChars(xmlDocPtr doc ATTRIBUTE_UNUSED, const xmlChar *input) {\n    const xmlChar *cur = input;\n    xmlChar *buffer = NULL;\n    xmlChar *out = NULL;\n    int buffer_size = 0;\n    if (input == NULL) return(NULL);\n\n    /*\n     * allocate an translation buffer.\n     */\n    buffer_size = 1000;\n    buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) {\n        xmlEntitiesErrMemory(\"xmlEncodeSpecialChars: malloc failed\");\n\treturn(NULL);\n    }\n    out = buffer;\n\n    while (*cur != '\\0') {\n        if (out - buffer > buffer_size - 10) {\n\t    int indx = out - buffer;\n\n\t    growBufferReentrant();\n\t    out = &buffer[indx];\n\t}\n\n\t/*\n\t * By default one have to encode at least '<', '>', '\"' and '&' !\n\t */\n\tif (*cur == '<') {\n\t    *out++ = '&';\n\t    *out++ = 'l';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '>') {\n\t    *out++ = '&';\n\t    *out++ = 'g';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '&') {\n\t    *out++ = '&';\n\t    *out++ = 'a';\n\t    *out++ = 'm';\n\t    *out++ = 'p';\n\t    *out++ = ';';\n\t} else if (*cur == '\"') {\n\t    *out++ = '&';\n\t    *out++ = 'q';\n\t    *out++ = 'u';\n\t    *out++ = 'o';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '\\r') {\n\t    *out++ = '&';\n\t    *out++ = '#';\n\t    *out++ = '1';\n\t    *out++ = '3';\n\t    *out++ = ';';\n\t} else {\n\t    /*\n\t     * Works because on UTF-8, all extended sequences cannot\n\t     * result in bytes in the ASCII range.\n\t     */\n\t    *out++ = *cur;\n\t}\n\tcur++;\n    }\n    *out = 0;\n    return(buffer);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix entities local buffers size problems"}
{"func": "xmlEncodeEntitiesReentrant(xmlDocPtr doc, const xmlChar *input) {\n    const xmlChar *cur = input;\n    xmlChar *buffer = NULL;\n    xmlChar *out = NULL;\n    int buffer_size = 0;\n    int html = 0;\n\n    if (input == NULL) return(NULL);\n    if (doc != NULL)\n        html = (doc->type == XML_HTML_DOCUMENT_NODE);\n\n    /*\n     * allocate an translation buffer.\n     */\n    buffer_size = 1000;\n    buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) {\n        xmlEntitiesErrMemory(\"xmlEncodeEntitiesReentrant: malloc failed\");\n\treturn(NULL);\n    }\n    out = buffer;\n\n    while (*cur != '\\0') {\n        if (out - buffer > buffer_size - 100) {\n\t    int indx = out - buffer;\n\n\t    growBufferReentrant();\n\t    out = &buffer[indx];\n\t}\n\n\t/*\n\t * By default one have to encode at least '<', '>', '\"' and '&' !\n\t */\n\tif (*cur == '<') {\n\t    *out++ = '&';\n\t    *out++ = 'l';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '>') {\n\t    *out++ = '&';\n\t    *out++ = 'g';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '&') {\n\t    *out++ = '&';\n\t    *out++ = 'a';\n\t    *out++ = 'm';\n\t    *out++ = 'p';\n\t    *out++ = ';';\n\t} else if (((*cur >= 0x20) && (*cur < 0x80)) ||\n\t    (*cur == '\\n') || (*cur == '\\t') || ((html) && (*cur == '\\r'))) {\n\t    /*\n\t     * default case, just copy !\n\t     */\n\t    *out++ = *cur;\n\t} else if (*cur >= 0x80) {\n\t    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {\n\t\t/*\n\t\t * Bjrn Reese <br@sseusa.com> provided the patch\n\t        xmlChar xc;\n\t        xc = (*cur & 0x3F) << 6;\n\t        if (cur[1] != 0) {\n\t\t    xc += *(++cur) & 0x3F;\n\t\t    *out++ = xc;\n\t        } else\n\t\t */\n\t\t*out++ = *cur;\n\t    } else {\n\t\t/*\n\t\t * We assume we have UTF-8 input.\n\t\t */\n\t\tchar buf[11], *ptr;\n\t\tint val = 0, l = 1;\n\n\t\tif (*cur < 0xC0) {\n\t\t    xmlEntitiesErr(XML_CHECK_NOT_UTF8,\n\t\t\t    \"xmlEncodeEntitiesReentrant : input not UTF-8\");\n\t\t    if (doc != NULL)\n\t\t\tdoc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n\t\t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n\t\t    buf[sizeof(buf) - 1] = 0;\n\t\t    ptr = buf;\n\t\t    while (*ptr != 0) *out++ = *ptr++;\n\t\t    cur++;\n\t\t    continue;\n\t\t} else if (*cur < 0xE0) {\n                    val = (cur[0]) & 0x1F;\n\t\t    val <<= 6;\n\t\t    val |= (cur[1]) & 0x3F;\n\t\t    l = 2;\n\t\t} else if (*cur < 0xF0) {\n                    val = (cur[0]) & 0x0F;\n\t\t    val <<= 6;\n\t\t    val |= (cur[1]) & 0x3F;\n\t\t    val <<= 6;\n\t\t    val |= (cur[2]) & 0x3F;\n\t\t    l = 3;\n\t\t} else if (*cur < 0xF8) {\n                    val = (cur[0]) & 0x07;\n\t\t    val <<= 6;\n\t\t    val |= (cur[1]) & 0x3F;\n\t\t    val <<= 6;\n\t\t    val |= (cur[2]) & 0x3F;\n\t\t    val <<= 6;\n\t\t    val |= (cur[3]) & 0x3F;\n\t\t    l = 4;\n\t\t}\n\t\tif ((l == 1) || (!IS_CHAR(val))) {\n\t\t    xmlEntitiesErr(XML_ERR_INVALID_CHAR,\n\t\t\t\"xmlEncodeEntitiesReentrant : char out of range\\n\");\n\t\t    if (doc != NULL)\n\t\t\tdoc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n\t\t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n\t\t    buf[sizeof(buf) - 1] = 0;\n\t\t    ptr = buf;\n\t\t    while (*ptr != 0) *out++ = *ptr++;\n\t\t    cur++;\n\t\t    continue;\n\t\t}\n\t\t/*\n\t\t * We could do multiple things here. Just save as a char ref\n\t\t */\n\t\tsnprintf(buf, sizeof(buf), \"&#x%X;\", val);\n\t\tbuf[sizeof(buf) - 1] = 0;\n\t\tptr = buf;\n\t\twhile (*ptr != 0) *out++ = *ptr++;\n\t\tcur += l;\n\t\tcontinue;\n\t    }\n\t} else if (IS_BYTE_CHAR(*cur)) {\n\t    char buf[11], *ptr;\n\n\t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n\t    buf[sizeof(buf) - 1] = 0;\n            ptr = buf;\n\t    while (*ptr != 0) *out++ = *ptr++;\n\t}\n\tcur++;\n    }\n    *out = 0;\n    return(buffer);\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix entities local buffers size problems"}
{"func": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths.\n\t *\n\t * We hold epmutex across the loop check and the insert in this case, in\n\t * order to prevent two separate inserts from racing and each doing the\n\t * insert \"at the same time\" such that ep_loop_check passes on both\n\t * before either one does the insert, thereby creating a cycle.\n\t */\n\tif (unlikely(is_file_epoll(tfile) && op == EPOLL_CTL_ADD)) {\n\t\tmutex_lock(&epmutex);\n\t\tdid_lock_epmutex = 1;\n\t\terror = -ELOOP;\n\t\tif (ep_loop_check(ep, tfile) != 0)\n\t\t\tgoto error_tgt_fput;\n\t}\n\n\n\tmutex_lock_nested(&ep->mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (unlikely(did_lock_epmutex))\n\t\tmutex_unlock(&epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "SYSCALL_DEFINE1(epoll_create1, int, flags)\n{\n\tint error;\n\tstruct eventpoll *ep = NULL;\n\n\t/* Check the EPOLL_* constant for consistency.  */\n\tBUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);\n\n\tif (flags & ~EPOLL_CLOEXEC)\n\t\treturn -EINVAL;\n\t/*\n\t * Create the internal data structure (\"struct eventpoll\").\n\t */\n\terror = ep_alloc(&ep);\n\tif (error < 0)\n\t\treturn error;\n\t/*\n\t * Creates all the items needed to setup an eventpoll file. That is,\n\t * a file structure and a free file descriptor.\n\t */\n\terror = anon_inode_getfd(\"[eventpoll]\", &eventpoll_fops, ep,\n\t\t\t\t O_RDWR | (flags & O_CLOEXEC));\n\tif (error < 0)\n\t\tep_free(ep);\n\n\treturn error;\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline void eventpoll_init_file(struct file *file) {}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ep_loop_check(struct eventpoll *ep, struct file *file)\n{\n\treturn ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t      ep_loop_check_proc, file, ep, current);\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n\t\t     struct file *tfile, int fd)\n{\n\tint error, revents, pwake = 0;\n\tunsigned long flags;\n\tlong user_watches;\n\tstruct epitem *epi;\n\tstruct ep_pqueue epq;\n\n\tuser_watches = atomic_long_read(&ep->user->epoll_watches);\n\tif (unlikely(user_watches >= max_user_watches))\n\t\treturn -ENOSPC;\n\tif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* Item initialization follow here ... */\n\tINIT_LIST_HEAD(&epi->rdllink);\n\tINIT_LIST_HEAD(&epi->fllink);\n\tINIT_LIST_HEAD(&epi->pwqlist);\n\tepi->ep = ep;\n\tep_set_ffd(&epi->ffd, tfile, fd);\n\tepi->event = *event;\n\tepi->nwait = 0;\n\tepi->next = EP_UNACTIVE_PTR;\n\n\t/* Initialize the poll table using the queue callback */\n\tepq.epi = epi;\n\tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n\n\t/*\n\t * Attach the item to the poll hooks and get current event bits.\n\t * We can safely use the file* here because its usage count has\n\t * been increased by the caller of this function. Note that after\n\t * this operation completes, the poll callback can start hitting\n\t * the new item.\n\t */\n\trevents = tfile->f_op->poll(tfile, &epq.pt);\n\n\t/*\n\t * We have to check if something went wrong during the poll wait queue\n\t * install process. Namely an allocation for a wait queue failed due\n\t * high memory pressure.\n\t */\n\terror = -ENOMEM;\n\tif (epi->nwait < 0)\n\t\tgoto error_unregister;\n\n\t/* Add the current item to the list of active epoll hook for this file */\n\tspin_lock(&tfile->f_lock);\n\tlist_add_tail(&epi->fllink, &tfile->f_ep_links);\n\tspin_unlock(&tfile->f_lock);\n\n\t/*\n\t * Add the current item to the RB tree. All RB tree operations are\n\t * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n\t */\n\tep_rbtree_insert(ep, epi);\n\n\t/* We have to drop the new item inside our item list to keep track of it */\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/* If the file is already \"ready\" we drop it inside the ready list */\n\tif ((revents & event->events) && !ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\n\t\t/* Notify waiting tasks that events are available */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tatomic_long_inc(&ep->user->epoll_watches);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n\nerror_unregister:\n\tep_unregister_pollwait(ep, epi);\n\n\t/*\n\t * We need to do this because an event could have been arrived on some\n\t * allocated wait queue. Note that we don't care about the ep->ovflist\n\t * list, since that is used/cleaned only inside a section bound by \"mtx\".\n\t * And ep_insert() is called with \"mtx\" held.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tkmem_cache_free(epi_cache, epi);\n\n\treturn error;\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static inline void eventpoll_init_file(struct file *file)\n{\n\tINIT_LIST_HEAD(&file->f_ep_links);\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\t       ep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\t       epi->ffd.file->private_data, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}", "target": 1, "cwe": [], "message": "epoll: limit paths\n\nThe current epoll code can be tickled to run basically indefinitely in\nboth loop detection path check (on ep_insert()), and in the wakeup paths.\nThe programs that tickle this behavior set up deeply linked networks of\nepoll file descriptors that cause the epoll algorithms to traverse them\nindefinitely.  A couple of these sample programs have been previously\nposted in this thread: https://lkml.org/lkml/2011/2/25/297.\n\nTo fix the loop detection path check algorithms, I simply keep track of\nthe epoll nodes that have been already visited.  Thus, the loop detection\nbecomes proportional to the number of epoll file descriptor and links.\nThis dramatically decreases the run-time of the loop check algorithm.  In\none diabolical case I tried it reduced the run-time from 15 mintues (all\nin kernel time) to .3 seconds.\n\nFixing the wakeup paths could be done at wakeup time in a similar manner\nby keeping track of nodes that have already been visited, but the\ncomplexity is harder, since there can be multiple wakeups on different\ncpus...Thus, I've opted to limit the number of possible wakeup paths when\nthe paths are created.\n\nThis is accomplished, by noting that the end file descriptor points that\nare found during the loop detection pass (from the newly added link), are\nactually the sources for wakeup events.  I keep a list of these file\ndescriptors and limit the number and length of these paths that emanate\nfrom these 'source file descriptors'.  In the current implemetation I\nallow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of\nlength 4 and 10 of length 5.  Note that it is sufficient to check the\n'source file descriptors' reachable from the newly added link, since no\nother 'source file descriptors' will have newly added links.  This allows\nus to check only the wakeup paths that may have gotten too long, and not\nre-check all possible wakeup paths on the system.\n\nIn terms of the path limit selection, I think its first worth noting that\nthe most common case for epoll, is probably the model where you have 1\nepoll file descriptor that is monitoring n number of 'source file\ndescriptors'.  In this case, each 'source file descriptor' has a 1 path of\nlength 1.  Thus, I believe that the limits I'm proposing are quite\nreasonable and in fact may be too generous.  Thus, I'm hoping that the\nproposed limits will not prevent any workloads that currently work to\nfail.\n\nIn terms of locking, I have extended the use of the 'epmutex' to all\nepoll_ctl add and remove operations.  Currently its only used in a subset\nof the add paths.  I need to hold the epmutex, so that we can correctly\ntraverse a coherent graph, to check the number of paths.  I believe that\nthis additional locking is probably ok, since its in the setup/teardown\npaths, and doesn't affect the running paths, but it certainly is going to\nadd some extra overhead.  Also, worth noting is that the epmuex was\nrecently added to the ep_ctl add operations in the initial path loop\ndetection code using the argument that it was not on a critical path.\n\nAnother thing to note here, is the length of epoll chains that is allowed.\nCurrently, eventpoll.c defines:\n\n/* Maximum number of nesting allowed inside epoll sets */\n#define EP_MAX_NESTS 4\n\nThis basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS\n+ 1).  However, this limit is currently only enforced during the loop\ncheck detection code, and only when the epoll file descriptors are added\nin a certain order.  Thus, this limit is currently easily bypassed.  The\nnewly added check for wakeup paths, stricly limits the wakeup paths to a\nlength of 5, regardless of the order in which ep's are linked together.\nThus, a side-effect of the new code is a more consistent enforcement of\nthe graph depth.\n\nThus far, I've tested this, using the sample programs previously\nmentioned, which now either return quickly or return -EINVAL.  I've also\ntesting using the piptest.c epoll tester, which showed no difference in\nperformance.  I've also created a number of different epoll networks and\ntested that they behave as expectded.\n\nI believe this solves the original diabolical test cases, while still\npreserving the sane epoll nesting.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nCc: Nelson Elhage <nelhage@ksplice.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We need to hold the epmutex across both ep_insert and ep_remove\n\t * b/c we want to make sure we are looking at a coherent view of\n\t * epoll network.\n\t */\n\tif (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {\n\t\tmutex_lock(&epmutex);\n\t\tdid_lock_epmutex = 1;\n\t}\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (is_file_epoll(tfile)) {\n\t\t\terror = -ELOOP;\n\t\t\tif (ep_loop_check(ep, tfile) != 0)\n\t\t\t\tgoto error_tgt_fput;\n\t\t} else\n\t\t\tlist_add(&tfile->f_tfile_llink, &tfile_check_list);\n\t}\n\n\tmutex_lock_nested(&ep->mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (did_lock_epmutex)\n\t\tmutex_unlock(&epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}", "target": 1, "cwe": [], "message": "epoll: clear the tfile_check_list on -ELOOP\n\nAn epoll_ctl(,EPOLL_CTL_ADD,,) operation can return '-ELOOP' to prevent\ncircular epoll dependencies from being created.  However, in that case we\ndo not properly clear the 'tfile_check_list'.  Thus, add a call to\nclear_tfile_check_list() for the -ELOOP case.\n\nSigned-off-by: Jason Baron <jbaron@redhat.com>\nReported-by: Yurij M. Plotnikov <Yurij.Plotnikov@oktetlabs.ru>\nCc: Nelson Elhage <nelhage@nelhage.com>\nCc: Davide Libenzi <davidel@xmailserver.org>\nTested-by: Alexandra N. Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "register_application (SpiBridge * app)\n{\n  DBusMessage *message;\n  DBusMessageIter iter;\n  DBusError error;\n  DBusPendingCall *pending;\n  const int max_addr_length = 128; /* should be long enough */\n\n  dbus_error_init (&error);\n\n  /* These will be overridden when we get a reply, but in practice these\n     defaults should always be correct */\n  app->desktop_name = ATSPI_DBUS_NAME_REGISTRY;\n  app->desktop_path = ATSPI_DBUS_PATH_ROOT;\n\n  message = dbus_message_new_method_call (SPI_DBUS_NAME_REGISTRY,\n                                          ATSPI_DBUS_PATH_ROOT,\n                                          ATSPI_DBUS_INTERFACE_SOCKET,\n                                          \"Embed\");\n\n  dbus_message_iter_init_append (message, &iter);\n  spi_object_append_reference (&iter, app->root);\n  \n    if (!dbus_connection_send_with_reply (app->bus, message, &pending, -1)\n        || !pending)\n    {\n        return FALSE;\n    }\n\n    dbus_pending_call_set_notify (pending, register_reply, app, NULL);\n\n  if (message)\n    dbus_message_unref (message);\n\n  /* could this be better, we accept some amount of race in getting the temp name*/\n  /* make sure the directory exists */\n  mkdir (\"/tmp/at-spi2/\", S_IRWXU|S_IRWXG|S_IRWXO|S_ISVTX);\n  chmod (\"/tmp/at-spi2/\", S_IRWXU|S_IRWXG|S_IRWXO|S_ISVTX);\n  app->app_bus_addr = g_malloc(max_addr_length * sizeof(char));\n#ifndef DISABLE_P2P\n  sprintf (app->app_bus_addr, \"unix:path=/tmp/at-spi2/socket-%d-%d\", getpid(),\n           rand());\n#else\n  app->app_bus_addr [0] = '\\0';\n#endif\n\n  return TRUE;\n}", "target": 1, "cwe": [], "message": "Use XDG_RUNTIME_DIR to hold sockets, and do not make a world-writable dir\n\nIf we use XDG_RUNTIME_DIR, then the directory should be owned by the\nappropriate user, so it should not need to be world-writable. Hopefully this\nwon't break accessibility for administrative apps on some distro.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=678348"}
{"func": "setup_bus (void)\n{\n#ifndef DISABLE_P2P\n  DBusServer *server;\n  DBusError err;\n\n  dbus_error_init(&err);\n  server = dbus_server_listen(spi_global_app_data->app_bus_addr, &err);\n  if (server == NULL)\n  {\n    g_warning (\"atk-bridge: Couldn't listen on dbus server: %s\", err.message);\n    dbus_error_init (&err);\n    spi_global_app_data->app_bus_addr [0] = '\\0';\n    g_main_context_unref (spi_global_app_data->main_context);\n    spi_global_app_data->main_context = NULL;\n    return -1;\n  }\n\n  atspi_dbus_server_setup_with_g_main(server, NULL);\n  dbus_server_set_new_connection_function(server, new_connection_cb, NULL, NULL);\n\n  spi_global_app_data->server = server;\n#endif\n\n  return 0;\n}", "target": 1, "cwe": [], "message": "Use XDG_RUNTIME_DIR to hold sockets, and do not make a world-writable dir\n\nIf we use XDG_RUNTIME_DIR, then the directory should be owned by the\nappropriate user, so it should not need to be world-writable. Hopefully this\nwon't break accessibility for administrative apps on some distro.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=678348"}
{"func": "impl_get_app_bus(DBusConnection *bus, DBusMessage *msg, void *data)\n{\nDBusMessage *reply;\n\n  if (bus == spi_global_app_data->bus)\n    spi_atk_add_client (dbus_message_get_sender (msg));\n\nreply = dbus_message_new_method_return(msg);\nif (reply)\n    {\n      const char *retval = (g_getenv (\"AT_SPI_CLIENT\") ?\n                            \"\":\n                            spi_global_app_data->app_bus_addr);\n      dbus_message_append_args(reply, DBUS_TYPE_STRING, &retval, DBUS_TYPE_INVALID);\n    }\n\nreturn reply;\n}", "target": 1, "cwe": [], "message": "Use XDG_RUNTIME_DIR to hold sockets, and do not make a world-writable dir\n\nIf we use XDG_RUNTIME_DIR, then the directory should be owned by the\nappropriate user, so it should not need to be world-writable. Hopefully this\nwon't break accessibility for administrative apps on some distro.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=678348"}
{"func": "deregister_application (SpiBridge * app)\n{\n  DBusMessage *message;\n  DBusMessageIter iter;\n  DBusError error;\n  const char *uname;\n\n  dbus_error_init (&error);\n\n  message = dbus_message_new_method_call (SPI_DBUS_NAME_REGISTRY,\n                                          ATSPI_DBUS_PATH_REGISTRY,\n                                          ATSPI_DBUS_INTERFACE_REGISTRY,\n                                          \"DeregisterApplication\");\n  dbus_message_set_no_reply (message, TRUE);\n\n  uname = dbus_bus_get_unique_name (app->bus);\n\n  dbus_message_iter_init_append (message, &iter);\n  dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &uname);\n  dbus_connection_send (app->bus, message, NULL);\n  if (message)\n    dbus_message_unref (message);\n}", "target": 1, "cwe": [], "message": "Use XDG_RUNTIME_DIR to hold sockets, and do not make a world-writable dir\n\nIf we use XDG_RUNTIME_DIR, then the directory should be owned by the\nappropriate user, so it should not need to be world-writable. Hopefully this\nwon't break accessibility for administrative apps on some distro.\n\nhttps://bugzilla.gnome.org/show_bug.cgi?id=678348"}
{"func": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-119", "CWE-787"], "message": "udf: Fortify loading of sparing table\n\nAdd sanity checks when loading sparing table from disk to avoid accessing\nunallocated memory or writing to it.\n\nSigned-off-by: Jan Kara <jack@suse.cz>"}
{"func": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-399", "CWE-119"], "message": "udf: Avoid run away loop when partition table length is corrupted\n\nCheck provided length of partition table so that (possibly maliciously)\ncorrupted partition table cannot cause accessing data beyond current buffer.\n\nSigned-off-by: Jan Kara <jack@suse.cz>"}
{"func": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tif (udf_load_sparable_map(sb, map,\n\t\t\t\t    (struct sparablePartitionMap *)gpm) < 0)\n\t\t\t\t\tgoto out_bh;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}", "target": 1, "cwe": [], "message": "udf: Improve table length check to avoid possible overflow\n\nWhen a partition table length is corrupted to be close to 1 << 32, the\ncheck for its length may overflow on 32-bit systems and we will think\nthe length is valid. Later on the kernel can crash trying to read beyond\nend of buffer. Fix the check to avoid possible overflow.\n\nCC: stable@vger.kernel.org\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Jan Kara <jack@suse.cz>"}
{"func": "submit_request(CMD_Request *request, CMD_Reply *reply, int *reply_auth_ok)\n{\n  unsigned long tx_sequence;\n  socklen_t where_from_len;\n  union sockaddr_in46 where_from;\n  int bad_length, bad_sender, bad_sequence, bad_header;\n  int select_status;\n  int recvfrom_status;\n  int read_length;\n  int expected_length;\n  int command_length;\n  int auth_length;\n  struct timeval tv;\n  int timeout;\n  int n_attempts;\n  fd_set rdfd, wrfd, exfd;\n\n  request->version = PROTO_VERSION_NUMBER;\n  request->pkt_type = PKT_TYPE_CMD_REQUEST;\n  request->res1 = 0;\n  request->res2 = 0;\n  tx_sequence = sequence++;\n  request->sequence = htonl(tx_sequence);\n  request->attempt = 0;\n  request->utoken = htonl(utoken);\n  request->token = htonl(token);\n\n  timeout = initial_timeout;\n\n  n_attempts = 0;\n\n  do {\n\n    /* Decide whether to authenticate */\n    if (password) {\n      if (!utoken || (request->command == htons(REQ_LOGON))) {\n        /* Otherwise, the daemon won't bother authenticating our\n           packet and we won't get a token back */\n        request->utoken = htonl(SPECIAL_UTOKEN);\n      }\n      auth_length = generate_auth(request);\n    } else {\n      auth_length = 0;\n    }\n\n    command_length = PKL_CommandLength(request);\n    assert(command_length > 0);\n\n    /* add empty MD5 auth so older servers will not drop the request\n       due to bad length */\n    if (!auth_length) {\n      memset(((char *)request) + command_length, 0, 16);\n      auth_length = 16;\n    }\n\n#if 0\n    printf(\"Sent command length=%d bytes auth length=%d bytes\\n\", command_length, auth_length);\n#endif\n\n    if (sendto(sock_fd, (void *) request, command_length + auth_length, 0,\n               &his_addr.u, his_addr_len) < 0) {\n\n\n#if 0\n      perror(\"Could not send packet\");\n#endif\n      return 0;\n    }\n\n    /* Increment this for next time */\n    ++ request->attempt;\n      \n    tv.tv_sec = timeout / 1000;\n    tv.tv_usec = timeout % 1000 * 1000;\n    timeout *= 2;\n\n    FD_ZERO(&rdfd);\n    FD_ZERO(&wrfd);\n    FD_ZERO(&exfd);\n\n    FD_SET(sock_fd, &rdfd);\n\n    select_status = select(sock_fd + 1, &rdfd, &wrfd, &exfd, &tv);\n\n    if (select_status < 0) {\n#if 0\n      perror(\"Select returned negative status\");\n#endif\n    } else if (select_status == 0) {\n      /* Timeout must have elapsed, try a resend? */\n      n_attempts ++;\n      if (n_attempts > max_retries) {\n        return 0;\n      }\n\n      /* Back to top of loop to do resend */\n      continue;\n      \n    } else {\n      \n      where_from_len = sizeof(where_from);\n      recvfrom_status = recvfrom(sock_fd, (void *) reply, sizeof(CMD_Reply), 0,\n                                 &where_from.u, &where_from_len);\n      \n\n#if 0\n      printf(\"Received packet, status=%d\\n\", recvfrom_status);\n#endif\n\n      if (recvfrom_status < 0) {\n        /* If we get connrefused here, it suggests the sendto is\n           going to a dead port - but only if the daemon machine is\n           running Linux (Solaris doesn't return anything) */\n        n_attempts++;\n        if (n_attempts > max_retries) {\n          return 0;\n        }\n      } else {\n        \n        read_length = recvfrom_status;\n        expected_length = PKL_ReplyLength(reply);\n\n        bad_length = (read_length < expected_length);\n        bad_sender = (where_from.u.sa_family != his_addr.u.sa_family ||\n                      (where_from.u.sa_family == AF_INET &&\n                       (where_from.in4.sin_addr.s_addr != his_addr.in4.sin_addr.s_addr ||\n                        where_from.in4.sin_port != his_addr.in4.sin_port)) ||\n#ifdef HAVE_IPV6\n                      (where_from.u.sa_family == AF_INET6 &&\n                       (memcmp(where_from.in6.sin6_addr.s6_addr, his_addr.in6.sin6_addr.s6_addr,\n                               sizeof (where_from.in6.sin6_addr.s6_addr)) != 0 ||\n                        where_from.in6.sin6_port != his_addr.in6.sin6_port)) ||\n#endif\n                      0);\n        \n        if (!bad_length) {\n          bad_sequence = (ntohl(reply->sequence) != tx_sequence);\n        } else {\n          bad_sequence = 0;\n        }\n        \n        if (bad_length || bad_sender || bad_sequence) {\n          n_attempts++;\n          if (n_attempts > max_retries) {\n            return 0;\n          }\n          continue;\n        }\n        \n        bad_header = ((reply->version != PROTO_VERSION_NUMBER &&\n                       !(reply->version >= PROTO_VERSION_MISMATCH_COMPAT &&\n                         ntohs(reply->status) == STT_BADPKTVERSION)) ||\n                      (reply->pkt_type != PKT_TYPE_CMD_REPLY) ||\n                      (reply->res1 != 0) ||\n                      (reply->res2 != 0) ||\n                      (reply->command != request->command));\n        \n        if (bad_header) {\n          n_attempts++;\n          if (n_attempts > max_retries) {\n            return 0;\n          }\n          continue;\n        }\n        \n        /* Good packet received, print out results */\n#if 0\n        printf(\"Reply cmd=%d reply=%d stat=%d num=%d tot=%d seq=%d utok=%08lx tok=%d\\n\",\n               ntohs(reply->command), ntohs(reply->reply),\n               ntohs(reply->status), ntohs(reply->number),\n               ntohs(reply->total),\n               ntohl(reply->sequence),\n               ntohl(reply->utoken),\n               ntohl(reply->token));\n#endif\n\n        if (password) {\n          *reply_auth_ok = check_reply_auth(reply, read_length);\n        } else {\n          /* Assume in this case that the reply is always considered\n             to be authentic */\n          *reply_auth_ok = 1;\n        }\n            \n        utoken = ntohl(reply->utoken);\n\n        if (*reply_auth_ok) {\n          /* If we're in authenticated mode, only acquire the utoken\n             and new token values if the reply authenticated properly.\n             This protects against forged packets with bogus tokens\n             in.  We won't accept a repeat of an old message with a\n             stale token in it, due to bad_sequence processing\n             earlier. */\n          utoken = ntohl(reply->utoken);\n          token = ntohl(reply->token);\n        }\n        \n        break;\n\n      }\n    }\n  } while (1);\n\n  return 1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix buffer overflow when processing crafted command packets\n\nWhen the length of the REQ_SUBNETS_ACCESSED, REQ_CLIENT_ACCESSES\ncommand requests and the RPY_SUBNETS_ACCESSED, RPY_CLIENT_ACCESSES,\nRPY_CLIENT_ACCESSES_BY_INDEX, RPY_MANUAL_LIST command replies is\ncalculated, the number of items stored in the packet is not validated.\n\nA crafted command request/reply can be used to crash the server/client.\nOnly clients allowed by cmdallow (by default only localhost) can crash\nthe server.\n\nWith chrony versions 1.25 and 1.26 this bug has a smaller security\nimpact as the server requires the clients to be authenticated in order\nto process the subnet and client accesses commands. In 1.27 and 1.28,\nhowever, the invalid calculated length is included also in the\nauthentication check which may cause another crash."}
{"func": "PKL_CommandLength(CMD_Request *r)\n{\n  int type;\n  type = ntohs(r->command);\n  if (type < 0 || type >= N_REQUEST_TYPES) {\n    return 0;\n  } else {\n    switch (type) {\n      \n      case REQ_NULL:\n        return offsetof(CMD_Request, data);\n      case REQ_ONLINE:\n        return offsetof(CMD_Request, data.online.EOR);\n      case REQ_OFFLINE:\n        return offsetof(CMD_Request, data.offline.EOR);\n      case REQ_BURST:\n        return offsetof(CMD_Request, data.burst.EOR);\n      case REQ_MODIFY_MINPOLL:\n        return offsetof(CMD_Request, data.modify_minpoll.EOR);\n      case REQ_MODIFY_MAXPOLL:\n        return offsetof(CMD_Request, data.modify_maxpoll.EOR);\n      case REQ_DUMP:\n        return offsetof(CMD_Request, data.dump.EOR);\n      case REQ_MODIFY_MAXDELAY:\n        return offsetof(CMD_Request, data.modify_maxdelay.EOR);\n      case REQ_MODIFY_MAXDELAYRATIO:\n        return offsetof(CMD_Request, data.modify_maxdelayratio.EOR);\n      case REQ_MODIFY_MAXDELAYDEVRATIO:\n        return offsetof(CMD_Request, data.modify_maxdelaydevratio.EOR);\n      case REQ_MODIFY_MAXUPDATESKEW:\n        return offsetof(CMD_Request, data.modify_maxupdateskew.EOR);\n      case REQ_LOGON :\n        return offsetof(CMD_Request, data.logon.EOR);\n      case REQ_SETTIME :\n        return offsetof(CMD_Request, data.settime.EOR);\n      case REQ_LOCAL :\n        return offsetof(CMD_Request, data.local.EOR);\n      case REQ_MANUAL :\n        return offsetof(CMD_Request, data.manual.EOR);\n      case REQ_N_SOURCES :\n        return offsetof(CMD_Request, data.n_sources.EOR);\n      case REQ_SOURCE_DATA :\n        return offsetof(CMD_Request, data.source_data.EOR);\n      case REQ_REKEY :\n        return offsetof(CMD_Request, data.rekey.EOR);\n      case REQ_ALLOW :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_ALLOWALL :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_DENY :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_DENYALL :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_CMDALLOW :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_CMDALLOWALL :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_CMDDENY :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_CMDDENYALL :\n        return offsetof(CMD_Request, data.allow_deny.EOR);\n      case REQ_ACCHECK :\n        return offsetof(CMD_Request, data.ac_check.EOR);\n      case REQ_CMDACCHECK :\n        return offsetof(CMD_Request, data.ac_check.EOR);\n      case REQ_ADD_SERVER :\n        return offsetof(CMD_Request, data.ntp_source.EOR);\n      case REQ_ADD_PEER :\n        return offsetof(CMD_Request, data.ntp_source.EOR);\n      case REQ_DEL_SOURCE :\n        return offsetof(CMD_Request, data.del_source.EOR);\n      case REQ_WRITERTC :\n        return offsetof(CMD_Request, data.writertc.EOR);\n      case REQ_DFREQ :\n        return offsetof(CMD_Request, data.dfreq.EOR);\n      case REQ_DOFFSET :\n        return offsetof(CMD_Request, data.doffset.EOR);\n      case REQ_TRACKING :\n        return offsetof(CMD_Request, data.tracking.EOR);\n      case REQ_SOURCESTATS :\n        return offsetof(CMD_Request, data.sourcestats.EOR);\n      case REQ_RTCREPORT :\n        return offsetof(CMD_Request, data.rtcreport.EOR);\n      case REQ_TRIMRTC :\n        return offsetof(CMD_Request, data.trimrtc.EOR);\n      case REQ_CYCLELOGS :\n        return offsetof(CMD_Request, data.cyclelogs.EOR);\n      case REQ_SUBNETS_ACCESSED :\n        {\n          unsigned long ns;\n          ns = ntohl(r->data.subnets_accessed.n_subnets);\n          return (offsetof(CMD_Request, data.subnets_accessed.subnets) +\n                  ns * sizeof(REQ_SubnetsAccessed_Subnet));\n        }\n      case REQ_CLIENT_ACCESSES:\n        {\n          unsigned long nc;\n          nc = ntohl(r->data.client_accesses.n_clients);\n          return (offsetof(CMD_Request, data.client_accesses.client_ips) +\n                  nc * sizeof(unsigned long));\n        }\n      case REQ_CLIENT_ACCESSES_BY_INDEX:\n        return offsetof(CMD_Request, data.client_accesses_by_index.EOR);\n      case REQ_MANUAL_LIST:\n        return offsetof(CMD_Request, data.manual_list.EOR);\n      case REQ_MANUAL_DELETE:\n        return offsetof(CMD_Request, data.manual_delete.EOR);\n      case REQ_MAKESTEP:\n        return offsetof(CMD_Request, data.make_step.EOR);\n      case REQ_ACTIVITY:\n        return offsetof(CMD_Request, data.activity.EOR);\n      case REQ_RESELECT:\n        return offsetof(CMD_Request, data.reselect.EOR);\n      case REQ_RESELECTDISTANCE:\n        return offsetof(CMD_Request, data.reselect_distance.EOR);\n      case REQ_MODIFY_MINSTRATUM:\n        return offsetof(CMD_Request, data.modify_minstratum.EOR);\n      case REQ_MODIFY_POLLTARGET:\n        return offsetof(CMD_Request, data.modify_polltarget.EOR);\n      default:\n        /* If we fall through the switch, it most likely means we've forgotten to implement a new case */\n        assert(0);\n    }\n  }\n\n  /* Catch-all case */\n  return 0;\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix buffer overflow when processing crafted command packets\n\nWhen the length of the REQ_SUBNETS_ACCESSED, REQ_CLIENT_ACCESSES\ncommand requests and the RPY_SUBNETS_ACCESSED, RPY_CLIENT_ACCESSES,\nRPY_CLIENT_ACCESSES_BY_INDEX, RPY_MANUAL_LIST command replies is\ncalculated, the number of items stored in the packet is not validated.\n\nA crafted command request/reply can be used to crash the server/client.\nOnly clients allowed by cmdallow (by default only localhost) can crash\nthe server.\n\nWith chrony versions 1.25 and 1.26 this bug has a smaller security\nimpact as the server requires the clients to be authenticated in order\nto process the subnet and client accesses commands. In 1.27 and 1.28,\nhowever, the invalid calculated length is included also in the\nauthentication check which may cause another crash."}
{"func": "PKL_ReplyLength(CMD_Reply *r)\n{\n  int type;\n  type = ntohs(r->reply);\n  /* Note that reply type codes start from 1, not 0 */\n  if (type < 1 || type >= N_REPLY_TYPES) {\n    return 0;\n  } else {\n    switch (type) {\n      case RPY_NULL:\n        return offsetof(CMD_Reply, data.null.EOR);\n      case RPY_N_SOURCES:\n        return offsetof(CMD_Reply, data.n_sources.EOR);\n      case RPY_SOURCE_DATA:\n        return offsetof(CMD_Reply, data.source_data.EOR);\n      case RPY_MANUAL_TIMESTAMP:\n        return offsetof(CMD_Reply, data.manual_timestamp.EOR);\n      case RPY_TRACKING:\n        return offsetof(CMD_Reply, data.tracking.EOR);\n      case RPY_SOURCESTATS:\n        return offsetof(CMD_Reply, data.sourcestats.EOR);\n      case RPY_RTC:\n        return offsetof(CMD_Reply, data.rtc.EOR);\n      case RPY_SUBNETS_ACCESSED :\n        {\n          unsigned long ns = ntohl(r->data.subnets_accessed.n_subnets);\n          if (r->status == htons(STT_SUCCESS)) {\n            return (offsetof(CMD_Reply, data.subnets_accessed.subnets) +\n                    ns * sizeof(RPY_SubnetsAccessed_Subnet));\n          } else {\n            return offsetof(CMD_Reply, data);\n          }\n        }\n      case RPY_CLIENT_ACCESSES:\n        {\n          unsigned long nc = ntohl(r->data.client_accesses.n_clients);\n          if (r->status == htons(STT_SUCCESS)) {\n            return (offsetof(CMD_Reply, data.client_accesses.clients) +\n                    nc * sizeof(RPY_ClientAccesses_Client));\n          } else {\n            return offsetof(CMD_Reply, data);\n          }\n        }\n      case RPY_CLIENT_ACCESSES_BY_INDEX:\n        {\n          unsigned long nc = ntohl(r->data.client_accesses_by_index.n_clients);\n          if (r->status == htons(STT_SUCCESS)) {\n            return (offsetof(CMD_Reply, data.client_accesses_by_index.clients) +\n                    nc * sizeof(RPY_ClientAccesses_Client));\n          } else {\n            return offsetof(CMD_Reply, data);\n          }\n        }\n      case RPY_MANUAL_LIST:\n        {\n          unsigned long ns = ntohl(r->data.manual_list.n_samples);\n          if (r->status == htons(STT_SUCCESS)) {\n            return (offsetof(CMD_Reply, data.manual_list.samples) +\n                    ns * sizeof(RPY_ManualListSample));\n          } else {\n            return offsetof(CMD_Reply, data);\n          }\n        }\n      case RPY_ACTIVITY:\n        return offsetof(CMD_Reply, data.activity.EOR);\n        \n      default:\n        assert(0);\n    }\n  }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix buffer overflow when processing crafted command packets\n\nWhen the length of the REQ_SUBNETS_ACCESSED, REQ_CLIENT_ACCESSES\ncommand requests and the RPY_SUBNETS_ACCESSED, RPY_CLIENT_ACCESSES,\nRPY_CLIENT_ACCESSES_BY_INDEX, RPY_MANUAL_LIST command replies is\ncalculated, the number of items stored in the packet is not validated.\n\nA crafted command request/reply can be used to crash the server/client.\nOnly clients allowed by cmdallow (by default only localhost) can crash\nthe server.\n\nWith chrony versions 1.25 and 1.26 this bug has a smaller security\nimpact as the server requires the clients to be authenticated in order\nto process the subnet and client accesses commands. In 1.27 and 1.28,\nhowever, the invalid calculated length is included also in the\nauthentication check which may cause another crash."}
{"func": "read_from_cmd_socket(void *anything)\n{\n  int status;\n  int read_length; /* Length of packet read */\n  int expected_length; /* Expected length of packet without auth data */\n  unsigned long flags;\n  CMD_Request rx_message;\n  CMD_Reply tx_message, *prev_tx_message;\n  int rx_message_length, tx_message_length;\n  int sock_fd;\n  union sockaddr_in46 where_from;\n  socklen_t from_length;\n  IPAddr remote_ip;\n  unsigned short remote_port;\n  int auth_length;\n  int auth_ok;\n  int utoken_ok, token_ok;\n  int issue_token;\n  int valid_ts;\n  int authenticated;\n  int localhost;\n  int allowed;\n  unsigned short rx_command;\n  unsigned long rx_message_token;\n  unsigned long tx_message_token;\n  unsigned long rx_message_seq;\n  unsigned long rx_attempt;\n  struct timeval now;\n  struct timeval cooked_now;\n\n  flags = 0;\n  rx_message_length = sizeof(rx_message);\n  from_length = sizeof(where_from);\n\n  sock_fd = (long)anything;\n  status = recvfrom(sock_fd, (char *)&rx_message, rx_message_length, flags,\n                    &where_from.u, &from_length);\n\n  if (status < 0) {\n    LOG(LOGS_WARN, LOGF_CmdMon, \"Error [%s] reading from control socket %d\",\n        strerror(errno), sock_fd);\n    return;\n  }\n\n  read_length = status;\n  expected_length = PKL_CommandLength(&rx_message);\n  rx_command = ntohs(rx_message.command);\n\n  LCL_ReadRawTime(&now);\n  LCL_CookTime(&now, &cooked_now, NULL);\n\n  tx_message.version = PROTO_VERSION_NUMBER;\n  tx_message.pkt_type = PKT_TYPE_CMD_REPLY;\n  tx_message.res1 = 0;\n  tx_message.res2 = 0;\n  tx_message.command = rx_message.command;\n  tx_message.sequence = rx_message.sequence;\n  tx_message.reply = htons(RPY_NULL);\n  tx_message.number = htons(1);\n  tx_message.total = htons(1);\n  tx_message.pad1 = 0;\n  tx_message.utoken = htonl(utoken);\n  /* Set this to a default (invalid) value.  This protects against the\n     token field being set to an arbitrary value if we reject the\n     message, e.g. due to the host failing the access check. */\n  tx_message.token = htonl(0xffffffffUL);\n  memset(&tx_message.auth, 0, sizeof(tx_message.auth));\n\n  switch (where_from.u.sa_family) {\n    case AF_INET:\n      remote_ip.family = IPADDR_INET4;\n      remote_ip.addr.in4 = ntohl(where_from.in4.sin_addr.s_addr);\n      remote_port = ntohs(where_from.in4.sin_port);\n      localhost = (remote_ip.addr.in4 == 0x7f000001UL);\n      break;\n#ifdef HAVE_IPV6\n    case AF_INET6:\n      remote_ip.family = IPADDR_INET6;\n      memcpy(&remote_ip.addr.in6, where_from.in6.sin6_addr.s6_addr,\n          sizeof (remote_ip.addr.in6));\n      remote_port = ntohs(where_from.in6.sin6_port);\n      /* Check for ::1 */\n      for (localhost = 0; localhost < 16; localhost++)\n        if (remote_ip.addr.in6[localhost] != 0)\n          break;\n      localhost = (localhost == 15 && remote_ip.addr.in6[localhost] == 1);\n      break;\n#endif\n    default:\n      assert(0);\n  }\n\n  allowed = ADF_IsAllowed(access_auth_table, &remote_ip) || localhost;\n\n  if (read_length < offsetof(CMD_Request, data) ||\n      rx_message.pkt_type != PKT_TYPE_CMD_REQUEST ||\n      rx_message.res1 != 0 ||\n      rx_message.res2 != 0) {\n\n    /* We don't know how to process anything like this */\n    if (allowed)\n      CLG_LogCommandAccess(&remote_ip, CLG_CMD_BAD_PKT, cooked_now.tv_sec);\n    \n    return;\n  }\n\n  if (rx_message.version != PROTO_VERSION_NUMBER) {\n    tx_message.status = htons(STT_NOHOSTACCESS);\n    if (!LOG_RateLimited()) {\n      LOG(LOGS_WARN, LOGF_CmdMon, \"Read command packet with protocol version %d (expected %d) from %s:%hu\", rx_message.version, PROTO_VERSION_NUMBER, UTI_IPToString(&remote_ip), remote_port);\n    }\n    if (allowed)\n      CLG_LogCommandAccess(&remote_ip, CLG_CMD_BAD_PKT, cooked_now.tv_sec);\n\n    if (rx_message.version >= PROTO_VERSION_MISMATCH_COMPAT) {\n      tx_message.status = htons(STT_BADPKTVERSION);\n      /* add empty MD5 auth so older clients will not drop\n         the reply due to bad length */\n      memset(((char *)&tx_message) + PKL_ReplyLength(&tx_message), 0, 16);\n      transmit_reply(&tx_message, &where_from, 16);\n    }\n    return;\n  }\n\n  if (rx_command >= N_REQUEST_TYPES) {\n    if (!LOG_RateLimited()) {\n      LOG(LOGS_WARN, LOGF_CmdMon, \"Read command packet with invalid command %d from %s:%hu\", rx_command, UTI_IPToString(&remote_ip), remote_port);\n    }\n    if (allowed)\n      CLG_LogCommandAccess(&remote_ip, CLG_CMD_BAD_PKT, cooked_now.tv_sec);\n\n    tx_message.status = htons(STT_INVALID);\n    transmit_reply(&tx_message, &where_from, 0);\n    return;\n  }\n\n  if (read_length < expected_length) {\n    if (!LOG_RateLimited()) {\n      LOG(LOGS_WARN, LOGF_CmdMon, \"Read incorrectly sized command packet from %s:%hu\", UTI_IPToString(&remote_ip), remote_port);\n    }\n    if (allowed)\n      CLG_LogCommandAccess(&remote_ip, CLG_CMD_BAD_PKT, cooked_now.tv_sec);\n\n    tx_message.status = htons(STT_BADPKTLENGTH);\n    transmit_reply(&tx_message, &where_from, 0);\n    return;\n  }\n\n  if (!allowed) {\n    /* The client is not allowed access, so don't waste any more time\n       on him.  Note that localhost is always allowed access\n       regardless of the defined access rules - otherwise, we could\n       shut ourselves out completely! */\n\n    if (!LOG_RateLimited()) {\n      LOG(LOGS_WARN, LOGF_CmdMon, \"Command packet received from unauthorised host %s port %d\",\n          UTI_IPToString(&remote_ip),\n          remote_port);\n    }\n\n    tx_message.status = htons(STT_NOHOSTACCESS);\n    transmit_reply(&tx_message, &where_from, 0);\n\n    return;\n  }\n\n  /* OK, we have a valid message.  Now dispatch on message type and process it. */\n\n  /* Do authentication stuff and command tokens here.  Well-behaved\n     clients will set their utokens to 0 to save us wasting our time\n     if the packet is unauthenticatable. */\n  if (rx_message.utoken != 0) {\n    auth_ok = check_rx_packet_auth(&rx_message, read_length);\n  } else {\n    auth_ok = 0;\n  }\n\n  /* All this malarky is to protect the system against various forms\n     of attack.\n\n     Simple packet forgeries are blocked by requiring the packet to\n     authenticate properly with MD5 or other crypto hash.  (The\n     assumption is that the command key is in a read-only keys file\n     read by the daemon, and is known only to administrators.)\n\n     Replay attacks are prevented by 2 fields in the packet.  The\n     'token' field is where the client plays back to us a token that\n     he was issued in an earlier reply.  Each time we reply to a\n     suitable packet, we issue a new token.  The 'utoken' field is set\n     to a new (hopefully increasing) value each time the daemon is\n     run.  This prevents packets from a previous incarnation being\n     played back at us when the same point in the 'token' sequence\n     comes up.  (The token mechanism also prevents a non-idempotent\n     command from being executed twice from the same client, if the\n     client fails to receive our reply the first time and tries a\n     resend.)\n\n     The problem is how a client should get its first token.  Our\n     token handling only remembers a finite number of issued tokens\n     (actually 32) - if a client replies with a (legitimate) token\n     older than that, it will be treated as though a duplicate token\n     has been supplied.  If a simple token-request protocol were used,\n     the whole thing would be vulnerable to a denial of service\n     attack, where an attacker just replays valid token-request\n     packets at us, causing us to keep issuing new tokens,\n     invalidating all the ones we have given out to true clients\n     already.\n\n     To protect against this, the token-request (REQ_LOGON) packet\n     includes a timestamp field.  To issue a token, we require that\n     this field is different from any we have processed before.  To\n     bound our storage, we require that the timestamp is within a\n     certain period of our current time.  For clients running on the\n     same host this will be easily satisfied.\n\n     */\n\n  utoken_ok = (ntohl(rx_message.utoken) == utoken);\n\n  /* Avoid binning a valid user's token if we merely get a forged\n     packet */\n  rx_message_token = ntohl(rx_message.token);\n  rx_message_seq = ntohl(rx_message.sequence);\n  rx_attempt = ntohs(rx_message.attempt);\n\n  if (auth_ok && utoken_ok) {\n    token_ok = check_token(rx_message_token);\n  } else {\n    token_ok = 0;\n  }\n\n  if (auth_ok && utoken_ok && !token_ok) {\n    /* This might be a resent message, due to the client not getting\n       our reply to the first attempt.  See if we can find the message. */\n    prev_tx_message = lookup_reply(rx_message_token, rx_message_seq, rx_attempt);\n    if (prev_tx_message) {\n      /* Just send this message again */\n      tx_message_length = PKL_ReplyLength(prev_tx_message);\n      status = sendto(sock_fd, (void *) prev_tx_message, tx_message_length, 0,\n                      &where_from.u, from_length);\n      if (status < 0 && !LOG_RateLimited()) {\n        LOG(LOGS_WARN, LOGF_CmdMon, \"Could not send response to %s:%hu\", UTI_IPToString(&remote_ip), remote_port);\n      }\n      return;\n    }\n    /* Otherwise, just fall through into normal processing */\n\n  }\n\n  if (auth_ok && utoken_ok && token_ok) {\n    /* See whether we can discard the previous reply from storage */\n    token_acknowledged(rx_message_token, &now);\n  }\n\n  valid_ts = 0;\n\n  if (auth_ok) {\n    struct timeval ts;\n\n    UTI_TimevalNetworkToHost(&rx_message.data.logon.ts, &ts);\n    if ((utoken_ok && token_ok) ||\n        ((ntohl(rx_message.utoken) == SPECIAL_UTOKEN) &&\n         (rx_command == REQ_LOGON) &&\n         (valid_ts = ts_is_unique_and_not_stale(&ts, &now))))\n      issue_token = 1;\n    else \n      issue_token = 0;\n  } else {\n    issue_token = 0;\n  }\n\n  authenticated = auth_ok & utoken_ok & token_ok;\n\n  if (authenticated) {\n    CLG_LogCommandAccess(&remote_ip, CLG_CMD_AUTH, cooked_now.tv_sec);\n  } else {\n    CLG_LogCommandAccess(&remote_ip, CLG_CMD_NORMAL, cooked_now.tv_sec);\n  }\n\n  if (issue_token) {\n    /* Only command clients where the user has apparently 'logged on'\n       get a token to allow them to emit an authenticated command next\n       time */\n    tx_message_token = get_token();\n  } else {\n    tx_message_token = 0xffffffffUL;\n  }\n\n  tx_message.token = htonl(tx_message_token);\n\n\n  if (rx_command >= N_REQUEST_TYPES) {\n    /* This should be already handled */\n    assert(0);\n  } else {\n    allowed = 0;\n\n    /* Check level of authority required to issue the command */\n    switch(permissions[rx_command]) {\n      case PERMIT_AUTH:\n        if (authenticated) {\n          allowed = 1;\n        } else {\n          allowed = 0;\n        }\n        break;\n      case PERMIT_LOCAL:\n        if (authenticated || localhost) {\n          allowed = 1;\n        } else {\n          allowed = 0;\n        }\n        break;\n      case PERMIT_OPEN:\n        allowed = 1;\n        break;\n      default:\n        assert(0);\n    }\n\n    if (allowed) {\n      switch(rx_command) {\n        case REQ_NULL:\n          handle_null(&rx_message, &tx_message);\n          break;\n\n        case REQ_ONLINE:\n          handle_online(&rx_message, &tx_message);\n          break;\n\n        case REQ_OFFLINE:\n          handle_offline(&rx_message, &tx_message);\n          break;\n\n        case REQ_BURST:\n          handle_burst(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MINPOLL:\n          handle_modify_minpoll(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MAXPOLL:\n          handle_modify_maxpoll(&rx_message, &tx_message);\n          break;\n\n        case REQ_DUMP:\n          SRC_DumpSources();\n          tx_message.status = htons(STT_SUCCESS);\n          break;\n\n        case REQ_MODIFY_MAXDELAY:\n          handle_modify_maxdelay(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MAXDELAYRATIO:\n          handle_modify_maxdelayratio(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MAXDELAYDEVRATIO:\n          handle_modify_maxdelaydevratio(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MAXUPDATESKEW:\n          handle_modify_maxupdateskew(&rx_message, &tx_message);\n          break;\n\n        case REQ_LOGON:\n          /* If the log-on fails, record the reason why */\n          if (!issue_token && !LOG_RateLimited()) {\n            LOG(LOGS_WARN, LOGF_CmdMon,\n                \"Bad command logon from %s port %d (auth_ok=%d valid_ts=%d)\",\n                UTI_IPToString(&remote_ip),\n                remote_port,\n                auth_ok, valid_ts);\n          }\n\n          if (issue_token == 1) {\n            tx_message.status = htons(STT_SUCCESS);\n          } else if (!auth_ok) {\n            tx_message.status = htons(STT_UNAUTH);\n          } else if (!valid_ts) {\n            tx_message.status = htons(STT_INVALIDTS);\n          } else {\n            tx_message.status = htons(STT_FAILED);\n          }\n            \n          break;\n\n        case REQ_SETTIME:\n          handle_settime(&rx_message, &tx_message);\n          break;\n        \n        case REQ_LOCAL:\n          handle_local(&rx_message, &tx_message);\n          break;\n\n        case REQ_MANUAL:\n          handle_manual(&rx_message, &tx_message);\n          break;\n\n        case REQ_N_SOURCES:\n          handle_n_sources(&rx_message, &tx_message);\n          break;\n\n        case REQ_SOURCE_DATA:\n          handle_source_data(&rx_message, &tx_message);\n          break;\n\n        case REQ_REKEY:\n          handle_rekey(&rx_message, &tx_message);\n          break;\n\n        case REQ_ALLOW:\n          handle_allow(&rx_message, &tx_message);\n          break;\n\n        case REQ_ALLOWALL:\n          handle_allowall(&rx_message, &tx_message);\n          break;\n\n        case REQ_DENY:\n          handle_deny(&rx_message, &tx_message);\n          break;\n\n        case REQ_DENYALL:\n          handle_denyall(&rx_message, &tx_message);\n          break;\n\n        case REQ_CMDALLOW:\n          handle_cmdallow(&rx_message, &tx_message);\n          break;\n\n        case REQ_CMDALLOWALL:\n          handle_cmdallowall(&rx_message, &tx_message);\n          break;\n\n        case REQ_CMDDENY:\n          handle_cmddeny(&rx_message, &tx_message);\n          break;\n\n        case REQ_CMDDENYALL:\n          handle_cmddenyall(&rx_message, &tx_message);\n          break;\n\n        case REQ_ACCHECK:\n          handle_accheck(&rx_message, &tx_message);\n          break;\n\n        case REQ_CMDACCHECK:\n          handle_cmdaccheck(&rx_message, &tx_message);\n          break;\n\n        case REQ_ADD_SERVER:\n          handle_add_source(NTP_SERVER, &rx_message, &tx_message);\n          break;\n\n        case REQ_ADD_PEER:\n          handle_add_source(NTP_PEER, &rx_message, &tx_message);\n          break;\n\n        case REQ_DEL_SOURCE:\n          handle_del_source(&rx_message, &tx_message);\n          break;\n\n        case REQ_WRITERTC:\n          handle_writertc(&rx_message, &tx_message);\n          break;\n          \n        case REQ_DFREQ:\n          handle_dfreq(&rx_message, &tx_message);\n          break;\n\n        case REQ_DOFFSET:\n          handle_doffset(&rx_message, &tx_message);\n          break;\n\n        case REQ_TRACKING:\n          handle_tracking(&rx_message, &tx_message);\n          break;\n\n        case REQ_SOURCESTATS:\n          handle_sourcestats(&rx_message, &tx_message);\n          break;\n\n        case REQ_RTCREPORT:\n          handle_rtcreport(&rx_message, &tx_message);\n          break;\n          \n        case REQ_TRIMRTC:\n          handle_trimrtc(&rx_message, &tx_message);\n          break;\n\n        case REQ_CYCLELOGS:\n          handle_cyclelogs(&rx_message, &tx_message);\n          break;\n\n        case REQ_SUBNETS_ACCESSED:\n          handle_subnets_accessed(&rx_message, &tx_message);\n          break;\n\n        case REQ_CLIENT_ACCESSES:\n          handle_client_accesses(&rx_message, &tx_message);\n          break;\n\n        case REQ_CLIENT_ACCESSES_BY_INDEX:\n          handle_client_accesses_by_index(&rx_message, &tx_message);\n          break;\n\n        case REQ_MANUAL_LIST:\n          handle_manual_list(&rx_message, &tx_message);\n          break;\n\n        case REQ_MANUAL_DELETE:\n          handle_manual_delete(&rx_message, &tx_message);\n          break;\n\n        case REQ_MAKESTEP:\n          handle_make_step(&rx_message, &tx_message);\n          break;\n\n        case REQ_ACTIVITY:\n          handle_activity(&rx_message, &tx_message);\n          break;\n\n        case REQ_RESELECTDISTANCE:\n          handle_reselect_distance(&rx_message, &tx_message);\n          break;\n\n        case REQ_RESELECT:\n          handle_reselect(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_MINSTRATUM:\n          handle_modify_minstratum(&rx_message, &tx_message);\n          break;\n\n        case REQ_MODIFY_POLLTARGET:\n          handle_modify_polltarget(&rx_message, &tx_message);\n          break;\n\n        default:\n          assert(0);\n          break;\n      }\n    } else {\n      tx_message.status = htons(STT_UNAUTH);\n    }\n  }\n\n  if (auth_ok) {\n    auth_length = generate_tx_packet_auth(&tx_message);\n  } else {\n    auth_length = 0;\n  }\n\n  if (token_ok) {\n    save_reply(&tx_message,\n               rx_message_token,\n               tx_message_token,\n               rx_message_seq,\n               rx_attempt,\n               &now);\n  }\n\n  /* Transmit the response */\n  {\n    /* Include a simple way to lose one message in three to test resend */\n\n    static int do_it=1;\n\n    if (do_it) {\n      transmit_reply(&tx_message, &where_from, auth_length);\n    }\n\n#if 0\n    do_it = ((do_it + 1) % 3);\n#endif\n  }\n}", "target": 1, "cwe": ["CWE-189"], "message": "Fix buffer overflow when processing crafted command packets\n\nWhen the length of the REQ_SUBNETS_ACCESSED, REQ_CLIENT_ACCESSES\ncommand requests and the RPY_SUBNETS_ACCESSED, RPY_CLIENT_ACCESSES,\nRPY_CLIENT_ACCESSES_BY_INDEX, RPY_MANUAL_LIST command replies is\ncalculated, the number of items stored in the packet is not validated.\n\nA crafted command request/reply can be used to crash the server/client.\nOnly clients allowed by cmdallow (by default only localhost) can crash\nthe server.\n\nWith chrony versions 1.25 and 1.26 this bug has a smaller security\nimpact as the server requires the clients to be authenticated in order\nto process the subnet and client accesses commands. In 1.27 and 1.28,\nhowever, the invalid calculated length is included also in the\nauthentication check which may cause another crash."}
{"func": "handle_subnets_accessed(CMD_Request *rx_message, CMD_Reply *tx_message)\n{\n  int i, j;\n  unsigned long ns, bits_specd;\n  IPAddr ip;\n  CLG_Status result;\n  \n  ns = ntohl(rx_message->data.subnets_accessed.n_subnets);\n  tx_message->status = htons(STT_SUCCESS);\n  tx_message->reply = htons(RPY_SUBNETS_ACCESSED);\n  tx_message->data.subnets_accessed.n_subnets = htonl(ns);\n\n  for (i=0; i<ns; i++) {\n    UTI_IPNetworkToHost(&rx_message->data.subnets_accessed.subnets[i].ip, &ip);\n    bits_specd = ntohl(rx_message->data.subnets_accessed.subnets[i].bits_specd);\n\n    UTI_IPHostToNetwork(&ip, &tx_message->data.subnets_accessed.subnets[i].ip);\n    tx_message->data.subnets_accessed.subnets[i].bits_specd = htonl(bits_specd);\n    \n    result = CLG_GetSubnetBitmap(&ip, bits_specd, tx_message->data.subnets_accessed.subnets[i].bitmap);\n    switch (result) {\n      case CLG_SUCCESS:\n      case CLG_EMPTYSUBNET:\n        /* Flip endianness of each 4 byte word.  Don't care if subnet\n           is empty - just return an all-zero bitmap. */\n        for (j=0; j<8; j++) {\n          FLIPL(tx_message->data.subnets_accessed.subnets[i].bitmap[j]);\n        }\n        break;\n      case CLG_BADSUBNET:\n        tx_message->status = htons(STT_BADSUBNET);\n        return;\n      case CLG_INACTIVE:\n        tx_message->status = htons(STT_INACTIVE);\n        return;\n      default:\n        assert(0);\n        break;\n    }\n  }\n}", "target": 1, "cwe": ["CWE-189"], "message": "Don't send uninitialized data in command replies\n\nThe RPY_SUBNETS_ACCESSED and RPY_CLIENT_ACCESSES command replies can\ncontain uninitalized data from stack when the client logging is disabled\nor a bad subnet is requested. These commands were never used by chronyc\nand they require the client to be authenticated since version 1.25."}
{"func": "handle_client_accesses(CMD_Request *rx_message, CMD_Reply *tx_message)\n{\n  CLG_Status result;\n  RPT_ClientAccess_Report report;\n  unsigned long nc;\n  IPAddr ip;\n  int i;\n  struct timeval now;\n\n  LCL_ReadCookedTime(&now, NULL);\n\n  nc = ntohl(rx_message->data.client_accesses.n_clients);\n  tx_message->status = htons(STT_SUCCESS);\n  tx_message->reply = htons(RPY_CLIENT_ACCESSES);\n  tx_message->data.client_accesses.n_clients = htonl(nc);\n\n  printf(\"%d %d\\n\", (int)sizeof(RPY_ClientAccesses_Client), (int)offsetof(CMD_Reply, data.client_accesses.clients));\n\n  for (i=0; i<nc; i++) {\n    UTI_IPNetworkToHost(&rx_message->data.client_accesses.client_ips[i], &ip);\n    UTI_IPHostToNetwork(&ip, &tx_message->data.client_accesses.clients[i].ip);\n\n    result = CLG_GetClientAccessReportByIP(&ip, &report, now.tv_sec);\n    switch (result) {\n      case CLG_SUCCESS:\n        tx_message->data.client_accesses.clients[i].client_hits = htonl(report.client_hits);\n        tx_message->data.client_accesses.clients[i].peer_hits = htonl(report.peer_hits);\n        tx_message->data.client_accesses.clients[i].cmd_hits_auth = htonl(report.cmd_hits_auth);\n        tx_message->data.client_accesses.clients[i].cmd_hits_normal = htonl(report.cmd_hits_normal);\n        tx_message->data.client_accesses.clients[i].cmd_hits_bad = htonl(report.cmd_hits_bad);\n        tx_message->data.client_accesses.clients[i].last_ntp_hit_ago = htonl(report.last_ntp_hit_ago);\n        tx_message->data.client_accesses.clients[i].last_cmd_hit_ago = htonl(report.last_cmd_hit_ago);\n        printf(\"%s %lu %lu %lu %lu %lu %lu %lu\\n\", UTI_IPToString(&ip), report.client_hits, report.peer_hits, report.cmd_hits_auth, report.cmd_hits_normal, report.cmd_hits_bad, report.last_ntp_hit_ago, report.last_cmd_hit_ago);\n        break;\n      case CLG_EMPTYSUBNET:\n        /* Signal back to the client that this single client address\n           was unknown */\n        ip.family = IPADDR_UNSPEC;\n        UTI_IPHostToNetwork(&ip, &tx_message->data.client_accesses.clients[i].ip);\n        break;\n      case CLG_INACTIVE:\n        tx_message->status = htons(STT_INACTIVE);\n        return;\n      default:\n        assert(0);\n        break;\n    }\n  }\n\n}", "target": 1, "cwe": ["CWE-189"], "message": "Don't send uninitialized data in command replies\n\nThe RPY_SUBNETS_ACCESSED and RPY_CLIENT_ACCESSES command replies can\ncontain uninitalized data from stack when the client logging is disabled\nor a bad subnet is requested. These commands were never used by chronyc\nand they require the client to be authenticated since version 1.25."}
{"func": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\t/* convert pages-jiffies to Mbyte-usec */\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1, "cwe": ["CWE-399"], "message": "[PATCH] xacct_add_tsk: fix pure theoretical ->mm use-after-free\n\nParanoid fix. The task can free its ->mm after the 'if (p->mm)' check.\n\nSigned-off-by: Oleg Nesterov <oleg@tv-sign.ru>\nCc: Shailabh Nagar <nagar@watson.ibm.com>\nCc: Balbir Singh <balbir@in.ibm.com>\nCc: Jay Lan <jlan@sgi.com>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/* filesystem's fallocate may need to take i_mutex */\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-362"], "message": "mm: Hold a file reference in madvise_remove\n\nOtherwise the code races with munmap (causing a use-after-free\nof the vma) or with close (causing a use-after-free of the struct\nfile).\n\nThe bug was introduced by commit 90ed52ebe481 (\"[PATCH] holepunch: fix\nmmap_sem i_mutex deadlock\")\n\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Badari Pulavarty <pbadari@us.ibm.com>\nCc: Nick Piggin <npiggin@suse.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "dns_resolve_impl(edge_connection_t *exitconn, int is_resolve,\n                 or_circuit_t *oncirc, char **hostname_out)\n{\n  cached_resolve_t *resolve;\n  cached_resolve_t search;\n  pending_connection_t *pending_connection;\n  const routerinfo_t *me;\n  tor_addr_t addr;\n  time_t now = time(NULL);\n  uint8_t is_reverse = 0;\n  int r;\n  assert_connection_ok(TO_CONN(exitconn), 0);\n  tor_assert(!SOCKET_OK(exitconn->_base.s));\n  assert_cache_ok();\n  tor_assert(oncirc);\n\n  /* first check if exitconn->_base.address is an IP. If so, we already\n   * know the answer. */\n  if (tor_addr_parse(&addr, exitconn->_base.address) >= 0) {\n    if (tor_addr_family(&addr) == AF_INET) {\n      tor_addr_copy(&exitconn->_base.addr, &addr);\n      exitconn->address_ttl = DEFAULT_DNS_TTL;\n      return 1;\n    } else {\n      /* XXXX IPv6 */\n      return -1;\n    }\n  }\n\n  /* If we're a non-exit, don't even do DNS lookups. */\n  if (!(me = router_get_my_routerinfo()) ||\n      policy_is_reject_star(me->exit_policy)) {\n    return -1;\n  }\n  if (address_is_invalid_destination(exitconn->_base.address, 0)) {\n    log(LOG_PROTOCOL_WARN, LD_EXIT,\n        \"Rejecting invalid destination address %s\",\n        escaped_safe_str(exitconn->_base.address));\n    return -1;\n  }\n\n  /* then take this opportunity to see if there are any expired\n   * resolves in the hash table. */\n  purge_expired_resolves(now);\n\n  /* lower-case exitconn->_base.address, so it's in canonical form */\n  tor_strlower(exitconn->_base.address);\n\n  /* Check whether this is a reverse lookup.  If it's malformed, or it's a\n   * .in-addr.arpa address but this isn't a resolve request, kill the\n   * connection.\n   */\n  if ((r = tor_addr_parse_PTR_name(&addr, exitconn->_base.address,\n                                              AF_UNSPEC, 0)) != 0) {\n    if (r == 1) {\n      is_reverse = 1;\n      if (tor_addr_is_internal(&addr, 0)) /* internal address? */\n        return -1;\n    }\n\n    if (!is_reverse || !is_resolve) {\n      if (!is_reverse)\n        log_info(LD_EXIT, \"Bad .in-addr.arpa address \\\"%s\\\"; sending error.\",\n                 escaped_safe_str(exitconn->_base.address));\n      else if (!is_resolve)\n        log_info(LD_EXIT,\n                 \"Attempt to connect to a .in-addr.arpa address \\\"%s\\\"; \"\n                 \"sending error.\",\n                 escaped_safe_str(exitconn->_base.address));\n\n      return -1;\n    }\n    //log_notice(LD_EXIT, \"Looks like an address %s\",\n    //exitconn->_base.address);\n  }\n\n  /* now check the hash table to see if 'address' is already there. */\n  strlcpy(search.address, exitconn->_base.address, sizeof(search.address));\n  resolve = HT_FIND(cache_map, &cache_root, &search);\n  if (resolve && resolve->expire > now) { /* already there */\n    switch (resolve->state) {\n      case CACHE_STATE_PENDING:\n        /* add us to the pending list */\n        pending_connection = tor_malloc_zero(\n                                      sizeof(pending_connection_t));\n        pending_connection->conn = exitconn;\n        pending_connection->next = resolve->pending_connections;\n        resolve->pending_connections = pending_connection;\n        log_debug(LD_EXIT,\"Connection (fd %d) waiting for pending DNS \"\n                  \"resolve of %s\", exitconn->_base.s,\n                  escaped_safe_str(exitconn->_base.address));\n        return 0;\n      case CACHE_STATE_CACHED_VALID:\n        log_debug(LD_EXIT,\"Connection (fd %d) found cached answer for %s\",\n                  exitconn->_base.s,\n                  escaped_safe_str(resolve->address));\n        exitconn->address_ttl = resolve->ttl;\n        if (resolve->is_reverse) {\n          tor_assert(is_resolve);\n          *hostname_out = tor_strdup(resolve->result.hostname);\n        } else {\n          tor_addr_from_ipv4h(&exitconn->_base.addr, resolve->result.a.addr);\n        }\n        return 1;\n      case CACHE_STATE_CACHED_FAILED:\n        log_debug(LD_EXIT,\"Connection (fd %d) found cached error for %s\",\n                  exitconn->_base.s,\n                  escaped_safe_str(exitconn->_base.address));\n        return -1;\n      case CACHE_STATE_DONE:\n        log_err(LD_BUG, \"Found a 'DONE' dns resolve still in the cache.\");\n        tor_fragile_assert();\n    }\n    tor_assert(0);\n  }\n  tor_assert(!resolve);\n  /* not there, need to add it */\n  resolve = tor_malloc_zero(sizeof(cached_resolve_t));\n  resolve->magic = CACHED_RESOLVE_MAGIC;\n  resolve->state = CACHE_STATE_PENDING;\n  resolve->minheap_idx = -1;\n  resolve->is_reverse = is_reverse;\n  strlcpy(resolve->address, exitconn->_base.address, sizeof(resolve->address));\n\n  /* add this connection to the pending list */\n  pending_connection = tor_malloc_zero(sizeof(pending_connection_t));\n  pending_connection->conn = exitconn;\n  resolve->pending_connections = pending_connection;\n\n  /* Add this resolve to the cache and priority queue. */\n  HT_INSERT(cache_map, &cache_root, resolve);\n  set_expiry(resolve, now + RESOLVE_MAX_TIMEOUT);\n\n  log_debug(LD_EXIT,\"Launching %s.\",\n            escaped_safe_str(exitconn->_base.address));\n  assert_cache_ok();\n\n  return launch_resolve(exitconn);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Avoid hard (impossible?)-to-trigger double-free in dns_resolve()\n\nFixes 6480; fix on 0.2.0.1-alpha; based on pseudonymous patch."}
{"func": "dns_resolve(edge_connection_t *exitconn)\n{\n  or_circuit_t *oncirc = TO_OR_CIRCUIT(exitconn->on_circuit);\n  int is_resolve, r;\n  char *hostname = NULL;\n  is_resolve = exitconn->_base.purpose == EXIT_PURPOSE_RESOLVE;\n\n  r = dns_resolve_impl(exitconn, is_resolve, oncirc, &hostname);\n\n  switch (r) {\n    case 1:\n      /* We got an answer without a lookup -- either the answer was\n       * cached, or it was obvious (like an IP address). */\n      if (is_resolve) {\n        /* Send the answer back right now, and detach. */\n        if (hostname)\n          send_resolved_hostname_cell(exitconn, hostname);\n        else\n          send_resolved_cell(exitconn, RESOLVED_TYPE_IPV4);\n        exitconn->on_circuit = NULL;\n      } else {\n        /* Add to the n_streams list; the calling function will send back a\n         * connected cell. */\n        exitconn->next_stream = oncirc->n_streams;\n        oncirc->n_streams = exitconn;\n      }\n      break;\n    case 0:\n      /* The request is pending: add the connection into the linked list of\n       * resolving_streams on this circuit. */\n      exitconn->_base.state = EXIT_CONN_STATE_RESOLVING;\n      exitconn->next_stream = oncirc->resolving_streams;\n      oncirc->resolving_streams = exitconn;\n      break;\n    case -2:\n    case -1:\n      /* The request failed before it could start: cancel this connection,\n       * and stop everybody waiting for the same connection. */\n      if (is_resolve) {\n        send_resolved_cell(exitconn,\n             (r == -1) ? RESOLVED_TYPE_ERROR : RESOLVED_TYPE_ERROR_TRANSIENT);\n      }\n\n      exitconn->on_circuit = NULL;\n\n      dns_cancel_pending_resolve(exitconn->_base.address);\n\n      if (!exitconn->_base.marked_for_close) {\n        connection_free(TO_CONN(exitconn));\n        // XXX ... and we just leak exitconn otherwise? -RD\n        // If it's marked for close, it's on closeable_connection_lst in\n        // main.c.  If it's on the closeable list, it will get freed from\n        // main.c. -NM\n        // \"<armadev> If that's true, there are other bugs around, where we\n        //  don't check if it's marked, and will end up double-freeing.\"\n        // On the other hand, I don't know of any actual bugs here, so this\n        // shouldn't be holding up the rc. -RD\n      }\n      break;\n    default:\n      tor_assert(0);\n  }\n\n  tor_free(hostname);\n  return r;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Avoid hard (impossible?)-to-trigger double-free in dns_resolve()\n\nFixes 6480; fix on 0.2.0.1-alpha; based on pseudonymous patch."}
{"func": "networkstatus_parse_vote_from_string(const char *s, const char **eos_out,\n                                     networkstatus_type_t ns_type)\n{\n  smartlist_t *tokens = smartlist_create();\n  smartlist_t *rs_tokens = NULL, *footer_tokens = NULL;\n  networkstatus_voter_info_t *voter = NULL;\n  networkstatus_t *ns = NULL;\n  digests_t ns_digests;\n  const char *cert, *end_of_header, *end_of_footer, *s_dup = s;\n  directory_token_t *tok;\n  int ok;\n  struct in_addr in;\n  int i, inorder, n_signatures = 0;\n  memarea_t *area = NULL, *rs_area = NULL;\n  consensus_flavor_t flav = FLAV_NS;\n\n  tor_assert(s);\n\n  if (eos_out)\n    *eos_out = NULL;\n\n  if (router_get_networkstatus_v3_hashes(s, &ns_digests)) {\n    log_warn(LD_DIR, \"Unable to compute digest of network-status\");\n    goto err;\n  }\n\n  area = memarea_new();\n  end_of_header = find_start_of_next_routerstatus(s);\n  if (tokenize_string(area, s, end_of_header, tokens,\n                      (ns_type == NS_TYPE_CONSENSUS) ?\n                      networkstatus_consensus_token_table :\n                      networkstatus_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote header\");\n    goto err;\n  }\n\n  ns = tor_malloc_zero(sizeof(networkstatus_t));\n  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));\n\n  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);\n  tor_assert(tok);\n  if (tok->n_args > 1) {\n    int flavor = networkstatus_parse_flavor_name(tok->args[1]);\n    if (flavor < 0) {\n      log_warn(LD_DIR, \"Can't parse document with unknown flavor %s\",\n               escaped(tok->args[2]));\n      goto err;\n    }\n    ns->flavor = flav = flavor;\n  }\n  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {\n    log_warn(LD_DIR, \"Flavor found on non-consensus networkstatus.\");\n    goto err;\n  }\n\n  if (ns_type != NS_TYPE_CONSENSUS) {\n    const char *end_of_cert = NULL;\n    if (!(cert = strstr(s, \"\\ndir-key-certificate-version\")))\n      goto err;\n    ++cert;\n    ns->cert = authority_cert_parse_from_string(cert, &end_of_cert);\n    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)\n      goto err;\n  }\n\n  tok = find_by_keyword(tokens, K_VOTE_STATUS);\n  tor_assert(tok->n_args);\n  if (!strcmp(tok->args[0], \"vote\")) {\n    ns->type = NS_TYPE_VOTE;\n  } else if (!strcmp(tok->args[0], \"consensus\")) {\n    ns->type = NS_TYPE_CONSENSUS;\n  } else if (!strcmp(tok->args[0], \"opinion\")) {\n    ns->type = NS_TYPE_OPINION;\n  } else {\n    log_warn(LD_DIR, \"Unrecognized vote status %s in network-status\",\n             escaped(tok->args[0]));\n    goto err;\n  }\n  if (ns_type != ns->type) {\n    log_warn(LD_DIR, \"Got the wrong kind of v3 networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {\n    tok = find_by_keyword(tokens, K_PUBLISHED);\n    if (parse_iso_time(tok->args[0], &ns->published))\n      goto err;\n\n    ns->supported_methods = smartlist_create();\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);\n    if (tok) {\n      for (i=0; i < tok->n_args; ++i)\n        smartlist_add(ns->supported_methods, tor_strdup(tok->args[i]));\n    } else {\n      smartlist_add(ns->supported_methods, tor_strdup(\"1\"));\n    }\n  } else {\n    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);\n    if (tok) {\n      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,\n                                                 &ok, NULL);\n      if (!ok)\n        goto err;\n    } else {\n      ns->consensus_method = 1;\n    }\n  }\n\n  tok = find_by_keyword(tokens, K_VALID_AFTER);\n  if (parse_iso_time(tok->args[0], &ns->valid_after))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_FRESH_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->fresh_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VALID_UNTIL);\n  if (parse_iso_time(tok->args[0], &ns->valid_until))\n    goto err;\n\n  tok = find_by_keyword(tokens, K_VOTING_DELAY);\n  tor_assert(tok->n_args >= 2);\n  ns->vote_seconds =\n    (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  ns->dist_seconds =\n    (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);\n  if (!ok)\n    goto err;\n  if (ns->valid_after + MIN_VOTE_INTERVAL > ns->fresh_until) {\n    log_warn(LD_DIR, \"Vote/consensus freshness interval is too short\");\n    goto err;\n  }\n  if (ns->valid_after + MIN_VOTE_INTERVAL*2 > ns->valid_until) {\n    log_warn(LD_DIR, \"Vote/consensus liveness interval is too short\");\n    goto err;\n  }\n  if (ns->vote_seconds < MIN_VOTE_SECONDS) {\n    log_warn(LD_DIR, \"Vote seconds is too short\");\n    goto err;\n  }\n  if (ns->dist_seconds < MIN_DIST_SECONDS) {\n    log_warn(LD_DIR, \"Dist seconds is too short\");\n    goto err;\n  }\n\n  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {\n    ns->client_versions = tor_strdup(tok->args[0]);\n  }\n  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {\n    ns->server_versions = tor_strdup(tok->args[0]);\n  }\n\n  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);\n  ns->known_flags = smartlist_create();\n  inorder = 1;\n  for (i = 0; i < tok->n_args; ++i) {\n    smartlist_add(ns->known_flags, tor_strdup(tok->args[i]));\n    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {\n      log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n      inorder = 0;\n    }\n  }\n  if (!inorder) {\n    log_warn(LD_DIR, \"known-flags not in order\");\n    goto err;\n  }\n\n  tok = find_opt_by_keyword(tokens, K_PARAMS);\n  if (tok) {\n    inorder = 1;\n    ns->net_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {\n        log_warn(LD_DIR, \"%s >= %s\", tok->args[i-1], tok->args[i]);\n        inorder = 0;\n      }\n      smartlist_add(ns->net_params, tor_strdup(tok->args[i]));\n    }\n    if (!inorder) {\n      log_warn(LD_DIR, \"params not in order\");\n      goto err;\n    }\n  }\n\n  ns->voters = smartlist_create();\n\n  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {\n    tok = _tok;\n    if (tok->tp == K_DIR_SOURCE) {\n      tor_assert(tok->n_args >= 6);\n\n      if (voter)\n        smartlist_add(ns->voters, voter);\n      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));\n      voter->sigs = smartlist_create();\n      if (ns->type != NS_TYPE_CONSENSUS)\n        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);\n\n      voter->nickname = tor_strdup(tok->args[0]);\n      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||\n          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),\n                        tok->args[1], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding identity digest %s in \"\n                 \"network-status vote.\", escaped(tok->args[1]));\n        goto err;\n      }\n      if (ns->type != NS_TYPE_CONSENSUS &&\n          tor_memneq(ns->cert->cache_info.identity_digest,\n                 voter->identity_digest, DIGEST_LEN)) {\n        log_warn(LD_DIR,\"Mismatch between identities in certificate and vote\");\n        goto err;\n      }\n      voter->address = tor_strdup(tok->args[2]);\n      if (!tor_inet_aton(tok->args[3], &in)) {\n        log_warn(LD_DIR, \"Error decoding IP address %s in network-status.\",\n                 escaped(tok->args[3]));\n        goto err;\n      }\n      voter->addr = ntohl(in.s_addr);\n      voter->dir_port = (uint16_t)\n        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n      voter->or_port = (uint16_t)\n        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);\n      if (!ok)\n        goto err;\n    } else if (tok->tp == K_CONTACT) {\n      if (!voter || voter->contact) {\n        log_warn(LD_DIR, \"contact element is out of place.\");\n        goto err;\n      }\n      voter->contact = tor_strdup(tok->args[0]);\n    } else if (tok->tp == K_VOTE_DIGEST) {\n      tor_assert(ns->type == NS_TYPE_CONSENSUS);\n      tor_assert(tok->n_args >= 1);\n      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {\n        log_warn(LD_DIR, \"vote-digest element is out of place.\");\n        goto err;\n      }\n      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||\n        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),\n                      tok->args[0], HEX_DIGEST_LEN) < 0) {\n        log_warn(LD_DIR, \"Error decoding vote digest %s in \"\n                 \"network-status consensus.\", escaped(tok->args[0]));\n        goto err;\n      }\n    }\n  } SMARTLIST_FOREACH_END(_tok);\n  if (voter) {\n    smartlist_add(ns->voters, voter);\n    voter = NULL;\n  }\n  if (smartlist_len(ns->voters) == 0) {\n    log_warn(LD_DIR, \"Missing dir-source elements in a vote networkstatus.\");\n    goto err;\n  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {\n    log_warn(LD_DIR, \"Too many dir-source elements in a vote networkstatus.\");\n    goto err;\n  }\n\n  if (ns->type != NS_TYPE_CONSENSUS &&\n      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {\n    int bad = 1;\n    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {\n      networkstatus_voter_info_t *voter = smartlist_get(ns->voters, 0);\n      if (base16_decode(voter->legacy_id_digest, DIGEST_LEN,\n                        tok->args[0], HEX_DIGEST_LEN)<0)\n        bad = 1;\n      else\n        bad = 0;\n    }\n    if (bad) {\n      log_warn(LD_DIR, \"Invalid legacy key digest %s on vote.\",\n               escaped(tok->args[0]));\n    }\n  }\n\n  /* Parse routerstatus lines. */\n  rs_tokens = smartlist_create();\n  rs_area = memarea_new();\n  s = end_of_header;\n  ns->routerstatus_list = smartlist_create();\n\n  while (!strcmpstart(s, \"r \")) {\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *rs = tor_malloc_zero(sizeof(vote_routerstatus_t));\n      if (routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens, ns,\n                                               rs, 0, 0))\n        smartlist_add(ns->routerstatus_list, rs);\n      else {\n        tor_free(rs->version);\n        tor_free(rs);\n      }\n    } else {\n      routerstatus_t *rs;\n      if ((rs = routerstatus_parse_entry_from_string(rs_area, &s, rs_tokens,\n                                                     NULL, NULL,\n                                                     ns->consensus_method,\n                                                     flav)))\n        smartlist_add(ns->routerstatus_list, rs);\n    }\n  }\n  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {\n    routerstatus_t *rs1, *rs2;\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);\n      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);\n      rs1 = &a->status; rs2 = &b->status;\n    } else {\n      rs1 = smartlist_get(ns->routerstatus_list, i-1);\n      rs2 = smartlist_get(ns->routerstatus_list, i);\n    }\n    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)\n        >= 0) {\n      log_warn(LD_DIR, \"Vote networkstatus entries not sorted by identity \"\n               \"digest\");\n      goto err;\n    }\n  }\n\n  /* Parse footer; check signature. */\n  footer_tokens = smartlist_create();\n  if ((end_of_footer = strstr(s, \"\\nnetwork-status-version \")))\n    ++end_of_footer;\n  else\n    end_of_footer = s + strlen(s);\n  if (tokenize_string(area,s, end_of_footer, footer_tokens,\n                      networkstatus_vote_footer_token_table, 0)) {\n    log_warn(LD_DIR, \"Error tokenizing network-status vote footer.\");\n    goto err;\n  }\n\n  {\n    int found_sig = 0;\n    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n      tok = _tok;\n      if (tok->tp == K_DIRECTORY_SIGNATURE)\n        found_sig = 1;\n      else if (found_sig) {\n        log_warn(LD_DIR, \"Extraneous token after first directory-signature\");\n        goto err;\n      }\n    } SMARTLIST_FOREACH_END(_tok);\n  }\n\n  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {\n    if (tok != smartlist_get(footer_tokens, 0)) {\n      log_warn(LD_DIR, \"Misplaced directory-footer token\");\n      goto err;\n    }\n  }\n\n  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);\n  if (tok) {\n    ns->weight_params = smartlist_create();\n    for (i = 0; i < tok->n_args; ++i) {\n      int ok=0;\n      char *eq = strchr(tok->args[i], '=');\n      if (!eq) {\n        log_warn(LD_DIR, \"Bad element '%s' in weight params\",\n                 escaped(tok->args[i]));\n        goto err;\n      }\n      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);\n      if (!ok) {\n        log_warn(LD_DIR, \"Bad element '%s' in params\", escaped(tok->args[i]));\n        goto err;\n      }\n      smartlist_add(ns->weight_params, tor_strdup(tok->args[i]));\n    }\n  }\n\n  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {\n    char declared_identity[DIGEST_LEN];\n    networkstatus_voter_info_t *v;\n    document_signature_t *sig;\n    const char *id_hexdigest = NULL;\n    const char *sk_hexdigest = NULL;\n    digest_algorithm_t alg = DIGEST_SHA1;\n    tok = _tok;\n    if (tok->tp != K_DIRECTORY_SIGNATURE)\n      continue;\n    tor_assert(tok->n_args >= 2);\n    if (tok->n_args == 2) {\n      id_hexdigest = tok->args[0];\n      sk_hexdigest = tok->args[1];\n    } else {\n      const char *algname = tok->args[0];\n      int a;\n      id_hexdigest = tok->args[1];\n      sk_hexdigest = tok->args[2];\n      a = crypto_digest_algorithm_parse_name(algname);\n      if (a<0) {\n        log_warn(LD_DIR, \"Unknown digest algorithm %s; skipping\",\n                 escaped(algname));\n        continue;\n      }\n      alg = a;\n    }\n\n    if (!tok->object_type ||\n        strcmp(tok->object_type, \"SIGNATURE\") ||\n        tok->object_size < 128 || tok->object_size > 512) {\n      log_warn(LD_DIR, \"Bad object type or length on directory-signature\");\n      goto err;\n    }\n\n    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(declared_identity, sizeof(declared_identity),\n                      id_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared identity %s in \"\n               \"network-status vote.\", escaped(id_hexdigest));\n      goto err;\n    }\n    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {\n      log_warn(LD_DIR, \"ID on signature on network-status vote does not match \"\n               \"any declared directory source.\");\n      goto err;\n    }\n    sig = tor_malloc_zero(sizeof(document_signature_t));\n    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);\n    sig->alg = alg;\n    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||\n        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),\n                      sk_hexdigest, HEX_DIGEST_LEN) < 0) {\n      log_warn(LD_DIR, \"Error decoding declared signing key digest %s in \"\n               \"network-status vote.\", escaped(sk_hexdigest));\n      tor_free(sig);\n      goto err;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,\n                 DIGEST_LEN)) {\n        log_warn(LD_DIR, \"Digest mismatch between declared and actual on \"\n                 \"network-status vote.\");\n        tor_free(sig);\n        goto err;\n      }\n    }\n\n    if (voter_get_sig_by_algorithm(v, sig->alg)) {\n      /* We already parsed a vote with this algorithm from this voter. Use the\n         first one. */\n      log_fn(LOG_PROTOCOL_WARN, LD_DIR, \"We received a networkstatus \"\n             \"that contains two votes from the same voter with the same \"\n             \"algorithm. Ignoring the second vote.\");\n      tor_free(sig);\n      continue;\n    }\n\n    if (ns->type != NS_TYPE_CONSENSUS) {\n      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,\n                                tok, ns->cert->signing_key, 0,\n                                \"network-status vote\")) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->good_signature = 1;\n    } else {\n      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {\n        tor_free(sig);\n        goto err;\n      }\n      sig->signature = tor_memdup(tok->object_body, tok->object_size);\n      sig->signature_len = (int) tok->object_size;\n    }\n    smartlist_add(v->sigs, sig);\n\n    ++n_signatures;\n  } SMARTLIST_FOREACH_END(_tok);\n\n  if (! n_signatures) {\n    log_warn(LD_DIR, \"No signatures on networkstatus vote.\");\n    goto err;\n  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {\n    log_warn(LD_DIR, \"Received more than one signature on a \"\n             \"network-status vote.\");\n    goto err;\n  }\n\n  if (eos_out)\n    *eos_out = end_of_footer;\n\n  goto done;\n err:\n  dump_desc(s_dup, \"v3 networkstatus\");\n  networkstatus_vote_free(ns);\n  ns = NULL;\n done:\n  if (tokens) {\n    SMARTLIST_FOREACH(tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(tokens);\n  }\n  if (voter) {\n    if (voter->sigs) {\n      SMARTLIST_FOREACH(voter->sigs, document_signature_t *, sig,\n                        document_signature_free(sig));\n      smartlist_free(voter->sigs);\n    }\n    tor_free(voter->nickname);\n    tor_free(voter->address);\n    tor_free(voter->contact);\n    tor_free(voter);\n  }\n  if (rs_tokens) {\n    SMARTLIST_FOREACH(rs_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(rs_tokens);\n  }\n  if (footer_tokens) {\n    SMARTLIST_FOREACH(footer_tokens, directory_token_t *, t, token_clear(t));\n    smartlist_free(footer_tokens);\n  }\n  if (area) {\n    DUMP_AREA(area, \"v3 networkstatus\");\n    memarea_drop_all(area);\n  }\n  if (rs_area)\n    memarea_drop_all(rs_area);\n\n  return ns;\n}", "target": 1, "cwe": ["CWE-399"], "message": "Avoid possible segfault when handling networkstatus vote with bad flavor\n\nFix for 6530; fix on 0.2.2.6-alpha."}
{"func": "smartlist_choose_by_bandwidth(smartlist_t *sl, bandwidth_weight_rule_t rule,\n                              int statuses)\n{\n  unsigned int i;\n  routerinfo_t *router;\n  routerstatus_t *status=NULL;\n  int32_t *bandwidths;\n  int is_exit;\n  int is_guard;\n  uint64_t total_nonexit_bw = 0, total_exit_bw = 0, total_bw = 0;\n  uint64_t total_nonguard_bw = 0, total_guard_bw = 0;\n  uint64_t rand_bw, tmp;\n  double exit_weight;\n  double guard_weight;\n  int n_unknown = 0;\n  bitarray_t *exit_bits;\n  bitarray_t *guard_bits;\n  int me_idx = -1;\n\n  // This function does not support WEIGHT_FOR_DIR\n  // or WEIGHT_FOR_MID\n  if (rule == WEIGHT_FOR_DIR || rule == WEIGHT_FOR_MID) {\n    rule = NO_WEIGHTING;\n  }\n\n  /* Can't choose exit and guard at same time */\n  tor_assert(rule == NO_WEIGHTING ||\n             rule == WEIGHT_FOR_EXIT ||\n             rule == WEIGHT_FOR_GUARD);\n\n  if (smartlist_len(sl) == 0) {\n    log_info(LD_CIRC,\n             \"Empty routerlist passed in to old node selection for rule %s\",\n             bandwidth_weight_rule_to_string(rule));\n    return NULL;\n  }\n\n  /* First count the total bandwidth weight, and make a list\n   * of each value.  <0 means \"unknown; no routerinfo.\"  We use the\n   * bits of negative values to remember whether the router was fast (-x)&1\n   * and whether it was an exit (-x)&2 or guard (-x)&4.  Yes, it's a hack. */\n  bandwidths = tor_malloc(sizeof(int32_t)*smartlist_len(sl));\n  exit_bits = bitarray_init_zero(smartlist_len(sl));\n  guard_bits = bitarray_init_zero(smartlist_len(sl));\n\n  /* Iterate over all the routerinfo_t or routerstatus_t, and */\n  for (i = 0; i < (unsigned)smartlist_len(sl); ++i) {\n    /* first, learn what bandwidth we think i has */\n    int is_known = 1;\n    int32_t flags = 0;\n    uint32_t this_bw = 0;\n    if (statuses) {\n      status = smartlist_get(sl, i);\n      if (router_digest_is_me(status->identity_digest))\n        me_idx = i;\n      router = router_get_by_digest(status->identity_digest);\n      is_exit = status->is_exit;\n      is_guard = status->is_possible_guard;\n      if (status->has_bandwidth) {\n        this_bw = kb_to_bytes(status->bandwidth);\n      } else { /* guess */\n        /* XXX023 once consensuses always list bandwidths, we can take\n         * this guessing business out. -RD */\n        is_known = 0;\n        flags = status->is_fast ? 1 : 0;\n        flags |= is_exit ? 2 : 0;\n        flags |= is_guard ? 4 : 0;\n      }\n    } else {\n      routerstatus_t *rs;\n      router = smartlist_get(sl, i);\n      rs = router_get_consensus_status_by_id(\n             router->cache_info.identity_digest);\n      if (router_digest_is_me(router->cache_info.identity_digest))\n        me_idx = i;\n      is_exit = router->is_exit;\n      is_guard = router->is_possible_guard;\n      if (rs && rs->has_bandwidth) {\n        this_bw = kb_to_bytes(rs->bandwidth);\n      } else if (rs) { /* guess; don't trust the descriptor */\n        /* XXX023 once consensuses always list bandwidths, we can take\n         * this guessing business out. -RD */\n        is_known = 0;\n        flags = router->is_fast ? 1 : 0;\n        flags |= is_exit ? 2 : 0;\n        flags |= is_guard ? 4 : 0;\n      } else /* bridge or other descriptor not in our consensus */\n        this_bw = bridge_get_advertised_bandwidth_bounded(router);\n    }\n    if (is_exit)\n      bitarray_set(exit_bits, i);\n    if (is_guard)\n      bitarray_set(guard_bits, i);\n    if (is_known) {\n      bandwidths[i] = (int32_t) this_bw; // safe since MAX_BELIEVABLE<INT32_MAX\n      // XXX this is no longer true! We don't always cap the bw anymore. Can\n      // a consensus make us overflow?-sh\n      tor_assert(bandwidths[i] >= 0);\n      if (is_guard)\n        total_guard_bw += this_bw;\n      else\n        total_nonguard_bw += this_bw;\n      if (is_exit)\n        total_exit_bw += this_bw;\n      else\n        total_nonexit_bw += this_bw;\n    } else {\n      ++n_unknown;\n      bandwidths[i] = -flags;\n    }\n  }\n\n  /* Now, fill in the unknown values. */\n  if (n_unknown) {\n    int32_t avg_fast, avg_slow;\n    if (total_exit_bw+total_nonexit_bw) {\n      /* if there's some bandwidth, there's at least one known router,\n       * so no worries about div by 0 here */\n      int n_known = smartlist_len(sl)-n_unknown;\n      avg_fast = avg_slow = (int32_t)\n        ((total_exit_bw+total_nonexit_bw)/((uint64_t) n_known));\n    } else {\n      avg_fast = 40000;\n      avg_slow = 20000;\n    }\n    for (i=0; i<(unsigned)smartlist_len(sl); ++i) {\n      int32_t bw = bandwidths[i];\n      if (bw>=0)\n        continue;\n      is_exit = ((-bw)&2);\n      is_guard = ((-bw)&4);\n      bandwidths[i] = ((-bw)&1) ? avg_fast : avg_slow;\n      if (is_exit)\n        total_exit_bw += bandwidths[i];\n      else\n        total_nonexit_bw += bandwidths[i];\n      if (is_guard)\n        total_guard_bw += bandwidths[i];\n      else\n        total_nonguard_bw += bandwidths[i];\n    }\n  }\n\n  /* If there's no bandwidth at all, pick at random. */\n  if (!(total_exit_bw+total_nonexit_bw)) {\n    tor_free(bandwidths);\n    tor_free(exit_bits);\n    tor_free(guard_bits);\n    return smartlist_choose(sl);\n  }\n\n  /* Figure out how to weight exits and guards */\n  {\n    double all_bw = U64_TO_DBL(total_exit_bw+total_nonexit_bw);\n    double exit_bw = U64_TO_DBL(total_exit_bw);\n    double guard_bw = U64_TO_DBL(total_guard_bw);\n    /*\n     * For detailed derivation of this formula, see\n     *   http://archives.seul.org/or/dev/Jul-2007/msg00056.html\n     */\n    if (rule == WEIGHT_FOR_EXIT || !total_exit_bw)\n      exit_weight = 1.0;\n    else\n      exit_weight = 1.0 - all_bw/(3.0*exit_bw);\n\n    if (rule == WEIGHT_FOR_GUARD || !total_guard_bw)\n      guard_weight = 1.0;\n    else\n      guard_weight = 1.0 - all_bw/(3.0*guard_bw);\n\n    if (exit_weight <= 0.0)\n      exit_weight = 0.0;\n\n    if (guard_weight <= 0.0)\n      guard_weight = 0.0;\n\n    total_bw = 0;\n    sl_last_weighted_bw_of_me = 0;\n    for (i=0; i < (unsigned)smartlist_len(sl); i++) {\n      uint64_t bw;\n      is_exit = bitarray_is_set(exit_bits, i);\n      is_guard = bitarray_is_set(guard_bits, i);\n      if (is_exit && is_guard)\n        bw = ((uint64_t)(bandwidths[i] * exit_weight * guard_weight));\n      else if (is_guard)\n        bw = ((uint64_t)(bandwidths[i] * guard_weight));\n      else if (is_exit)\n        bw = ((uint64_t)(bandwidths[i] * exit_weight));\n      else\n        bw = bandwidths[i];\n      total_bw += bw;\n      if (i == (unsigned) me_idx)\n        sl_last_weighted_bw_of_me = bw;\n    }\n  }\n\n  /* XXXX023 this is a kludge to expose these values. */\n  sl_last_total_weighted_bw = total_bw;\n\n  log_debug(LD_CIRC, \"Total weighted bw = \"U64_FORMAT\n            \", exit bw = \"U64_FORMAT\n            \", nonexit bw = \"U64_FORMAT\", exit weight = %f \"\n            \"(for exit == %d)\"\n            \", guard bw = \"U64_FORMAT\n            \", nonguard bw = \"U64_FORMAT\", guard weight = %f \"\n            \"(for guard == %d)\",\n            U64_PRINTF_ARG(total_bw),\n            U64_PRINTF_ARG(total_exit_bw), U64_PRINTF_ARG(total_nonexit_bw),\n            exit_weight, (int)(rule == WEIGHT_FOR_EXIT),\n            U64_PRINTF_ARG(total_guard_bw), U64_PRINTF_ARG(total_nonguard_bw),\n            guard_weight, (int)(rule == WEIGHT_FOR_GUARD));\n\n  /* Almost done: choose a random value from the bandwidth weights. */\n  rand_bw = crypto_rand_uint64(total_bw);\n  rand_bw++; /* crypto_rand_uint64() counts from 0, and we need to count\n              * from 1 below. See bug 1203 for details. */\n\n  /* Last, count through sl until we get to the element we picked */\n  tmp = 0;\n  for (i=0; i < (unsigned)smartlist_len(sl); i++) {\n    is_exit = bitarray_is_set(exit_bits, i);\n    is_guard = bitarray_is_set(guard_bits, i);\n\n    /* Weights can be 0 if not counting guards/exits */\n    if (is_exit && is_guard)\n      tmp += ((uint64_t)(bandwidths[i] * exit_weight * guard_weight));\n    else if (is_guard)\n      tmp += ((uint64_t)(bandwidths[i] * guard_weight));\n    else if (is_exit)\n      tmp += ((uint64_t)(bandwidths[i] * exit_weight));\n    else\n      tmp += bandwidths[i];\n\n    if (tmp >= rand_bw)\n      break;\n  }\n  if (i == (unsigned)smartlist_len(sl)) {\n    /* This was once possible due to round-off error, but shouldn't be able\n     * to occur any longer. */\n    tor_fragile_assert();\n    --i;\n    log_warn(LD_BUG, \"Round-off error in computing bandwidth had an effect on \"\n             \" which router we chose. Please tell the developers. \"\n             U64_FORMAT \" \" U64_FORMAT \" \" U64_FORMAT, U64_PRINTF_ARG(tmp),\n             U64_PRINTF_ARG(rand_bw), U64_PRINTF_ARG(total_bw));\n  }\n  tor_free(bandwidths);\n  tor_free(exit_bits);\n  tor_free(guard_bits);\n  return smartlist_get(sl, i);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Mitigate a side-channel leak of which relays Tor chooses for a circuit\n\nTor's and OpenSSL's current design guarantee that there are other leaks,\nbut this one is likely to be more easily exploitable, and is easy to fix."}
{"func": "smartlist_choose_by_bandwidth_weights(smartlist_t *sl,\n                                      bandwidth_weight_rule_t rule,\n                                      int statuses)\n{\n  int64_t weight_scale;\n  int64_t rand_bw;\n  double Wg = -1, Wm = -1, We = -1, Wd = -1;\n  double Wgb = -1, Wmb = -1, Web = -1, Wdb = -1;\n  double weighted_bw = 0;\n  double *bandwidths;\n  double tmp = 0;\n  unsigned int i;\n  int have_unknown = 0; /* true iff sl contains element not in consensus. */\n\n  /* Can't choose exit and guard at same time */\n  tor_assert(rule == NO_WEIGHTING ||\n             rule == WEIGHT_FOR_EXIT ||\n             rule == WEIGHT_FOR_GUARD ||\n             rule == WEIGHT_FOR_MID ||\n             rule == WEIGHT_FOR_DIR);\n\n  if (smartlist_len(sl) == 0) {\n    log_info(LD_CIRC,\n             \"Empty routerlist passed in to consensus weight node \"\n             \"selection for rule %s\",\n             bandwidth_weight_rule_to_string(rule));\n    return NULL;\n  }\n\n  weight_scale = circuit_build_times_get_bw_scale(NULL);\n\n  if (rule == WEIGHT_FOR_GUARD) {\n    Wg = networkstatus_get_bw_weight(NULL, \"Wgg\", -1);\n    Wm = networkstatus_get_bw_weight(NULL, \"Wgm\", -1); /* Bridges */\n    We = 0;\n    Wd = networkstatus_get_bw_weight(NULL, \"Wgd\", -1);\n\n    Wgb = networkstatus_get_bw_weight(NULL, \"Wgb\", -1);\n    Wmb = networkstatus_get_bw_weight(NULL, \"Wmb\", -1);\n    Web = networkstatus_get_bw_weight(NULL, \"Web\", -1);\n    Wdb = networkstatus_get_bw_weight(NULL, \"Wdb\", -1);\n  } else if (rule == WEIGHT_FOR_MID) {\n    Wg = networkstatus_get_bw_weight(NULL, \"Wmg\", -1);\n    Wm = networkstatus_get_bw_weight(NULL, \"Wmm\", -1);\n    We = networkstatus_get_bw_weight(NULL, \"Wme\", -1);\n    Wd = networkstatus_get_bw_weight(NULL, \"Wmd\", -1);\n\n    Wgb = networkstatus_get_bw_weight(NULL, \"Wgb\", -1);\n    Wmb = networkstatus_get_bw_weight(NULL, \"Wmb\", -1);\n    Web = networkstatus_get_bw_weight(NULL, \"Web\", -1);\n    Wdb = networkstatus_get_bw_weight(NULL, \"Wdb\", -1);\n  } else if (rule == WEIGHT_FOR_EXIT) {\n    // Guards CAN be exits if they have weird exit policies\n    // They are d then I guess...\n    We = networkstatus_get_bw_weight(NULL, \"Wee\", -1);\n    Wm = networkstatus_get_bw_weight(NULL, \"Wem\", -1); /* Odd exit policies */\n    Wd = networkstatus_get_bw_weight(NULL, \"Wed\", -1);\n    Wg = networkstatus_get_bw_weight(NULL, \"Weg\", -1); /* Odd exit policies */\n\n    Wgb = networkstatus_get_bw_weight(NULL, \"Wgb\", -1);\n    Wmb = networkstatus_get_bw_weight(NULL, \"Wmb\", -1);\n    Web = networkstatus_get_bw_weight(NULL, \"Web\", -1);\n    Wdb = networkstatus_get_bw_weight(NULL, \"Wdb\", -1);\n  } else if (rule == WEIGHT_FOR_DIR) {\n    We = networkstatus_get_bw_weight(NULL, \"Wbe\", -1);\n    Wm = networkstatus_get_bw_weight(NULL, \"Wbm\", -1);\n    Wd = networkstatus_get_bw_weight(NULL, \"Wbd\", -1);\n    Wg = networkstatus_get_bw_weight(NULL, \"Wbg\", -1);\n\n    Wgb = Wmb = Web = Wdb = weight_scale;\n  } else if (rule == NO_WEIGHTING) {\n    Wg = Wm = We = Wd = weight_scale;\n    Wgb = Wmb = Web = Wdb = weight_scale;\n  }\n\n  if (Wg < 0 || Wm < 0 || We < 0 || Wd < 0 || Wgb < 0 || Wmb < 0 || Wdb < 0\n      || Web < 0) {\n    log_debug(LD_CIRC,\n              \"Got negative bandwidth weights. Defaulting to old selection\"\n              \" algorithm.\");\n    return NULL; // Use old algorithm.\n  }\n\n  Wg /= weight_scale;\n  Wm /= weight_scale;\n  We /= weight_scale;\n  Wd /= weight_scale;\n\n  Wgb /= weight_scale;\n  Wmb /= weight_scale;\n  Web /= weight_scale;\n  Wdb /= weight_scale;\n\n  bandwidths = tor_malloc_zero(sizeof(double)*smartlist_len(sl));\n\n  // Cycle through smartlist and total the bandwidth.\n  for (i = 0; i < (unsigned)smartlist_len(sl); ++i) {\n    int is_exit = 0, is_guard = 0, is_dir = 0, this_bw = 0, is_me = 0;\n    double weight = 1;\n    if (statuses) {\n      routerstatus_t *status = smartlist_get(sl, i);\n      is_exit = status->is_exit && !status->is_bad_exit;\n      is_guard = status->is_possible_guard;\n      is_dir = (status->dir_port != 0);\n      if (!status->has_bandwidth) {\n        tor_free(bandwidths);\n        /* This should never happen, unless all the authorites downgrade\n         * to 0.2.0 or rogue routerstatuses get inserted into our consensus. */\n        log_warn(LD_BUG,\n                 \"Consensus is not listing bandwidths. Defaulting back to \"\n                 \"old router selection algorithm.\");\n        return NULL;\n      }\n      this_bw = kb_to_bytes(status->bandwidth);\n      if (router_digest_is_me(status->identity_digest))\n        is_me = 1;\n    } else {\n      routerstatus_t *rs;\n      routerinfo_t *router = smartlist_get(sl, i);\n      rs = router_get_consensus_status_by_id(\n             router->cache_info.identity_digest);\n      is_exit = router->is_exit && !router->is_bad_exit;\n      is_guard = router->is_possible_guard;\n      is_dir = (router->dir_port != 0);\n      if (rs && rs->has_bandwidth) {\n        this_bw = kb_to_bytes(rs->bandwidth);\n      } else { /* bridge or other descriptor not in our consensus */\n        this_bw = bridge_get_advertised_bandwidth_bounded(router);\n        have_unknown = 1;\n      }\n      if (router_digest_is_me(router->cache_info.identity_digest))\n        is_me = 1;\n    }\n    if (is_guard && is_exit) {\n      weight = (is_dir ? Wdb*Wd : Wd);\n    } else if (is_guard) {\n      weight = (is_dir ? Wgb*Wg : Wg);\n    } else if (is_exit) {\n      weight = (is_dir ? Web*We : We);\n    } else { // middle\n      weight = (is_dir ? Wmb*Wm : Wm);\n    }\n\n    bandwidths[i] = weight*this_bw;\n    weighted_bw += weight*this_bw;\n    if (is_me)\n      sl_last_weighted_bw_of_me = weight*this_bw;\n  }\n\n  /* XXXX023 this is a kludge to expose these values. */\n  sl_last_total_weighted_bw = weighted_bw;\n\n  log_debug(LD_CIRC, \"Choosing node for rule %s based on weights \"\n            \"Wg=%f Wm=%f We=%f Wd=%f with total bw %f\",\n            bandwidth_weight_rule_to_string(rule),\n            Wg, Wm, We, Wd, weighted_bw);\n\n  /* If there is no bandwidth, choose at random */\n  if (DBL_TO_U64(weighted_bw) == 0) {\n    /* Don't warn when using bridges/relays not in the consensus */\n    if (!have_unknown)\n      log_warn(LD_CIRC,\n               \"Weighted bandwidth is %f in node selection for rule %s\",\n               weighted_bw, bandwidth_weight_rule_to_string(rule));\n    tor_free(bandwidths);\n    return smartlist_choose(sl);\n  }\n\n  rand_bw = crypto_rand_uint64(DBL_TO_U64(weighted_bw));\n  rand_bw++; /* crypto_rand_uint64() counts from 0, and we need to count\n              * from 1 below. See bug 1203 for details. */\n\n  /* Last, count through sl until we get to the element we picked */\n  tmp = 0.0;\n  for (i=0; i < (unsigned)smartlist_len(sl); i++) {\n    tmp += bandwidths[i];\n    if (tmp >= rand_bw)\n      break;\n  }\n\n  if (i == (unsigned)smartlist_len(sl)) {\n    /* This was once possible due to round-off error, but shouldn't be able\n     * to occur any longer. */\n    tor_fragile_assert();\n    --i;\n    log_warn(LD_BUG, \"Round-off error in computing bandwidth had an effect on \"\n             \" which router we chose. Please tell the developers. \"\n             \"%f \" U64_FORMAT \" %f\", tmp, U64_PRINTF_ARG(rand_bw),\n             weighted_bw);\n  }\n  tor_free(bandwidths);\n  return smartlist_get(sl, i);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Mitigate a side-channel leak of which relays Tor chooses for a circuit\n\nTor's and OpenSSL's current design guarantee that there are other leaks,\nbut this one is likely to be more easily exploitable, and is easy to fix."}
{"func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm) {\n\t\tsiocb->scm = &scm;\n\t\tmemset(&scm, 0, sizeof(scm));\n\t}\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)\n{\n\tint err = 0;\n\tUNIXCB(skb).pid  = get_pid(scm->pid);\n\tUNIXCB(skb).cred = get_cred(scm->cred);\n\tUNIXCB(skb).fp = NULL;\n\tif (scm->fp && send_fds)\n\t\terr = unix_attach_fds(scm, skb);\n\n\tskb->destructor = unix_destruct_scm;\n\treturn err;\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p)\n{\n\tstruct cmsghdr *cmsg;\n\tint err;\n\n\tfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))\n\t{\n\t\terr = -EINVAL;\n\n\t\t/* Verify that cmsg_len is at least sizeof(struct cmsghdr) */\n\t\t/* The first check was omitted in <= 2.2.5. The reasoning was\n\t\t   that parser checks cmsg_len in any case, so that\n\t\t   additional check would be work duplication.\n\t\t   But if cmsg_level is not SOL_SOCKET, we do not check\n\t\t   for too short ancillary data object at all! Oops.\n\t\t   OK, let's add it...\n\t\t */\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\tgoto error;\n\n\t\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type)\n\t\t{\n\t\tcase SCM_RIGHTS:\n\t\t\tif (!sock->ops || sock->ops->family != PF_UNIX)\n\t\t\t\tgoto error;\n\t\t\terr=scm_fp_copy(cmsg, &p->fp);\n\t\t\tif (err<0)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase SCM_CREDENTIALS:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct ucred)))\n\t\t\t\tgoto error;\n\t\t\tmemcpy(&p->creds, CMSG_DATA(cmsg), sizeof(struct ucred));\n\t\t\terr = scm_check_creds(&p->creds);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\tif (pid_vnr(p->pid) != p->creds.pid) {\n\t\t\t\tstruct pid *pid;\n\t\t\t\terr = -ESRCH;\n\t\t\t\tpid = find_get_pid(p->creds.pid);\n\t\t\t\tif (!pid)\n\t\t\t\t\tgoto error;\n\t\t\t\tput_pid(p->pid);\n\t\t\t\tp->pid = pid;\n\t\t\t}\n\n\t\t\tif ((p->cred->euid != p->creds.uid) ||\n\t\t\t\t(p->cred->egid != p->creds.gid)) {\n\t\t\t\tstruct cred *cred;\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tcred = prepare_creds();\n\t\t\t\tif (!cred)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tcred->uid = cred->euid = p->creds.uid;\n\t\t\t\tcred->gid = cred->egid = p->creds.gid;\n\t\t\t\tput_cred(p->cred);\n\t\t\t\tp->cred = cred;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (p->fp && !p->fp->count)\n\t{\n\t\tkfree(p->fp);\n\t\tp->fp = NULL;\n\t}\n\treturn 0;\n\nerror:\n\tscm_destroy(p);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(siocb->scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_reset_transport_header(skb);\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = get_cred(cred);\n\tcred_to_ucred(pid, cred, &scm->creds);\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tscm_set_cred(scm, task_tgid(current), current_cred());\n\tscm->fp = NULL;\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1, "cwe": [], "message": "af_unix: dont send SCM_CREDENTIALS by default\n\nSince commit 7361c36c5224 (af_unix: Allow credentials to work across\nuser and pid namespaces) af_unix performance dropped a lot.\n\nThis is because we now take a reference on pid and cred in each write(),\nand release them in read(), usually done from another process,\neventually from another cpu. This triggers false sharing.\n\n# Events: 154K cycles\n#\n# Overhead  Command       Shared Object        Symbol\n# ........  .......  ..................  .........................\n#\n    10.40%  hackbench  [kernel.kallsyms]   [k] put_pid\n     8.60%  hackbench  [kernel.kallsyms]   [k] unix_stream_recvmsg\n     7.87%  hackbench  [kernel.kallsyms]   [k] unix_stream_sendmsg\n     6.11%  hackbench  [kernel.kallsyms]   [k] do_raw_spin_lock\n     4.95%  hackbench  [kernel.kallsyms]   [k] unix_scm_to_skb\n     4.87%  hackbench  [kernel.kallsyms]   [k] pid_nr_ns\n     4.34%  hackbench  [kernel.kallsyms]   [k] cred_to_ucred\n     2.39%  hackbench  [kernel.kallsyms]   [k] unix_destruct_scm\n     2.24%  hackbench  [kernel.kallsyms]   [k] sub_preempt_count\n     1.75%  hackbench  [kernel.kallsyms]   [k] fget_light\n     1.51%  hackbench  [kernel.kallsyms]   [k]\n__mutex_lock_interruptible_slowpath\n     1.42%  hackbench  [kernel.kallsyms]   [k] sock_alloc_send_pskb\n\nThis patch includes SCM_CREDENTIALS information in a af_unix message/skb\nonly if requested by the sender, [man 7 unix for details how to include\nancillary data using sendmsg() system call]\n\nNote: This might break buggy applications that expected SCM_CREDENTIAL\nfrom an unaware write() system call, and receiver not using SO_PASSCRED\nsocket option.\n\nIf SOCK_PASSCRED is set on source or destination socket, we still\ninclude credentials for mere write() syscalls.\n\nPerformance boost in hackbench : more than 50% gain on a 16 thread\nmachine (2 quad-core cpus, 2 threads per core)\n\nhackbench 20 thread 2000\n\n4.228 sec instead of 9.102 sec\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1, "cwe": ["CWE-287", "CWE-284"], "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-287", "CWE-284"], "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned int hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\tint max_level;\n\tint data_len = 0;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tif (len > SKB_MAX_ALLOC)\n\t\tdata_len = min_t(size_t,\n\t\t\t\t len - SKB_MAX_ALLOC,\n\t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);\n\n\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(siocb->scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_put(skb, len - data_len);\n\tskb->data_len = data_len;\n\tskb->len = len;\n\terr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tmaybe_add_creds(skb, sock, other);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-287", "CWE-284"], "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tmaybe_add_creds(skb, sock, other);\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}", "target": 1, "cwe": ["CWE-287", "CWE-284"], "message": "af_netlink: force credentials passing [CVE-2012-3520]\n\nPablo Neira Ayuso discovered that avahi and\npotentially NetworkManager accept spoofed Netlink messages because of a\nkernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data\nto the receiver if the sender did not provide such data, instead of not\nincluding any such data at all or including the correct data from the\npeer (as it is the case with AF_UNIX).\n\nThis bug was introduced in commit 16e572626961\n(af_unix: dont send SCM_CREDENTIALS by default)\n\nThis patch forces passing credentials for netlink, as\nbefore the regression.\n\nAnother fix would be to not add SCM_CREDENTIALS in\nnetlink messages if not provided by the sender, but it\nmight break some programs.\n\nWith help from Florian Weimer & Petr Matousek\n\nThis issue is designated as CVE-2012-3520\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Florian Weimer <fweimer@redhat.com>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fixed possibility of Unsolicited Dialback Attacks"}
{"func": "static void _out_verify(conn_t out, nad_t nad) {\n    int attr, ns;\n    jid_t from, to;\n    conn_t in;\n    char *rkey;\n    int valid;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db verify packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db verify packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"id\", NULL);\n    if(attr < 0) {\n        log_debug(ZONE, \"missing id on db verify packet\");\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    /* get the incoming conn */\n    in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));\n    if(in == NULL) {\n        log_debug(ZONE, \"got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n\n    attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");\n    if(attr >= 0) {\n        xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        valid = 1;\n    } else {\n        log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now invalid\", in->fd->fd, in->ip, in->port, rkey);\n        valid = 0;\n    }\n\n    free(rkey);\n\n    nad_free(nad);\n\n    /* decrement outstanding verify counter */\n    --out->verify;\n\n    /* let them know what happened */\n    nad = nad_new();\n\n    ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");\n    nad_append_elem(nad, ns, \"result\", 0);\n    nad_append_attr(nad, -1, \"to\", from->domain);\n    nad_append_attr(nad, -1, \"from\", to->domain);\n    nad_append_attr(nad, -1, \"type\", valid ? \"valid\" : \"invalid\");\n\n    /* off it goes */\n    sx_nad_write(in->s, nad);\n\n    /* if invalid, close the stream */\n    if (!valid) {\n        /* generate stream error */\n        sx_error(in->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n        /* close the incoming stream */\n        sx_close(in->s);\n    }\n\n    jid_free(from);\n    jid_free(to);\n}", "target": 1, "cwe": ["CWE-20"], "message": "Fixed possibility of Unsolicited Dialback Attacks"}
{"func": "static int cbtls_verify(int ok, X509_STORE_CTX *ctx)\n{\n\tchar subject[1024]; /* Used for the subject name */\n\tchar issuer[1024]; /* Used for the issuer name */\n\tchar common_name[1024];\n\tchar cn_str[1024];\n\tchar buf[64];\n\tEAP_HANDLER *handler = NULL;\n\tX509 *client_cert;\n\tX509 *issuer_cert;\n\tSSL *ssl;\n\tint err, depth, lookup, loc;\n\tEAP_TLS_CONF *conf;\n\tint my_ok = ok;\n\tREQUEST *request;\n\tASN1_INTEGER *sn = NULL;\n\tASN1_TIME *asn_time = NULL;\n#ifdef HAVE_OPENSSL_OCSP_H\n\tX509_STORE *ocsp_store = NULL;\n#endif\n\n\tclient_cert = X509_STORE_CTX_get_current_cert(ctx);\n\terr = X509_STORE_CTX_get_error(ctx);\n\tdepth = X509_STORE_CTX_get_error_depth(ctx);\n\n\tlookup = depth;\n\n\t/*\n\t *\tLog client/issuing cert.  If there's an error, log\n\t *\tissuing cert.\n\t */\n\tif ((lookup > 1) && !my_ok) lookup = 1;\n\n\t/*\n\t * Retrieve the pointer to the SSL of the connection currently treated\n\t * and the application specific data stored into the SSL object.\n\t */\n\tssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n\thandler = (EAP_HANDLER *)SSL_get_ex_data(ssl, 0);\n\trequest = handler->request;\n\tconf = (EAP_TLS_CONF *)SSL_get_ex_data(ssl, 1);\n#ifdef HAVE_OPENSSL_OCSP_H\n\tocsp_store = (X509_STORE *)SSL_get_ex_data(ssl, 2);\n#endif\n\n\n\t/*\n\t *\tGet the Serial Number\n\t */\n\tbuf[0] = '\\0';\n\tsn = X509_get_serialNumber(client_cert);\n\n\t/*\n\t *\tFor this next bit, we create the attributes *only* if\n\t *\twe're at the client or issuing certificate.\n\t */\n\tif ((lookup <= 1) && sn && (sn->length < (sizeof(buf) / 2))) {\n\t\tchar *p = buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < sn->length; i++) {\n\t\t\tsprintf(p, \"%02x\", (unsigned int)sn->data[i]);\n\t\t\tp += 2;\n\t\t}\n\t\tpairadd(&handler->certs,\n\t\t\tpairmake(cert_attr_names[EAPTLS_SERIAL][lookup], buf, T_OP_SET));\n\t}\n\n\n\t/*\n\t *\tGet the Expiration Date\n\t */\n\tbuf[0] = '\\0';\n\tasn_time = X509_get_notAfter(client_cert);\n\tif ((lookup <= 1) && asn_time && (asn_time->length < MAX_STRING_LEN)) {\n\t\tmemcpy(buf, (char*) asn_time->data, asn_time->length);\n\t\tbuf[asn_time->length] = '\\0';\n\t\tpairadd(&handler->certs,\n\t\t\tpairmake(cert_attr_names[EAPTLS_EXPIRATION][lookup], buf, T_OP_SET));\n\t}\n\n\t/*\n\t *\tGet the Subject & Issuer\n\t */\n\tsubject[0] = issuer[0] = '\\0';\n\tX509_NAME_oneline(X509_get_subject_name(client_cert), subject,\n\t\t\t  sizeof(subject));\n\tsubject[sizeof(subject) - 1] = '\\0';\n\tif ((lookup <= 1) && subject[0] && (strlen(subject) < MAX_STRING_LEN)) {\n\t\tpairadd(&handler->certs,\n\t\t\tpairmake(cert_attr_names[EAPTLS_SUBJECT][lookup], subject, T_OP_SET));\n\t}\n\n\tX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), issuer,\n\t\t\t  sizeof(issuer));\n\tissuer[sizeof(issuer) - 1] = '\\0';\n\tif ((lookup <= 1) && issuer[0] && (strlen(issuer) < MAX_STRING_LEN)) {\n\t\tpairadd(&handler->certs,\n\t\t\tpairmake(cert_attr_names[EAPTLS_ISSUER][lookup], issuer, T_OP_SET));\n\t}\n\n\t/*\n\t *\tGet the Common Name, if there is a subject.\n\t */\n\tX509_NAME_get_text_by_NID(X509_get_subject_name(client_cert),\n\t\t\t\t  NID_commonName, common_name, sizeof(common_name));\n\tcommon_name[sizeof(common_name) - 1] = '\\0';\n\tif ((lookup <= 1) && common_name[0] && subject[0] && (strlen(common_name) < MAX_STRING_LEN)) {\n\t\tpairadd(&handler->certs,\n\t\t\tpairmake(cert_attr_names[EAPTLS_CN][lookup], common_name, T_OP_SET));\n\t}\n\n#ifdef GEN_EMAIL\n\t/*\n\t *\tGet the RFC822 Subject Alternative Name\n\t */\n\tloc = X509_get_ext_by_NID(client_cert, NID_subject_alt_name, 0);\n\tif (lookup <= 1 && loc >= 0) {\n\t\tX509_EXTENSION *ext = NULL;\n\t\tGENERAL_NAMES *names = NULL;\n\t\tint i;\n\n\t\tif ((ext = X509_get_ext(client_cert, loc)) &&\n\t\t    (names = X509V3_EXT_d2i(ext))) {\n\t\t\tfor (i = 0; i < sk_GENERAL_NAME_num(names); i++) {\n\t\t\t\tGENERAL_NAME *name = sk_GENERAL_NAME_value(names, i);\n\n\t\t\t\tswitch (name->type) {\n\t\t\t\tcase GEN_EMAIL:\n\t\t\t\t\tif (ASN1_STRING_length(name->d.rfc822Name) >= MAX_STRING_LEN)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tpairadd(&handler->certs,\n\t\t\t\t\t\tpairmake(cert_attr_names[EAPTLS_SAN_EMAIL][lookup],\n\t\t\t\t\t\t\t ASN1_STRING_data(name->d.rfc822Name), T_OP_SET));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* XXX TODO handle other SAN types */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (names != NULL)\n\t\t\tsk_GENERAL_NAME_free(names);\n\t}\n#endif\t/* GEN_EMAIL */\n\n\t/*\n\t *\tIf the CRL has expired, that might still be OK.\n\t */\n\tif (!my_ok &&\n\t    (conf->allow_expired_crl) &&\n\t    (err == X509_V_ERR_CRL_HAS_EXPIRED)) {\n\t\tmy_ok = 1;\n\t\tX509_STORE_CTX_set_error( ctx, 0 );\n\t}\n\n\tif (!my_ok) {\n\t\tconst char *p = X509_verify_cert_error_string(err);\n\t\tradlog(L_ERR,\"--> verify error:num=%d:%s\\n\",err, p);\n\t\tradius_pairmake(request, &request->packet->vps,\n\t\t\t\t\"Module-Failure-Message\", p, T_OP_SET);\n\t\treturn my_ok;\n\t}\n\n\tswitch (ctx->error) {\n\n\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\t\tradlog(L_ERR, \"issuer= %s\\n\", issuer);\n\t\tbreak;\n\tcase X509_V_ERR_CERT_NOT_YET_VALID:\n\tcase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\n\t\tradlog(L_ERR, \"notBefore=\");\n#if 0\n\t\tASN1_TIME_print(bio_err, X509_get_notBefore(ctx->current_cert));\n#endif\n\t\tbreak;\n\tcase X509_V_ERR_CERT_HAS_EXPIRED:\n\tcase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\n\t\tradlog(L_ERR, \"notAfter=\");\n#if 0\n\t\tASN1_TIME_print(bio_err, X509_get_notAfter(ctx->current_cert));\n#endif\n\t\tbreak;\n\t}\n\n\t/*\n\t *\tIf we're at the actual client cert, apply additional\n\t *\tchecks.\n\t */\n\tif (depth == 0) {\n\t\t/*\n\t\t *\tIf the conf tells us to, check cert issuer\n\t\t *\tagainst the specified value and fail\n\t\t *\tverification if they don't match.\n\t\t */\n\t\tif (conf->check_cert_issuer &&\n\t\t    (strcmp(issuer, conf->check_cert_issuer) != 0)) {\n\t\t\tradlog(L_AUTH, \"rlm_eap_tls: Certificate issuer (%s) does not match specified value (%s)!\", issuer, conf->check_cert_issuer);\n \t\t\tmy_ok = 0;\n \t\t}\n\n\t\t/*\n\t\t *\tIf the conf tells us to, check the CN in the\n\t\t *\tcert against xlat'ed value, but only if the\n\t\t *\tprevious checks passed.\n\t\t */\n\t\tif (my_ok && conf->check_cert_cn) {\n\t\t\tif (!radius_xlat(cn_str, sizeof(cn_str), conf->check_cert_cn, handler->request, NULL)) {\n\t\t\t\tradlog(L_ERR, \"rlm_eap_tls (%s): xlat failed.\",\n\t\t\t\t       conf->check_cert_cn);\n\t\t\t\t/* if this fails, fail the verification */\n\t\t\t\tmy_ok = 0;\n\t\t\t} else {\n\t\t\t\tRDEBUG2(\"checking certificate CN (%s) with xlat'ed value (%s)\", common_name, cn_str);\n\t\t\t\tif (strcmp(cn_str, common_name) != 0) {\n\t\t\t\t\tradlog(L_AUTH, \"rlm_eap_tls: Certificate CN (%s) does not match specified value (%s)!\", common_name, cn_str);\n\t\t\t\t\tmy_ok = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} /* check_cert_cn */\n\n#ifdef HAVE_OPENSSL_OCSP_H\n\t\tif (my_ok && conf->ocsp_enable){\n\t\t\tRDEBUG2(\"--> Starting OCSP Request\");\n\t\t\tif(X509_STORE_CTX_get1_issuer(&issuer_cert, ctx, client_cert)!=1) {\n\t\t\t\tradlog(L_ERR, \"Error: Couldn't get issuer_cert for %s\", common_name);\n\t\t\t}\n\t\t\tmy_ok = ocsp_check(ocsp_store, issuer_cert, client_cert, conf);\n\t\t}\n#endif\n\n\t\twhile (conf->verify_client_cert_cmd) {\n\t\t\tchar filename[256];\n\t\t\tint fd;\n\t\t\tFILE *fp;\n\n\t\t\tsnprintf(filename, sizeof(filename), \"%s/%s.client.XXXXXXXX\",\n\t\t\t\t conf->verify_tmp_dir, progname);\n\t\t\tfd = mkstemp(filename);\n\t\t\tif (fd < 0) {\n\t\t\t\tRDEBUG(\"Failed creating file in %s: %s\",\n\t\t\t\t       conf->verify_tmp_dir, strerror(errno));\n\t\t\t\tbreak;\t\t\t\t       \n\t\t\t}\n\n\t\t\tfp = fdopen(fd, \"w\");\n\t\t\tif (!fp) {\n\t\t\t\tRDEBUG(\"Failed opening file %s: %s\",\n\t\t\t\t       filename, strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!PEM_write_X509(fp, client_cert)) {\n\t\t\t\tfclose(fp);\n\t\t\t\tRDEBUG(\"Failed writing certificate to file\");\n\t\t\t\tgoto do_unlink;\n\t\t\t}\n\t\t\tfclose(fp);\n\n\t\t\tif (!radius_pairmake(request, &request->packet->vps,\n\t\t\t\t\t     \"TLS-Client-Cert-Filename\",\n\t\t\t\t\t     filename, T_OP_SET)) {\n\t\t\t\tRDEBUG(\"Failed creating TLS-Client-Cert-Filename\");\n\t\t\t\t\n\t\t\t\tgoto do_unlink;\n\t\t\t}\n\n\t\t\tRDEBUG(\"Verifying client certificate: %s\",\n\t\t\t       conf->verify_client_cert_cmd);\n\t\t\tif (radius_exec_program(conf->verify_client_cert_cmd,\n\t\t\t\t\t\trequest, 1, NULL, 0, \n\t\t\t\t\t\trequest->packet->vps,\n\t\t\t\t\t\tNULL, 1) != 0) {\n\t\t\t\tradlog(L_AUTH, \"rlm_eap_tls: Certificate CN (%s) fails external verification!\", common_name);\n\t\t\t\tmy_ok = 0;\n\t\t\t} else {\n\t\t\t\tRDEBUG(\"Client certificate CN %s passed external validation\", common_name);\n\t\t\t}\n\n\t\tdo_unlink:\n\t\t\tunlink(filename);\n\t\t\tbreak;\n\t\t}\n\n\n\t} /* depth == 0 */\n\n\tif (debug_flag > 0) {\n\t\tRDEBUG2(\"chain-depth=%d, \", depth);\n\t\tRDEBUG2(\"error=%d\", err);\n\n\t\tRDEBUG2(\"--> User-Name = %s\", handler->identity);\n\t\tRDEBUG2(\"--> BUF-Name = %s\", common_name);\n\t\tRDEBUG2(\"--> subject = %s\", subject);\n\t\tRDEBUG2(\"--> issuer  = %s\", issuer);\n\t\tRDEBUG2(\"--> verify return:%d\", my_ok);\n\t}\n\treturn my_ok;\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix CVE-2012-3547.  Found by Timo Warns"}
{"func": "xsltApplyTemplates(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemApplyTemplatesPtr comp =\n\t(xsltStyleItemApplyTemplatesPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    int i;\n    xmlNodePtr cur, delNode = NULL, oldContextNode;\n    xmlNodeSetPtr list = NULL, oldList;\n    xsltStackElemPtr withParams = NULL;\n    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n    const xmlChar *oldMode, *oldModeURI;\n    xmlDocPtr oldXPDoc;\n    xsltDocumentPtr oldDocInfo;\n    xmlXPathContextPtr xpctxt;\n    xmlNsPtr *oldXPNamespaces;\n\n    if (comp == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:apply-templates : compilation failed\\n\");\n\treturn;\n    }\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n\treturn;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if ((node != NULL) && (node->name != NULL))\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltApplyTemplates: node: '%s'\\n\", node->name));\n#endif\n\n    xpctxt = ctxt->xpathCtxt;\n    /*\n    * Save context states.\n    */\n    oldContextNode = ctxt->node;\n    oldMode = ctxt->mode;\n    oldModeURI = ctxt->modeURI;\n    oldDocInfo = ctxt->document;\n    oldList = ctxt->nodeList;\n\n    /*\n     * The xpath context size and proximity position, as\n     * well as the xpath and context documents, may be changed\n     * so we save their initial state and will restore on exit\n     */\n    oldXPContextSize = xpctxt->contextSize;\n    oldXPProximityPosition = xpctxt->proximityPosition;\n    oldXPDoc = xpctxt->doc;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n\n    /*\n    * Set up contexts.\n    */\n    ctxt->mode = comp->mode;\n    ctxt->modeURI = comp->modeURI;\n\n    if (comp->select != NULL) {\n\txmlXPathObjectPtr res = NULL;\n\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsl:apply-templates : compilation failed\\n\");\n\t    goto error;\n\t}\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltApplyTemplates: select %s\\n\", comp->select));\n#endif\n\n\t/*\n\t* Set up XPath.\n\t*/\n\txpctxt->node = node; /* Set the \"context node\" */\n#ifdef XSLT_REFACTORED\n\tif (comp->inScopeNs != NULL) {\n\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n#else\n\txpctxt->namespaces = comp->nsList;\n\txpctxt->nsNr = comp->nsNr;\n#endif\n\tres = xmlXPathCompiledEval(comp->comp, xpctxt);\n\n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n\tif (res != NULL) {\n\t    if (res->type == XPATH_NODESET) {\n\t\tlist = res->nodesetval; /* consume the node set */\n\t\tres->nodesetval = NULL;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t    \"The 'select' expression did not evaluate to a \"\n\t\t    \"node set.\\n\");\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t\txmlXPathFreeObject(res);\n\t\tgoto error;\n\t    }\n\t    xmlXPathFreeObject(res);\n\t    /*\n\t    * Note: An xsl:apply-templates with a 'select' attribute,\n\t    * can change the current source doc.\n\t    */\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"Failed to evaluate the 'select' expression.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    goto error;\n\t}\n\tif (list == NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsltApplyTemplates: select didn't evaluate to a node list\\n\"));\n#endif\n\t    goto exit;\n\t}\n\t/*\n\t*\n\t* NOTE: Previously a document info (xsltDocument) was\n\t* created and attached to the Result Tree Fragment.\n\t* But such a document info is created on demand in\n\t* xsltKeyFunction() (functions.c), so we need to create\n\t* it here beforehand.\n\t* In order to take care of potential keys we need to\n\t* do some extra work for the case when a Result Tree Fragment\n\t* is converted into a nodeset (e.g. exslt:node-set()) :\n\t* We attach a \"pseudo-doc\" (xsltDocument) to _private.\n\t* This xsltDocument, together with the keyset, will be freed\n\t* when the Result Tree Fragment is freed.\n\t*\n\t*/\n#if 0\n\tif ((ctxt->nbKeys > 0) &&\n\t    (list->nodeNr != 0) &&\n\t    (list->nodeTab[0]->doc != NULL) &&\n\t    XSLT_IS_RES_TREE_FRAG(list->nodeTab[0]->doc))\n\t{\n\t    /*\n\t    * NOTE that it's also OK if @effectiveDocInfo will be\n\t    * set to NULL.\n\t    */\n\t    isRTF = 1;\n\t    effectiveDocInfo = list->nodeTab[0]->doc->_private;\n\t}\n#endif\n    } else {\n\t/*\n\t * Build an XPath node set with the children\n\t */\n\tlist = xmlXPathNodeSetCreate(NULL);\n\tif (list == NULL)\n\t    goto error;\n\tcur = node->children;\n\twhile (cur != NULL) {\n\t    switch (cur->type) {\n\t\tcase XML_TEXT_NODE:\n\t\t    if ((IS_BLANK_NODE(cur)) &&\n\t\t\t(cur->parent != NULL) &&\n\t\t\t(cur->parent->type == XML_ELEMENT_NODE) &&\n\t\t\t(ctxt->style->stripSpaces != NULL)) {\n\t\t\tconst xmlChar *val;\n\n\t\t\tif (cur->parent->ns != NULL) {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name,\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    if (val == NULL) {\n\t\t\t\tval = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t BAD_CAST \"*\",\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name, NULL);\n\t\t\t}\n\t\t\tif ((val != NULL) &&\n\t\t\t    (xmlStrEqual(val, (xmlChar *) \"strip\"))) {\n\t\t\t    delNode = cur;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    /* no break on purpose */\n\t\tcase XML_ELEMENT_NODE:\n\t\tcase XML_DOCUMENT_NODE:\n\t\tcase XML_HTML_DOCUMENT_NODE:\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\tcase XML_PI_NODE:\n\t\tcase XML_COMMENT_NODE:\n\t\t    xmlXPathNodeSetAddUnique(list, cur);\n\t\t    break;\n\t\tcase XML_DTD_NODE:\n\t\t    /* Unlink the DTD, it's still reachable\n\t\t     * using doc->intSubset */\n\t\t    if (cur->next != NULL)\n\t\t\tcur->next->prev = cur->prev;\n\t\t    if (cur->prev != NULL)\n\t\t\tcur->prev->next = cur->next;\n\t\t    break;\n\t\tdefault:\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: skipping cur type %d\\n\",\n\t\t\t\t     cur->type));\n#endif\n\t\t    delNode = cur;\n\t    }\n\t    cur = cur->next;\n\t    if (delNode != NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: removing ignorable blank cur\\n\"));\n#endif\n\t\txmlUnlinkNode(delNode);\n\t\txmlFreeNode(delNode);\n\t\tdelNode = NULL;\n\t    }\n\t}\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if (list != NULL)\n    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\"xsltApplyTemplates: list of %d nodes\\n\", list->nodeNr));\n#endif\n\n    if ((list == NULL) || (list->nodeNr == 0))\n\tgoto exit;\n\n    /*\n    * Set the context's node set and size; this is also needed for\n    * for xsltDoSortFunction().\n    */\n    ctxt->nodeList = list;\n    /*\n    * Process xsl:with-param and xsl:sort instructions.\n    * (The code became so verbose just to avoid the\n    *  xmlNodePtr sorts[XSLT_MAX_SORT] if there's no xsl:sort)\n    * BUG TODO: We are not using namespaced potentially defined on the\n    * xsl:sort or xsl:with-param elements; XPath expression might fail.\n    */\n    if (inst->children) {\n\txsltStackElemPtr param;\n\n\tcur = inst->children;\n\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\tbreak;\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tcur = cur->next;\n\t\tcontinue;\n\t    }\n\t    if (! IS_XSLT_ELEM(cur))\n\t\tbreak;\n\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\tif (param != NULL) {\n\t\t    param->next = withParams;\n\t\t    withParams = param;\n\t\t}\n\t    }\n\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\txsltTemplatePtr oldCurTempRule =\n\t\t    ctxt->currentTemplateRule;\n\t\tint nbsorts = 0;\n\t\txmlNodePtr sorts[XSLT_MAX_SORT];\n\n\t\tsorts[nbsorts++] = cur;\n\n\t\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\t\tbreak;\n\n\t\t    if (cur->type == XML_TEXT_NODE) {\n\t\t\tcur = cur->next;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    if (! IS_XSLT_ELEM(cur))\n\t\t\tbreak;\n\t\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\t\tif (param != NULL) {\n\t\t\t    param->next = withParams;\n\t\t\t    withParams = param;\n\t\t\t}\n\t\t    }\n\t\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\t\tif (nbsorts >= XSLT_MAX_SORT) {\n\t\t\t    xsltTransformError(ctxt, NULL, cur,\n\t\t\t\t\"The number (%d) of xsl:sort instructions exceeds the \"\n\t\t\t\t\"maximum allowed by this processor's settings.\\n\",\n\t\t\t\tnbsorts);\n\t\t\t    ctxt->state = XSLT_STATE_STOPPED;\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    sorts[nbsorts++] = cur;\n\t\t\t}\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n\t\t/*\n\t\t* The \"current template rule\" is cleared for xsl:sort.\n\t\t*/\n\t\tctxt->currentTemplateRule = NULL;\n\t\t/*\n\t\t* Sort.\n\t\t*/\n\t\txsltDoSortFunction(ctxt, sorts, nbsorts);\n\t\tctxt->currentTemplateRule = oldCurTempRule;\n\t\tbreak;\n\t    }\n\t    cur = cur->next;\n\t}\n    }\n    xpctxt->contextSize = list->nodeNr;\n    /*\n    * Apply templates for all selected source nodes.\n    */\n    for (i = 0; i < list->nodeNr; i++) {\n\tcur = list->nodeTab[i];\n\t/*\n\t* The node becomes the \"current node\".\n\t*/\n\tctxt->node = cur;\n\t/*\n\t* An xsl:apply-templates can change the current context doc.\n\t* OPTIMIZE TODO: Get rid of the need to set the context doc.\n\t*/\n\tif ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n\t    xpctxt->doc = cur->doc;\n\n\txpctxt->proximityPosition = i + 1;\n\t/*\n\t* Find and apply a template for this node.\n\t*/\n\txsltProcessOneNode(ctxt, cur, withParams);\n    }\n\nexit:\nerror:\n    /*\n    * Free the parameter list.\n    */\n    if (withParams != NULL)\n\txsltFreeStackElemList(withParams);\n    if (list != NULL)\n\txmlXPathFreeNodeSet(list);\n    /*\n    * Restore context states.\n    */\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n    xpctxt->doc = oldXPDoc;\n    xpctxt->contextSize = oldXPContextSize;\n    xpctxt->proximityPosition = oldXPProximityPosition;\n\n    ctxt->document = oldDocInfo;\n    ctxt->nodeList = oldList;\n    ctxt->node = oldContextNode;\n    ctxt->mode = oldMode;\n    ctxt->modeURI = oldModeURI;\n}", "target": 1, "cwe": [], "message": "Fix default template processing on namespace nodes"}
{"func": "int ip_queue_xmit(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n\tstruct rtable *rt;\n\tstruct iphdr *iph;\n\tint res;\n\n\t/* Skip all of this if the packet is already routed,\n\t * f.e. by something like SCTP.\n\t */\n\trcu_read_lock();\n\trt = skb_rtable(skb);\n\tif (rt != NULL)\n\t\tgoto packet_routed;\n\n\t/* Make sure we can route this packet. */\n\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\tif (rt == NULL) {\n\t\t__be32 daddr;\n\n\t\t/* Use correct destination address if we have options. */\n\t\tdaddr = inet->inet_daddr;\n\t\tif(opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport,\n\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol,\n\t\t\t\t\t   RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set_noref(skb, &rt->dst);\n\npacket_routed:\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto no_route;\n\n\t/* OK, we know where to send it, allocate and build IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\t*((__be16 *)iph) = htons((4 << 12) | (5 << 8) | (inet->tos & 0xff));\n\tif (ip_dont_fragment(sk, &rt->dst) && !skb->local_df)\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->protocol = sk->sk_protocol;\n\tiph->saddr    = rt->rt_src;\n\tiph->daddr    = rt->rt_dst;\n\t/* Transport layer set skb->h.foo itself. */\n\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen >> 2;\n\t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);\n\t}\n\n\tip_select_ident_more(iph, &rt->dst, sk,\n\t\t\t     (skb_shinfo(skb)->gso_segs ?: 1) - 1);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tres = ip_local_out(skb);\n\trcu_read_unlock();\n\treturn res;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct flowi4 *fl4;\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\t__be16 dport;\n\tu8  tos;\n\tint err, is_udplite = IS_UDPLITE(sk);\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\tstruct sk_buff *skb;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tgetfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in * usin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\tdport = inet->inet_dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n\t}\n\tipc.addr = inet->inet_saddr;\n\n\tipc.oif = sk->sk_bound_dev_if;\n\terr = sock_tx_timestamp(sk, &ipc.tx_flags);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t\tconnected = 0;\n\t}\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tfaddr = ipc.opt->faddr;\n\t\tconnected = 0;\n\t}\n\ttos = RT_TOS(inet->tos);\n\tif (sock_flag(sk, SOCK_LOCALROUTE) ||\n\t    (msg->msg_flags & MSG_DONTROUTE) ||\n\t    (ipc.opt && ipc.opt->is_strictroute)) {\n\t\ttos |= RTO_ONLINK;\n\t\tconnected = 0;\n\t}\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t\tconnected = 0;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *)sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\tstruct flowi4 fl4;\n\t\tstruct net *net = sock_net(sk);\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   inet_sk_flowi_flags(sk)|FLOWI_FLAG_CAN_SLEEP,\n\t\t\t\t   faddr, saddr, dport, inet->inet_sport);\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(net, &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tif (err == -ENETUNREACH)\n\t\t\t\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = rt->rt_src;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = rt->rt_dst;\n\n\t/* Lockless fast path for the non-corking case. */\n\tif (!corkreq) {\n\t\tskb = ip_make_skb(sk, getfrag, msg->msg_iov, ulen,\n\t\t\t\t  sizeof(struct udphdr), &ipc, &rt,\n\t\t\t\t  msg->msg_flags);\n\t\terr = PTR_ERR(skb);\n\t\tif (skb && !IS_ERR(skb))\n\t\t\terr = udp_send_skb(skb, daddr, dport);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tfl4 = &inet->cork.fl.u.ip4;\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->fl4_dport = dport;\n\tfl4->fl4_sport = inet->inet_sport;\n\tup->pending = AF_INET;\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\t\tsizeof(struct udphdr), &ipc, &rt,\n\t\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tstatic int complained;\n\t\t\tif (!complained++)\n\t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"\n\t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",\n\t\t\t\t\t\t current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (inet->hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->faddr;\n\t\t}\n\t}\n\ttos = RT_CONN_FLAGS(sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);\n\n\t\tif (!inet->hdrincl) {\n\t\t\terr = raw_probe_proto_opt(&fl4, msg);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,\n\t\t\t\t\t&rt, msg->msg_flags);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = rt->rt_dst;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,\n\t\t\t\t\t&ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct ip_options *opt)\n{\n\tstruct tcp_options_received tcp_opt;\n\tu8 *hash_location;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tbool ecn_ok;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk) ||\n\t    (mss = cookie_check(skb, cookie)) == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, &hash_location, 0);\n\n\tif (!cookie_check_timestamp(&tcp_opt, &ecn_ok))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp_request_sock_ops); /* for safety */\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\treq->mss\t\t= mss;\n\tireq->loc_port\t\t= th->dest;\n\tireq->rmt_port\t\t= th->source;\n\tireq->loc_addr\t\t= ip_hdr(skb)->daddr;\n\tireq->rmt_addr\t\t= ip_hdr(skb)->saddr;\n\tireq->ecn_ok\t\t= ecn_ok;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t */\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->expires\t= 0UL;\n\treq->retrans\t= 0;\n\n\t/*\n\t * We need to lookup the route here to get at the correct\n\t * window size. We should better make sure that the window size\n\t * hasn't changed since we received the original syn, but I see\n\t * no easy way to do this.\n\t */\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),\n\t\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_TCP,\n\t\t\t\t   inet_sk_flowi_flags(sk),\n\t\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t\t   ireq->loc_addr, th->source, th->dest);\n\t\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\treqsk_free(req);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to redo what tcp_v4_send_synack did. */\n\treq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rcv_wnd, &req->window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\n\tret = get_cookie_sock(sk, skb, req, &rt->dst);\nout:\treturn ret;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n\tstruct rtable *rt = NULL;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n\t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n\n\tif (rt == NULL) {\n\t\t/* Use correct destination address if we have options. */\n\t\tif (opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\n\t/* Route is OK, nothing to do. */\n\tif (rt)\n\t\treturn 0;\n\n\t/* Reroute. */\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t/* Routing failed... */\n\t\tsk->sk_route_caps = 0;\n\t\t/*\n\t\t * Other protocols have to map its equivalent state to TCP_SYN_SENT.\n\t\t * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme\n\t\t */\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\n\treturn err;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n\t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\n\t/*\n\t * setup for corking.\n\t */\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t/*\n\t * We steal reference to this route, caller should not release it\n\t */\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->opt = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt != NULL && inet->opt->srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet->opt == NULL || !inet->opt->srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt != NULL)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk_setup_caps(sk, &rt->dst);\n\n\tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t    inet->inet_daddr,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport);\n\tinet->inet_id = dp->dccps_iss ^ jiffies;\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port, if necessary.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\tgoto out;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt && inet->opt->srr) {\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_TCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\treturn err;\n\t}\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (!inet->opt || !inet->opt->srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tif (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {\n\t\t/* Reset inherited state */\n\t\ttp->rx_opt.ts_recent\t   = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq\t\t   = 0;\n\t}\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {\n\t\tstruct inet_peer *peer = rt_get_peer(rt);\n\t\t/*\n\t\t * VJ's idea. We save last timestamp seen from\n\t\t * the destination in peer table, when entering state\n\t\t * TIME-WAIT * and initialize rx_opt.ts_recent from it,\n\t\t * when trying new connection.\n\t\t */\n\t\tif (peer) {\n\t\t\tinet_peer_refcheck(peer);\n\t\t\tif ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) {\n\t\t\t\ttp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;\n\t\t\t\ttp->rx_opt.ts_recent = peer->tcp_ts;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n\n\ttp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n\n\t/* Socket identity is still unknown (sport may be zero).\n\t * However we set state to SYN-SENT and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (!tp->write_seq)\n\t\ttp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t\t   inet->inet_daddr,\n\t\t\t\t\t\t\t   inet->inet_sport,\n\t\t\t\t\t\t\t   usin->sin_port);\n\n\tinet->inet_id = tp->write_seq ^ jiffies;\n\n\terr = tcp_connect(sk);\n\trt = NULL;\n\tif (err)\n\t\tgoto failure;\n\n\treturn 0;\n\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port,\n\t * if necessary.\n\t */\n\ttcp_set_state(sk, TCP_CLOSE);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\treturn err;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\n\t/* Build the IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\t/* Send it out. */\n\treturn ip_local_out(skb);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\n\t/* Query new route. */\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tnew_saddr = rt->rt_src;\n\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\n\t/*\n\t * XXX The only one ugly spot where we need to\n\t * XXX really change the sockets identity after\n\t * XXX it has entered the hashes. -DaveM\n\t *\n\t * Besides that, it does not check for connection\n\t * uniqueness. Wait for troubles.\n\t */\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int do_ip_setsockopt(struct sock *sk, int level,\n\t\t\t    int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val = 0, err;\n\n\tif (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |\n\t\t\t     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |\n\t\t\t     (1<<IP_RETOPTS) | (1<<IP_TOS) |\n\t\t\t     (1<<IP_TTL) | (1<<IP_HDRINCL) |\n\t\t\t     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |\n\t\t\t     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |\n\t\t\t     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |\n\t\t\t     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||\n\t    optname == IP_MULTICAST_TTL ||\n\t    optname == IP_MULTICAST_ALL ||\n\t    optname == IP_MULTICAST_LOOP ||\n\t    optname == IP_RECVORIGDSTADDR) {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (get_user(ucval, (unsigned char __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t/* If optlen==0, it is equivalent to val == 0 */\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\terr = 0;\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tstruct ip_options *opt = NULL;\n\t\tif (optlen > 40)\n\t\t\tgoto e_inval;\n\t\terr = ip_options_get_from_user(sock_net(sk), &opt,\n\t\t\t\t\t       optval, optlen);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (inet->is_icsk) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n\t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n#endif\n\t\t\t\tif (inet->opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= inet->opt->optlen;\n\t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->optlen;\n\t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\t\t\t}\n#endif\n\t\t}\n\t\topt = xchg(&inet->opt, opt);\n\t\tkfree(opt);\n\t\tbreak;\n\t}\n\tcase IP_PKTINFO:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PKTINFO;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PKTINFO;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TTL;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TTL;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_TOS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_TOS;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |=  IP_CMSG_RECVOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RECVOPTS;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_RETOPTS;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_RETOPTS;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_PASSSEC;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_PASSSEC;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tif (val)\n\t\t\tinet->cmsg_flags |= IP_CMSG_ORIGDSTADDR;\n\t\telse\n\t\t\tinet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tbreak;\n\tcase IP_TOS:\t/* This sets both TOS and Precedence */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~3;\n\t\t\tval |= inet->tos & 3;\n\t\t}\n\t\tif (inet->tos != val) {\n\t\t\tinet->tos = val;\n\t\t\tsk->sk_priority = rt_tos2priority(val);\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tbreak;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != -1 && (val < 0 || val > 255))\n\t\t\tgoto e_inval;\n\t\tinet->uc_ttl = val;\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->hdrincl = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tinet->nodefrag = val ? 1 : 0;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_RECVERR:\n\t\tinet->recverr = !!val;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_loop = !!val;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t/*\n\t\t *\tCheck the arguments are allowable\n\t\t */\n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct in_addr) &&\n\t\t\t    copy_from_user(&mreq.imr_address, optval,\n\t\t\t\t\t   sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_user(&mreq, optval, sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(msf, optval, optlen)) {\n\t\t\tkfree(msf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (1G-4) overflow in 32 bits */\n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > sysctl_igmp_max_msf) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* IP_DROP_SOURCE_MEMBERSHIP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_mreqn mreq;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(greq)))\n\t\t\tbreak;\n\t\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto e_inval;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_ifindex = greq.gr_interface;\n\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tstruct ip_mreq_source mreqs;\n\t\tstruct sockaddr_in *psin;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t\t    greqs.gsr_source.ss_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\t\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\t\tmreqs.imr_interface = 0; /* use index for mc_source */\n\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\t\tmreq.imr_address.s_addr = 0;\n\t\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs,\n\t\t\t\t   greqs.gsr_interface);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct sockaddr_in *psin;\n\t\tstruct ip_msfilter *msf = NULL;\n\t\tstruct group_filter *gsf = NULL;\n\t\tint msize, i, ifindex;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen))\n\t\t\tgoto mc_msf_out;\n\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t\t    gsf->gf_numsrc > sysctl_igmp_max_msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsize = IP_MSFILTER_SIZE(gsf->gf_numsrc);\n\t\tmsf = kmalloc(msize, GFP_KERNEL);\n\t\tif (!msf) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tifindex = gsf->gf_interface;\n\t\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\t\tif (psin->sin_family != AF_INET) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto mc_msf_out;\n\t\t}\n\t\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\t\tmsf->imsf_interface = 0;\n\t\tmsf->imsf_fmode = gsf->gf_fmode;\n\t\tmsf->imsf_numsrc = gsf->gf_numsrc;\n\t\terr = -EADDRNOTAVAIL;\n\t\tfor (i = 0; i < gsf->gf_numsrc; ++i) {\n\t\t\tpsin = (struct sockaddr_in *)&gsf->gf_slist[i];\n\n\t\t\tif (psin->sin_family != AF_INET)\n\t\t\t\tgoto mc_msf_out;\n\t\t\tmsf->imsf_slist[i] = psin->sin_addr.s_addr;\n\t\t}\n\t\tkfree(gsf);\n\t\tgsf = NULL;\n\n\t\terr = ip_mc_msfilter(sk, msf, ifindex);\nmc_msf_out:\n\t\tkfree(msf);\n\t\tkfree(gsf);\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val != 0 && val != 1)\n\t\t\tgoto e_inval;\n\t\tinet->mc_all = val;\n\t\tbreak;\n\tcase IP_ROUTER_ALERT:\n\t\terr = ip_ra_control(sk, val ? 1 : 0, NULL);\n\t\tbreak;\n\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->freebind = !!val;\n\t\tbreak;\n\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_TRANSPARENT:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tinet->transparent = !!val;\n\t\tbreak;\n\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->min_ttl = val;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n\ne_inval:\n\trelease_sock(sk);\n\treturn -EINVAL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n{\n\tstruct ip_options *sopt;\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tsopt = &(IPCB(skb)->opt);\n\n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n\t\treturn 0;\n\t}\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->srr) {\n\t\tunsigned char * start = sptr+sopt->srr;\n\t\t__be32 faddr;\n\n\t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\n\t/* And let IP do all the hard work.\n\n\t   This chunk is not reenterable, hence spinlock.\n\t   Note that it uses the fact, that this function is called\n\t   with locally disabled BH and that sk cannot be already spinlocked.\n\t */\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tip_rt_put(rt);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\n\t\t/* determining the new total option length is tricky because of\n\t\t * the padding necessary, the only thing i can think to do at\n\t\t * this point is walk the options one-by-one, skipping the\n\t\t * padding at the end to determine the actual option size and\n\t\t * from there we can determine the new total option length */\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t/* only the cipso option was present on the socket so we can\n\t\t * remove the entire option struct */\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\n\treturn hdr_delta;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\n\t/* In the case of sock_create_lite(), the sock->sk field is not\n\t * defined yet but it is not a problem as the only users of these\n\t * \"lite\" PF_INET sockets are functions which do an accept() call\n\t * afterwards so we will label the socket as part of the accept(). */\n\tif (sk == NULL)\n\t\treturn 0;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\n\treturn 0;\n\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint val;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options * opt = (struct ip_options *)optbuf;\n\t\topt->optlen = 0;\n\t\tif (inet->opt)\n\t\t\tmemcpy(optbuf, inet->opt,\n\t\t\t       sizeof(struct ip_options)+\n\t\t\t       inet->opt->optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_PKTINFO:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;\n\t\tbreak;\n\tcase IP_RECVTTL:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TTL) != 0;\n\t\tbreak;\n\tcase IP_RECVTOS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_TOS) != 0;\n\t\tbreak;\n\tcase IP_RECVOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;\n\t\tbreak;\n\tcase IP_RETOPTS:\n\t\tval = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;\n\t\tbreak;\n\tcase IP_PASSSEC:\n\t\tval = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;\n\t\tbreak;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;\n\t\tbreak;\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_TTL:\n\t\tval = (inet->uc_ttl == -1 ?\n\t\t       sysctl_ip_default_ttl :\n\t\t       inet->uc_ttl);\n\t\tbreak;\n\tcase IP_HDRINCL:\n\t\tval = inet->hdrincl;\n\t\tbreak;\n\tcase IP_NODEFRAG:\n\t\tval = inet->nodefrag;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_RECVERR:\n\t\tval = inet->recverr;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet->mc_loop;\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\trelease_sock(sk);\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\t\tint err;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf,\n\t\t\t\t   (struct ip_msfilter __user *)optval, optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\t\tint err;\n\n\t\tif (len < GROUP_FILTER_SIZE(0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ip_mc_gsfget(sk, &gsf,\n\t\t\t\t   (struct group_filter __user *)optval,\n\t\t\t\t   optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet->mc_all;\n\t\tbreak;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\trelease_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = 0;\n\n\t\tif (inet->cmsg_flags & IP_CMSG_PKTINFO) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet->cmsg_flags & IP_CMSG_TTL) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IP_FREEBIND:\n\t\tval = inet->freebind;\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tval = inet->transparent;\n\t\tbreak;\n\tcase IP_MINTTL:\n\t\tval = inet->min_ttl;\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\trelease_sock(sk);\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\n\treturn 0;\n\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n\t\t\t\t\tstruct icmp_bxm *param)\n{\n\tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.srr ?\n\t\t\t  param->replyopts.faddr : iph->saddr),\n\t\t.saddr = saddr,\n\t\t.flowi4_tos = RT_TOS(tos),\n\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\n\ticmp_param->data.icmph.checksum = 0;\n\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n\t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n\t\t\t\t\t  iph->tos;\n\n\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n\t\tgoto out_unlock;\n\n\n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n\ticmp_param.offset = skb_network_offset(skb_in);\n\tinet_sk(sk)->tos = tos;\n\tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts;\n\tipc.tx_flags = 0;\n\n\trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n\troom = dst_mtu(&rt->dst);\n\tif (room > 576)\n\t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n\troom -= sizeof(struct icmphdr);\n\n\ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(newsk, dst);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n\tnewinet->inet_daddr   = ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t      = ireq->loc_addr;\n\tnewinet->opt\t      = ireq->opt;\n\tireq->opt\t      = NULL;\n\tnewinet->mc_index     = inet_iif(skb);\n\tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newinet->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;\n\tnewinet->inet_id = newtp->write_seq ^ jiffies;\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr);\n\tif (key != NULL) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v4_md5_do_add(newsk, newinet->inet_daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1, "cwe": ["CWE-362"], "message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "process (GeglOperation       *operation,\n         GeglBuffer          *output,\n         const GeglRectangle *result,\n         gint                 level)\n{\n  GeglChantO   *o = GEGL_CHANT_PROPERTIES (operation);\n  FILE         *fp;\n  pnm_struct    img;\n  GeglRectangle rect = {0,0,0,0};\n  gboolean      ret = FALSE;\n\n  fp = (!strcmp (o->path, \"-\") ? stdin : fopen (o->path,\"rb\"));\n\n  if (!fp)\n    return FALSE;\n\n  if (!ppm_load_read_header (fp, &img))\n    goto out;\n\n  rect.height = img.height;\n  rect.width = img.width;\n\n  /* Allocating Array Size */\n  img.data = (guchar*) g_malloc (img.numsamples * img.bpc);\n\n  switch (img.bpc)\n    {\n    case 1:\n      gegl_buffer_get (output, &rect, 1.0, babl_format (\"R'G'B' u8\"), img.data,\n                       GEGL_AUTO_ROWSTRIDE, GEGL_ABYSS_NONE);\n      break;\n\n    case 2:\n      gegl_buffer_get (output, &rect, 1.0, babl_format (\"R'G'B' u16\"), img.data,\n                       GEGL_AUTO_ROWSTRIDE, GEGL_ABYSS_NONE);\n      break;\n\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n\n  ppm_load_read_image (fp, &img);\n\n  switch (img.bpc)\n    {\n    case 1:\n      gegl_buffer_set (output, &rect, 0, babl_format (\"R'G'B' u8\"), img.data,\n                       GEGL_AUTO_ROWSTRIDE);\n      break;\n\n    case 2:\n      gegl_buffer_set (output, &rect, 0, babl_format (\"R'G'B' u16\"), img.data,\n                       GEGL_AUTO_ROWSTRIDE);\n      break;\n\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n\n  g_free (img.data);\n\n  ret = TRUE;\n\n out:\n  if (stdin != fp)\n    fclose (fp);\n\n  return ret;\n}", "target": 1, "cwe": ["CWE-189"], "message": "ppm-load: CVE-2012-4433: don't overflow memory allocation\n\nCarefully selected width/height values could cause the size of a later\nallocation to overflow, resulting in a buffer much too small to store\nthe data which would then written beyond its end."}
{"func": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    /* PPM Headers Variable Declaration */\n    gchar *ptr;\n    //gchar *retval;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n\n    /* Check the PPM file Type P2 or P5 */\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n\n    if (header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n\n    img->type = header[1];\n\n    /* Check the Comments */\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    while(header[0] == '#')\n      {\n        fgets (header,MAX_CHARS_IN_ROW,fp);\n      }\n\n    /* Get Width and Height */\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    maxval = strtol (header,&ptr,0);\n\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-189"], "message": "ppm-load: CVE-2012-4433: don't overflow memory allocation\n\nCarefully selected width/height values could cause the size of a later\nallocation to overflow, resulting in a buffer much too small to store\nthe data which would then written beyond its end."}
{"func": "ppm_load_read_header(FILE       *fp,\n                     pnm_struct *img)\n{\n    /* PPM Headers Variable Declaration */\n    gchar *ptr;\n    //gchar *retval;\n    gchar  header[MAX_CHARS_IN_ROW];\n    gint   maxval;\n\n    /* Check the PPM file Type P2 or P5 */\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n\n    if (header[0] != ASCII_P ||\n        (header[1] != PIXMAP_ASCII &&\n         header[1] != PIXMAP_RAW))\n      {\n        g_warning (\"Image is not a portable pixmap\");\n        return FALSE;\n      }\n\n    img->type = header[1];\n\n    /* Check the Comments */\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    while(header[0] == '#')\n      {\n        fgets (header,MAX_CHARS_IN_ROW,fp);\n      }\n\n    /* Get Width and Height */\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n\n    fgets (header,MAX_CHARS_IN_ROW,fp);\n    maxval = strtol (header,&ptr,0);\n\n    if ((maxval != 255) && (maxval != 65535))\n      {\n        g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n        return FALSE;\n      }\n\n  switch (maxval)\n    {\n    case 255:\n      img->bpc = sizeof (guchar);\n      break;\n\n    case 65535:\n      img->bpc = sizeof (gushort);\n      break;\n\n    default:\n      g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n    }\n\n    /* Later on, img->numsamples is multiplied with img->bpc to allocate\n     * memory. Ensure it doesn't overflow. */\n    if (!img->width || !img->height ||\n        G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n      {\n        g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n        return FALSE;\n      }\n    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-189"], "message": "ppm-load: CVE-2012-4433: add plausibility checks for header fields\n\nRefuse values that are non-decimal, negative or overflow the target\ntype."}
{"func": "directory_handle_command_get(dir_connection_t *conn, const char *headers,\n                             const char *body, size_t body_len)\n{\n  size_t dlen;\n  char *url, *url_mem, *header;\n  or_options_t *options = get_options();\n  time_t if_modified_since = 0;\n  int compressed;\n  size_t url_len;\n\n  /* We ignore the body of a GET request. */\n  (void)body;\n  (void)body_len;\n\n  log_debug(LD_DIRSERV,\"Received GET command.\");\n\n  conn->_base.state = DIR_CONN_STATE_SERVER_WRITING;\n\n  if (parse_http_url(headers, &url) < 0) {\n    write_http_status_line(conn, 400, \"Bad request\");\n    return 0;\n  }\n  if ((header = http_get_header(headers, \"If-Modified-Since: \"))) {\n    struct tm tm;\n    if (parse_http_time(header, &tm) == 0) {\n      if_modified_since = tor_timegm(&tm);\n    }\n    /* The correct behavior on a malformed If-Modified-Since header is to\n     * act as if no If-Modified-Since header had been given. */\n    tor_free(header);\n  }\n  log_debug(LD_DIRSERV,\"rewritten url as '%s'.\", url);\n\n  url_mem = url;\n  url_len = strlen(url);\n  compressed = url_len > 2 && !strcmp(url+url_len-2, \".z\");\n  if (compressed) {\n    url[url_len-2] = '\\0';\n    url_len -= 2;\n  }\n\n  if (!strcmp(url,\"/tor/\")) {\n    const char *frontpage = get_dirportfrontpage();\n\n    if (frontpage) {\n      dlen = strlen(frontpage);\n      /* Let's return a disclaimer page (users shouldn't use V1 anymore,\n         and caches don't fetch '/', so this is safe). */\n\n      /* [We don't check for write_bucket_low here, since we want to serve\n       *  this page no matter what.] */\n      note_request(url, dlen);\n      write_http_response_header_impl(conn, dlen, \"text/html\", \"identity\",\n                                      NULL, DIRPORTFRONTPAGE_CACHE_LIFETIME);\n      connection_write_to_buf(frontpage, dlen, TO_CONN(conn));\n      goto done;\n    }\n    /* if no disclaimer file, fall through and continue */\n  }\n\n  if (!strcmp(url,\"/tor/\") || !strcmp(url,\"/tor/dir\")) { /* v1 dir fetch */\n    cached_dir_t *d = dirserv_get_directory();\n\n    if (!d) {\n      log_info(LD_DIRSERV,\"Client asked for the mirrored directory, but we \"\n               \"don't have a good one yet. Sending 503 Dir not available.\");\n      write_http_status_line(conn, 503, \"Directory unavailable\");\n      goto done;\n    }\n    if (d->published < if_modified_since) {\n      write_http_status_line(conn, 304, \"Not modified\");\n      goto done;\n    }\n\n    dlen = compressed ? d->dir_z_len : d->dir_len;\n\n    if (global_write_bucket_low(TO_CONN(conn), dlen, 1)) {\n      log_debug(LD_DIRSERV,\n               \"Client asked for the mirrored directory, but we've been \"\n               \"writing too many bytes lately. Sending 503 Dir busy.\");\n      write_http_status_line(conn, 503, \"Directory busy, try again later\");\n      goto done;\n    }\n\n    note_request(url, dlen);\n\n    log_debug(LD_DIRSERV,\"Dumping %sdirectory to client.\",\n              compressed?\"compressed \":\"\");\n    write_http_response_header(conn, dlen, compressed,\n                          FULL_DIR_CACHE_LIFETIME);\n    conn->cached_dir = d;\n    conn->cached_dir_offset = 0;\n    if (!compressed)\n      conn->zlib_state = tor_zlib_new(0, ZLIB_METHOD);\n    ++d->refcnt;\n\n    /* Prime the connection with some data. */\n    conn->dir_spool_src = DIR_SPOOL_CACHED_DIR;\n    connection_dirserv_flushed_some(conn);\n    goto done;\n  }\n\n  if (!strcmp(url,\"/tor/running-routers\")) { /* running-routers fetch */\n    cached_dir_t *d = dirserv_get_runningrouters();\n    if (!d) {\n      write_http_status_line(conn, 503, \"Directory unavailable\");\n      goto done;\n    }\n    if (d->published < if_modified_since) {\n      write_http_status_line(conn, 304, \"Not modified\");\n      goto done;\n    }\n    dlen = compressed ? d->dir_z_len : d->dir_len;\n\n    if (global_write_bucket_low(TO_CONN(conn), dlen, 1)) {\n      log_info(LD_DIRSERV,\n               \"Client asked for running-routers, but we've been \"\n               \"writing too many bytes lately. Sending 503 Dir busy.\");\n      write_http_status_line(conn, 503, \"Directory busy, try again later\");\n      goto done;\n    }\n    note_request(url, dlen);\n    write_http_response_header(conn, dlen, compressed,\n                 RUNNINGROUTERS_CACHE_LIFETIME);\n    connection_write_to_buf(compressed ? d->dir_z : d->dir, dlen,\n                            TO_CONN(conn));\n    goto done;\n  }\n\n  if (!strcmpstart(url,\"/tor/status/\")\n      || !strcmpstart(url, \"/tor/status-vote/current/consensus\")) {\n    /* v2 or v3 network status fetch. */\n    smartlist_t *dir_fps = smartlist_create();\n    int is_v3 = !strcmpstart(url, \"/tor/status-vote\");\n    geoip_client_action_t act =\n        is_v3 ? GEOIP_CLIENT_NETWORKSTATUS : GEOIP_CLIENT_NETWORKSTATUS_V2;\n    const char *request_type = NULL;\n    const char *key = url + strlen(\"/tor/status/\");\n    long lifetime = NETWORKSTATUS_CACHE_LIFETIME;\n\n    if (!is_v3) {\n      dirserv_get_networkstatus_v2_fingerprints(dir_fps, key);\n      if (!strcmpstart(key, \"fp/\"))\n        request_type = compressed?\"/tor/status/fp.z\":\"/tor/status/fp\";\n      else if (!strcmpstart(key, \"authority\"))\n        request_type = compressed?\"/tor/status/authority.z\":\n          \"/tor/status/authority\";\n      else if (!strcmpstart(key, \"all\"))\n        request_type = compressed?\"/tor/status/all.z\":\"/tor/status/all\";\n      else\n        request_type = \"/tor/status/?\";\n    } else {\n      networkstatus_t *v = networkstatus_get_latest_consensus();\n      time_t now = time(NULL);\n      const char *want_fps = NULL;\n      char *flavor = NULL;\n      #define CONSENSUS_URL_PREFIX \"/tor/status-vote/current/consensus/\"\n      #define CONSENSUS_FLAVORED_PREFIX \"/tor/status-vote/current/consensus-\"\n      /* figure out the flavor if any, and who we wanted to sign the thing */\n      if (!strcmpstart(url, CONSENSUS_FLAVORED_PREFIX)) {\n        const char *f, *cp;\n        f = url + strlen(CONSENSUS_FLAVORED_PREFIX);\n        cp = strchr(f, '/');\n        if (cp) {\n          want_fps = cp+1;\n          flavor = tor_strndup(f, cp-f);\n        } else {\n          flavor = tor_strdup(f);\n        }\n      } else {\n        if (!strcmpstart(url, CONSENSUS_URL_PREFIX))\n          want_fps = url+strlen(CONSENSUS_URL_PREFIX);\n      }\n\n      /* XXXX MICRODESC NM NM should check document of correct flavor */\n      if (v && want_fps &&\n          !client_likes_consensus(v, want_fps)) {\n        write_http_status_line(conn, 404, \"Consensus not signed by sufficient \"\n                                          \"number of requested authorities\");\n        smartlist_free(dir_fps);\n        geoip_note_ns_response(act, GEOIP_REJECT_NOT_ENOUGH_SIGS);\n        tor_free(flavor);\n        goto done;\n      }\n\n      {\n        char *fp = tor_malloc_zero(DIGEST_LEN);\n        if (flavor)\n          strlcpy(fp, flavor, DIGEST_LEN);\n        tor_free(flavor);\n        smartlist_add(dir_fps, fp);\n      }\n      request_type = compressed?\"v3.z\":\"v3\";\n      lifetime = (v && v->fresh_until > now) ? v->fresh_until - now : 0;\n    }\n\n    if (!smartlist_len(dir_fps)) { /* we failed to create/cache cp */\n      write_http_status_line(conn, 503, \"Network status object unavailable\");\n      smartlist_free(dir_fps);\n      geoip_note_ns_response(act, GEOIP_REJECT_UNAVAILABLE);\n      goto done;\n    }\n\n    if (!dirserv_remove_old_statuses(dir_fps, if_modified_since)) {\n      write_http_status_line(conn, 404, \"Not found\");\n      SMARTLIST_FOREACH(dir_fps, char *, cp, tor_free(cp));\n      smartlist_free(dir_fps);\n      geoip_note_ns_response(act, GEOIP_REJECT_NOT_FOUND);\n      goto done;\n    } else if (!smartlist_len(dir_fps)) {\n      write_http_status_line(conn, 304, \"Not modified\");\n      SMARTLIST_FOREACH(dir_fps, char *, cp, tor_free(cp));\n      smartlist_free(dir_fps);\n      geoip_note_ns_response(act, GEOIP_REJECT_NOT_MODIFIED);\n      goto done;\n    }\n\n    dlen = dirserv_estimate_data_size(dir_fps, 0, compressed);\n    if (global_write_bucket_low(TO_CONN(conn), dlen, 2)) {\n      log_debug(LD_DIRSERV,\n               \"Client asked for network status lists, but we've been \"\n               \"writing too many bytes lately. Sending 503 Dir busy.\");\n      write_http_status_line(conn, 503, \"Directory busy, try again later\");\n      SMARTLIST_FOREACH(dir_fps, char *, fp, tor_free(fp));\n      smartlist_free(dir_fps);\n      geoip_note_ns_response(act, GEOIP_REJECT_BUSY);\n      goto done;\n    }\n\n    {\n      struct in_addr in;\n      if (tor_inet_aton((TO_CONN(conn))->address, &in)) {\n        geoip_note_client_seen(act, ntohl(in.s_addr), time(NULL));\n        geoip_note_ns_response(act, GEOIP_SUCCESS);\n        /* Note that a request for a network status has started, so that we\n         * can measure the download time later on. */\n        if (TO_CONN(conn)->dirreq_id)\n          geoip_start_dirreq(TO_CONN(conn)->dirreq_id, dlen, act,\n                             DIRREQ_TUNNELED);\n        else\n          geoip_start_dirreq(TO_CONN(conn)->global_identifier, dlen, act,\n                             DIRREQ_DIRECT);\n      }\n    }\n\n    // note_request(request_type,dlen);\n    (void) request_type;\n    write_http_response_header(conn, -1, compressed,\n                               smartlist_len(dir_fps) == 1 ? lifetime : 0);\n    conn->fingerprint_stack = dir_fps;\n    if (! compressed)\n      conn->zlib_state = tor_zlib_new(0, ZLIB_METHOD);\n\n    /* Prime the connection with some data. */\n    conn->dir_spool_src = DIR_SPOOL_NETWORKSTATUS;\n    connection_dirserv_flushed_some(conn);\n    goto done;\n  }\n\n  if (!strcmpstart(url,\"/tor/status-vote/current/\") ||\n      !strcmpstart(url,\"/tor/status-vote/next/\")) {\n    /* XXXX If-modified-since is only implemented for the current\n     * consensus: that's probably fine, since it's the only vote document\n     * people fetch much. */\n    int current;\n    ssize_t body_len = 0;\n    ssize_t estimated_len = 0;\n    smartlist_t *items = smartlist_create();\n    smartlist_t *dir_items = smartlist_create();\n    int lifetime = 60; /* XXXX023 should actually use vote intervals. */\n    url += strlen(\"/tor/status-vote/\");\n    current = !strcmpstart(url, \"current/\");\n    url = strchr(url, '/');\n    tor_assert(url);\n    ++url;\n    if (!strcmp(url, \"consensus\")) {\n      const char *item;\n      tor_assert(!current); /* we handle current consensus specially above,\n                             * since it wants to be spooled. */\n      if ((item = dirvote_get_pending_consensus(FLAV_NS)))\n        smartlist_add(items, (char*)item);\n    } else if (!current && !strcmp(url, \"consensus-signatures\")) {\n      /* XXXX the spec says that we should implement\n       * current/consensus-signatures too.  It doesn't seem to be needed,\n       * though. */\n      const char *item;\n      if ((item=dirvote_get_pending_detached_signatures()))\n        smartlist_add(items, (char*)item);\n    } else if (!strcmp(url, \"authority\")) {\n      const cached_dir_t *d;\n      int flags = DGV_BY_ID |\n        (current ? DGV_INCLUDE_PREVIOUS : DGV_INCLUDE_PENDING);\n      if ((d=dirvote_get_vote(NULL, flags)))\n        smartlist_add(dir_items, (cached_dir_t*)d);\n    } else {\n      const cached_dir_t *d;\n      smartlist_t *fps = smartlist_create();\n      int flags;\n      if (!strcmpstart(url, \"d/\")) {\n        url += 2;\n        flags = DGV_INCLUDE_PENDING | DGV_INCLUDE_PREVIOUS;\n      } else {\n        flags = DGV_BY_ID |\n          (current ? DGV_INCLUDE_PREVIOUS : DGV_INCLUDE_PENDING);\n      }\n      dir_split_resource_into_fingerprints(url, fps, NULL,\n                                           DSR_HEX|DSR_SORT_UNIQ);\n      SMARTLIST_FOREACH(fps, char *, fp, {\n          if ((d = dirvote_get_vote(fp, flags)))\n            smartlist_add(dir_items, (cached_dir_t*)d);\n          tor_free(fp);\n        });\n      smartlist_free(fps);\n    }\n    if (!smartlist_len(dir_items) && !smartlist_len(items)) {\n      write_http_status_line(conn, 404, \"Not found\");\n      goto vote_done;\n    }\n    SMARTLIST_FOREACH(dir_items, cached_dir_t *, d,\n                      body_len += compressed ? d->dir_z_len : d->dir_len);\n    estimated_len += body_len;\n    SMARTLIST_FOREACH(items, const char *, item, {\n        size_t ln = strlen(item);\n        if (compressed) {\n          estimated_len += ln/2;\n        } else {\n          body_len += ln; estimated_len += ln;\n        }\n      });\n\n    if (global_write_bucket_low(TO_CONN(conn), estimated_len, 2)) {\n      write_http_status_line(conn, 503, \"Directory busy, try again later.\");\n      goto vote_done;\n    }\n    write_http_response_header(conn, body_len ? body_len : -1, compressed,\n                 lifetime);\n\n    if (smartlist_len(items)) {\n      if (compressed) {\n        conn->zlib_state = tor_zlib_new(1, ZLIB_METHOD);\n        SMARTLIST_FOREACH(items, const char *, c,\n                 connection_write_to_buf_zlib(c, strlen(c), conn, 0));\n        connection_write_to_buf_zlib(\"\", 0, conn, 1);\n      } else {\n        SMARTLIST_FOREACH(items, const char *, c,\n                         connection_write_to_buf(c, strlen(c), TO_CONN(conn)));\n      }\n    } else {\n      SMARTLIST_FOREACH(dir_items, cached_dir_t *, d,\n          connection_write_to_buf(compressed ? d->dir_z : d->dir,\n                                  compressed ? d->dir_z_len : d->dir_len,\n                                  TO_CONN(conn)));\n    }\n  vote_done:\n    smartlist_free(items);\n    smartlist_free(dir_items);\n    goto done;\n  }\n\n  if (!strcmpstart(url, \"/tor/micro/d/\")) {\n    smartlist_t *fps = smartlist_create();\n\n    dir_split_resource_into_fingerprints(url+strlen(\"/tor/micro/d/\"),\n                                      fps, NULL,\n                                      DSR_DIGEST256|DSR_BASE64|DSR_SORT_UNIQ);\n\n    if (!dirserv_have_any_microdesc(fps)) {\n      write_http_status_line(conn, 404, \"Not found\");\n      SMARTLIST_FOREACH(fps, char *, fp, tor_free(fp));\n      smartlist_free(fps);\n      goto done;\n    }\n    dlen = dirserv_estimate_microdesc_size(fps, compressed);\n    if (global_write_bucket_low(TO_CONN(conn), dlen, 2)) {\n      log_info(LD_DIRSERV,\n               \"Client asked for server descriptors, but we've been \"\n               \"writing too many bytes lately. Sending 503 Dir busy.\");\n      write_http_status_line(conn, 503, \"Directory busy, try again later\");\n      SMARTLIST_FOREACH(fps, char *, fp, tor_free(fp));\n      smartlist_free(fps);\n      goto done;\n    }\n\n    write_http_response_header(conn, -1, compressed, MICRODESC_CACHE_LIFETIME);\n    conn->dir_spool_src = DIR_SPOOL_MICRODESC;\n    conn->fingerprint_stack = fps;\n\n    if (compressed)\n      conn->zlib_state = tor_zlib_new(1, ZLIB_METHOD);\n\n    connection_dirserv_flushed_some(conn);\n    goto done;\n  }\n\n  if (!strcmpstart(url,\"/tor/server/\") ||\n      (!options->BridgeAuthoritativeDir &&\n       !options->BridgeRelay && !strcmpstart(url,\"/tor/extra/\"))) {\n    int res;\n    const char *msg;\n    const char *request_type = NULL;\n    int cache_lifetime = 0;\n    int is_extra = !strcmpstart(url,\"/tor/extra/\");\n    url += is_extra ? strlen(\"/tor/extra/\") : strlen(\"/tor/server/\");\n    conn->fingerprint_stack = smartlist_create();\n    res = dirserv_get_routerdesc_fingerprints(conn->fingerprint_stack, url,\n                                          &msg,\n                                          !connection_dir_is_encrypted(conn),\n                                          is_extra);\n\n    if (!strcmpstart(url, \"fp/\")) {\n      request_type = compressed?\"/tor/server/fp.z\":\"/tor/server/fp\";\n      if (smartlist_len(conn->fingerprint_stack) == 1)\n        cache_lifetime = ROUTERDESC_CACHE_LIFETIME;\n    } else if (!strcmpstart(url, \"authority\")) {\n      request_type = compressed?\"/tor/server/authority.z\":\n        \"/tor/server/authority\";\n      cache_lifetime = ROUTERDESC_CACHE_LIFETIME;\n    } else if (!strcmpstart(url, \"all\")) {\n      request_type = compressed?\"/tor/server/all.z\":\"/tor/server/all\";\n      cache_lifetime = FULL_DIR_CACHE_LIFETIME;\n    } else if (!strcmpstart(url, \"d/\")) {\n      request_type = compressed?\"/tor/server/d.z\":\"/tor/server/d\";\n      if (smartlist_len(conn->fingerprint_stack) == 1)\n        cache_lifetime = ROUTERDESC_BY_DIGEST_CACHE_LIFETIME;\n    } else {\n      request_type = \"/tor/server/?\";\n    }\n    (void) request_type; /* usable for note_request. */\n    if (!strcmpstart(url, \"d/\"))\n      conn->dir_spool_src =\n        is_extra ? DIR_SPOOL_EXTRA_BY_DIGEST : DIR_SPOOL_SERVER_BY_DIGEST;\n    else\n      conn->dir_spool_src =\n        is_extra ? DIR_SPOOL_EXTRA_BY_FP : DIR_SPOOL_SERVER_BY_FP;\n\n    if (!dirserv_have_any_serverdesc(conn->fingerprint_stack,\n                                     conn->dir_spool_src)) {\n      res = -1;\n      msg = \"Not found\";\n    }\n\n    if (res < 0)\n      write_http_status_line(conn, 404, msg);\n    else {\n      dlen = dirserv_estimate_data_size(conn->fingerprint_stack,\n                                        1, compressed);\n      if (global_write_bucket_low(TO_CONN(conn), dlen, 2)) {\n        log_info(LD_DIRSERV,\n                 \"Client asked for server descriptors, but we've been \"\n                 \"writing too many bytes lately. Sending 503 Dir busy.\");\n        write_http_status_line(conn, 503, \"Directory busy, try again later\");\n        conn->dir_spool_src = DIR_SPOOL_NONE;\n        goto done;\n      }\n      write_http_response_header(conn, -1, compressed, cache_lifetime);\n      if (compressed)\n        conn->zlib_state = tor_zlib_new(1, ZLIB_METHOD);\n      /* Prime the connection with some data. */\n      connection_dirserv_flushed_some(conn);\n    }\n    goto done;\n  }\n\n  if (!strcmpstart(url,\"/tor/keys/\")) {\n    smartlist_t *certs = smartlist_create();\n    ssize_t len = -1;\n    if (!strcmp(url, \"/tor/keys/all\")) {\n      authority_cert_get_all(certs);\n    } else if (!strcmp(url, \"/tor/keys/authority\")) {\n      authority_cert_t *cert = get_my_v3_authority_cert();\n      if (cert)\n        smartlist_add(certs, cert);\n    } else if (!strcmpstart(url, \"/tor/keys/fp/\")) {\n      smartlist_t *fps = smartlist_create();\n      dir_split_resource_into_fingerprints(url+strlen(\"/tor/keys/fp/\"),\n                                           fps, NULL,\n                                           DSR_HEX|DSR_SORT_UNIQ);\n      SMARTLIST_FOREACH(fps, char *, d, {\n          authority_cert_t *c = authority_cert_get_newest_by_id(d);\n          if (c) smartlist_add(certs, c);\n          tor_free(d);\n      });\n      smartlist_free(fps);\n    } else if (!strcmpstart(url, \"/tor/keys/sk/\")) {\n      smartlist_t *fps = smartlist_create();\n      dir_split_resource_into_fingerprints(url+strlen(\"/tor/keys/sk/\"),\n                                           fps, NULL,\n                                           DSR_HEX|DSR_SORT_UNIQ);\n      SMARTLIST_FOREACH(fps, char *, d, {\n          authority_cert_t *c = authority_cert_get_by_sk_digest(d);\n          if (c) smartlist_add(certs, c);\n          tor_free(d);\n      });\n      smartlist_free(fps);\n    } else if (!strcmpstart(url, \"/tor/keys/fp-sk/\")) {\n      smartlist_t *fp_sks = smartlist_create();\n      dir_split_resource_into_fingerprint_pairs(url+strlen(\"/tor/keys/fp-sk/\"),\n                                                fp_sks);\n      SMARTLIST_FOREACH(fp_sks, fp_pair_t *, pair, {\n          authority_cert_t *c = authority_cert_get_by_digests(pair->first,\n                                                              pair->second);\n          if (c) smartlist_add(certs, c);\n          tor_free(pair);\n      });\n      smartlist_free(fp_sks);\n    } else {\n      write_http_status_line(conn, 400, \"Bad request\");\n      goto keys_done;\n    }\n    if (!smartlist_len(certs)) {\n      write_http_status_line(conn, 404, \"Not found\");\n      goto keys_done;\n    }\n    SMARTLIST_FOREACH(certs, authority_cert_t *, c,\n      if (c->cache_info.published_on < if_modified_since)\n        SMARTLIST_DEL_CURRENT(certs, c));\n    if (!smartlist_len(certs)) {\n      write_http_status_line(conn, 304, \"Not modified\");\n      goto keys_done;\n    }\n    len = 0;\n    SMARTLIST_FOREACH(certs, authority_cert_t *, c,\n                      len += c->cache_info.signed_descriptor_len);\n\n    if (global_write_bucket_low(TO_CONN(conn), compressed?len/2:len, 2)) {\n      write_http_status_line(conn, 503, \"Directory busy, try again later.\");\n      goto keys_done;\n    }\n\n    write_http_response_header(conn, compressed?-1:len, compressed, 60*60);\n    if (compressed) {\n      conn->zlib_state = tor_zlib_new(1, ZLIB_METHOD);\n      SMARTLIST_FOREACH(certs, authority_cert_t *, c,\n            connection_write_to_buf_zlib(c->cache_info.signed_descriptor_body,\n                                         c->cache_info.signed_descriptor_len,\n                                         conn, 0));\n      connection_write_to_buf_zlib(\"\", 0, conn, 1);\n    } else {\n      SMARTLIST_FOREACH(certs, authority_cert_t *, c,\n            connection_write_to_buf(c->cache_info.signed_descriptor_body,\n                                    c->cache_info.signed_descriptor_len,\n                                    TO_CONN(conn)));\n    }\n  keys_done:\n    smartlist_free(certs);\n    goto done;\n  }\n\n  if (options->HidServDirectoryV2 &&\n       !strcmpstart(url,\"/tor/rendezvous2/\")) {\n    /* Handle v2 rendezvous descriptor fetch request. */\n    const char *descp;\n    const char *query = url + strlen(\"/tor/rendezvous2/\");\n    if (strlen(query) == REND_DESC_ID_V2_LEN_BASE32) {\n      log_info(LD_REND, \"Got a v2 rendezvous descriptor request for ID '%s'\",\n               safe_str(query));\n      switch (rend_cache_lookup_v2_desc_as_dir(query, &descp)) {\n        case 1: /* valid */\n          write_http_response_header(conn, strlen(descp), 0, 0);\n          connection_write_to_buf(descp, strlen(descp), TO_CONN(conn));\n          break;\n        case 0: /* well-formed but not present */\n          write_http_status_line(conn, 404, \"Not found\");\n          break;\n        case -1: /* not well-formed */\n          write_http_status_line(conn, 400, \"Bad request\");\n          break;\n      }\n    } else { /* not well-formed */\n      write_http_status_line(conn, 400, \"Bad request\");\n    }\n    goto done;\n  }\n\n  if (options->HSAuthoritativeDir && !strcmpstart(url,\"/tor/rendezvous/\")) {\n    /* rendezvous descriptor fetch */\n    const char *descp;\n    size_t desc_len;\n    const char *query = url+strlen(\"/tor/rendezvous/\");\n\n    log_info(LD_REND, \"Handling rendezvous descriptor get\");\n    switch (rend_cache_lookup_desc(query, 0, &descp, &desc_len)) {\n      case 1: /* valid */\n        write_http_response_header_impl(conn, desc_len,\n                                        \"application/octet-stream\",\n                                        NULL, NULL, 0);\n        note_request(\"/tor/rendezvous?/\", desc_len);\n        /* need to send descp separately, because it may include NULs */\n        connection_write_to_buf(descp, desc_len, TO_CONN(conn));\n        break;\n      case 0: /* well-formed but not present */\n        write_http_status_line(conn, 404, \"Not found\");\n        break;\n      case -1: /* not well-formed */\n        write_http_status_line(conn, 400, \"Bad request\");\n        break;\n    }\n    goto done;\n  }\n\n  if (options->BridgeAuthoritativeDir &&\n      options->_BridgePassword_AuthDigest &&\n      connection_dir_is_encrypted(conn) &&\n      !strcmp(url,\"/tor/networkstatus-bridges\")) {\n    char *status;\n    char digest[DIGEST256_LEN];\n\n    header = http_get_header(headers, \"Authorization: Basic \");\n    if (header)\n      crypto_digest256(digest, header, strlen(header), DIGEST_SHA256);\n\n    /* now make sure the password is there and right */\n    if (!header ||\n        tor_memneq(digest,\n                   options->_BridgePassword_AuthDigest, DIGEST256_LEN)) {\n      write_http_status_line(conn, 404, \"Not found\");\n      tor_free(header);\n      goto done;\n    }\n    tor_free(header);\n\n    /* all happy now. send an answer. */\n    status = networkstatus_getinfo_by_purpose(\"bridge\", time(NULL));\n    dlen = strlen(status);\n    write_http_response_header(conn, dlen, 0, 0);\n    connection_write_to_buf(status, dlen, TO_CONN(conn));\n    tor_free(status);\n    goto done;\n  }\n\n  if (!strcmpstart(url,\"/tor/bytes.txt\")) {\n    char *bytes = directory_dump_request_log();\n    size_t len = strlen(bytes);\n    write_http_response_header(conn, len, 0, 0);\n    connection_write_to_buf(bytes, len, TO_CONN(conn));\n    tor_free(bytes);\n    goto done;\n  }\n\n  if (!strcmp(url,\"/tor/robots.txt\")) { /* /robots.txt will have been\n                                           rewritten to /tor/robots.txt */\n    char robots[] = \"User-agent: *\\r\\nDisallow: /\\r\\n\";\n    size_t len = strlen(robots);\n    write_http_response_header(conn, len, 0, ROBOTS_CACHE_LIFETIME);\n    connection_write_to_buf(robots, len, TO_CONN(conn));\n    goto done;\n  }\n\n  if (!strcmp(url,\"/tor/dbg-stability.txt\")) {\n    const char *stability;\n    size_t len;\n    if (options->BridgeAuthoritativeDir ||\n        ! authdir_mode_tests_reachability(options) ||\n        ! (stability = rep_hist_get_router_stability_doc(time(NULL)))) {\n      write_http_status_line(conn, 404, \"Not found.\");\n      goto done;\n    }\n\n    len = strlen(stability);\n    write_http_response_header(conn, len, 0, 0);\n    connection_write_to_buf(stability, len, TO_CONN(conn));\n    goto done;\n  }\n\n#if defined(EXPORTMALLINFO) && defined(HAVE_MALLOC_H) && defined(HAVE_MALLINFO)\n#define ADD_MALLINFO_LINE(x) do {                               \\\n    tor_snprintf(tmp, sizeof(tmp), \"%s %d\\n\", #x, mi.x);        \\\n    smartlist_add(lines, tor_strdup(tmp));                      \\\n  }while(0);\n\n  if (!strcmp(url,\"/tor/mallinfo.txt\") &&\n      (tor_addr_eq_ipv4h(&conn->_base.addr, 0x7f000001ul))) {\n    char *result;\n    size_t len;\n    struct mallinfo mi;\n    smartlist_t *lines;\n    char tmp[256];\n\n    memset(&mi, 0, sizeof(mi));\n    mi = mallinfo();\n    lines = smartlist_create();\n\n    ADD_MALLINFO_LINE(arena)\n    ADD_MALLINFO_LINE(ordblks)\n    ADD_MALLINFO_LINE(smblks)\n    ADD_MALLINFO_LINE(hblks)\n    ADD_MALLINFO_LINE(hblkhd)\n    ADD_MALLINFO_LINE(usmblks)\n    ADD_MALLINFO_LINE(fsmblks)\n    ADD_MALLINFO_LINE(uordblks)\n    ADD_MALLINFO_LINE(fordblks)\n    ADD_MALLINFO_LINE(keepcost)\n\n    result = smartlist_join_strings(lines, \"\", 0, NULL);\n    SMARTLIST_FOREACH(lines, char *, cp, tor_free(cp));\n    smartlist_free(lines);\n\n    len = strlen(result);\n    write_http_response_header(conn, len, 0, 0);\n    connection_write_to_buf(result, len, TO_CONN(conn));\n    tor_free(result);\n    goto done;\n  }\n#endif\n\n  /* we didn't recognize the url */\n  write_http_status_line(conn, 404, \"Not found\");\n\n done:\n  tor_free(url_mem);\n  return 0;\n}", "target": 1, "cwe": [], "message": "Fix assertion failure in tor_timegm.\n\nFixes bug 6811."}
{"func": "tor_timegm(struct tm *tm)\n{\n  /* This is a pretty ironclad timegm implementation, snarfed from Python2.2.\n   * It's way more brute-force than fiddling with tzset().\n   */\n  time_t year, days, hours, minutes, seconds;\n  int i;\n  year = tm->tm_year + 1900;\n  if (year < 1970 || tm->tm_mon < 0 || tm->tm_mon > 11) {\n    log_warn(LD_BUG, \"Out-of-range argument to tor_timegm\");\n    return -1;\n  }\n  tor_assert(year < INT_MAX);\n  days = 365 * (year-1970) + n_leapdays(1970,(int)year);\n  for (i = 0; i < tm->tm_mon; ++i)\n    days += days_per_month[i];\n  if (tm->tm_mon > 1 && IS_LEAPYEAR(year))\n    ++days;\n  days += tm->tm_mday - 1;\n  hours = days*24 + tm->tm_hour;\n\n  minutes = hours*60 + tm->tm_min;\n  seconds = minutes*60 + tm->tm_sec;\n  return seconds;\n}", "target": 1, "cwe": [], "message": "Fix assertion failure in tor_timegm.\n\nFixes bug 6811."}
{"func": "parse_iso_time(const char *cp, time_t *t)\n{\n  struct tm st_tm;\n  unsigned int year=0, month=0, day=0, hour=0, minute=0, second=0;\n  if (tor_sscanf(cp, \"%u-%2u-%2u %2u:%2u:%2u\", &year, &month,\n                &day, &hour, &minute, &second) < 6) {\n    char *esc = esc_for_log(cp);\n    log_warn(LD_GENERAL, \"ISO time %s was unparseable\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  if (year < 1970 || month < 1 || month > 12 || day < 1 || day > 31 ||\n          hour > 23 || minute > 59 || second > 60) {\n    char *esc = esc_for_log(cp);\n    log_warn(LD_GENERAL, \"ISO time %s was nonsensical\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  st_tm.tm_year = year-1900;\n  st_tm.tm_mon = month-1;\n  st_tm.tm_mday = day;\n  st_tm.tm_hour = hour;\n  st_tm.tm_min = minute;\n  st_tm.tm_sec = second;\n\n  if (st_tm.tm_year < 70) {\n    char *esc = esc_for_log(cp);\n    log_warn(LD_GENERAL, \"Got invalid ISO time %s. (Before 1970)\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  *t = tor_timegm(&st_tm);\n  return 0;\n}", "target": 1, "cwe": [], "message": "Fix assertion failure in tor_timegm.\n\nFixes bug 6811."}
{"func": "parse_rfc1123_time(const char *buf, time_t *t)\n{\n  struct tm tm;\n  char month[4];\n  char weekday[4];\n  int i, m;\n  unsigned tm_mday, tm_year, tm_hour, tm_min, tm_sec;\n\n  if (strlen(buf) != RFC1123_TIME_LEN)\n    return -1;\n  memset(&tm, 0, sizeof(tm));\n  if (tor_sscanf(buf, \"%3s, %2u %3s %u %2u:%2u:%2u GMT\", weekday,\n             &tm_mday, month, &tm_year, &tm_hour,\n             &tm_min, &tm_sec) < 7) {\n    char *esc = esc_for_log(buf);\n    log_warn(LD_GENERAL, \"Got invalid RFC1123 time %s\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  if (tm_mday < 1 || tm_mday > 31 || tm_hour > 23 || tm_min > 59 ||\n      tm_sec > 60) {\n    char *esc = esc_for_log(buf);\n    log_warn(LD_GENERAL, \"Got invalid RFC1123 time %s\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  tm.tm_mday = (int)tm_mday;\n  tm.tm_year = (int)tm_year;\n  tm.tm_hour = (int)tm_hour;\n  tm.tm_min = (int)tm_min;\n  tm.tm_sec = (int)tm_sec;\n\n  m = -1;\n  for (i = 0; i < 12; ++i) {\n    if (!strcmp(month, MONTH_NAMES[i])) {\n      m = i;\n      break;\n    }\n  }\n  if (m<0) {\n    char *esc = esc_for_log(buf);\n    log_warn(LD_GENERAL, \"Got invalid RFC1123 time %s: No such month\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  tm.tm_mon = m;\n\n  if (tm.tm_year < 1970) {\n    char *esc = esc_for_log(buf);\n    log_warn(LD_GENERAL,\n             \"Got invalid RFC1123 time %s. (Before 1970)\", esc);\n    tor_free(esc);\n    return -1;\n  }\n  tm.tm_year -= 1900;\n\n  *t = tor_timegm(&tm);\n  return 0;\n}", "target": 1, "cwe": [], "message": "Fix assertion failure in tor_timegm.\n\nFixes bug 6811."}
{"func": "dirvote_get_start_of_next_interval(time_t now, int interval)\n{\n  struct tm tm;\n  time_t midnight_today;\n  time_t midnight_tomorrow;\n  time_t next;\n\n  tor_gmtime_r(&now, &tm);\n  tm.tm_hour = 0;\n  tm.tm_min = 0;\n  tm.tm_sec = 0;\n\n  midnight_today = tor_timegm(&tm);\n  midnight_tomorrow = midnight_today + (24*60*60);\n\n  next = midnight_today + ((now-midnight_today)/interval + 1)*interval;\n\n  /* Intervals never cross midnight. */\n  if (next > midnight_tomorrow)\n    next = midnight_tomorrow;\n\n  /* If the interval would only last half as long as it's supposed to, then\n   * skip over to the next day. */\n  if (next + interval/2 > midnight_tomorrow)\n    next = midnight_tomorrow;\n\n  return next;\n}", "target": 1, "cwe": [], "message": "Fix assertion failure in tor_timegm.\n\nFixes bug 6811."}
{"func": "compare_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,\n                                const smartlist_t *policy)\n{\n  if (!policy) {\n    /* no policy? accept all. */\n    return ADDR_POLICY_ACCEPTED;\n  } else if (tor_addr_is_null(addr)) {\n    tor_assert(port != 0);\n    return compare_unknown_tor_addr_to_addr_policy(port, policy);\n  } else if (port == 0) {\n    return compare_known_tor_addr_to_addr_policy_noport(addr, policy);\n  } else {\n    return compare_known_tor_addr_to_addr_policy(addr, port, policy);\n  }\n}", "target": 1, "cwe": [], "message": "Do not assert when comparing a null address/port against a policy\n\nThis can create a remote crash opportunity for/against directory\nauthorities."}
{"func": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1, "cwe": ["CWE-200"], "message": "Do not leak clipboard to unauthenticated clients\n\nvino_server_clipboard_cb() in vino-server.c is the callback which is\ntriggered when a clipboard copy event is fired.\n\nAfter doing some initial checks, (1. If there are any connected clients,\n2. If the server is on hold etc), it converts the text to UTF-8 and then\npasses it on to rfbSendServerCutText(). Here data is pasted to each\nclient, without verifying if the client is authenticated.\n\nThe patch checks if the client is authenticated and only then it allows\nthe clipboard text to be sent to it.\n\nFixes bug 678434. This is a security issue, and has been assigned\nCVE-2012-4429:\nhttp://www.openwall.com/lists/oss-security/2012/09/14/1"}
{"func": "xsltAttrTemplateProcess(xsltTransformContextPtr ctxt, xmlNodePtr target,\n\t                xmlAttrPtr attr)\n{\n    const xmlChar *value;\n    xmlAttrPtr ret;\n\n    if ((ctxt == NULL) || (attr == NULL) || (target == NULL) ||\n        (target->type != XML_ELEMENT_NODE))\n\treturn(NULL);\n    \n    if (attr->type != XML_ATTRIBUTE_NODE)\n\treturn(NULL);\n\n    /*\n    * Skip all XSLT attributes.\n    */\n#ifdef XSLT_REFACTORED    \n    if (attr->psvi == xsltXSLTAttrMarker)\n\treturn(NULL);\n#else\n    if ((attr->ns != NULL) && xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n\treturn(NULL);\n#endif\n    /*\n    * Get the value.\n    */\n    if (attr->children != NULL) {\n\tif ((attr->children->type != XML_TEXT_NODE) ||\n\t    (attr->children->next != NULL))\n\t{\n\t    xsltTransformError(ctxt, NULL, attr->parent,\n\t\t\"Internal error: The children of an attribute node of a \"\n\t\t\"literal result element are not in the expected form.\\n\");\n\t    return(NULL);\n\t}\n\tvalue = attr->children->content;\n\tif (value == NULL)\n\t    value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n    } else\n\tvalue = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n    /*\n    * Overwrite duplicates.\n    */\n    ret = target->properties;\n    while (ret != NULL) {\n        if (((attr->ns != NULL) == (ret->ns != NULL)) &&\n\t    xmlStrEqual(ret->name, attr->name) &&\n\t    ((attr->ns == NULL) || xmlStrEqual(ret->ns->href, attr->ns->href)))\n\t{\n\t    break;\n\t}\n        ret = ret->next;\n    }\n    if (ret != NULL) {\t\n        /* free the existing value */\n\txmlFreeNodeList(ret->children);\n\tret->children = ret->last = NULL;\n\t/*\n\t* Adjust ns-prefix if needed.\n\t*/\n\tif ((ret->ns != NULL) &&\n\t    (! xmlStrEqual(ret->ns->prefix, attr->ns->prefix)))\n\t{\n\t    ret->ns = xsltGetNamespace(ctxt, attr->parent, attr->ns, target);\n\t}\n    } else {\n        /* create a new attribute */\n\tif (attr->ns != NULL)\n\t    ret = xmlNewNsProp(target,\n\t\txsltGetNamespace(ctxt, attr->parent, attr->ns, target),\n\t\t    attr->name, NULL);\n\telse\n\t    ret = xmlNewNsProp(target, NULL, attr->name, NULL);\t\n    }\n    /*\n    * Set the value.\n    */\n    if (ret != NULL) {\n        xmlNodePtr text;\n\n        text = xmlNewText(NULL);\n\tif (text != NULL) {\n\t    ret->last = ret->children = text;\n\t    text->parent = (xmlNodePtr) ret;\n\t    text->doc = ret->doc;\n\n\t    if (attr->psvi != NULL) {\n\t\t/*\n\t\t* Evaluate the Attribute Value Template.\n\t\t*/\n\t\txmlChar *val;\n\t\tval = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n\t\tif (val == NULL) {\n\t\t    /*\n\t\t    * TODO: Damn, we need an easy mechanism to report\n\t\t    * qualified names!\n\t\t    */\n\t\t    if (attr->ns) {\n\t\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t\t    \"Internal error: Failed to evaluate the AVT \"\n\t\t\t    \"of attribute '{%s}%s'.\\n\",\n\t\t\t    attr->ns->href, attr->name);\n\t\t    } else {\n\t\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t\t    \"Internal error: Failed to evaluate the AVT \"\n\t\t\t    \"of attribute '%s'.\\n\",\n\t\t\t    attr->name);\n\t\t    }\n\t\t    text->content = xmlStrdup(BAD_CAST \"\");\n\t\t} else {\n\t\t    text->content = val;\n\t\t}\n\t    } else if ((ctxt->internalized) && (target != NULL) &&\n\t               (target->doc != NULL) &&\n\t\t       (target->doc->dict == ctxt->dict)) {\n\t\ttext->content = (xmlChar *) value;\n\t    } else {\n\t\ttext->content = xmlStrdup(value);\n\t    }\n\t}\n    } else {\n\tif (attr->ns) {\n\t    xsltTransformError(ctxt, NULL, attr->parent,\n\t    \t\"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n\t\tattr->ns->href, attr->name);\n\t} else {\n\t    xsltTransformError(ctxt, NULL, attr->parent,\n\t    \t\"Internal error: Failed to create attribute '%s'.\\n\",\n\t\tattr->name);\n\t}\n    }\n    return(ret);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Fix a dictionary string usage\n\nRaised in chromium, but also affecting xsltproc\nAlso updated AUTHORS to list Chris and other contributors"}
{"func": "xsltAttrListTemplateProcess(xsltTransformContextPtr ctxt, \n\t                    xmlNodePtr target, xmlAttrPtr attrs)\n{\n    xmlAttrPtr attr, copy, last;\n    xmlNodePtr oldInsert, text;\n    xmlNsPtr origNs = NULL, copyNs = NULL;\n    const xmlChar *value;\n    xmlChar *valueAVT;\n\n    if ((ctxt == NULL) || (target == NULL) || (attrs == NULL) ||\n        (target->type != XML_ELEMENT_NODE))\n\treturn(NULL);\n\n    oldInsert = ctxt->insert;\n    ctxt->insert = target;        \n\n    /*\n    * Instantiate LRE-attributes.\n    */\n    if (target->properties) {\n\tlast = target->properties;\n\twhile (last->next != NULL)\n\t    last = last->next;\n    } else {\n\tlast = NULL;\n    }\n    attr = attrs;\n    do {\n\t/*\n\t* Skip XSLT attributes.\n\t*/\n#ifdef XSLT_REFACTORED\n\tif (attr->psvi == xsltXSLTAttrMarker) {\n\t    goto next_attribute;\n\t}\n#else\n\tif ((attr->ns != NULL) &&\n\t    xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n\t{\n\t    goto next_attribute;\n\t}\n#endif\n\t/*\n\t* Get the value.\n\t*/\n\tif (attr->children != NULL) {\n\t    if ((attr->children->type != XML_TEXT_NODE) ||\n\t\t(attr->children->next != NULL))\n\t    {\n\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t    \"Internal error: The children of an attribute node of a \"\n\t\t    \"literal result element are not in the expected form.\\n\");\n\t\tgoto error;\n\t    }\n\t    value = attr->children->content;\n\t    if (value == NULL)\n\t\tvalue = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n\t} else\n\t    value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n\n\t/*\n\t* Create a new attribute.\n\t*/\n\tcopy = xmlNewDocProp(target->doc, attr->name, NULL);\n\tif (copy == NULL) {\n\t    if (attr->ns) {\n\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t    \"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n\t\t    attr->ns->href, attr->name);\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t    \"Internal error: Failed to create attribute '%s'.\\n\",\n\t\t    attr->name);\n\t    }\n\t    goto error;\n\t}\n\t/*\n\t* Attach it to the target element.\n\t*/\n\tcopy->parent = target;\n\tif (last == NULL) {\n\t    target->properties = copy;\n\t    last = copy;\n\t} else {\n\t    last->next = copy;\n\t    copy->prev = last;\n\t    last = copy;\n\t}\n\t/*\n\t* Set the namespace. Avoid lookups of same namespaces.\n\t*/\n\tif (attr->ns != origNs) {\n\t    origNs = attr->ns;\n\t    if (attr->ns != NULL) {\n#ifdef XSLT_REFACTORED\n\t\tcopyNs = xsltGetSpecialNamespace(ctxt, attr->parent,\n\t\t    attr->ns->href, attr->ns->prefix, target);\n#else\n\t\tcopyNs = xsltGetNamespace(ctxt, attr->parent,\n\t\t    attr->ns, target);\n#endif\n\t\tif (copyNs == NULL)\n\t\t    goto error;\n\t    } else\n\t\tcopyNs = NULL;\n\t}\n\tcopy->ns = copyNs;\n\n\t/*\n\t* Set the value.\n\t*/\n\ttext = xmlNewText(NULL);\n\tif (text != NULL) {\n\t    copy->last = copy->children = text;\n\t    text->parent = (xmlNodePtr) copy;\n\t    text->doc = copy->doc;\n\n\t    if (attr->psvi != NULL) {\n\t\t/*\n\t\t* Evaluate the Attribute Value Template.\n\t\t*/\n\t\tvalueAVT = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n\t\tif (valueAVT == NULL) {\n\t\t    /*\n\t\t    * TODO: Damn, we need an easy mechanism to report\n\t\t    * qualified names!\n\t\t    */\n\t\t    if (attr->ns) {\n\t\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t\t    \"Internal error: Failed to evaluate the AVT \"\n\t\t\t    \"of attribute '{%s}%s'.\\n\",\n\t\t\t    attr->ns->href, attr->name);\n\t\t    } else {\n\t\t\txsltTransformError(ctxt, NULL, attr->parent,\n\t\t\t    \"Internal error: Failed to evaluate the AVT \"\n\t\t\t    \"of attribute '%s'.\\n\",\n\t\t\t    attr->name);\n\t\t    }\n\t\t    text->content = xmlStrdup(BAD_CAST \"\");\n\t\t    goto error;\n\t\t} else {\n\t\t    text->content = valueAVT;\n\t\t}\n\t    } else if ((ctxt->internalized) &&\n\t\t(target->doc != NULL) &&\n\t\t(target->doc->dict == ctxt->dict))\n\t    {\n\t\ttext->content = (xmlChar *) value;\n\t    } else {\n\t\ttext->content = xmlStrdup(value);\n\t    }\n            if ((copy != NULL) && (text != NULL) &&\n                (xmlIsID(copy->doc, copy->parent, copy)))\n                xmlAddID(NULL, copy->doc, text->content, copy);\n\t}\n\nnext_attribute:\n\tattr = attr->next;\n    } while (attr != NULL);\n\n    /*\n    * Apply attribute-sets.\n    * The creation of such attributes will not overwrite any existing\n    * attribute.\n    */\n    attr = attrs;\n    do {\n#ifdef XSLT_REFACTORED\n\tif ((attr->psvi == xsltXSLTAttrMarker) &&\n\t    xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\"))\n\t{\n\t    xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n\t}\n#else\n\tif ((attr->ns != NULL) &&\n\t    xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\") &&\n\t    xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n\t{\n\t    xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n\t}\n#endif\n\tattr = attr->next;\n    } while (attr != NULL);\n\n    ctxt->insert = oldInsert;\n    return(target->properties);\n\nerror:\n    ctxt->insert = oldInsert;\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-399"], "message": "Fix a dictionary string usage\n\nRaised in chromium, but also affecting xsltproc\nAlso updated AUTHORS to list Chris and other contributors"}
{"func": "static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}", "target": 1, "cwe": [], "message": "KVM: x86: invalid opcode oops on SET_SREGS with OSXSAVE bit set (CVE-2012-4461)\n\nOn hosts without the XSAVE support unprivileged local user can trigger\noops similar to the one below by setting X86_CR4_OSXSAVE bit in guest\ncr4 register using KVM_SET_SREGS ioctl and later issuing KVM_RUN\nioctl.\n\ninvalid opcode: 0000 [#2] SMP\nModules linked in: tun ip6table_filter ip6_tables ebtable_nat ebtables\n...\nPid: 24935, comm: zoog_kvm_monito Tainted: G      D      3.2.0-3-686-pae\nEIP: 0060:[<f8b9550c>] EFLAGS: 00210246 CPU: 0\nEIP is at kvm_arch_vcpu_ioctl_run+0x92a/0xd13 [kvm]\nEAX: 00000001 EBX: 000f387e ECX: 00000000 EDX: 00000000\nESI: 00000000 EDI: 00000000 EBP: ef5a0060 ESP: d7c63e70\n DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\nProcess zoog_kvm_monito (pid: 24935, ti=d7c62000 task=ed84a0c0\ntask.ti=d7c62000)\nStack:\n 00000001 f70a1200 f8b940a9 ef5a0060 00000000 00200202 f8769009 00000000\n ef5a0060 000f387e eda5c020 8722f9c8 00015bae 00000000 ed84a0c0 ed84a0c0\n c12bf02d 0000ae80 ef7f8740 fffffffb f359b740 ef5a0060 f8b85dc1 0000ae80\nCall Trace:\n [<f8b940a9>] ? kvm_arch_vcpu_ioctl_set_sregs+0x2fe/0x308 [kvm]\n...\n [<c12bfb44>] ? syscall_call+0x7/0xb\nCode: 89 e8 e8 14 ee ff ff ba 00 00 04 00 89 e8 e8 98 48 ff ff 85 c0 74\n1e 83 7d 48 00 75 18 8b 85 08 07 00 00 31 c9 8b 95 0c 07 00 00 <0f> 01\nd1 c7 45 48 01 00 00 00 c7 45 1c 01 00 00 00 0f ae f0 89\nEIP: [<f8b9550c>] kvm_arch_vcpu_ioctl_run+0x92a/0xd13 [kvm] SS:ESP\n0068:d7c63e70\n\nQEMU first retrieves the supported features via KVM_GET_SUPPORTED_CPUID\nand then sets them later. So guest's X86_FEATURE_XSAVE should be masked\nout on hosts without X86_FEATURE_XSAVE, making kvm_set_cr4 with\nX86_CR4_OSXSAVE fail. Userspaces that allow specifying guest cpuid with\nX86_FEATURE_XSAVE even on hosts that do not support it, might be\nsusceptible to this attack from inside the guest as well.\n\nAllow setting X86_CR4_OSXSAVE bit only if host has XSAVE support.\n\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint pending_vec, max_bits, idx;\n\tstruct desc_ptr dt;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tmmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (sregs->cr4 & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu)) {\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tmmu_reset_needed = 1;\n\t}\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "KVM: x86: invalid opcode oops on SET_SREGS with OSXSAVE bit set (CVE-2012-4461)\n\nOn hosts without the XSAVE support unprivileged local user can trigger\noops similar to the one below by setting X86_CR4_OSXSAVE bit in guest\ncr4 register using KVM_SET_SREGS ioctl and later issuing KVM_RUN\nioctl.\n\ninvalid opcode: 0000 [#2] SMP\nModules linked in: tun ip6table_filter ip6_tables ebtable_nat ebtables\n...\nPid: 24935, comm: zoog_kvm_monito Tainted: G      D      3.2.0-3-686-pae\nEIP: 0060:[<f8b9550c>] EFLAGS: 00210246 CPU: 0\nEIP is at kvm_arch_vcpu_ioctl_run+0x92a/0xd13 [kvm]\nEAX: 00000001 EBX: 000f387e ECX: 00000000 EDX: 00000000\nESI: 00000000 EDI: 00000000 EBP: ef5a0060 ESP: d7c63e70\n DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068\nProcess zoog_kvm_monito (pid: 24935, ti=d7c62000 task=ed84a0c0\ntask.ti=d7c62000)\nStack:\n 00000001 f70a1200 f8b940a9 ef5a0060 00000000 00200202 f8769009 00000000\n ef5a0060 000f387e eda5c020 8722f9c8 00015bae 00000000 ed84a0c0 ed84a0c0\n c12bf02d 0000ae80 ef7f8740 fffffffb f359b740 ef5a0060 f8b85dc1 0000ae80\nCall Trace:\n [<f8b940a9>] ? kvm_arch_vcpu_ioctl_set_sregs+0x2fe/0x308 [kvm]\n...\n [<c12bfb44>] ? syscall_call+0x7/0xb\nCode: 89 e8 e8 14 ee ff ff ba 00 00 04 00 89 e8 e8 98 48 ff ff 85 c0 74\n1e 83 7d 48 00 75 18 8b 85 08 07 00 00 31 c9 8b 95 0c 07 00 00 <0f> 01\nd1 c7 45 48 01 00 00 00 c7 45 1c 01 00 00 00 0f ae f0 89\nEIP: [<f8b9550c>] kvm_arch_vcpu_ioctl_run+0x92a/0xd13 [kvm] SS:ESP\n0068:d7c63e70\n\nQEMU first retrieves the supported features via KVM_GET_SUPPORTED_CPUID\nand then sets them later. So guest's X86_FEATURE_XSAVE should be masked\nout on hosts without X86_FEATURE_XSAVE, making kvm_set_cr4 with\nX86_CR4_OSXSAVE fail. Userspaces that allow specifying guest cpuid with\nX86_FEATURE_XSAVE even on hosts that do not support it, might be\nsusceptible to this attack from inside the guest as well.\n\nAllow setting X86_CR4_OSXSAVE bit only if host has XSAVE support.\n\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>"}
{"func": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\n\t/*\n\t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: do not leave bprm->interp on stack\n\nIf a series of scripts are executed, each triggering module loading via\nunprintable bytes in the script header, kernel stack contents can leak\ninto the command line.\n\nNormally execution of binfmt_script and binfmt_misc happens recursively.\nHowever, when modules are enabled, and unprintable bytes exist in the\nbprm->buf, execution will restart after attempting to load matching\nbinfmt modules.  Unfortunately, the logic in binfmt_script and\nbinfmt_misc does not expect to get restarted.  They leave bprm->interp\npointing to their local stack.  This means on restart bprm->interp is\nleft pointing into unused stack memory which can then be copied into the\nuserspace argv areas.\n\nAfter additional study, it seems that both recursion and restart remains\nthe desirable way to handle exec with scripts, misc, and modules.  As\nsuch, we need to protect the changes to interp.\n\nThis changes the logic to require allocation for any changes to the\nbprm->interp.  To avoid adding a new kmalloc to every exec, the default\nvalue is left as-is.  Only when passing through binfmt_script or\nbinfmt_misc does an allocation take place.\n\nFor a proof of concept, see DoTest.sh from:\n\n   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file * interp_file = NULL;\n\tchar iname[BINPRM_BUF_SIZE];\n\tconst char *iname_addr = iname;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\tgoto _ret;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tstrlcpy(iname, fmt->interpreter, BINPRM_BUF_SIZE);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\tgoto _ret;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto _ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it */\n \t\tfd_binary = get_unused_fd();\n \t\tif (fd_binary < 0) {\n \t\t\tretval = fd_binary;\n \t\t\tgoto _ret;\n \t\t}\n \t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n \t} else {\n \t\tallow_write_access(bprm->file);\n \t\tfput(bprm->file);\n \t\tbprm->file = NULL;\n \t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel (1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\tbprm->interp = iname;\t/* for binfmt_script */\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n\t} else\n\t\tretval = prepare_binprm (bprm);\n\n\tif (retval < 0)\n\t\tgoto _error;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\n_ret:\n\treturn retval;\n_error:\n\tif (fd_binary > 0)\n\t\tsys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto _ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: do not leave bprm->interp on stack\n\nIf a series of scripts are executed, each triggering module loading via\nunprintable bytes in the script header, kernel stack contents can leak\ninto the command line.\n\nNormally execution of binfmt_script and binfmt_misc happens recursively.\nHowever, when modules are enabled, and unprintable bytes exist in the\nbprm->buf, execution will restart after attempting to load matching\nbinfmt modules.  Unfortunately, the logic in binfmt_script and\nbinfmt_misc does not expect to get restarted.  They leave bprm->interp\npointing to their local stack.  This means on restart bprm->interp is\nleft pointing into unused stack memory which can then be copied into the\nuserspace argv areas.\n\nAfter additional study, it seems that both recursion and restart remains\nthe desirable way to handle exec with scripts, misc, and modules.  As\nsuch, we need to protect the changes to interp.\n\nThis changes the logic to require allocation for any changes to the\nbprm->interp.  To avoid adding a new kmalloc to every exec, the default\nvalue is left as-is.  Only when passing through binfmt_script or\nbinfmt_misc does an allocation take place.\n\nFor a proof of concept, see DoTest.sh from:\n\n   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tkfree(bprm);\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: do not leave bprm->interp on stack\n\nIf a series of scripts are executed, each triggering module loading via\nunprintable bytes in the script header, kernel stack contents can leak\ninto the command line.\n\nNormally execution of binfmt_script and binfmt_misc happens recursively.\nHowever, when modules are enabled, and unprintable bytes exist in the\nbprm->buf, execution will restart after attempting to load matching\nbinfmt modules.  Unfortunately, the logic in binfmt_script and\nbinfmt_misc does not expect to get restarted.  They leave bprm->interp\npointing to their local stack.  This means on restart bprm->interp is\nleft pointing into unused stack memory which can then be copied into the\nuserspace argv areas.\n\nAfter additional study, it seems that both recursion and restart remains\nthe desirable way to handle exec with scripts, misc, and modules.  As\nsuch, we need to protect the changes to interp.\n\nThis changes the logic to require allocation for any changes to the\nbprm->interp.  To avoid adding a new kmalloc to every exec, the default\nvalue is left as-is.  Only when passing through binfmt_script or\nbinfmt_misc does an allocation take place.\n\nFor a proof of concept, see DoTest.sh from:\n\n   http://www.halfdog.net/Security/2012/LinuxKernelBinfmtScriptStackDataDisclosure/\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int load_em86(struct linux_binprm *bprm)\n{\n\tchar *interp, *i_name, *i_arg;\n\tstruct file * file;\n\tint retval;\n\tstruct elfhdr\telf_ex;\n\n\t/* Make sure this is a Linux/Intel ELF executable... */\n\telf_ex = *((struct elfhdr *)bprm->buf);\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn  -ENOEXEC;\n\n\t/* First of all, some simple consistency checks */\n\tif ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n\t\t(!((elf_ex.e_machine == EM_386) || (elf_ex.e_machine == EM_486))) ||\n\t\t(!bprm->file->f_op || !bprm->file->f_op->mmap)) {\n\t\t\treturn -ENOEXEC;\n\t}\n\n\tbprm->recursion_depth++; /* Well, the bang-shell is implicit... */\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\t/* Unlike in the script case, we don't have to do any hairy\n\t * parsing to find our interpreter... it's hardcoded!\n\t */\n\tinterp = EM86_INTERP;\n\ti_name = EM86_I_NAME;\n\ti_arg = NULL;\t\t/* We reserve the right to add an arg later */\n\n\t/*\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of emulated file (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tremove_arg_zero(bprm);\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval < 0)\treturn retval;\n\tbprm->argc++;\n\n\t/*\n\t * OK, now restart the process with the interpreter's inode.\n\t * Note that we use open_exec() as the name is now in kernel\n\t * space, and we don't need to copy it.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn search_binary_handler(bprm);\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: use -ELOOP for max recursion depth\n\nTo avoid an explosion of request_module calls on a chain of abusive\nscripts, fail maximum recursion with -ELOOP instead of -ENOEXEC. As soon\nas maximum recursion depth is hit, the error will fail all the way back\nup the chain, aborting immediately.\n\nThis also has the side-effect of stopping the user's shell from attempting\nto reexecute the top-level file as a shell script. As seen in the\ndash source:\n\n        if (cmd != path_bshell && errno == ENOEXEC) {\n                *argv-- = cmd;\n                *argv = cmd = path_bshell;\n                goto repeat;\n        }\n\nThe above logic was designed for running scripts automatically that lacked\nthe \"#!\" header, not to re-try failed recursion. On a legitimate -ENOEXEC,\nthings continue to behave as the shell expects.\n\nAdditionally, when tracking recursion, the binfmt handlers should not be\ninvolved. The recursion being tracked is the depth of calls through\nsearch_binary_handler(), so that function should be exclusively responsible\nfor tracking the depth.\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tunsigned int depth = bprm->recursion_depth;\n\tint try,retval;\n\tstruct linux_binfmt *fmt;\n\tpid_t old_pid, old_vpid;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = audit_bprm(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tretval = -ENOENT;\n\tfor (try=0; try<2; try++) {\n\t\tread_lock(&binfmt_lock);\n\t\tlist_for_each_entry(fmt, &formats, lh) {\n\t\t\tint (*fn)(struct linux_binprm *) = fmt->load_binary;\n\t\t\tif (!fn)\n\t\t\t\tcontinue;\n\t\t\tif (!try_module_get(fmt->module))\n\t\t\t\tcontinue;\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tretval = fn(bprm);\n\t\t\t/*\n\t\t\t * Restore the depth counter to its starting value\n\t\t\t * in this call, so we don't have to rely on every\n\t\t\t * load_binary function to restore it on return.\n\t\t\t */\n\t\t\tbprm->recursion_depth = depth;\n\t\t\tif (retval >= 0) {\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\t\t\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\t\t\t}\n\t\t\t\tput_binfmt(fmt);\n\t\t\t\tallow_write_access(bprm->file);\n\t\t\t\tif (bprm->file)\n\t\t\t\t\tfput(bprm->file);\n\t\t\t\tbprm->file = NULL;\n\t\t\t\tcurrent->did_exec = 1;\n\t\t\t\tproc_exec_connector(current);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\tread_lock(&binfmt_lock);\n\t\t\tput_binfmt(fmt);\n\t\t\tif (retval != -ENOEXEC || bprm->mm == NULL)\n\t\t\t\tbreak;\n\t\t\tif (!bprm->file) {\n\t\t\t\tread_unlock(&binfmt_lock);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t\tread_unlock(&binfmt_lock);\n#ifdef CONFIG_MODULES\n\t\tif (retval != -ENOEXEC || bprm->mm == NULL) {\n\t\t\tbreak;\n\t\t} else {\n#define printable(c) (((c)=='\\t') || ((c)=='\\n') || (0x20<=(c) && (c)<=0x7e))\n\t\t\tif (printable(bprm->buf[0]) &&\n\t\t\t    printable(bprm->buf[1]) &&\n\t\t\t    printable(bprm->buf[2]) &&\n\t\t\t    printable(bprm->buf[3]))\n\t\t\t\tbreak; /* -ENOEXEC */\n\t\t\tif (try)\n\t\t\t\tbreak; /* -ENOEXEC */\n\t\t\trequest_module(\"binfmt-%04x\", *(unsigned short *)(&bprm->buf[2]));\n\t\t}\n#else\n\t\tbreak;\n#endif\n\t}\n\treturn retval;\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: use -ELOOP for max recursion depth\n\nTo avoid an explosion of request_module calls on a chain of abusive\nscripts, fail maximum recursion with -ELOOP instead of -ENOEXEC. As soon\nas maximum recursion depth is hit, the error will fail all the way back\nup the chain, aborting immediately.\n\nThis also has the side-effect of stopping the user's shell from attempting\nto reexecute the top-level file as a shell script. As seen in the\ndash source:\n\n        if (cmd != path_bshell && errno == ENOEXEC) {\n                *argv-- = cmd;\n                *argv = cmd = path_bshell;\n                goto repeat;\n        }\n\nThe above logic was designed for running scripts automatically that lacked\nthe \"#!\" header, not to re-try failed recursion. On a legitimate -ENOEXEC,\nthings continue to behave as the shell expects.\n\nAdditionally, when tracking recursion, the binfmt handlers should not be\ninvolved. The recursion being tracked is the depth of calls through\nsearch_binary_handler(), so that function should be exclusively responsible\nfor tracking the depth.\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file * interp_file = NULL;\n\tchar iname[BINPRM_BUF_SIZE];\n\tconst char *iname_addr = iname;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\tgoto _ret;\n\n\tretval = -ENOEXEC;\n\tif (bprm->recursion_depth > BINPRM_MAX_RECURSION)\n\t\tgoto _ret;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tstrlcpy(iname, fmt->interpreter, BINPRM_BUF_SIZE);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\tgoto _ret;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto _ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it */\n \t\tfd_binary = get_unused_fd();\n \t\tif (fd_binary < 0) {\n \t\t\tretval = fd_binary;\n \t\t\tgoto _ret;\n \t\t}\n \t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n \t} else {\n \t\tallow_write_access(bprm->file);\n \t\tfput(bprm->file);\n \t\tbprm->file = NULL;\n \t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel (1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\tbprm->interp = iname;\t/* for binfmt_script */\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n\t} else\n\t\tretval = prepare_binprm (bprm);\n\n\tif (retval < 0)\n\t\tgoto _error;\n\n\tbprm->recursion_depth++;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\n_ret:\n\treturn retval;\n_error:\n\tif (fd_binary > 0)\n\t\tsys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto _ret;\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: use -ELOOP for max recursion depth\n\nTo avoid an explosion of request_module calls on a chain of abusive\nscripts, fail maximum recursion with -ELOOP instead of -ENOEXEC. As soon\nas maximum recursion depth is hit, the error will fail all the way back\nup the chain, aborting immediately.\n\nThis also has the side-effect of stopping the user's shell from attempting\nto reexecute the top-level file as a shell script. As seen in the\ndash source:\n\n        if (cmd != path_bshell && errno == ENOEXEC) {\n                *argv-- = cmd;\n                *argv = cmd = path_bshell;\n                goto repeat;\n        }\n\nThe above logic was designed for running scripts automatically that lacked\nthe \"#!\" header, not to re-try failed recursion. On a legitimate -ENOEXEC,\nthings continue to behave as the shell expects.\n\nAdditionally, when tracking recursion, the binfmt handlers should not be\ninvolved. The recursion being tracked is the depth of calls through\nsearch_binary_handler(), so that function should be exclusively responsible\nfor tracking the depth.\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!') ||\n\t    (bprm->recursion_depth > BINPRM_MAX_RECURSION))\n\t\treturn -ENOEXEC;\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tbprm->recursion_depth++;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\n\t/*\n\t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1, "cwe": ["CWE-200"], "message": "exec: use -ELOOP for max recursion depth\n\nTo avoid an explosion of request_module calls on a chain of abusive\nscripts, fail maximum recursion with -ELOOP instead of -ENOEXEC. As soon\nas maximum recursion depth is hit, the error will fail all the way back\nup the chain, aborting immediately.\n\nThis also has the side-effect of stopping the user's shell from attempting\nto reexecute the top-level file as a shell script. As seen in the\ndash source:\n\n        if (cmd != path_bshell && errno == ENOEXEC) {\n                *argv-- = cmd;\n                *argv = cmd = path_bshell;\n                goto repeat;\n        }\n\nThe above logic was designed for running scripts automatically that lacked\nthe \"#!\" header, not to re-try failed recursion. On a legitimate -ENOEXEC,\nthings continue to behave as the shell expects.\n\nAdditionally, when tracking recursion, the binfmt handlers should not be\ninvolved. The recursion being tracked is the depth of calls through\nsearch_binary_handler(), so that function should be exclusively responsible\nfor tracking the depth.\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: halfdog <me@halfdog.net>\nCc: P J P <ppandit@redhat.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\n\text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n\t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n\n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n\t\tif (err)\n\t\t\tgoto fix_extent_len;\n\t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-362"], "message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org"}
{"func": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\t/*\n\t * It is safe to convert extent to initialized via explicit\n\t * zeroout only if extent is fully insde i_size or new_size.\n\t */\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "target": 1, "cwe": ["CWE-362"], "message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org"}
{"func": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1, "cwe": ["CWE-362"], "message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org"}
{"func": "ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tstruct ext4_ext_path *path, int flags,\n\t\t\tunsigned int allocated, ext4_fsblk_t newblock)\n{\n\tint ret = 0;\n\tint err = 0;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\n\text_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \"\n\t\t  \"block %llu, max_blocks %u, flags %x, allocated %u\\n\",\n\t\t  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,\n\t\t  flags, allocated);\n\text4_ext_show_leaf(inode, path);\n\n\ttrace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,\n\t\t\t\t\t\t    newblock);\n\n\t/* get_block() before submit the IO, split the extent */\n\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\tret = ext4_split_unwritten_extents(handle, inode, map,\n\t\t\t\t\t\t   path, flags);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Flag the inode(non aio case) or end_io struct (aio case)\n\t\t * that this IO needs to conversion to written when IO is\n\t\t * completed\n\t\t */\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tmap->m_flags |= EXT4_MAP_UNINIT;\n\t\tgoto out;\n\t}\n\t/* IO end_io complete, convert the filled extent to written */\n\tif ((flags & EXT4_GET_BLOCKS_CONVERT)) {\n\t\tret = ext4_convert_unwritten_extents_endio(handle, inode,\n\t\t\t\t\t\t\tpath);\n\t\tif (ret >= 0) {\n\t\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t\t path, map->m_len);\n\t\t} else\n\t\t\terr = ret;\n\t\tgoto out2;\n\t}\n\t/* buffered IO case */\n\t/*\n\t * repeat fallocate creation request\n\t * we already have an unwritten extent\n\t */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT)\n\t\tgoto map_out;\n\n\t/* buffered READ or buffered write_begin() lookup */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * We have blocks reserved already.  We\n\t\t * return allocated blocks so that delalloc\n\t\t * won't do block reservation for us.  But\n\t\t * the buffer head will be unmapped so that\n\t\t * a read from the block returns 0s.\n\t\t */\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\tgoto out1;\n\t}\n\n\t/* buffered write, writepage time, convert*/\n\tret = ext4_ext_convert_to_initialized(handle, inode, map, path);\n\tif (ret >= 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\nout:\n\tif (ret <= 0) {\n\t\terr = ret;\n\t\tgoto out2;\n\t} else\n\t\tallocated = ret;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\t/*\n\t * if we allocated more blocks than requested\n\t * we need to make sure we unmap the extra block\n\t * allocated. The actual needed block will get\n\t * unmapped later when we find the buffer_head marked\n\t * new.\n\t */\n\tif (allocated > map->m_len) {\n\t\tunmap_underlying_metadata_blocks(inode->i_sb->s_bdev,\n\t\t\t\t\tnewblock + map->m_len,\n\t\t\t\t\tallocated - map->m_len);\n\t\tallocated = map->m_len;\n\t}\n\n\t/*\n\t * If we have done fallocate with the offset that is already\n\t * delayed allocated, we would have block reservation\n\t * and quota reservation done in the delayed write path.\n\t * But fallocate would have already updated quota and block\n\t * count for this offset. So cancel these reservation\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\tmap->m_lblk, map->m_len);\n\t\tif (reserved_clusters)\n\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\t     reserved_clusters,\n\t\t\t\t\t\t     0);\n\t}\n\nmap_out:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path,\n\t\t\t\t\t map->m_len);\n\t\tif (err < 0)\n\t\t\tgoto out2;\n\t}\nout1:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}", "target": 1, "cwe": ["CWE-362"], "message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org"}
{"func": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\t/* first mark the extent as initialized */\n\text4_ext_mark_initialized(ex);\n\n\t/* note: ext4_ext_correct_indexes() isn't needed here because\n\t * borders are not changed\n\t */\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t/* Mark modified extent as dirty */\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-362"], "message": "ext4: race-condition protection for ext4_convert_unwritten_extents_endio\n\nWe assumed that at the time we call ext4_convert_unwritten_extents_endio()\nextent in question is fully inside [map.m_lblk, map->m_len] because\nit was already split during submission.  But this may not be true due to\na race between writeback vs fallocate.\n\nIf extent in question is larger than requested we will split it again.\nSpecial precautions should being done if zeroout required because\n[map.m_lblk, map->m_len] already contains valid data.\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org"}
{"func": "PgDatabase *add_database(const char *name)\n{\n\tPgDatabase *db = find_database(name);\n\n\t/* create new object if needed */\n\tif (db == NULL) {\n\t\tdb = slab_alloc(db_cache);\n\t\tif (!db)\n\t\t\treturn NULL;\n\n\t\tlist_init(&db->head);\n\t\tsafe_strcpy(db->name, name, sizeof(db->name));\n\t\tput_in_order(&db->head, &database_list, cmp_database);\n\t}\n\n\treturn db;\n}", "target": 1, "cwe": [], "message": "add_database: fail gracefully if too long db name\n\nTruncating & adding can lead to fatal() later.\n\nIt was not an issue before, but with audodb (* in [databases] section)\nthe database name can some from network, thus allowing remote shutdown.."}
{"func": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1, "cwe": [], "message": "ipv6: discard overlapping fragment\n\nRFC5722 prohibits reassembling fragments when some data overlaps.\n\nBug spotted by Zhang Zuotao <zuotao.zhang@6wind.com>.\n\nSigned-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* We found where to put this one.  Check for overlap with\n\t * preceding fragment, and, if needed, align things so that\n\t * any overlaps are eliminated.\n\t */\n\tif (prev) {\n\t\tint i = (FRAG6_CB(prev)->offset + prev->len) - offset;\n\n\t\tif (i > 0) {\n\t\t\toffset += i;\n\t\t\tif (end <= offset)\n\t\t\t\tgoto err;\n\t\t\tif (!pskb_pull(skb, i))\n\t\t\t\tgoto err;\n\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t}\n\n\t/* Look for overlap with succeeding segments.\n\t * If we can merge fragments, do it.\n\t */\n\twhile (next && FRAG6_CB(next)->offset < end) {\n\t\tint i = end - FRAG6_CB(next)->offset; /* overlap is 'i' bytes */\n\n\t\tif (i < next->len) {\n\t\t\t/* Eat head of the next overlapped fragment\n\t\t\t * and leave the loop. The next ones cannot overlap.\n\t\t\t */\n\t\t\tif (!pskb_pull(next, i))\n\t\t\t\tgoto err;\n\t\t\tFRAG6_CB(next)->offset += i;\t/* next fragment */\n\t\t\tfq->q.meat -= i;\n\t\t\tif (next->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tnext->ip_summed = CHECKSUM_NONE;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct sk_buff *free_it = next;\n\n\t\t\t/* Old fragment is completely overridden with\n\t\t\t * new one drop it.\n\t\t\t */\n\t\t\tnext = next->next;\n\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tfq->q.fragments = next;\n\n\t\t\tfq->q.meat -= free_it->len;\n\t\t\tfrag_kfree_skb(fq->q.net, free_it);\n\t\t}\n\t}\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}", "target": 1, "cwe": [], "message": "ipv6: discard overlapping fragment\n\nRFC5722 prohibits reassembling fragments when some data overlaps.\n\nBug spotted by Zhang Zuotao <zuotao.zhang@6wind.com>.\n\nSigned-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* RFC5722, Section 4:\n\t *                                  When reassembling an IPv6 datagram, if\n\t *   one or more its constituent fragments is determined to be an\n\t *   overlapping fragment, the entire datagram (and any constituent\n\t *   fragments, including those not yet received) MUST be silently\n\t *   discarded.\n\t */\n\n\t/* Check for overlap with preceding fragment. */\n\tif (prev &&\n\t    (FRAG6_CB(prev)->offset + prev->len) - offset > 0)\n\t\tgoto discard_fq;\n\n\t/* Look for overlap with succeeding segment. */\n\tif (next && FRAG6_CB(next)->offset < end)\n\t\tgoto discard_fq;\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\ndiscard_fq:\n\tfq_kill(fq);\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}", "target": 1, "cwe": [], "message": "ipv6: fix overlap check for fragments\n\nThe type of FRAG6_CB(prev)->offset is int, skb->len is *unsigned* int,\nand offset is int.\n\nWithout this patch, type conversion occurred to this expression, when\n(FRAG6_CB(prev)->offset + prev->len) is less than offset.\n\nSigned-off-by: Shan Wei <shanwei@cn.fujitsu.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "irc_color_decode (const char *string, int keep_colors)\n{\n    unsigned char *out, *ptr_string;\n    int out_length, length, out_pos;\n    char str_fg[3], str_bg[3], str_color[128], str_key[128];\n    const char *remapped_color;\n    int fg, bg, bold, reverse, italic, underline, rc;\n\n    out_length = (strlen (string) * 2) + 1;\n    out = malloc (out_length);\n    if (!out)\n        return NULL;\n\n    bold = 0;\n    reverse = 0;\n    italic = 0;\n    underline = 0;\n\n    ptr_string = (unsigned char *)string;\n    out[0] = '\\0';\n    while (ptr_string && ptr_string[0])\n    {\n        switch (ptr_string[0])\n        {\n            case IRC_COLOR_BOLD_CHAR:\n                if (keep_colors)\n                    strcat ((char *)out,\n                            weechat_color((bold) ? \"-bold\" : \"bold\"));\n                bold ^= 1;\n                ptr_string++;\n                break;\n            case IRC_COLOR_RESET_CHAR:\n                if (keep_colors)\n                    strcat ((char *)out, weechat_color(\"reset\"));\n                bold = 0;\n                reverse = 0;\n                italic = 0;\n                underline = 0;\n                ptr_string++;\n                break;\n            case IRC_COLOR_FIXED_CHAR:\n                ptr_string++;\n                break;\n            case IRC_COLOR_REVERSE_CHAR:\n            case IRC_COLOR_REVERSE2_CHAR:\n                if (keep_colors)\n                    strcat ((char *)out,\n                            weechat_color((reverse) ? \"-reverse\" : \"reverse\"));\n                reverse ^= 1;\n                ptr_string++;\n                break;\n            case IRC_COLOR_ITALIC_CHAR:\n                if (keep_colors)\n                    strcat ((char *)out,\n                            weechat_color((italic) ? \"-italic\" : \"italic\"));\n                italic ^= 1;\n                ptr_string++;\n                break;\n            case IRC_COLOR_UNDERLINE_CHAR:\n                if (keep_colors)\n                    strcat ((char *)out,\n                            weechat_color((underline) ? \"-underline\" : \"underline\"));\n                underline ^= 1;\n                ptr_string++;\n                break;\n            case IRC_COLOR_COLOR_CHAR:\n                ptr_string++;\n                str_fg[0] = '\\0';\n                str_bg[0] = '\\0';\n                if (isdigit (ptr_string[0]))\n                {\n                    str_fg[0] = ptr_string[0];\n                    str_fg[1] = '\\0';\n                    ptr_string++;\n                    if (isdigit (ptr_string[0]))\n                    {\n                        str_fg[1] = ptr_string[0];\n                        str_fg[2] = '\\0';\n                        ptr_string++;\n                    }\n                }\n                if ((ptr_string[0] == ',') && (isdigit (ptr_string[1])))\n                {\n                    ptr_string++;\n                    str_bg[0] = ptr_string[0];\n                    str_bg[1] = '\\0';\n                    ptr_string++;\n                    if (isdigit (ptr_string[0]))\n                    {\n                        str_bg[1] = ptr_string[0];\n                        str_bg[2] = '\\0';\n                        ptr_string++;\n                    }\n                }\n                if (keep_colors)\n                {\n                    if (str_fg[0] || str_bg[0])\n                    {\n                        fg = -1;\n                        bg = -1;\n                        if (str_fg[0])\n                        {\n                            rc = sscanf (str_fg, \"%d\", &fg);\n                            if ((rc != EOF) && (rc >= 1))\n                            {\n                                fg %= IRC_NUM_COLORS;\n                            }\n                        }\n                        if (str_bg[0])\n                        {\n                            rc = sscanf (str_bg, \"%d\", &bg);\n                            if ((rc != EOF) && (rc >= 1))\n                            {\n                                bg %= IRC_NUM_COLORS;\n                            }\n                        }\n                        /* search \"fg,bg\" in hashtable of remapped colors */\n                        snprintf (str_key, sizeof (str_key), \"%d,%d\", fg, bg);\n                        remapped_color = weechat_hashtable_get (\n                            irc_config_hashtable_color_mirc_remap,\n                            str_key);\n                        if (remapped_color)\n                        {\n                            snprintf (str_color, sizeof (str_color),\n                                      \"|%s\", remapped_color);\n                        }\n                        else\n                        {\n                            snprintf (str_color, sizeof (str_color),\n                                      \"|%s%s%s\",\n                                      (fg >= 0) ? irc_color_to_weechat[fg] : \"\",\n                                      (bg >= 0) ? \",\" : \"\",\n                                      (bg >= 0) ? irc_color_to_weechat[bg] : \"\");\n                        }\n                        strcat ((char *)out, weechat_color(str_color));\n                    }\n                    else\n                        strcat ((char *)out, weechat_color(\"resetcolor\"));\n                }\n                break;\n            default:\n                length = weechat_utf8_char_size ((char *)ptr_string);\n                if (length == 0)\n                    length = 1;\n                out_pos = strlen ((char *)out);\n                memcpy (out + out_pos, ptr_string, length);\n                out[out_pos + length] = '\\0';\n                ptr_string += length;\n                break;\n        }\n    }\n\n    return (char *)out;\n}", "target": 1, "cwe": ["CWE-119"], "message": "irc: fix crash when decoding IRC colors in strings (bug #37704)"}
{"func": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\t/*\n\t * This doesn't need a lock to do pfn_to_page().\n\t * The section can't be removed here because of the\n\t * memory_block->state_mutex.\n\t */\n\tzone = page_zone(pfn_to_page(pfn));\n\t/*\n\t * If this zone is not populated, then it is not in zonelist.\n\t * This means the page allocator ignores this zone.\n\t * So, zonelist must be updated after online.\n\t */\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\n\tmutex_unlock(&zonelists_mutex);\n\n\tinit_per_zone_wmark_min();\n\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\n\tvm_total_pages = nr_free_pagecache_pages();\n\n\twriteback_set_ratelimit();\n\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\n\treturn 0;\n}", "target": 1, "cwe": [], "message": "mm/hotplug: correctly add new zone to all other nodes' zone lists\n\nWhen online_pages() is called to add new memory to an empty zone, it\nrebuilds all zone lists by calling build_all_zonelists().  But there's a\nbug which prevents the new zone to be added to other nodes' zone lists.\n\nonline_pages() {\n\tbuild_all_zonelists()\n\t.....\n\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY)\n}\n\nHere the node of the zone is put into N_HIGH_MEMORY state after calling\nbuild_all_zonelists(), but build_all_zonelists() only adds zones from\nnodes in N_HIGH_MEMORY state to the fallback zone lists.\nbuild_all_zonelists()\n\n    ->__build_all_zonelists()\n\t->build_zonelists()\n\t    ->find_next_best_node()\n\t\t->for_each_node_state(n, N_HIGH_MEMORY)\n\nSo memory in the new zone will never be used by other nodes, and it may\ncause strange behavor when system is under memory pressure.  So put node\ninto N_HIGH_MEMORY state before calling build_all_zonelists().\n\nSigned-off-by: Jianguo Wu <wujianguo@huawei.com>\nSigned-off-by: Jiang Liu <liuj97@gmail.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Michal Hocko <mhocko@suse.cz>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Yinghai Lu <yinghai@kernel.org>\nCc: Tony Luck <tony.luck@intel.com>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Keping Chen <chenkeping@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "int main(void)\n{\n\tint fd, len, sock_opt;\n\tint error;\n\tstruct cn_msg *message;\n\tstruct pollfd pfd;\n\tstruct nlmsghdr *incoming_msg;\n\tstruct cn_msg\t*incoming_cn_msg;\n\tstruct hv_kvp_msg *hv_msg;\n\tchar\t*p;\n\tchar\t*key_value;\n\tchar\t*key_name;\n\tint\top;\n\tint\tpool;\n\tchar\t*if_name;\n\tstruct hv_kvp_ipaddr_value *kvp_ip_val;\n\n\tdaemon(1, 0);\n\topenlog(\"KVP\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"KVP starting; pid is:%d\", getpid());\n\t/*\n\t * Retrieve OS release information.\n\t */\n\tkvp_get_os_info();\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, \"Failed to initialize the pools\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (fd < 0) {\n\t\tsyslog(LOG_ERR, \"netlink socket creation failed; error:%d\", fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_pad = 0;\n\taddr.nl_pid = 0;\n\taddr.nl_groups = CN_KVP_IDX;\n\n\n\terror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\n\tif (error < 0) {\n\t\tsyslog(LOG_ERR, \"bind failed; error:%d\", error);\n\t\tclose(fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsock_opt = addr.nl_groups;\n\tsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\n\t/*\n\t * Register ourselves with the kernel.\n\t */\n\tmessage = (struct cn_msg *)kvp_send_buffer;\n\tmessage->id.idx = CN_KVP_IDX;\n\tmessage->id.val = CN_KVP_VAL;\n\n\thv_msg = (struct hv_kvp_msg *)message->data;\n\thv_msg->kvp_hdr.operation = KVP_OP_REGISTER1;\n\tmessage->ack = 0;\n\tmessage->len = sizeof(struct hv_kvp_msg);\n\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &addr_l);\n\n\t\tif (len < 0 || addr.nl_pid) {\n\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\t/*\n\t\t * We will use the KVP header information to pass back\n\t\t * the error from this daemon. So, first copy the state\n\t\t * and set the error code to success.\n\t\t */\n\t\top = hv_msg->kvp_hdr.operation;\n\t\tpool = hv_msg->kvp_hdr.pool;\n\t\thv_msg->error = HV_S_OK;\n\n\t\tif ((in_hand_shake) && (op == KVP_OP_REGISTER1)) {\n\t\t\t/*\n\t\t\t * Driver is registering with us; stash away the version\n\t\t\t * information.\n\t\t\t */\n\t\t\tin_hand_shake = 0;\n\t\t\tp = (char *)hv_msg->body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, \"KVP LIC Version: %s\",\n\t\t\t\t\tlic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (op) {\n\t\tcase KVP_OP_GET_IP_INFO:\n\t\t\tkvp_ip_val = &hv_msg->body.kvp_ip_val;\n\t\t\tif_name =\n\t\t\tkvp_mac_to_if_name((char *)kvp_ip_val->adapter_id);\n\n\t\t\tif (if_name == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We could not map the mac address to an\n\t\t\t\t * interface name; return error.\n\t\t\t\t */\n\t\t\t\thv_msg->error = HV_E_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = kvp_get_ip_info(\n\t\t\t\t\t\t0, if_name, KVP_OP_GET_IP_INFO,\n\t\t\t\t\t\tkvp_ip_val,\n\t\t\t\t\t\t(MAX_IP_ADDR_SIZE * 2));\n\n\t\t\tif (error)\n\t\t\t\thv_msg->error = error;\n\n\t\t\tfree(if_name);\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET_IP_INFO:\n\t\t\tkvp_ip_val = &hv_msg->body.kvp_ip_val;\n\t\t\tif_name = kvp_get_if_name(\n\t\t\t\t\t(char *)kvp_ip_val->adapter_id);\n\t\t\tif (if_name == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We could not map the guid to an\n\t\t\t\t * interface name; return error.\n\t\t\t\t */\n\t\t\t\thv_msg->error = HV_GUID_NOTFOUND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = kvp_set_ip_info(if_name, kvp_ip_val);\n\t\t\tif (error)\n\t\t\t\thv_msg->error = error;\n\n\t\t\tfree(if_name);\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(pool,\n\t\t\t\t\thv_msg->body.kvp_delete.key,\n\t\t\t\t\thv_msg->body.kvp_delete.key_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (op != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t/*\n\t\t * If the pool is KVP_POOL_AUTO, dynamically generate\n\t\t * both the key and the value; if not read from the\n\t\t * appropriate pool.\n\t\t */\n\t\tif (pool != KVP_POOL_AUTO) {\n\t\t\tif (kvp_pool_enumerate(pool,\n\t\t\t\t\thv_msg->body.kvp_enum_data.index,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\t\tkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg->body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tkvp_get_domain_name(key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"FullyQualifiedDomainName\");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, \"IntegrationServicesVersion\");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_info(AF_INET, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv4\");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_info(AF_INET6, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv6\");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSBuildNumber\");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, \"OSName\");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, \"OSMajorVersion\");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, \"OSMinorVersion\");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_version);\n\t\t\tstrcpy(key_name, \"OSVersion\");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, \"ProcessorArchitecture\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Send the value back to the kernel. The response is\n\t\t * already in the receive buffer. Update the cn_msg header to\n\t\t * reflect the key value that has been added to the message\n\t\t */\nkvp_done:\n\n\t\tincoming_cn_msg->id.idx = CN_KVP_IDX;\n\t\tincoming_cn_msg->id.val = CN_KVP_VAL;\n\t\tincoming_cn_msg->ack = 0;\n\t\tincoming_cn_msg->len = sizeof(struct hv_kvp_msg);\n\n\t\tlen = netlink_send(fd, incoming_cn_msg);\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"net_link send failed; error:%d\", len);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n}", "target": 1, "cwe": [], "message": "tools: hv: Netlink source address validation allows DoS\n\nThe source code without this patch caused hypervkvpd to exit when it processed\na spoofed Netlink packet which has been sent from an untrusted local user.\nNow Netlink messages with a non-zero nl_pid source address are ignored\nand a warning is printed into the syslog.\n\nSigned-off-by: Tomas Hozza <thozza@redhat.com>\nAcked-by:  K. Y. Srinivasan <kys@microsoft.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"}
{"func": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    const char *ptr_url;\n    int rc;\n\n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n\n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n\n    rc = EXIT_SUCCESS;\n\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        /* get URL output (on stdout or file, depending on options) */\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        /* launch command */\n        exec_args[2] = HOOK_PROCESS(hook_process, command);\n        execvp (exec_args[0], exec_args);\n\n        /* should not be executed if execvp was ok */\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n\n    fflush (stdout);\n    fflush (stderr);\n\n    _exit (rc);\n}", "target": 1, "cwe": ["CWE-20"], "message": "core: do not call shell to execute command in hook_process (fix security problem when a plugin/script gives untrusted command) (bug #37764)"}
{"func": "static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request->username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request->username->vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw->ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw->uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, \"rlm_unix: [%s]: account locked\", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd->pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is < 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) < 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd->sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require 'pwd != NULL', which isn't true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd->pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       \"rlm_unix: [%s]: invalid shell\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd->pw_shell) == 0 ||\n\t\t    strcmp(shell, \"/RADIUSD/ANY/SHELL\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake(\"Crypt-Password\", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &vp);\n\tpairfree(&vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}", "target": 1, "cwe": ["CWE-522", "CWE-255"], "message": "heck for account and password expiration"}
{"func": "load_xwd_f1_d24_b1 (const gchar     *filename,\n                    FILE            *ifp,\n                    L_XWDFILEHEADER *xwdhdr,\n                    L_XWDCOLOR      *xwdcolmap)\n{\n  register guchar *dest, outmask, inmask, do_reverse;\n  gint             width, height, i, j, plane, fromright;\n  gint             tile_height, tile_start, tile_end;\n  gint             indexed, bytes_per_pixel;\n  gint             maxred, maxgreen, maxblue;\n  gint             red, green, blue, ncols, standard_rgb;\n  glong            data_offset, plane_offset, tile_offset;\n  gulong           redmask, greenmask, bluemask;\n  guint            redshift, greenshift, blueshift;\n  gulong           g;\n  guchar           redmap[256], greenmap[256], bluemap[256];\n  guchar           bit_reverse[256];\n  guchar          *xwddata, *xwdin, *data;\n  L_CARD32         pixelval;\n  PIXEL_MAP        pixel_map;\n  gint             err = 0;\n  gint32           layer_ID, image_ID;\n  GimpPixelRgn     pixel_rgn;\n  GimpDrawable    *drawable;\n\n#ifdef XWD_DEBUG\n  printf (\"load_xwd_f1_d24_b1 (%s)\\n\", filename);\n#endif\n\n  xwddata = g_malloc (xwdhdr->l_bytes_per_line);\n  if (xwddata == NULL)\n    return -1;\n\n  width           = xwdhdr->l_pixmap_width;\n  height          = xwdhdr->l_pixmap_height;\n  indexed         = (xwdhdr->l_pixmap_depth <= 8);\n  bytes_per_pixel = (indexed ? 1 : 3);\n\n  image_ID = create_new_image (filename, width, height,\n                               indexed ? GIMP_INDEXED : GIMP_RGB,\n                               &layer_ID, &drawable, &pixel_rgn);\n\n  tile_height = gimp_tile_height ();\n  data = g_malloc (tile_height * width * bytes_per_pixel);\n\n  for (j = 0; j < 256; j++)   /* Create an array for reversing bits */\n    {\n      inmask = 0;\n      for (i = 0; i < 8; i++)\n        {\n          inmask <<= 1;\n          if (j & (1 << i)) inmask |= 1;\n        }\n      bit_reverse[j] = inmask;\n    }\n\n  redmask   = xwdhdr->l_red_mask;\n  greenmask = xwdhdr->l_green_mask;\n  bluemask  = xwdhdr->l_blue_mask;\n\n  if (redmask   == 0) redmask   = 0xff0000;\n  if (greenmask == 0) greenmask = 0x00ff00;\n  if (bluemask  == 0) bluemask  = 0x0000ff;\n\n  standard_rgb =    (redmask == 0xff0000) && (greenmask == 0x00ff00)\n    && (bluemask == 0x0000ff);\n  redshift = greenshift = blueshift = 0;\n\n  if (!standard_rgb)   /* Do we need to re-map the pixel-values ? */\n    {\n      /* How to shift RGB to be right aligned ? */\n      /* (We rely on the the mask bits are grouped and not mixed) */\n\n      while (((1 << redshift)   & redmask)   == 0) redshift++;\n      while (((1 << greenshift) & greenmask) == 0) greenshift++;\n      while (((1 << blueshift)  & bluemask)  == 0) blueshift++;\n\n      /* The bits_per_rgb may not be correct. Use redmask instead */\n\n      maxred = 0; while (redmask >> (redshift + maxred)) maxred++;\n      maxred = (1 << maxred) - 1;\n\n      maxgreen = 0; while (greenmask >> (greenshift + maxgreen)) maxgreen++;\n      maxgreen = (1 << maxgreen) - 1;\n\n      maxblue = 0; while (bluemask >> (blueshift + maxblue)) maxblue++;\n      maxblue = (1 << maxblue) - 1;\n\n      /* Set map-arrays for red, green, blue */\n      for (red = 0; red <= maxred; red++)\n        redmap[red] = (red * 255) / maxred;\n      for (green = 0; green <= maxgreen; green++)\n        greenmap[green] = (green * 255) / maxgreen;\n      for (blue = 0; blue <= maxblue; blue++)\n        bluemap[blue] = (blue * 255) / maxblue;\n    }\n\n  ncols = xwdhdr->l_colormap_entries;\n  if (xwdhdr->l_ncolors < ncols)\n    ncols = xwdhdr->l_ncolors;\n\n  if (indexed)\n    {\n      if (ncols < 2)\n        set_bw_color_table (image_ID);\n      else\n        set_color_table (image_ID, xwdhdr, xwdcolmap);\n    }\n  else\n    {\n      set_pixelmap (ncols, xwdcolmap, &pixel_map);\n    }\n\n  do_reverse = !xwdhdr->l_bitmap_bit_order;\n\n  /* This is where the image data starts within the file */\n  data_offset = ftell (ifp);\n\n  for (tile_start = 0; tile_start < height; tile_start += tile_height)\n    {\n      memset (data, 0, width*tile_height*bytes_per_pixel);\n\n      tile_end = tile_start + tile_height - 1;\n      if (tile_end >= height)\n        tile_end = height - 1;\n\n      for (plane = 0; plane < xwdhdr->l_pixmap_depth; plane++)\n        {\n          dest = data;    /* Position to start of tile within the plane */\n          plane_offset = data_offset + plane*height*xwdhdr->l_bytes_per_line;\n          tile_offset = plane_offset + tile_start*xwdhdr->l_bytes_per_line;\n          fseek (ifp, tile_offset, SEEK_SET);\n\n          /* Place the last plane at the least significant bit */\n\n          if (indexed)   /* Only 1 byte per pixel */\n            {\n              fromright = xwdhdr->l_pixmap_depth-1-plane;\n              outmask = (1 << fromright);\n            }\n          else           /* 3 bytes per pixel */\n            {\n              fromright = xwdhdr->l_pixmap_depth-1-plane;\n              dest += 2 - fromright/8;\n              outmask = (1 << (fromright % 8));\n            }\n\n          for (i = tile_start; i <= tile_end; i++)\n            {\n              if (fread (xwddata,xwdhdr->l_bytes_per_line,1,ifp) != 1)\n                {\n                  err = 1;\n                  break;\n                }\n              xwdin = xwddata;\n\n              /* Handle bitmap unit */\n              if (xwdhdr->l_bitmap_unit == 16)\n                {\n                  if (xwdhdr->l_bitmap_bit_order != xwdhdr->l_byte_order)\n                    {\n                      j = xwdhdr->l_bytes_per_line/2;\n                      while (j--)\n                        {\n                          inmask = xwdin[0]; xwdin[0] = xwdin[1]; xwdin[1] = inmask;\n                          xwdin += 2;\n                        }\n                      xwdin = xwddata;\n                    }\n                }\n              else if (xwdhdr->l_bitmap_unit == 32)\n                {\n                  if (xwdhdr->l_bitmap_bit_order != xwdhdr->l_byte_order)\n                    {\n                      j = xwdhdr->l_bytes_per_line/4;\n                      while (j--)\n                        {\n                          inmask = xwdin[0]; xwdin[0] = xwdin[3]; xwdin[3] = inmask;\n                          inmask = xwdin[1]; xwdin[1] = xwdin[2]; xwdin[2] = inmask;\n                          xwdin += 4;\n                        }\n                      xwdin = xwddata;\n                    }\n                }\n\n              g = inmask = 0;\n              for (j = 0; j < width; j++)\n                {\n                  if (!inmask)\n                    {\n                      g = *(xwdin++);\n                      if (do_reverse)\n                        g = bit_reverse[g];\n                      inmask = 0x80;\n                    }\n\n                  if (g & inmask)\n                    *dest |= outmask;\n                  dest += bytes_per_pixel;\n\n                  inmask >>= 1;\n                }\n            }\n        }\n\n      /* For indexed images, the mapping to colors is done by the color table. */\n      /* Otherwise we must do the mapping by ourself. */\n      if (!indexed)\n        {\n          dest = data;\n          for (i = tile_start; i <= tile_end; i++)\n            {\n              for (j = 0; j < width; j++)\n                {\n                  pixelval = (*dest << 16) | (*(dest+1) << 8) | *(dest+2);\n\n                  if (get_pixelmap (pixelval, &pixel_map, dest, dest+1, dest+2)\n                      || standard_rgb)\n                    {\n                      dest += 3;\n                    }\n                  else   /* We have to map RGB to 0,...,255 */\n                    {\n                      *(dest++) = redmap[(pixelval & redmask) >> redshift];\n                      *(dest++) = greenmap[(pixelval & greenmask) >> greenshift];\n                      *(dest++) = bluemap[(pixelval & bluemask) >> blueshift];\n                    }\n                }\n            }\n        }\n\n      gimp_progress_update ((gdouble) tile_end / (gdouble) height);\n\n      gimp_pixel_rgn_set_rect (&pixel_rgn, data, 0, tile_start,\n                               width, tile_end-tile_start+1);\n    }\n\n  g_free (data);\n  g_free (xwddata);\n\n  if (err)\n    g_message (_(\"EOF encountered on reading\"));\n\n  gimp_drawable_flush (drawable);\n\n  return err ? -1 : image_ID;\n}", "target": 1, "cwe": ["CWE-787"], "message": "Bug 687392 - Memory corruption vulnerability when reading XWD files\n\nApplied and enhanced patch from andres which makes file-xwd detect\nthis kind of file corruption and abort loading with an error message."}
{"func": "load_xwd_f2_d24_b32 (const gchar     *filename,\n                     FILE            *ifp,\n                     L_XWDFILEHEADER *xwdhdr,\n                     L_XWDCOLOR      *xwdcolmap)\n{\n  register guchar *dest, lsbyte_first;\n  gint             width, height, linepad, i, j, c0, c1, c2, c3;\n  gint             tile_height, scan_lines;\n  L_CARD32         pixelval;\n  gint             red, green, blue, ncols;\n  gint             maxred, maxgreen, maxblue;\n  gulong           redmask, greenmask, bluemask;\n  guint            redshift, greenshift, blueshift;\n  guchar           redmap[256], greenmap[256], bluemap[256];\n  guchar          *data;\n  PIXEL_MAP        pixel_map;\n  gint             err = 0;\n  gint32           layer_ID, image_ID;\n  GimpPixelRgn     pixel_rgn;\n  GimpDrawable    *drawable;\n\n#ifdef XWD_DEBUG\n  printf (\"load_xwd_f2_d24_b32 (%s)\\n\", filename);\n#endif\n\n  width  = xwdhdr->l_pixmap_width;\n  height = xwdhdr->l_pixmap_height;\n\n  image_ID = create_new_image (filename, width, height, GIMP_RGB,\n                               &layer_ID, &drawable, &pixel_rgn);\n\n  tile_height = gimp_tile_height ();\n  data = g_malloc (tile_height * width * 3);\n\n  redmask   = xwdhdr->l_red_mask;\n  greenmask = xwdhdr->l_green_mask;\n  bluemask  = xwdhdr->l_blue_mask;\n\n  if (redmask   == 0) redmask   = 0xff0000;\n  if (greenmask == 0) greenmask = 0x00ff00;\n  if (bluemask  == 0) bluemask  = 0x0000ff;\n\n  /* How to shift RGB to be right aligned ? */\n  /* (We rely on the the mask bits are grouped and not mixed) */\n  redshift = greenshift = blueshift = 0;\n\n  while (((1 << redshift)   & redmask)   == 0) redshift++;\n  while (((1 << greenshift) & greenmask) == 0) greenshift++;\n  while (((1 << blueshift)  & bluemask)  == 0) blueshift++;\n\n  /* The bits_per_rgb may not be correct. Use redmask instead */\n\n  maxred = 0; while (redmask >> (redshift + maxred)) maxred++;\n  maxred = (1 << maxred) - 1;\n\n  maxgreen = 0; while (greenmask >> (greenshift + maxgreen)) maxgreen++;\n  maxgreen = (1 << maxgreen) - 1;\n\n  maxblue = 0; while (bluemask >> (blueshift + maxblue)) maxblue++;\n  maxblue = (1 << maxblue) - 1;\n\n  /* Set map-arrays for red, green, blue */\n  for (red = 0; red <= maxred; red++)\n    redmap[red] = (red * 255) / maxred;\n  for (green = 0; green <= maxgreen; green++)\n    greenmap[green] = (green * 255) / maxgreen;\n  for (blue = 0; blue <= maxblue; blue++)\n    bluemap[blue] = (blue * 255) / maxblue;\n\n  ncols = xwdhdr->l_colormap_entries;\n  if (xwdhdr->l_ncolors < ncols)\n    ncols = xwdhdr->l_ncolors;\n\n  set_pixelmap (ncols, xwdcolmap, &pixel_map);\n\n  /* What do we have to consume after a line has finished ? */\n  linepad =   xwdhdr->l_bytes_per_line\n    - (xwdhdr->l_pixmap_width*xwdhdr->l_bits_per_pixel)/8;\n  if (linepad < 0) linepad = 0;\n\n  lsbyte_first = (xwdhdr->l_byte_order == 0);\n\n  dest = data;\n  scan_lines = 0;\n\n  if (xwdhdr->l_bits_per_pixel == 32)\n    {\n      for (i = 0; i < height; i++)\n        {\n          for (j = 0; j < width; j++)\n            {\n              c0 = getc (ifp);\n              c1 = getc (ifp);\n              c2 = getc (ifp);\n              c3 = getc (ifp);\n              if (c3 < 0)\n                {\n                  err = 1;\n                  break;\n                }\n              if (lsbyte_first)\n                pixelval = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);\n              else\n                pixelval = (c0 << 24) | (c1 << 16) | (c2 << 8) | c3;\n\n              if (get_pixelmap (pixelval, &pixel_map, dest, dest+1, dest+2))\n                {\n                  dest += 3;\n                }\n              else\n                {\n                  *(dest++) = redmap[(pixelval & redmask) >> redshift];\n                  *(dest++) = greenmap[(pixelval & greenmask) >> greenshift];\n                  *(dest++) = bluemap[(pixelval & bluemask) >> blueshift];\n                }\n            }\n          scan_lines++;\n\n          if (err)\n            break;\n\n          for (j = 0; j < linepad; j++)\n            getc (ifp);\n\n          if ((i % 20) == 0)\n            gimp_progress_update ((gdouble) (i + 1) / (gdouble) height);\n\n          if ((scan_lines == tile_height) || ((i+1) == height))\n            {\n              gimp_pixel_rgn_set_rect (&pixel_rgn, data, 0, i-scan_lines+1,\n                                       width, scan_lines);\n              scan_lines = 0;\n              dest = data;\n            }\n        }\n    }\n  else    /* 24 bits per pixel */\n    {\n      for (i = 0; i < height; i++)\n        {\n          for (j = 0; j < width; j++)\n            {\n              c0 = getc (ifp);\n              c1 = getc (ifp);\n              c2 = getc (ifp);\n              if (c2 < 0)\n                {\n                  err = 1;\n                  break;\n                }\n              if (lsbyte_first)\n                pixelval = c0 | (c1 << 8) | (c2 << 16);\n              else\n                pixelval = (c0 << 16) | (c1 << 8) | c2;\n\n              if (get_pixelmap (pixelval, &pixel_map, dest, dest+1, dest+2))\n                {\n                  dest += 3;\n                }\n              else\n                {\n                  *(dest++) = redmap[(pixelval & redmask) >> redshift];\n                  *(dest++) = greenmap[(pixelval & greenmask) >> greenshift];\n                  *(dest++) = bluemap[(pixelval & bluemask) >> blueshift];\n                }\n            }\n          scan_lines++;\n\n          if (err)\n            break;\n\n          for (j = 0; j < linepad; j++)\n            getc (ifp);\n\n          if ((i % 20) == 0)\n            gimp_progress_update ((gdouble) (i + 1) / (gdouble) height);\n\n          if ((scan_lines == tile_height) || ((i+1) == height))\n            {\n              gimp_pixel_rgn_set_rect (&pixel_rgn, data, 0, i-scan_lines+1,\n                                       width, scan_lines);\n              scan_lines = 0;\n              dest = data;\n            }\n        }\n    }\n\n  g_free (data);\n\n  if (err)\n    g_message (_(\"EOF encountered on reading\"));\n\n  gimp_drawable_flush (drawable);\n\n  return err ? -1 : image_ID;\n}", "target": 1, "cwe": ["CWE-787"], "message": "Bug 687392 - Memory corruption vulnerability when reading XWD files\n\nApplied and enhanced patch from andres which makes file-xwd detect\nthis kind of file corruption and abort loading with an error message."}
{"func": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE            *ifp;\n  gint             depth, bpp;\n  gint32           image_ID;\n  L_XWDFILEHEADER  xwdhdr;\n  L_XWDCOLOR      *xwdcolmap = NULL;\n\n  ifp = g_fopen (filename, \"rb\");\n  if (!ifp)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  read_xwd_header (ifp, &xwdhdr);\n  if (xwdhdr.l_file_version != 7)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read XWD header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      fclose (ifp);\n      return -1;\n    }\n\n#ifdef XWD_COL_WAIT_DEBUG\n  {\n    int k = 1;\n\n    while (k)\n      k = k;\n  }\n#endif\n\n  /* Position to start of XWDColor structures */\n  fseek (ifp, (long)xwdhdr.l_header_size, SEEK_SET);\n\n  if (xwdhdr.l_colormap_entries > 0)\n    {\n      xwdcolmap = g_new (L_XWDCOLOR, xwdhdr.l_colormap_entries);\n\n      read_xwd_cols (ifp, &xwdhdr, xwdcolmap);\n\n#ifdef XWD_COL_DEBUG\n      {\n        int j;\n        printf (\"File %s\\n\",filename);\n        for (j = 0; j < xwdhdr.l_colormap_entries; j++)\n          printf (\"Entry 0x%08lx: 0x%04lx,  0x%04lx, 0x%04lx, %d\\n\",\n                  (long)xwdcolmap[j].l_pixel,(long)xwdcolmap[j].l_red,\n                  (long)xwdcolmap[j].l_green,(long)xwdcolmap[j].l_blue,\n                  (int)xwdcolmap[j].l_flags);\n      }\n#endif\n\n      if (xwdhdr.l_file_version != 7)\n        {\n          g_message (_(\"Can't read color entries\"));\n          g_free (xwdcolmap);\n          fclose (ifp);\n          return (-1);\n        }\n    }\n\n  if (xwdhdr.l_pixmap_width <= 0)\n    {\n      g_message (_(\"'%s':\\nNo image width specified\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_width > GIMP_MAX_IMAGE_SIZE\n      || xwdhdr.l_bytes_per_line > GIMP_MAX_IMAGE_SIZE * 3)\n    {\n      g_message (_(\"'%s':\\nImage width is larger than GIMP can handle\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_height <= 0)\n    {\n      g_message (_(\"'%s':\\nNo image height specified\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  if (xwdhdr.l_pixmap_height > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_message (_(\"'%s':\\nImage height is larger than GIMP can handle\"),\n                 gimp_filename_to_utf8 (filename));\n      g_free (xwdcolmap);\n      fclose (ifp);\n      return (-1);\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  depth = xwdhdr.l_pixmap_depth;\n  bpp   = xwdhdr.l_bits_per_pixel;\n\n  image_ID = -1;\n  switch (xwdhdr.l_pixmap_format)\n    {\n    case 0:    /* Single plane bitmap */\n      if ((depth == 1) && (bpp == 1))\n        { /* Can be performed by format 2 loader */\n          image_ID = load_xwd_f2_d1_b1 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      break;\n\n    case 1:    /* Single plane pixmap */\n      if ((depth <= 24) && (bpp == 1))\n        {\n          image_ID = load_xwd_f1_d24_b1 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      break;\n\n    case 2:    /* Multiplane pixmaps */\n      if ((depth == 1) && (bpp == 1))\n        {\n          image_ID = load_xwd_f2_d1_b1 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 8) && (bpp == 8))\n        {\n          image_ID = load_xwd_f2_d8_b8 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 16) && (bpp == 16))\n        {\n          image_ID = load_xwd_f2_d16_b16 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      else if ((depth <= 24) && ((bpp == 24) || (bpp == 32)))\n        {\n          image_ID = load_xwd_f2_d24_b32 (filename, ifp, &xwdhdr, xwdcolmap);\n        }\n      break;\n    }\n  gimp_progress_update (1.0);\n\n  fclose (ifp);\n\n  if (xwdcolmap)\n    g_free (xwdcolmap);\n\n  if (image_ID == -1)\n    g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                 _(\"XWD-file %s has format %d, depth %d and bits per pixel %d. \"\n                   \"Currently this is not supported.\"),\n                 gimp_filename_to_utf8 (filename),\n                 (gint) xwdhdr.l_pixmap_format, depth, bpp);\n\n  return image_ID;\n}", "target": 1, "cwe": ["CWE-787"], "message": "Bug 687392 - Memory corruption vulnerability when reading XWD files\n\nApplied and enhanced patch from andres which makes file-xwd detect\nthis kind of file corruption and abort loading with an error message."}
{"func": "xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n    xmlChar limit = 0;\n    xmlChar *buf = NULL;\n    xmlChar *rep = NULL;\n    size_t len = 0;\n    size_t buf_size = 0;\n    int c, l, in_space = 0;\n    xmlChar *current = NULL;\n    xmlEntityPtr ent;\n\n    if (NXT(0) == '\"') {\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\tlimit = '\"';\n        NEXT;\n    } else if (NXT(0) == '\\'') {\n\tlimit = '\\'';\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n        NEXT;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buf_size = XML_PARSER_BUFFER_SIZE;\n    buf = (xmlChar *) xmlMallocAtomic(buf_size);\n    if (buf == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     */\n    c = CUR_CHAR(l);\n    while (((NXT(0) != limit) && /* checked */\n            (IS_CHAR(c)) && (c != '<')) &&\n            (ctxt->instate != XML_PARSER_EOF)) {\n        /*\n         * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE\n         * special option is given\n         */\n        if ((len > XML_MAX_TEXT_LENGTH) &&\n            ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                           \"AttValue lenght too long\\n\");\n            goto mem_error;\n        }\n\tif (c == 0) break;\n\tif (c == '&') {\n\t    in_space = 0;\n\t    if (NXT(1) == '#') {\n\t\tint val = xmlParseCharRef(ctxt);\n\n\t\tif (val == '&') {\n\t\t    if (ctxt->replaceEntities) {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t    } else {\n\t\t\t/*\n\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n\t\t\t * called by the attribute() function in SAX.c\n\t\t\t */\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    }\n\t\t} else if (val != 0) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    len += xmlCopyChar(0, &buf[len], val);\n\t\t}\n\t    } else {\n\t\tent = xmlParseEntityRef(ctxt);\n\t\tctxt->nbentities++;\n\t\tif (ent != NULL)\n\t\t    ctxt->nbentities += ent->owner;\n\t\tif ((ent != NULL) &&\n\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\t    if (len + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    if ((ctxt->replaceEntities == 0) &&\n\t\t        (ent->content[0] == '&')) {\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    } else {\n\t\t\tbuf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if ((ent != NULL) &&\n\t\t           (ctxt->replaceEntities != 0)) {\n\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n\t\t\t\t\t\t      0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    current = rep;\n\t\t\t    while (*current != 0) { /* non input consuming */\n                                if ((*current == 0xD) || (*current == 0xA) ||\n                                    (*current == 0x9)) {\n                                    buf[len++] = 0x20;\n                                    current++;\n                                } else\n                                    buf[len++] = *current++;\n\t\t\t\tif (len + 10 > buf_size) {\n\t\t\t\t    growBuffer(buf, 10);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tif (ent->content != NULL)\n\t\t\t    buf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if (ent != NULL) {\n\t\t    int i = xmlStrlen(ent->name);\n\t\t    const xmlChar *cur = ent->name;\n\n\t\t    /*\n\t\t     * This may look absurd but is needed to detect\n\t\t     * entities problems\n\t\t     */\n\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t\t\t(ent->content != NULL)) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Just output the reference\n\t\t     */\n\t\t    buf[len++] = '&';\n\t\t    while (len + i + 10 > buf_size) {\n\t\t\tgrowBuffer(buf, i + 10);\n\t\t    }\n\t\t    for (;i > 0;i--)\n\t\t\tbuf[len++] = *cur++;\n\t\t    buf[len++] = ';';\n\t\t}\n\t    }\n\t} else {\n\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n\t        if ((len != 0) || (!normalize)) {\n\t\t    if ((!normalize) || (!in_space)) {\n\t\t\tCOPY_BUF(l,buf,len,0x20);\n\t\t\twhile (len + 10 > buf_size) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t    }\n\t\t    in_space = 1;\n\t\t}\n\t    } else {\n\t        in_space = 0;\n\t\tCOPY_BUF(l,buf,len,c);\n\t\tif (len + 10 > buf_size) {\n\t\t    growBuffer(buf, 10);\n\t\t}\n\t    }\n\t    NEXTL(l);\n\t}\n\tGROW;\n\tc = CUR_CHAR(l);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        goto error;\n\n    if ((in_space) && (normalize)) {\n        while (buf[len - 1] == 0x20) len--;\n    }\n    buf[len] = 0;\n    if (RAW == '<') {\n\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n    } else if (RAW != limit) {\n\tif ((c != 0) && (!IS_CHAR(c))) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n\t\t\t   \"invalid character in attribute value\\n\");\n\t} else {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n\t\t\t   \"AttValue: ' expected\\n\");\n        }\n    } else\n\tNEXT;\n\n    /*\n     * There we potentially risk an overflow, don't allow attribute value of\n     * lenght more than INT_MAX it is a very reasonnable assumption !\n     */\n    if (len >= INT_MAX) {\n        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n                       \"AttValue lenght too long\\n\");\n        goto mem_error;\n    }\n\n    if (attlen != NULL) *attlen = (int) len;\n    return(buf);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nerror:\n    if (buf != NULL)\n        xmlFree(buf);\n    if (rep != NULL)\n        xmlFree(rep);\n    return(NULL);\n}", "target": 1, "cwe": ["CWE-119"], "message": "Fix potential out of bound access"}
{"func": "Opal::Call::OnSetUp (OpalConnection & connection)\n{\n  outgoing = !IsNetworkOriginated ();\n  parse_info (connection);\n\n  Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_setup_in_main, this));\n  call_setup = true;\n\n  cleared.connect (boost::bind (&Opal::Call::on_cleared_call, this, _1));\n  missed.connect (boost::bind (&Opal::Call::on_missed_call, this));\n\n  new CallSetup (*this, connection);\n\n  return true; \n}", "target": 1, "cwe": [], "message": "Validate UTF-8 strings before showing them\n\nCloses bug #653009."}
{"func": "Opal::Call::parse_info (OpalConnection & connection)\n{\n  char start_special_chars [] = \"$\";\n  char end_special_chars [] = \"([;=\";\n  \n  std::string l_party_name;\n  std::string r_party_name;\n  std::string app;\n\n  if (!PIsDescendant(&connection, OpalPCSSConnection)) {\n\n    remote_uri = (const char *) connection.GetRemotePartyAddress ();\n\n    l_party_name = (const char *) connection.GetLocalPartyName ();\n    r_party_name = (const char *) connection.GetRemotePartyName ();\n    app = (const char *) connection.GetRemoteProductInfo ().AsString ();\n    start_time = connection.GetConnectionStartTime ();\n    if (!start_time.IsValid ())\n      start_time = PTime ();\n\n    if (!l_party_name.empty ())\n      local_party_name = (const char *) SIPURL (l_party_name).GetUserName ();\n    if (!r_party_name.empty ())\n      remote_party_name = r_party_name;\n    if (!app.empty ())\n      remote_application = app;\n    \n    strip_special_chars (remote_party_name, end_special_chars, false);\n    strip_special_chars (remote_application, end_special_chars, false);\n    strip_special_chars (remote_uri, end_special_chars, false);\n\n    strip_special_chars (remote_party_name, start_special_chars, true);\n    strip_special_chars (remote_uri, start_special_chars, true);\n  }\n}", "target": 1, "cwe": [], "message": "Validate UTF-8 strings before showing them\n\nCloses bug #653009."}
{"func": "Opal::Call::OnHold (OpalConnection & /*connection*/, \n                    bool /*from_remote*/, \n                    bool on_hold)\n{\n  if (on_hold)\n    Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_held_in_main, this));\n  else\n    Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_retrieved_in_main, this));\n}", "target": 1, "cwe": [], "message": "Validate UTF-8 strings before showing them\n\nCloses bug #653009."}
{"func": "Opal::Call::OnEstablished (OpalConnection & connection)\n{\n  RTP_Session *session = NULL; \n  OpalMediaStreamPtr stream;\n\n  NoAnswerTimer.Stop (false);\n\n  if (!PIsDescendant(&connection, OpalPCSSConnection)) {\n\n    parse_info (connection);\n    Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_established_in_main, this));\n  }\n\n  if (PIsDescendant(&connection, OpalRTPConnection)) {\n\n    stream = connection.GetMediaStream (OpalMediaType::Audio (), false);\n    if (stream != NULL) {\n\n      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n      if (session) {\n      \n        session->SetIgnorePayloadTypeChanges (TRUE);\n        session->SetRxStatisticsInterval(50);\n        session->SetTxStatisticsInterval(50);\n      }\n    }\n\n    stream = connection.GetMediaStream (OpalMediaType::Video (), false);\n    if (stream != NULL) { \n\n      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n      if (session) {\n\n        session->SetIgnorePayloadTypeChanges (TRUE);\n        session->SetRxStatisticsInterval(50);\n        session->SetTxStatisticsInterval(50);\n      }\n    }\n  }\n  \n  return OpalCall::OnEstablished (connection);\n}", "target": 1, "cwe": [], "message": "Validate UTF-8 strings before showing them\n\nCloses bug #653009."}
{"func": "Opal::Call::get_duration () const\n{\n  std::stringstream duration;\n  \n  if (start_time.IsValid () && IsEstablished ()) {\n\n    PTimeInterval t = PTime () - start_time;\n\n    duration << setfill ('0') << setw (2) << t.GetHours () << \":\";\n    duration << setfill ('0') << setw (2) << (t.GetMinutes () % 60) << \":\";\n    duration << setfill ('0') << setw (2) << (t.GetSeconds () % 60);\n  }\n\n  return duration.str ();\n}", "target": 1, "cwe": [], "message": "Validate UTF-8 strings before showing them\n\nCloses bug #653009."}
{"func": "void dd_sanitize_mode_and_owner(struct dump_dir *dd)\n{\n    /* Don't sanitize if we aren't run under root:\n     * we assume that during file creation (by whatever means,\n     * even by \"hostname >file\" in abrt_event.conf)\n     * normal umask-based mode setting takes care of correct mode,\n     * and uid:gid is, of course, set to user's uid and gid.\n     *\n     * For root operating on /var/spool/abrt/USERS_PROBLEM, this isn't true:\n     * \"hostname >file\", for example, would create file OWNED BY ROOT!\n     * This routine resets mode and uid:gid for all such files.\n     */\n    if (dd->dd_uid == (uid_t)-1)\n        return;\n\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    DIR *d = opendir(dd->dd_dirname);\n    if (!d)\n        return;\n\n    struct dirent *dent;\n    while ((dent = readdir(d)) != NULL)\n    {\n        if (dent->d_name[0] == '.') /* \".lock\", \".\", \"..\"? skip */\n            continue;\n        char *full_path = concat_path_file(dd->dd_dirname, dent->d_name);\n        struct stat statbuf;\n        if (lstat(full_path, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        {\n            if ((statbuf.st_mode & 0777) != dd->mode)\n                chmod(full_path, dd->mode);\n            if (statbuf.st_uid != dd->dd_uid || statbuf.st_gid != dd->dd_gid)\n            {\n                if (chown(full_path, dd->dd_uid, dd->dd_gid) != 0)\n                {\n                    perror_msg(\"Can't change '%s' ownership to %lu:%lu\", full_path,\n                               (long)dd->dd_uid, (long)dd->dd_gid);\n                }\n            }\n        }\n        free(full_path);\n    }\n    closedir(d);\n}", "target": 1, "cwe": ["CWE-264"], "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open"}
{"func": "static bool save_binary_file(const char *path, const char* data, unsigned size, uid_t uid, gid_t gid, mode_t mode)\n{\n    /* the mode is set by the caller, see dd_create() for security analysis */\n    unlink(path);\n    int fd = open(path, O_WRONLY | O_TRUNC | O_CREAT, mode);\n    if (fd < 0)\n    {\n        perror_msg(\"Can't open file '%s'\", path);\n        return false;\n    }\n\n    if (uid != (uid_t)-1L)\n    {\n        if (fchown(fd, uid, gid) == -1)\n        {\n            perror_msg(\"Can't change '%s' ownership to %lu:%lu\", path, (long)uid, (long)gid);\n        }\n    }\n\n    unsigned r = full_write(fd, data, size);\n    close(fd);\n    if (r != size)\n    {\n        error_msg(\"Can't save file '%s'\", path);\n        return false;\n    }\n\n    return true;\n}", "target": 1, "cwe": ["CWE-264"], "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open"}
{"func": "static bool not_valid_time_file(const char *filename)\n{\n    /* Open input file, and parse it. */\n    int fd = open(filename, O_RDONLY);\n    if (fd < 0)\n    {\n        VERB2 perror_msg(\"Can't open '%s'\", filename);\n        return true;\n    }\n\n    /* ~ maximal number of digits for positive time stamp string*/\n    char time_buf[sizeof(time_t) * 3 + 1];\n    ssize_t rdsz = read(fd, time_buf, sizeof(time_buf));\n\n    /* Just reading, so no need to check the returned value. */\n    close(fd);\n\n    if (rdsz == -1)\n    {\n        VERB2 perror_msg(\"Can't read from '%s'\", filename);\n        return true;\n    }\n\n    /* approximate maximal number of digits in timestamp is sizeof(time_t)*3 */\n    /* buffer has this size + 1 byte for trailing '\\0' */\n    /* if whole size of buffer was read then file is bigger */\n    /* than string representing maximal time stamp */\n    if (rdsz == sizeof(time_buf))\n    {\n        VERB2 log(\"File '%s' is too long to be valid unix \"\n                  \"time stamp (max size %zdB)\", filename, sizeof(time_buf));\n        return true;\n    }\n\n    /* Our tools don't put trailing newline into time file,\n     * but we allow such format too:\n     */\n    if (rdsz > 0 && time_buf[rdsz - 1] == '\\n')\n        rdsz--;\n    time_buf[rdsz] = '\\0';\n\n    /* the value should fit to timestamp number range because of file size */\n    /* condition above, hence check if the value string consists only from digits */\n    if (!isdigit_str(time_buf))\n    {\n        VERB2 log(\"File '%s' doesn't contain valid unix \"\n                  \"time stamp ('%s')\", filename, time_buf);\n        return true;\n    }\n\n    return false;\n}", "target": 1, "cwe": ["CWE-264"], "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open"}
{"func": "struct dump_dir *dd_create(const char *dir, uid_t uid, mode_t mode)\n{\n    /* a little trick to copy read bits from file mode to exec bit of dir mode*/\n    mode_t dir_mode = mode | ((mode & 0444) >> 2);\n    struct dump_dir *dd = dd_init();\n\n    dd->mode = mode;\n\n    /* Unlike dd_opendir, can't use realpath: the directory doesn't exist yet,\n     * realpath will always return NULL. We don't really have to:\n     * dd_opendir(\".\") makes sense, dd_create(\".\") does not.\n     */\n    dir = dd->dd_dirname = rm_trailing_slashes(dir);\n\n    const char *last_component = strrchr(dir, '/');\n    if (last_component)\n        last_component++;\n    else\n        last_component = dir;\n    if (dot_or_dotdot(last_component))\n    {\n        /* dd_create(\".\"), dd_create(\"..\"), dd_create(\"dir/.\"),\n         * dd_create(\"dir/..\") and similar are madness, refuse them.\n         */\n        error_msg(\"Bad dir name '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    /* Was creating it with mode 0700 and user as the owner, but this allows\n     * the user to replace any file in the directory, changing security-sensitive data\n     * (e.g. \"uid\", \"analyzer\", \"executable\")\n     */\n    if (g_mkdir_with_parents(dd->dd_dirname, dir_mode) != 0)\n    {\n        perror_msg(\"Can't create directory '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    if (dd_lock(dd, CREATE_LOCK_USLEEP, /*flags:*/ 0) < 0)\n    {\n        dd_close(dd);\n        return NULL;\n    }\n\n    /* mkdir's mode (above) can be affected by umask, fix it */\n    if (chmod(dir, dir_mode) == -1)\n    {\n        perror_msg(\"Can't change mode of '%s'\", dir);\n        dd_close(dd);\n        return NULL;\n    }\n\n    dd->dd_uid = (uid_t)-1L;\n    dd->dd_gid = (gid_t)-1L;\n    if (uid != (uid_t)-1L)\n    {\n        /* Get ABRT's user id */\n        dd->dd_uid = 0;\n        struct passwd *pw = getpwnam(\"abrt\");\n        if (pw)\n            dd->dd_uid = pw->pw_uid;\n        else\n            error_msg(\"user 'abrt' does not exist, using uid 0\");\n\n        /* Get crashed application's group id */\n        /*dd->dd_gid = 0; - dd_init did this already */\n        pw = getpwuid(uid);\n        if (pw)\n            dd->dd_gid = pw->pw_gid;\n        else\n            error_msg(\"User %lu does not exist, using gid 0\", (long)uid);\n\n        if (chown(dir, dd->dd_uid, dd->dd_gid) == -1)\n        {\n            perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dir,\n                       (long)dd->dd_uid, (long)dd->dd_gid);\n        }\n    }\n\n    return dd;\n}", "target": 1, "cwe": ["CWE-264"], "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open"}
{"func": "static char *load_text_file(const char *path, unsigned flags)\n{\n    FILE *fp = fopen(path, \"r\");\n    if (!fp)\n    {\n        if (!(flags & DD_FAIL_QUIETLY_ENOENT))\n            perror_msg(\"Can't open file '%s'\", path);\n        return (flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE ? NULL : xstrdup(\"\"));\n    }\n\n    struct strbuf *buf_content = strbuf_new();\n    int oneline = 0;\n    int ch;\n    while ((ch = fgetc(fp)) != EOF)\n    {\n//TODO? \\r -> \\n?\n//TODO? strip trailing spaces/tabs?\n        if (ch == '\\n')\n            oneline = (oneline << 1) | 1;\n        if (ch == '\\0')\n            ch = ' ';\n        if (isspace(ch) || ch >= ' ') /* used !iscntrl, but it failed on unicode */\n            strbuf_append_char(buf_content, ch);\n    }\n    fclose(fp);\n\n    char last = oneline != 0 ? buf_content->buf[buf_content->len - 1] : 0;\n    if (last == '\\n')\n    {\n        /* If file contains exactly one '\\n' and it is at the end, remove it.\n         * This enables users to use simple \"echo blah >file\" in order to create\n         * short string items in dump dirs.\n         */\n        if (oneline == 1)\n            buf_content->buf[--buf_content->len] = '\\0';\n    }\n    else /* last != '\\n' */\n    {\n        /* Last line is unterminated, fix it */\n        /* Cases: */\n        /* oneline=0: \"qwe\" - DONT fix this! */\n        /* oneline=1: \"qwe\\nrty\" - two lines in fact */\n        /* oneline>1: \"qwe\\nrty\\uio\" */\n        if (oneline >= 1)\n            strbuf_append_char(buf_content, '\\n');\n    }\n\n    return strbuf_free_nobuf(buf_content);\n}", "target": 1, "cwe": ["CWE-264"], "message": "never follow symlinks rhbz#887866\n\n- use lchown instead chown and O_NOFOLLOW where we use open"}
{"func": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n    struct e1000_rx_desc desc;\n    dma_addr_t base;\n    unsigned int n, rdt;\n    uint32_t rdh_start;\n    uint16_t vlan_special = 0;\n    uint8_t vlan_status = 0, vlan_offset = 0;\n    uint8_t min_buf[MIN_BUF_SIZE];\n    size_t desc_offset;\n    size_t desc_size;\n    size_t total_size;\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n        return -1;\n\n    /* Pad to minimum Ethernet frame length */\n    if (size < sizeof(min_buf)) {\n        memcpy(min_buf, buf, size);\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n        buf = min_buf;\n        size = sizeof(min_buf);\n    }\n\n    if (!receive_filter(s, buf, size))\n        return size;\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n        memmove((uint8_t *)buf + 4, buf, 12);\n        vlan_status = E1000_RXD_STAT_VP;\n        vlan_offset = 4;\n        size -= 4;\n    }\n\n    rdh_start = s->mac_reg[RDH];\n    desc_offset = 0;\n    total_size = size + fcs_len(s);\n    if (!e1000_has_rxbufs(s, total_size)) {\n            set_ics(s, 0, E1000_ICS_RXO);\n            return -1;\n    }\n    do {\n        desc_size = total_size - desc_offset;\n        if (desc_size > s->rxbuf_size) {\n            desc_size = s->rxbuf_size;\n        }\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n        pci_dma_read(&s->dev, base, &desc, sizeof(desc));\n        desc.special = vlan_special;\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n        if (desc.buffer_addr) {\n            if (desc_offset < size) {\n                size_t copy_size = size - desc_offset;\n                if (copy_size > s->rxbuf_size) {\n                    copy_size = s->rxbuf_size;\n                }\n                pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n                              buf + desc_offset + vlan_offset, copy_size);\n            }\n            desc_offset += desc_size;\n            desc.length = cpu_to_le16(desc_size);\n            if (desc_offset >= total_size) {\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n            } else {\n                /* Guest zeroing out status is not a hardware requirement.\n                   Clear EOP in case guest didn't do it. */\n                desc.status &= ~E1000_RXD_STAT_EOP;\n            }\n        } else { // as per intel docs; skip descriptors with null buf addr\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n        }\n        pci_dma_write(&s->dev, base, &desc, sizeof(desc));\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n            s->mac_reg[RDH] = 0;\n        /* see comment in start_xmit; same here */\n        if (s->mac_reg[RDH] == rdh_start) {\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n            set_ics(s, 0, E1000_ICS_RXO);\n            return -1;\n        }\n    } while (desc_offset < total_size);\n\n    s->mac_reg[GPRC]++;\n    s->mac_reg[TPR]++;\n    /* TOR - Total Octets Received:\n     * This register includes bytes received in a packet from the <Destination\n     * Address> field through the <CRC> field, inclusively.\n     */\n    n = s->mac_reg[TORL] + size + /* Always include FCS length. */ 4;\n    if (n < s->mac_reg[TORL])\n        s->mac_reg[TORH]++;\n    s->mac_reg[TORL] = n;\n\n    n = E1000_ICS_RXT0;\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n        s->rxbuf_min_shift)\n        n |= E1000_ICS_RXDMT0;\n\n    set_ics(s, 0, n);\n\n    return size;\n}", "target": 1, "cwe": ["CWE-120"], "message": "e1000: Discard packets that are too long if !SBP and !LPE\n\nThe e1000_receive function for the e1000 needs to discard packets longer than\n1522 bytes if the SBP and LPE flags are disabled. The linux driver assumes\nthis behavior and allocates memory based on this assumption.\n\nSigned-off-by: Michael Contreras <michael@inetric.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>"}
{"func": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n    struct e1000_rx_desc desc;\n    dma_addr_t base;\n    unsigned int n, rdt;\n    uint32_t rdh_start;\n    uint16_t vlan_special = 0;\n    uint8_t vlan_status = 0, vlan_offset = 0;\n    uint8_t min_buf[MIN_BUF_SIZE];\n    size_t desc_offset;\n    size_t desc_size;\n    size_t total_size;\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n        return -1;\n\n    /* Pad to minimum Ethernet frame length */\n    if (size < sizeof(min_buf)) {\n        memcpy(min_buf, buf, size);\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n        buf = min_buf;\n        size = sizeof(min_buf);\n    }\n\n    /* Discard oversized packets if !LPE and !SBP. */\n    if (size > MAXIMUM_ETHERNET_VLAN_SIZE\n        && !(s->mac_reg[RCTL] & E1000_RCTL_LPE)\n        && !(s->mac_reg[RCTL] & E1000_RCTL_SBP)) {\n        return size;\n    }\n\n    if (!receive_filter(s, buf, size))\n        return size;\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n        memmove((uint8_t *)buf + 4, buf, 12);\n        vlan_status = E1000_RXD_STAT_VP;\n        vlan_offset = 4;\n        size -= 4;\n    }\n\n    rdh_start = s->mac_reg[RDH];\n    desc_offset = 0;\n    total_size = size + fcs_len(s);\n    if (!e1000_has_rxbufs(s, total_size)) {\n            set_ics(s, 0, E1000_ICS_RXO);\n            return -1;\n    }\n    do {\n        desc_size = total_size - desc_offset;\n        if (desc_size > s->rxbuf_size) {\n            desc_size = s->rxbuf_size;\n        }\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n        pci_dma_read(&s->dev, base, &desc, sizeof(desc));\n        desc.special = vlan_special;\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n        if (desc.buffer_addr) {\n            if (desc_offset < size) {\n                size_t copy_size = size - desc_offset;\n                if (copy_size > s->rxbuf_size) {\n                    copy_size = s->rxbuf_size;\n                }\n                pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n                              buf + desc_offset + vlan_offset, copy_size);\n            }\n            desc_offset += desc_size;\n            desc.length = cpu_to_le16(desc_size);\n            if (desc_offset >= total_size) {\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n            } else {\n                /* Guest zeroing out status is not a hardware requirement.\n                   Clear EOP in case guest didn't do it. */\n                desc.status &= ~E1000_RXD_STAT_EOP;\n            }\n        } else { // as per intel docs; skip descriptors with null buf addr\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n        }\n        pci_dma_write(&s->dev, base, &desc, sizeof(desc));\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n            s->mac_reg[RDH] = 0;\n        /* see comment in start_xmit; same here */\n        if (s->mac_reg[RDH] == rdh_start) {\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n            set_ics(s, 0, E1000_ICS_RXO);\n            return -1;\n        }\n    } while (desc_offset < total_size);\n\n    s->mac_reg[GPRC]++;\n    s->mac_reg[TPR]++;\n    /* TOR - Total Octets Received:\n     * This register includes bytes received in a packet from the <Destination\n     * Address> field through the <CRC> field, inclusively.\n     */\n    n = s->mac_reg[TORL] + size + /* Always include FCS length. */ 4;\n    if (n < s->mac_reg[TORL])\n        s->mac_reg[TORH]++;\n    s->mac_reg[TORL] = n;\n\n    n = E1000_ICS_RXT0;\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n        s->rxbuf_min_shift)\n        n |= E1000_ICS_RXDMT0;\n\n    set_ics(s, 0, n);\n\n    return size;\n}", "target": 1, "cwe": ["CWE-120"], "message": "e1000: Discard oversized packets based on SBP|LPE\n\nDiscard packets longer than 16384 when !SBP to match the hardware behavior.\n\nSigned-off-by: Michael Contreras <michael@inetric.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>"}
{"func": "realloc_trans_if_necessary(struct dfa *d, int new_state)\n{\n  /* Make sure that the trans and fail arrays are allocated large enough\n     to hold a pointer for the new state. */\n  if (new_state >= d->tralloc)\n    {\n      int oldalloc = d->tralloc;\n\n      while (new_state >= d->tralloc)\n        d->tralloc *= 2;\n      REALLOC(d->realtrans, d->tralloc + 1);\n      d->trans = d->realtrans + 1;\n      REALLOC(d->fails, d->tralloc);\n      REALLOC(d->success, d->tralloc);\n      REALLOC(d->newlines, d->tralloc);\n      while (oldalloc < d->tralloc)\n        {\n          d->trans[oldalloc] = NULL;\n          d->fails[oldalloc++] = NULL;\n        }\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "transit_state_consume_1char (struct dfa *d, int s, unsigned char const **pp,\n                             int *match_lens, int *mbclen, position_set *pps)\n{\n  int i, j;\n  int s1, s2;\n  int* work_mbls;\n  status_transit_state rs = TRANSIT_STATE_DONE;\n\n  /* Calculate the length of the (single/multi byte) character\n     to which p points.  */\n  *mbclen = (mblen_buf[*pp - buf_begin] == 0)? 1\n    : mblen_buf[*pp - buf_begin];\n\n  /* Calculate the state which can be reached from the state `s' by\n     consuming `*mbclen' single bytes from the buffer.  */\n  s1 = s;\n  for (i = 0; i < *mbclen; i++)\n    {\n      s2 = s1;\n      rs = transit_state_singlebyte(d, s2, (*pp)++, &s1);\n    }\n  /* Copy the positions contained by `s1' to the set `pps'.  */\n  copy(&(d->states[s1].elems), pps);\n\n  /* Check (inputed)match_lens, and initialize if it is NULL.  */\n  if (match_lens == NULL && d->states[s].mbps.nelem != 0)\n    work_mbls = check_matching_with_multibyte_ops(d, s, *pp - buf_begin);\n  else\n    work_mbls = match_lens;\n\n  /* Add all of the positions which can be reached from `s' by consuming\n     a single character.  */\n  for (i = 0; i < d->states[s].mbps.nelem ; i++)\n   {\n      if (work_mbls[i] == *mbclen)\n        for (j = 0; j < d->follows[d->states[s].mbps.elems[i].index].nelem;\n             j++)\n          insert(d->follows[d->states[s].mbps.elems[i].index].elems[j],\n                 pps);\n    }\n\n  if (match_lens == NULL && work_mbls != NULL)\n    free(work_mbls);\n  return rs;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "insert (position p, position_set *s)\n{\n  int count = s->nelem;\n  int lo = 0, hi = count;\n  int i;\n  while (lo < hi)\n    {\n      int mid = ((unsigned) lo + (unsigned) hi) >> 1;\n      if (s->elems[mid].index > p.index)\n        lo = mid + 1;\n      else\n        hi = mid;\n    }\n\n  if (lo < count && p.index == s->elems[lo].index)\n    {\n      s->elems[lo].constraint |= p.constraint;\n      return;\n    }\n\n  REALLOC_IF_NECESSARY(s->elems, s->alloc, count + 1);\n  for (i = count; i > lo; i--)\n    s->elems[i] = s->elems[i - 1];\n  s->elems[lo] = p;\n  ++s->nelem;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfafree (struct dfa *d)\n{\n  int i;\n  struct dfamust *dm, *ndm;\n\n  free(d->charclasses);\n  free(d->tokens);\n\n  if (d->mb_cur_max > 1)\n    free_mbdata(d);\n\n  for (i = 0; i < d->sindex; ++i) {\n    free(d->states[i].elems.elems);\n    if (MBS_SUPPORT)\n      free(d->states[i].mbps.elems);\n  }\n  free(d->states);\n  for (i = 0; i < d->tindex; ++i)\n    free(d->follows[i].elems);\n  free(d->follows);\n  for (i = 0; i < d->tralloc; ++i)\n    {\n      free(d->trans[i]);\n      free(d->fails[i]);\n    }\n  free(d->realtrans);\n  free(d->fails);\n  free(d->newlines);\n  free(d->success);\n  for (dm = d->musts; dm; dm = ndm)\n    {\n      ndm = dm->next;\n      free(dm->must);\n      free(dm);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "transit_state (struct dfa *d, int s, unsigned char const **pp)\n{\n  int s1;\n  int mbclen;\t\t/* The length of current input multibyte character. */\n  int maxlen = 0;\n  int i, j;\n  int *match_lens = NULL;\n  int nelem = d->states[s].mbps.nelem; /* Just a alias.  */\n  position_set follows;\n  unsigned char const *p1 = *pp;\n  wchar_t wc;\n\n  if (nelem > 0)\n    /* This state has (a) multibyte operator(s).\n       We check whether each of them can match or not.  */\n    {\n      /* Note: caller must free the return value of this function.  */\n      match_lens = check_matching_with_multibyte_ops(d, s, *pp - buf_begin);\n\n      for (i = 0; i < nelem; i++)\n        /* Search the operator which match the longest string,\n           in this state.  */\n        {\n          if (match_lens[i] > maxlen)\n            maxlen = match_lens[i];\n        }\n    }\n\n  if (nelem == 0 || maxlen == 0)\n    /* This state has no multibyte operator which can match.\n       We need to check only one single byte character.  */\n    {\n      status_transit_state rs;\n      rs = transit_state_singlebyte(d, s, *pp, &s1);\n\n      /* We must update the pointer if state transition succeeded.  */\n      if (rs == TRANSIT_STATE_DONE)\n        ++*pp;\n\n      free(match_lens);\n      return s1;\n    }\n\n  /* This state has some operators which can match a multibyte character.  */\n  alloc_position_set(&follows, d->nleaves);\n\n  /* `maxlen' may be longer than the length of a character, because it may\n     not be a character but a (multi character) collating element.\n     We enumerate all of the positions which `s' can reach by consuming\n     `maxlen' bytes.  */\n  transit_state_consume_1char(d, s, pp, match_lens, &mbclen, &follows);\n\n  wc = inputwcs[*pp - mbclen - buf_begin];\n  s1 = state_index(d, &follows, wchar_context (wc));\n  realloc_trans_if_necessary(d, s1);\n\n  while (*pp - p1 < maxlen)\n    {\n      transit_state_consume_1char(d, s1, pp, NULL, &mbclen, &follows);\n\n      for (i = 0; i < nelem ; i++)\n        {\n          if (match_lens[i] == *pp - p1)\n            for (j = 0;\n                 j < d->follows[d->states[s1].mbps.elems[i].index].nelem; j++)\n              insert(d->follows[d->states[s1].mbps.elems[i].index].elems[j],\n                     &follows);\n        }\n\n      wc = inputwcs[*pp - mbclen - buf_begin];\n      s1 = state_index(d, &follows, wchar_context (wc));\n      realloc_trans_if_necessary(d, s1);\n    }\n  free(match_lens);\n  free(follows.elems);\n  return s1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "prtok (token t)\n{\n  char const *s;\n\n  if (t < 0)\n    fprintf(stderr, \"END\");\n  else if (t < NOTCHAR)\n    fprintf(stderr, \"%c\", t);\n  else\n    {\n      switch (t)\n        {\n        case EMPTY: s = \"EMPTY\"; break;\n        case BACKREF: s = \"BACKREF\"; break;\n        case BEGLINE: s = \"BEGLINE\"; break;\n        case ENDLINE: s = \"ENDLINE\"; break;\n        case BEGWORD: s = \"BEGWORD\"; break;\n        case ENDWORD: s = \"ENDWORD\"; break;\n        case LIMWORD: s = \"LIMWORD\"; break;\n        case NOTLIMWORD: s = \"NOTLIMWORD\"; break;\n        case QMARK: s = \"QMARK\"; break;\n        case STAR: s = \"STAR\"; break;\n        case PLUS: s = \"PLUS\"; break;\n        case CAT: s = \"CAT\"; break;\n        case OR: s = \"OR\"; break;\n        case LPAREN: s = \"LPAREN\"; break;\n        case RPAREN: s = \"RPAREN\"; break;\n        case ANYCHAR: s = \"ANYCHAR\"; break;\n        case MBCSET: s = \"MBCSET\"; break;\n        default: s = \"CSET\"; break;\n        }\n      fprintf(stderr, \"%s\", s);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "inboth (char **left, char **right)\n{\n  char **both;\n  char **temp;\n  int lnum, rnum;\n\n  if (left == NULL || right == NULL)\n    return NULL;\n  both = malloc(sizeof *both);\n  if (both == NULL)\n    return NULL;\n  both[0] = NULL;\n  for (lnum = 0; left[lnum] != NULL; ++lnum)\n    {\n      for (rnum = 0; right[rnum] != NULL; ++rnum)\n        {\n          temp = comsubs(left[lnum], right[rnum]);\n          if (temp == NULL)\n            {\n              freelist(both);\n              return NULL;\n            }\n          both = addlists(both, temp);\n          freelist(temp);\n          free(temp);\n          if (both == NULL)\n            return NULL;\n        }\n    }\n  return both;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "freelist (char **cpp)\n{\n  int i;\n\n  if (cpp == NULL)\n    return;\n  for (i = 0; cpp[i] != NULL; ++i)\n    {\n      free(cpp[i]);\n      cpp[i] = NULL;\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "enlist (char **cpp, char *new, size_t len)\n{\n  int i, j;\n\n  if (cpp == NULL)\n    return NULL;\n  if ((new = icpyalloc(new)) == NULL)\n    {\n      freelist(cpp);\n      return NULL;\n    }\n  new[len] = '\\0';\n  /* Is there already something in the list that's new (or longer)? */\n  for (i = 0; cpp[i] != NULL; ++i)\n    if (istrstr(cpp[i], new) != NULL)\n      {\n        free(new);\n        return cpp;\n      }\n  /* Eliminate any obsoleted strings. */\n  j = 0;\n  while (cpp[j] != NULL)\n    if (istrstr(new, cpp[j]) == NULL)\n      ++j;\n    else\n      {\n        free(cpp[j]);\n        if (--i == j)\n          break;\n        cpp[j] = cpp[i];\n        cpp[i] = NULL;\n      }\n  /* Add the new string. */\n  REALLOC(cpp, i + 2);\n  cpp[i] = new;\n  cpp[i + 1] = NULL;\n  return cpp;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "charclass_index (charclass const s)\n{\n  int i;\n\n  for (i = 0; i < dfa->cindex; ++i)\n    if (equal(s, dfa->charclasses[i]))\n      return i;\n  REALLOC_IF_NECESSARY(dfa->charclasses, dfa->calloc, dfa->cindex + 1);\n  ++dfa->cindex;\n  copyset(s, dfa->charclasses[i]);\n  return i;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "epsclosure (position_set *s, struct dfa const *d)\n{\n  int i, j;\n  char *visited;\t/* array of booleans, enough to use char, not int */\n  position p, old;\n\n  CALLOC(visited, d->tindex);\n\n  for (i = 0; i < s->nelem; ++i)\n    if (d->tokens[s->elems[i].index] >= NOTCHAR\n        && d->tokens[s->elems[i].index] != BACKREF\n#if MBS_SUPPORT\n        && d->tokens[s->elems[i].index] != ANYCHAR\n        && d->tokens[s->elems[i].index] != MBCSET\n#endif\n        && d->tokens[s->elems[i].index] < CSET)\n      {\n        old = s->elems[i];\n        p.constraint = old.constraint;\n        delete(s->elems[i], s);\n        if (visited[old.index])\n          {\n            --i;\n            continue;\n          }\n        visited[old.index] = 1;\n        switch (d->tokens[old.index])\n          {\n          case BEGLINE:\n            p.constraint &= BEGLINE_CONSTRAINT;\n            break;\n          case ENDLINE:\n            p.constraint &= ENDLINE_CONSTRAINT;\n            break;\n          case BEGWORD:\n            p.constraint &= BEGWORD_CONSTRAINT;\n            break;\n          case ENDWORD:\n            p.constraint &= ENDWORD_CONSTRAINT;\n            break;\n          case LIMWORD:\n            p.constraint &= LIMWORD_CONSTRAINT;\n            break;\n          case NOTLIMWORD:\n            p.constraint &= NOTLIMWORD_CONSTRAINT;\n            break;\n          default:\n            break;\n          }\n        for (j = 0; j < d->follows[old.index].nelem; ++j)\n          {\n            p.index = d->follows[old.index].elems[j].index;\n            insert(p, s);\n          }\n        /* Force rescan to start at the beginning. */\n        i = -1;\n      }\n\n  free(visited);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)\n{\n  int i;\n  int* rarray;\n\n  MALLOC(rarray, d->states[s].mbps.nelem);\n  for (i = 0; i < d->states[s].mbps.nelem; ++i)\n    {\n      position pos = d->states[s].mbps.elems[i];\n      switch(d->tokens[pos.index])\n        {\n        case ANYCHAR:\n          rarray[i] = match_anychar(d, s, pos, idx);\n          break;\n        case MBCSET:\n          rarray[i] = match_mb_charset(d, s, pos, idx);\n          break;\n        default:\n          break; /* cannot happen.  */\n        }\n    }\n  return rarray;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfaanalyze (struct dfa *d, int searchflag)\n{\n  int *nullable;\t\t/* Nullable stack. */\n  int *nfirstpos;\t\t/* Element count stack for firstpos sets. */\n  position *firstpos;\t\t/* Array where firstpos elements are stored. */\n  int *nlastpos;\t\t/* Element count stack for lastpos sets. */\n  position *lastpos;\t\t/* Array where lastpos elements are stored. */\n  position_set tmp;\t\t/* Temporary set for merging sets. */\n  position_set merged;\t\t/* Result of merging sets. */\n  int separate_contexts;\t/* Context wanted by some position. */\n  int *o_nullable;\n  int *o_nfirst, *o_nlast;\n  position *o_firstpos, *o_lastpos;\n  int i, j;\n  position *pos;\n\n#ifdef DEBUG\n  fprintf(stderr, \"dfaanalyze:\\n\");\n  for (i = 0; i < d->tindex; ++i)\n    {\n      fprintf(stderr, \" %d:\", i);\n      prtok(d->tokens[i]);\n    }\n  putc('\\n', stderr);\n#endif\n\n  d->searchflag = searchflag;\n\n  MALLOC(nullable, d->depth);\n  o_nullable = nullable;\n  MALLOC(nfirstpos, d->depth);\n  o_nfirst = nfirstpos;\n  MALLOC(firstpos, d->nleaves);\n  o_firstpos = firstpos, firstpos += d->nleaves;\n  MALLOC(nlastpos, d->depth);\n  o_nlast = nlastpos;\n  MALLOC(lastpos, d->nleaves);\n  o_lastpos = lastpos, lastpos += d->nleaves;\n  alloc_position_set(&merged, d->nleaves);\n\n  CALLOC(d->follows, d->tindex);\n\n  for (i = 0; i < d->tindex; ++i)\n    {\n    switch (d->tokens[i])\n      {\n      case EMPTY:\n        /* The empty set is nullable. */\n        *nullable++ = 1;\n\n        /* The firstpos and lastpos of the empty leaf are both empty. */\n        *nfirstpos++ = *nlastpos++ = 0;\n        break;\n\n      case STAR:\n      case PLUS:\n        /* Every element in the firstpos of the argument is in the follow\n           of every element in the lastpos. */\n        tmp.nelem = nfirstpos[-1];\n        tmp.elems = firstpos;\n        pos = lastpos;\n        for (j = 0; j < nlastpos[-1]; ++j)\n          {\n            merge(&tmp, &d->follows[pos[j].index], &merged);\n            copy(&merged, &d->follows[pos[j].index]);\n          }\n\n      case QMARK:\n        /* A QMARK or STAR node is automatically nullable. */\n        if (d->tokens[i] != PLUS)\n          nullable[-1] = 1;\n        break;\n\n      case CAT:\n        /* Every element in the firstpos of the second argument is in the\n           follow of every element in the lastpos of the first argument. */\n        tmp.nelem = nfirstpos[-1];\n        tmp.elems = firstpos;\n        pos = lastpos + nlastpos[-1];\n        for (j = 0; j < nlastpos[-2]; ++j)\n          {\n            merge(&tmp, &d->follows[pos[j].index], &merged);\n            copy(&merged, &d->follows[pos[j].index]);\n          }\n\n        /* The firstpos of a CAT node is the firstpos of the first argument,\n           union that of the second argument if the first is nullable. */\n        if (nullable[-2])\n          nfirstpos[-2] += nfirstpos[-1];\n        else\n          firstpos += nfirstpos[-1];\n        --nfirstpos;\n\n        /* The lastpos of a CAT node is the lastpos of the second argument,\n           union that of the first argument if the second is nullable. */\n        if (nullable[-1])\n          nlastpos[-2] += nlastpos[-1];\n        else\n          {\n            pos = lastpos + nlastpos[-2];\n            for (j = nlastpos[-1] - 1; j >= 0; --j)\n              pos[j] = lastpos[j];\n            lastpos += nlastpos[-2];\n            nlastpos[-2] = nlastpos[-1];\n          }\n        --nlastpos;\n\n        /* A CAT node is nullable if both arguments are nullable. */\n        nullable[-2] = nullable[-1] && nullable[-2];\n        --nullable;\n        break;\n\n      case OR:\n        /* The firstpos is the union of the firstpos of each argument. */\n        nfirstpos[-2] += nfirstpos[-1];\n        --nfirstpos;\n\n        /* The lastpos is the union of the lastpos of each argument. */\n        nlastpos[-2] += nlastpos[-1];\n        --nlastpos;\n\n        /* An OR node is nullable if either argument is nullable. */\n        nullable[-2] = nullable[-1] || nullable[-2];\n        --nullable;\n        break;\n\n      default:\n        /* Anything else is a nonempty position.  (Note that special\n           constructs like \\< are treated as nonempty strings here;\n           an \"epsilon closure\" effectively makes them nullable later.\n           Backreferences have to get a real position so we can detect\n           transitions on them later.  But they are nullable. */\n        *nullable++ = d->tokens[i] == BACKREF;\n\n        /* This position is in its own firstpos and lastpos. */\n        *nfirstpos++ = *nlastpos++ = 1;\n        --firstpos, --lastpos;\n        firstpos->index = lastpos->index = i;\n        firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;\n\n        /* Allocate the follow set for this position. */\n        alloc_position_set(&d->follows[i], 1);\n        break;\n      }\n#ifdef DEBUG\n    /* ... balance the above nonsyntactic #ifdef goo... */\n      fprintf(stderr, \"node %d:\", i);\n      prtok(d->tokens[i]);\n      putc('\\n', stderr);\n      fprintf(stderr, nullable[-1] ? \" nullable: yes\\n\" : \" nullable: no\\n\");\n      fprintf(stderr, \" firstpos:\");\n      for (j = nfirstpos[-1] - 1; j >= 0; --j)\n        {\n          fprintf(stderr, \" %d:\", firstpos[j].index);\n          prtok(d->tokens[firstpos[j].index]);\n        }\n      fprintf(stderr, \"\\n lastpos:\");\n      for (j = nlastpos[-1] - 1; j >= 0; --j)\n        {\n          fprintf(stderr, \" %d:\", lastpos[j].index);\n          prtok(d->tokens[lastpos[j].index]);\n        }\n      putc('\\n', stderr);\n#endif\n    }\n\n  /* For each follow set that is the follow set of a real position, replace\n     it with its epsilon closure. */\n  for (i = 0; i < d->tindex; ++i)\n    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF\n#if MBS_SUPPORT\n        || d->tokens[i] == ANYCHAR\n        || d->tokens[i] == MBCSET\n#endif\n        || d->tokens[i] >= CSET)\n      {\n#ifdef DEBUG\n        fprintf(stderr, \"follows(%d:\", i);\n        prtok(d->tokens[i]);\n        fprintf(stderr, \"):\");\n        for (j = d->follows[i].nelem - 1; j >= 0; --j)\n          {\n            fprintf(stderr, \" %d:\", d->follows[i].elems[j].index);\n            prtok(d->tokens[d->follows[i].elems[j].index]);\n          }\n        putc('\\n', stderr);\n#endif\n        copy(&d->follows[i], &merged);\n        epsclosure(&merged, d);\n        copy(&merged, &d->follows[i]);\n      }\n\n  /* Get the epsilon closure of the firstpos of the regexp.  The result will\n     be the set of positions of state 0. */\n  merged.nelem = 0;\n  for (i = 0; i < nfirstpos[-1]; ++i)\n    insert(firstpos[i], &merged);\n  epsclosure(&merged, d);\n\n  /* Build the initial state. */\n  d->salloc = 1;\n  d->sindex = 0;\n  MALLOC(d->states, d->salloc);\n\n  separate_contexts = state_separate_contexts (&merged);\n  state_index(d, &merged,\n              (separate_contexts & CTX_NEWLINE\n               ? CTX_NEWLINE\n               : separate_contexts ^ CTX_ANY));\n\n  free(o_nullable);\n  free(o_nfirst);\n  free(o_firstpos);\n  free(o_nlast);\n  free(o_lastpos);\n  free(merged.elems);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "match_mb_charset (struct dfa *d, int s, position pos, int idx)\n{\n  int i;\n  int match;\t\t/* Flag which represent that matching succeed.  */\n  int match_len;\t/* Length of the character (or collating element)\n                           with which this operator match.  */\n  int op_len;\t\t/* Length of the operator.  */\n  char buffer[128];\n  wchar_t wcbuf[6];\n\n  /* Pointer to the structure to which we are currently refering.  */\n  struct mb_char_classes *work_mbc;\n\n  int context;\n  wchar_t wc;\t\t/* Current refering character.  */\n\n  wc = inputwcs[idx];\n\n  /* Check syntax bits.  */\n  if (wc == (wchar_t)eolbyte)\n    {\n      if (!(syntax_bits & RE_DOT_NEWLINE))\n        return 0;\n    }\n  else if (wc == (wchar_t)'\\0')\n    {\n      if (syntax_bits & RE_DOT_NOT_NULL)\n        return 0;\n    }\n\n  context = wchar_context(wc);\n  if (!SUCCEEDS_IN_CONTEXT(pos.constraint, d->states[s].context, context))\n    return 0;\n\n  /* Assign the current refering operator to work_mbc.  */\n  work_mbc = &(d->mbcsets[(d->multibyte_prop[pos.index]) >> 2]);\n  match = !work_mbc->invert;\n  match_len = (mblen_buf[idx] == 0)? 1 : mblen_buf[idx];\n\n  /* Match in range 0-255?  */\n  if (wc < NOTCHAR && work_mbc->cset != -1\n      && tstbit((unsigned char)wc, d->charclasses[work_mbc->cset]))\n    goto charset_matched;\n\n  /* match with a character class?  */\n  for (i = 0; i<work_mbc->nch_classes; i++)\n    {\n      if (iswctype((wint_t)wc, work_mbc->ch_classes[i]))\n        goto charset_matched;\n    }\n\n  strncpy(buffer, (char const *) buf_begin + idx, match_len);\n  buffer[match_len] = '\\0';\n\n  /* match with an equivalent class?  */\n  for (i = 0; i<work_mbc->nequivs; i++)\n    {\n      op_len = strlen(work_mbc->equivs[i]);\n      strncpy(buffer, (char const *) buf_begin + idx, op_len);\n      buffer[op_len] = '\\0';\n      if (strcoll(work_mbc->equivs[i], buffer) == 0)\n        {\n          match_len = op_len;\n          goto charset_matched;\n        }\n    }\n\n  /* match with a collating element?  */\n  for (i = 0; i<work_mbc->ncoll_elems; i++)\n    {\n      op_len = strlen(work_mbc->coll_elems[i]);\n      strncpy(buffer, (char const *) buf_begin + idx, op_len);\n      buffer[op_len] = '\\0';\n\n      if (strcoll(work_mbc->coll_elems[i], buffer) == 0)\n        {\n          match_len = op_len;\n          goto charset_matched;\n        }\n    }\n\n  wcbuf[0] = wc;\n  wcbuf[1] = wcbuf[3] = wcbuf[5] = '\\0';\n\n  /* match with a range?  */\n  for (i = 0; i<work_mbc->nranges; i++)\n    {\n      wcbuf[2] = work_mbc->range_sts[i];\n      wcbuf[4] = work_mbc->range_ends[i];\n\n      if (wcscoll(wcbuf, wcbuf+2) >= 0 &&\n          wcscoll(wcbuf+4, wcbuf) >= 0)\n        goto charset_matched;\n    }\n\n  /* match with a character?  */\n  for (i = 0; i<work_mbc->nchars; i++)\n    {\n      if (wc == work_mbc->chars[i])\n        goto charset_matched;\n    }\n\n  match = !match;\n\n charset_matched:\n  return match ? match_len : 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "delete (position p, position_set *s)\n{\n  int i;\n\n  for (i = 0; i < s->nelem; ++i)\n    if (p.index == s->elems[i].index)\n      break;\n  if (i < s->nelem)\n    for (--s->nelem; i < s->nelem; ++i)\n      s->elems[i] = s->elems[i + 1];\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "build_state (int s, struct dfa *d)\n{\n  int *trans;\t\t\t/* The new transition table. */\n  int i;\n\n  /* Set an upper limit on the number of transition tables that will ever\n     exist at once.  1024 is arbitrary.  The idea is that the frequently\n     used transition tables will be quickly rebuilt, whereas the ones that\n     were only needed once or twice will be cleared away. */\n  if (d->trcount >= 1024)\n    {\n      for (i = 0; i < d->tralloc; ++i)\n        {\n          free(d->trans[i]);\n          free(d->fails[i]);\n          d->trans[i] = d->fails[i] = NULL;\n        }\n      d->trcount = 0;\n    }\n\n  ++d->trcount;\n\n  /* Set up the success bits for this state. */\n  d->success[s] = 0;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].context, CTX_NEWLINE, s, *d))\n    d->success[s] |= CTX_NEWLINE;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].context, CTX_LETTER, s, *d))\n    d->success[s] |= CTX_LETTER;\n  if (ACCEPTS_IN_CONTEXT(d->states[s].context, CTX_NONE, s, *d))\n    d->success[s] |= CTX_NONE;\n\n  MALLOC(trans, NOTCHAR);\n  dfastate(s, d, trans);\n\n  /* Now go through the new transition table, and make sure that the trans\n     and fail arrays are allocated large enough to hold a pointer for the\n     largest state mentioned in the table. */\n  for (i = 0; i < NOTCHAR; ++i)\n    if (trans[i] >= d->tralloc)\n      {\n        int oldalloc = d->tralloc;\n\n        while (trans[i] >= d->tralloc)\n          d->tralloc *= 2;\n        REALLOC(d->realtrans, d->tralloc + 1);\n        d->trans = d->realtrans + 1;\n        REALLOC(d->fails, d->tralloc);\n        REALLOC(d->success, d->tralloc);\n        REALLOC(d->newlines, d->tralloc);\n        while (oldalloc < d->tralloc)\n          {\n            d->trans[oldalloc] = NULL;\n            d->fails[oldalloc++] = NULL;\n          }\n      }\n\n  /* Keep the newline transition in a special place so we can use it as\n     a sentinel. */\n  d->newlines[s] = trans[eolbyte];\n  trans[eolbyte] = -1;\n\n  if (ACCEPTING(s, *d))\n    d->fails[s] = trans;\n  else\n    d->trans[s] = trans;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "lex (void)\n{\n  unsigned int c, c2;\n  int backslash = 0;\n  charclass ccl;\n  int i;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (i = 0; i < 2; ++i)\n    {\n      if (MB_CUR_MAX > 1)\n        {\n          FETCH_WC (c, wctok, NULL);\n          if ((int)c == EOF)\n            goto normal_char;\n        }\n      else\n        FETCH(c, NULL);\n\n      switch (c)\n        {\n        case '\\\\':\n          if (backslash)\n            goto normal_char;\n          if (lexleft == 0)\n            dfaerror(_(\"unfinished \\\\ escape\"));\n          backslash = 1;\n          break;\n\n        case '^':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lasttok == END\n              || lasttok == LPAREN\n              || lasttok == OR)\n            return lasttok = BEGLINE;\n          goto normal_char;\n\n        case '$':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lexleft == 0\n              || (syntax_bits & RE_NO_BK_PARENS\n                  ? lexleft > 0 && *lexptr == ')'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == ')')\n              || (syntax_bits & RE_NO_BK_VBAR\n                  ? lexleft > 0 && *lexptr == '|'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == '|')\n              || ((syntax_bits & RE_NEWLINE_ALT)\n                  && lexleft > 0 && *lexptr == '\\n'))\n            return lasttok = ENDLINE;\n          goto normal_char;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (backslash && !(syntax_bits & RE_NO_BK_REFS))\n            {\n              laststart = 0;\n              return lasttok = BACKREF;\n            }\n          goto normal_char;\n\n        case '`':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGLINE;\t/* FIXME: should be beginning of string */\n          goto normal_char;\n\n        case '\\'':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDLINE;\t/* FIXME: should be end of string */\n          goto normal_char;\n\n        case '<':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGWORD;\n          goto normal_char;\n\n        case '>':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDWORD;\n          goto normal_char;\n\n        case 'b':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = LIMWORD;\n          goto normal_char;\n\n        case 'B':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = NOTLIMWORD;\n          goto normal_char;\n\n        case '?':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = QMARK;\n\n        case '*':\n          if (backslash)\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = STAR;\n\n        case '+':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = PLUS;\n\n        case '{':\n          if (!(syntax_bits & RE_INTERVALS))\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n\n          if (syntax_bits & RE_NO_BK_BRACES)\n            {\n              /* Scan ahead for a valid interval; if it's not valid,\n                 treat it as a literal '{'.  */\n              int lo = -1, hi = -1;\n              char const *p = lexptr;\n              char const *lim = p + lexleft;\n              for (;  p != lim && ISASCIIDIGIT (*p);  p++)\n                lo = (lo < 0 ? 0 : lo * 10) + *p - '0';\n              if (p != lim && *p == ',')\n                while (++p != lim && ISASCIIDIGIT (*p))\n                  hi = (hi < 0 ? 0 : hi * 10) + *p - '0';\n              else\n                hi = lo;\n              if (p == lim || *p != '}'\n                  || lo < 0 || RE_DUP_MAX < hi || (0 <= hi && hi < lo))\n                goto normal_char;\n            }\n\n          minrep = 0;\n          /* Cases:\n             {M} - exact count\n             {M,} - minimum count, maximum is infinity\n             {M,N} - M through N */\n          FETCH(c, _(\"unfinished repeat count\"));\n          if (ISASCIIDIGIT (c))\n            {\n              minrep = c - '0';\n              for (;;)\n                {\n                  FETCH(c, _(\"unfinished repeat count\"));\n                  if (! ISASCIIDIGIT (c))\n                    break;\n                  minrep = 10 * minrep + c - '0';\n                }\n            }\n          else\n            dfaerror(_(\"malformed repeat count\"));\n          if (c == ',')\n            {\n              FETCH (c, _(\"unfinished repeat count\"));\n              if (! ISASCIIDIGIT (c))\n                maxrep = -1;\n              else\n                {\n                  maxrep = c - '0';\n                  for (;;)\n                    {\n                      FETCH (c, _(\"unfinished repeat count\"));\n                      if (! ISASCIIDIGIT (c))\n                        break;\n                      maxrep = 10 * maxrep + c - '0';\n                    }\n                  if (0 <= maxrep && maxrep < minrep)\n                    dfaerror (_(\"malformed repeat count\"));\n                }\n            }\n          else\n            maxrep = minrep;\n          if (!(syntax_bits & RE_NO_BK_BRACES))\n            {\n              if (c != '\\\\')\n                dfaerror(_(\"malformed repeat count\"));\n              FETCH(c, _(\"unfinished repeat count\"));\n            }\n          if (c != '}')\n            dfaerror(_(\"malformed repeat count\"));\n          laststart = 0;\n          return lasttok = REPMN;\n\n        case '|':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          laststart = 1;\n          return lasttok = OR;\n\n        case '\\n':\n          if (syntax_bits & RE_LIMITED_OPS\n              || backslash\n              || !(syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          laststart = 1;\n          return lasttok = OR;\n\n        case '(':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          ++parens;\n          laststart = 1;\n          return lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          --parens;\n          laststart = 0;\n          return lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (MB_CUR_MAX > 1)\n            {\n              /* In multibyte environment period must match with a single\n                 character not a byte.  So we use ANYCHAR.  */\n              laststart = 0;\n              return lasttok = ANYCHAR;\n            }\n          zeroset(ccl);\n          notset(ccl);\n          if (!(syntax_bits & RE_DOT_NEWLINE))\n            clrbit(eolbyte, ccl);\n          if (syntax_bits & RE_DOT_NOT_NULL)\n            clrbit('\\0', ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case 's':\n        case 'S':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          zeroset(ccl);\n          for (c2 = 0; c2 < NOTCHAR; ++c2)\n            if (isspace(c2))\n              setbit(c2, ccl);\n          if (c == 'S')\n            notset(ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case 'w':\n        case 'W':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          zeroset(ccl);\n          for (c2 = 0; c2 < NOTCHAR; ++c2)\n            if (IS_WORD_CONSTITUENT(c2))\n              setbit(c2, ccl);\n          if (c == 'W')\n            notset(ccl);\n          laststart = 0;\n          return lasttok = CSET + charclass_index(ccl);\n\n        case '[':\n          if (backslash)\n            goto normal_char;\n          laststart = 0;\n          return lasttok = parse_bracket_exp();\n\n        default:\n        normal_char:\n          laststart = 0;\n          /* For multibyte character sets, folding is done in atom.  Always\n             return WCHAR.  */\n          if (MB_CUR_MAX > 1)\n            return lasttok = WCHAR;\n\n          if (case_fold && isalpha(c))\n            {\n              zeroset(ccl);\n              setbit_case_fold_c (c, ccl);\n              return lasttok = CSET + charclass_index(ccl);\n            }\n\n          return lasttok = c;\n        }\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character. */\n  abort();\n  return END;\t/* keeps pedantic compilers happy. */\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "copytoks (int tindex, int ntokens)\n{\n  int i;\n\n  for (i = 0; i < ntokens; ++i)\n    {\n      addtok(dfa->tokens[tindex + i]);\n      /* Update index into multibyte csets.  */\n      if (MB_CUR_MAX > 1 && dfa->tokens[tindex + i] == MBCSET)\n        dfa->multibyte_prop[dfa->tindex - 1] = dfa->multibyte_prop[tindex + i];\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "state_index (struct dfa *d, position_set const *s, int context)\n{\n  int hash = 0;\n  int constraint;\n  int i, j;\n\n  for (i = 0; i < s->nelem; ++i)\n    hash ^= s->elems[i].index + s->elems[i].constraint;\n\n  /* Try to find a state that exactly matches the proposed one. */\n  for (i = 0; i < d->sindex; ++i)\n    {\n      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem\n          || context != d->states[i].context)\n        continue;\n      for (j = 0; j < s->nelem; ++j)\n        if (s->elems[j].constraint\n            != d->states[i].elems.elems[j].constraint\n            || s->elems[j].index != d->states[i].elems.elems[j].index)\n          break;\n      if (j == s->nelem)\n        return i;\n    }\n\n  /* We'll have to create a new state. */\n  REALLOC_IF_NECESSARY(d->states, d->salloc, d->sindex + 1);\n  d->states[i].hash = hash;\n  alloc_position_set(&d->states[i].elems, s->nelem);\n  copy(s, &d->states[i].elems);\n  d->states[i].context = context;\n  d->states[i].backref = 0;\n  d->states[i].constraint = 0;\n  d->states[i].first_end = 0;\n  if (MBS_SUPPORT)\n    {\n      d->states[i].mbps.nelem = 0;\n      d->states[i].mbps.elems = NULL;\n    }\n  for (j = 0; j < s->nelem; ++j)\n    if (d->tokens[s->elems[j].index] < 0)\n      {\n        constraint = s->elems[j].constraint;\n        if (SUCCEEDS_IN_CONTEXT (constraint, context, CTX_ANY))\n          d->states[i].constraint |= constraint;\n        if (! d->states[i].first_end)\n          d->states[i].first_end = d->tokens[s->elems[j].index];\n      }\n    else if (d->tokens[s->elems[j].index] == BACKREF)\n      {\n        d->states[i].constraint = NO_CONSTRAINT;\n        d->states[i].backref = 1;\n      }\n\n  ++d->sindex;\n\n  return i;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "match_anychar (struct dfa *d, int s, position pos, int idx)\n{\n  int context;\n  wchar_t wc;\n  int mbclen;\n\n  wc = inputwcs[idx];\n  mbclen = (mblen_buf[idx] == 0)? 1 : mblen_buf[idx];\n\n  /* Check syntax bits.  */\n  if (wc == (wchar_t)eolbyte)\n    {\n      if (!(syntax_bits & RE_DOT_NEWLINE))\n        return 0;\n    }\n  else if (wc == (wchar_t)'\\0')\n    {\n      if (syntax_bits & RE_DOT_NOT_NULL)\n        return 0;\n    }\n\n  context = wchar_context(wc);\n  if (!SUCCEEDS_IN_CONTEXT(pos.constraint, d->states[s].context, context))\n    return 0;\n\n  return mbclen;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfaoptimize (struct dfa *d)\n{\n  unsigned int i;\n\n  if (!MBS_SUPPORT || !using_utf8())\n    return;\n\n  for (i = 0; i < d->tindex; ++i)\n    {\n      switch(d->tokens[i])\n        {\n        case ANYCHAR:\n          /* Lowered.  */\n          abort ();\n        case MBCSET:\n          /* Requires multi-byte algorithm.  */\n          return;\n        default:\n          break;\n        }\n    }\n\n  free_mbdata (d);\n  d->mb_cur_max = 1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "transit_state_singlebyte (struct dfa *d, int s, unsigned char const *p,\n                                  int *next_state)\n{\n  int *t;\n  int works = s;\n\n  status_transit_state rval = TRANSIT_STATE_IN_PROGRESS;\n\n  while (rval == TRANSIT_STATE_IN_PROGRESS)\n    {\n      if ((t = d->trans[works]) != NULL)\n        {\n          works = t[*p];\n          rval = TRANSIT_STATE_DONE;\n          if (works < 0)\n            works = 0;\n        }\n      else if (works < 0)\n        {\n          if (p == buf_end)\n            {\n              /* At the moment, it must not happen.  */\n              abort ();\n            }\n          works = 0;\n        }\n      else if (d->fails[works])\n        {\n          works = d->fails[works][*p];\n          rval = TRANSIT_STATE_DONE;\n        }\n      else\n        {\n          build_state(works, d);\n        }\n    }\n  *next_state = works;\n  return rval;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "addtok (token t)\n{\n  if (MB_CUR_MAX > 1 && t == MBCSET)\n    {\n      bool need_or = false;\n      struct mb_char_classes *work_mbc = &dfa->mbcsets[dfa->nmbcsets - 1];\n\n      /* Extract wide characters into alternations for better performance.\n         This does not require UTF-8.  */\n      if (!work_mbc->invert)\n        {\n          int i;\n          for (i = 0; i < work_mbc->nchars; i++)\n            {\n              addtok_wc (work_mbc->chars[i]);\n              if (need_or)\n                addtok (OR);\n              need_or = true;\n            }\n          work_mbc->nchars = 0;\n        }\n\n      /* UTF-8 allows treating a simple, non-inverted MBCSET like a CSET.  */\n      if (work_mbc->invert\n          || (!using_utf8() && work_mbc->cset != -1)\n          || work_mbc->nchars != 0\n          || work_mbc->nch_classes != 0\n          || work_mbc->nranges != 0\n          || work_mbc->nequivs != 0\n          || work_mbc->ncoll_elems != 0)\n        {\n          addtok_mb (MBCSET, ((dfa->nmbcsets - 1) << 2) + 3);\n          if (need_or)\n            addtok (OR);\n        }\n      else\n        {\n          /* Characters have been handled above, so it is possible\n             that the mbcset is empty now.  Do nothing in that case.  */\n          if (work_mbc->cset != -1)\n            {\n              assert (using_utf8 ());\n              addtok (CSET + work_mbc->cset);\n              if (need_or)\n                addtok (OR);\n            }\n        }\n    }\n  else\n    {\n      addtok_mb (t, 3);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "merge (position_set const *s1, position_set const *s2, position_set *m)\n{\n  int i = 0, j = 0;\n\n  REALLOC_IF_NECESSARY(m->elems, m->alloc, s1->nelem + s2->nelem);\n  m->nelem = 0;\n  while (i < s1->nelem && j < s2->nelem)\n    if (s1->elems[i].index > s2->elems[j].index)\n      m->elems[m->nelem++] = s1->elems[i++];\n    else if (s1->elems[i].index < s2->elems[j].index)\n      m->elems[m->nelem++] = s2->elems[j++];\n    else\n      {\n        m->elems[m->nelem] = s1->elems[i++];\n        m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;\n      }\n  while (i < s1->nelem)\n    m->elems[m->nelem++] = s1->elems[i++];\n  while (j < s2->nelem)\n    m->elems[m->nelem++] = s2->elems[j++];\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfastate (int s, struct dfa *d, int trans[])\n{\n  leaf_set *grps;\t\t/* As many as will ever be needed. */\n  charclass *labels;\t\t/* Labels corresponding to the groups. */\n  int ngrps = 0;\t\t/* Number of groups actually used. */\n  position pos;\t\t\t/* Current position being considered. */\n  charclass matches;\t\t/* Set of matching characters. */\n  int matchesf;\t\t\t/* True if matches is nonempty. */\n  charclass intersect;\t\t/* Intersection with some label set. */\n  int intersectf;\t\t/* True if intersect is nonempty. */\n  charclass leftovers;\t\t/* Stuff in the label that didn't match. */\n  int leftoversf;\t\t/* True if leftovers is nonempty. */\n  position_set follows;\t\t/* Union of the follows of some group. */\n  position_set tmp;\t\t/* Temporary space for merging sets. */\n  int possible_contexts;\t/* Contexts that this group can match. */\n  int separate_contexts;\t/* Context that new state wants to know. */\n  int state;\t\t\t/* New state. */\n  int state_newline;\t\t/* New state on a newline transition. */\n  int state_letter;\t\t/* New state on a letter transition. */\n  int next_isnt_1st_byte = 0;\t/* Flag if we can't add state0.  */\n  int i, j, k;\n\n  MALLOC (grps, NOTCHAR);\n  MALLOC (labels, NOTCHAR);\n\n  zeroset(matches);\n\n  for (i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      pos = d->states[s].elems.elems[i];\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n        setbit(d->tokens[pos.index], matches);\n      else if (d->tokens[pos.index] >= CSET)\n        copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);\n      else if (MBS_SUPPORT\n               && (d->tokens[pos.index] == ANYCHAR\n                   || d->tokens[pos.index] == MBCSET))\n        /* MB_CUR_MAX > 1  */\n        {\n          /* ANYCHAR and MBCSET must match with a single character, so we\n             must put it to d->states[s].mbps, which contains the positions\n             which can match with a single character not a byte.  */\n          if (d->states[s].mbps.nelem == 0)\n            alloc_position_set(&d->states[s].mbps, 1);\n          insert(pos, &(d->states[s].mbps));\n          continue;\n        }\n      else\n        continue;\n\n      /* Some characters may need to be eliminated from matches because\n         they fail in the current context. */\n      if (pos.constraint != NO_CONSTRAINT)\n        {\n          if (! SUCCEEDS_IN_CONTEXT(pos.constraint,\n                                    d->states[s].context, CTX_NEWLINE))\n            for (j = 0; j < CHARCLASS_INTS; ++j)\n              matches[j] &= ~newline[j];\n          if (! SUCCEEDS_IN_CONTEXT(pos.constraint,\n                                    d->states[s].context, CTX_LETTER))\n            for (j = 0; j < CHARCLASS_INTS; ++j)\n              matches[j] &= ~letters[j];\n          if (! SUCCEEDS_IN_CONTEXT(pos.constraint,\n                                    d->states[s].context, CTX_NONE))\n            for (j = 0; j < CHARCLASS_INTS; ++j)\n              matches[j] &= letters[j] | newline[j];\n\n          /* If there are no characters left, there's no point in going on. */\n          for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)\n            continue;\n          if (j == CHARCLASS_INTS)\n            continue;\n        }\n\n      for (j = 0; j < ngrps; ++j)\n        {\n          /* If matches contains a single character only, and the current\n             group's label doesn't contain that character, go on to the\n             next group. */\n          if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR\n              && !tstbit(d->tokens[pos.index], labels[j]))\n            continue;\n\n          /* Check if this group's label has a nonempty intersection with\n             matches. */\n          intersectf = 0;\n          for (k = 0; k < CHARCLASS_INTS; ++k)\n            (intersect[k] = matches[k] & labels[j][k]) ? (intersectf = 1) : 0;\n          if (! intersectf)\n            continue;\n\n          /* It does; now find the set differences both ways. */\n          leftoversf = matchesf = 0;\n          for (k = 0; k < CHARCLASS_INTS; ++k)\n            {\n              /* Even an optimizing compiler can't know this for sure. */\n              int match = matches[k], label = labels[j][k];\n\n              (leftovers[k] = ~match & label) ? (leftoversf = 1) : 0;\n              (matches[k] = match & ~label) ? (matchesf = 1) : 0;\n            }\n\n          /* If there were leftovers, create a new group labeled with them. */\n          if (leftoversf)\n            {\n              copyset(leftovers, labels[ngrps]);\n              copyset(intersect, labels[j]);\n              MALLOC(grps[ngrps].elems, d->nleaves);\n              memcpy(grps[ngrps].elems, grps[j].elems,\n                     sizeof (grps[j].elems[0]) * grps[j].nelem);\n              grps[ngrps].nelem = grps[j].nelem;\n              ++ngrps;\n            }\n\n          /* Put the position in the current group.  The constraint is\n             irrelevant here.  */\n          grps[j].elems[grps[j].nelem++] = pos.index;\n\n          /* If every character matching the current position has been\n             accounted for, we're done. */\n          if (! matchesf)\n            break;\n        }\n\n      /* If we've passed the last group, and there are still characters\n         unaccounted for, then we'll have to create a new group. */\n      if (j == ngrps)\n        {\n          copyset(matches, labels[ngrps]);\n          zeroset(matches);\n          MALLOC(grps[ngrps].elems, d->nleaves);\n          grps[ngrps].nelem = 1;\n          grps[ngrps].elems[0] = pos.index;\n          ++ngrps;\n        }\n    }\n\n  alloc_position_set(&follows, d->nleaves);\n  alloc_position_set(&tmp, d->nleaves);\n\n  /* If we are a searching matcher, the default transition is to a state\n     containing the positions of state 0, otherwise the default transition\n     is to fail miserably. */\n  if (d->searchflag)\n    {\n      /* Find the state(s) corresponding to the positions of state 0. */\n      copy(&d->states[0].elems, &follows);\n      separate_contexts = state_separate_contexts (&follows);\n      state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      if (separate_contexts & CTX_NEWLINE)\n        state_newline = state_index(d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & CTX_LETTER)\n        state_letter = state_index(d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      for (i = 0; i < NOTCHAR; ++i)\n        trans[i] = (IS_WORD_CONSTITUENT(i)) ? state_letter : state;\n      trans[eolbyte] = state_newline;\n    }\n  else\n    for (i = 0; i < NOTCHAR; ++i)\n      trans[i] = -1;\n\n  for (i = 0; i < ngrps; ++i)\n    {\n      follows.nelem = 0;\n\n      /* Find the union of the follows of the positions of the group.\n         This is a hideously inefficient loop.  Fix it someday. */\n      for (j = 0; j < grps[i].nelem; ++j)\n        for (k = 0; k < d->follows[grps[i].elems[j]].nelem; ++k)\n          insert(d->follows[grps[i].elems[j]].elems[k], &follows);\n\n      if (d->mb_cur_max > 1)\n        {\n          /* If a token in follows.elems is not 1st byte of a multibyte\n             character, or the states of follows must accept the bytes\n             which are not 1st byte of the multibyte character.\n             Then, if a state of follows encounter a byte, it must not be\n             a 1st byte of a multibyte character nor single byte character.\n             We cansel to add state[0].follows to next state, because\n             state[0] must accept 1st-byte\n\n             For example, we assume <sb a> is a certain single byte\n             character, <mb A> is a certain multibyte character, and the\n             codepoint of <sb a> equals the 2nd byte of the codepoint of\n             <mb A>.\n             When state[0] accepts <sb a>, state[i] transit to state[i+1]\n             by accepting accepts 1st byte of <mb A>, and state[i+1]\n             accepts 2nd byte of <mb A>, if state[i+1] encounter the\n             codepoint of <sb a>, it must not be <sb a> but 2nd byte of\n             <mb A>, so we cannot add state[0].  */\n\n          next_isnt_1st_byte = 0;\n          for (j = 0; j < follows.nelem; ++j)\n            {\n              if (!(d->multibyte_prop[follows.elems[j].index] & 1))\n                {\n                  next_isnt_1st_byte = 1;\n                  break;\n                }\n            }\n        }\n\n      /* If we are building a searching matcher, throw in the positions\n         of state 0 as well. */\n      if (d->searchflag\n          && (! MBS_SUPPORT\n              || (d->mb_cur_max == 1 || !next_isnt_1st_byte)))\n        for (j = 0; j < d->states[0].elems.nelem; ++j)\n          insert(d->states[0].elems.elems[j], &follows);\n\n      /* Find out if the new state will want any context information. */\n      possible_contexts = charclass_context(labels[i]);\n      separate_contexts = state_separate_contexts (&follows);\n\n      /* Find the state(s) corresponding to the union of the follows. */\n      if ((separate_contexts & possible_contexts) != possible_contexts)\n        state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      else\n        state = -1;\n      if (separate_contexts & possible_contexts & CTX_NEWLINE)\n        state_newline = state_index (d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & possible_contexts & CTX_LETTER)\n        state_letter = state_index(d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      /* Set the transitions for each character in the current label. */\n      for (j = 0; j < CHARCLASS_INTS; ++j)\n        for (k = 0; k < INTBITS; ++k)\n          if (labels[i][j] & 1 << k)\n            {\n              int c = j * INTBITS + k;\n\n              if (c == eolbyte)\n                trans[c] = state_newline;\n              else if (IS_WORD_CONSTITUENT(c))\n                trans[c] = state_letter;\n              else if (c < NOTCHAR)\n                trans[c] = state;\n            }\n    }\n\n  for (i = 0; i < ngrps; ++i)\n    free(grps[i].elems);\n  free(follows.elems);\n  free(tmp.elems);\n  free(grps);\n  free(labels);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "addlists (char **old, char **new)\n{\n  int i;\n\n  if (old == NULL || new == NULL)\n    return NULL;\n  for (i = 0; new[i] != NULL; ++i)\n    {\n      old = enlist(old, new[i], strlen(new[i]));\n      if (old == NULL)\n        break;\n    }\n  return old;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "nsubtoks (int tindex)\n{\n  int ntoks1;\n\n  switch (dfa->tokens[tindex - 1])\n    {\n    default:\n      return 1;\n    case QMARK:\n    case STAR:\n    case PLUS:\n      return 1 + nsubtoks(tindex - 1);\n    case CAT:\n    case OR:\n      ntoks1 = nsubtoks(tindex - 1);\n      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "state_separate_contexts (position_set const *s)\n{\n  int separate_contexts = 0;\n  unsigned int j;\n\n  for (j = 0; j < s->nelem; ++j)\n    {\n      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_NEWLINE;\n      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_LETTER;\n    }\n\n  return separate_contexts;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "parse_bracket_exp (void)\n{\n  int invert;\n  int c, c1, c2;\n  charclass ccl;\n\n  /* Used to warn about [:space:].\n     Bit 0 = first character is a colon.\n     Bit 1 = last character is a colon.\n     Bit 2 = includes any other character but a colon.\n     Bit 3 = includes ranges, char/equiv classes or collation elements.  */\n  int colon_warning_state;\n\n  wint_t wc;\n  wint_t wc2;\n  wint_t wc1 = 0;\n\n  /* Work area to build a mb_char_classes.  */\n  struct mb_char_classes *work_mbc;\n  int chars_al, range_sts_al, range_ends_al, ch_classes_al,\n    equivs_al, coll_elems_al;\n\n  chars_al = 0;\n  range_sts_al = range_ends_al = 0;\n  ch_classes_al = equivs_al = coll_elems_al = 0;\n  if (MB_CUR_MAX > 1)\n    {\n      REALLOC_IF_NECESSARY(dfa->mbcsets, dfa->mbcsets_alloc, dfa->nmbcsets + 1);\n\n      /* dfa->multibyte_prop[] hold the index of dfa->mbcsets.\n         We will update dfa->multibyte_prop[] in addtok(), because we can't\n         decide the index in dfa->tokens[].  */\n\n      /* Initialize work area.  */\n      work_mbc = &(dfa->mbcsets[dfa->nmbcsets++]);\n      memset (work_mbc, 0, sizeof *work_mbc);\n    }\n  else\n    work_mbc = NULL;\n\n  memset (ccl, 0, sizeof ccl);\n  FETCH_WC (c, wc, _(\"unbalanced [\"));\n  if (c == '^')\n    {\n      FETCH_WC (c, wc, _(\"unbalanced [\"));\n      invert = 1;\n    }\n  else\n    invert = 0;\n\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = EOF; /* mark c1 is not initialized\".  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called. */\n      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))\n        {\n#define BRACKET_BUFFER_SIZE 128\n          char str[BRACKET_BUFFER_SIZE];\n          FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n          /* If pattern contains `[[:', `[[.', or `[[='.  */\n          if (c1 == ':'\n              /* TODO: handle `[[.' and `[[=' also for MB_CUR_MAX == 1.  */\n              || (MB_CUR_MAX > 1 && (c1 == '.' || c1 == '='))\n              )\n            {\n              size_t len = 0;\n              for (;;)\n                {\n                  FETCH_WC (c, wc, _(\"unbalanced [\"));\n                  if ((c == c1 && *lexptr == ']') || lexleft == 0)\n                    break;\n                  if (len < BRACKET_BUFFER_SIZE)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              FETCH_WC (c, wc, _(\"unbalanced [\"));\n              if (c1 == ':')\n                /* build character class.  */\n                {\n                  char const *class\n                    = (case_fold && (STREQ  (str, \"upper\")\n                                     || STREQ  (str, \"lower\"))\n                                       ? \"alpha\"\n                                       : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror(_(\"invalid character class\"));\n\n                  if (MB_CUR_MAX > 1 && !pred->single_byte_only)\n                    {\n                      /* Store the character class as wctype_t.  */\n                      wctype_t wt = wctype (class);\n\n                      REALLOC_IF_NECESSARY(work_mbc->ch_classes,\n                                           ch_classes_al,\n                                           work_mbc->nch_classes + 1);\n                      work_mbc->ch_classes[work_mbc->nch_classes++] = wt;\n                    }\n\n                  for (c2 = 0; c2 < NOTCHAR; ++c2)\n                    if (pred->func(c2))\n                      setbit_case_fold_c (c2, ccl);\n                }\n\n              else if (MBS_SUPPORT && (c1 == '=' || c1 == '.'))\n                {\n                  char *elem;\n                  MALLOC(elem, len + 1);\n                  strncpy(elem, str, len + 1);\n\n                  if (c1 == '=')\n                    /* build equivalent class.  */\n                    {\n                      REALLOC_IF_NECESSARY(work_mbc->equivs,\n                                           equivs_al,\n                                           work_mbc->nequivs + 1);\n                      work_mbc->equivs[work_mbc->nequivs++] = elem;\n                    }\n\n                  if (c1 == '.')\n                    /* build collating element.  */\n                    {\n                      REALLOC_IF_NECESSARY(work_mbc->coll_elems,\n                                           coll_elems_al,\n                                           work_mbc->ncoll_elems + 1);\n                      work_mbc->coll_elems[work_mbc->ncoll_elems++] = elem;\n                    }\n                }\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n        }\n\n      if (c == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n        FETCH_WC(c, wc, _(\"unbalanced [\"));\n\n      if (c1 == EOF)\n        FETCH_WC(c1, wc1, _(\"unbalanced [\"));\n\n      if (c1 == '-')\n        /* build range characters.  */\n        {\n          FETCH_WC(c2, wc2, _(\"unbalanced [\"));\n          if (c2 == ']')\n            {\n              /* In the case [x-], the - is an ordinary hyphen,\n                 which is left in c1, the lookahead character. */\n              lexptr -= cur_mb_len;\n              lexleft += cur_mb_len;\n            }\n        }\n\n      if (c1 == '-' && c2 != ']')\n        {\n          if (c2 == '\\\\'\n              && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n            FETCH_WC(c2, wc2, _(\"unbalanced [\"));\n\n          if (MB_CUR_MAX > 1)\n            {\n              /* When case folding map a range, say [m-z] (or even [M-z])\n                 to the pair of ranges, [m-z] [M-Z].  */\n              REALLOC_IF_NECESSARY(work_mbc->range_sts,\n                                   range_sts_al, work_mbc->nranges + 1);\n              REALLOC_IF_NECESSARY(work_mbc->range_ends,\n                                   range_ends_al, work_mbc->nranges + 1);\n              work_mbc->range_sts[work_mbc->nranges] =\n                case_fold ? towlower(wc) : (wchar_t)wc;\n              work_mbc->range_ends[work_mbc->nranges++] =\n                case_fold ? towlower(wc2) : (wchar_t)wc2;\n\n#ifndef GREP\n              if (case_fold && (iswalpha(wc) || iswalpha(wc2)))\n                {\n                  REALLOC_IF_NECESSARY(work_mbc->range_sts,\n                                       range_sts_al, work_mbc->nranges + 1);\n                  work_mbc->range_sts[work_mbc->nranges] = towupper(wc);\n                  REALLOC_IF_NECESSARY(work_mbc->range_ends,\n                                       range_ends_al, work_mbc->nranges + 1);\n                  work_mbc->range_ends[work_mbc->nranges++] = towupper(wc2);\n                }\n#endif\n            }\n          else\n            {\n              c1 = c;\n              if (case_fold)\n                {\n                  c1 = tolower (c1);\n                  c2 = tolower (c2);\n                }\n              if (!hard_LC_COLLATE)\n                for (c = c1; c <= c2; c++)\n                  setbit_case_fold_c (c, ccl);\n              else\n                {\n                  /* Defer to the system regex library about the meaning\n                     of range expressions.  */\n                  regex_t re;\n                  char pattern[6] = { '[', c1, '-', c2, ']', 0 };\n                  char subject[2] = { 0, 0 };\n                  regcomp (&re, pattern, REG_NOSUB);\n                  for (c = 0; c < NOTCHAR; ++c)\n                    {\n                      subject[0] = c;\n                      if (!(case_fold && isupper (c))\n                          && regexec (&re, subject, 0, NULL, 0) != REG_NOMATCH)\n                        setbit_case_fold_c (c, ccl);\n                    }\n                  regfree (&re);\n                }\n            }\n\n          colon_warning_state |= 8;\n          FETCH_WC(c1, wc1, _(\"unbalanced [\"));\n          continue;\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (MB_CUR_MAX == 1)\n        {\n          setbit_case_fold_c (c, ccl);\n          continue;\n        }\n\n      if (case_fold && iswalpha(wc))\n        {\n          wc = towlower(wc);\n          if (!setbit_wc (wc, ccl))\n            {\n              REALLOC_IF_NECESSARY(work_mbc->chars, chars_al,\n                                   work_mbc->nchars + 1);\n              work_mbc->chars[work_mbc->nchars++] = wc;\n            }\n#ifdef GREP\n          continue;\n#else\n          wc = towupper(wc);\n#endif\n        }\n      if (!setbit_wc (wc, ccl))\n        {\n          REALLOC_IF_NECESSARY(work_mbc->chars, chars_al,\n                               work_mbc->nchars + 1);\n          work_mbc->chars[work_mbc->nchars++] = wc;\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (MB_CUR_MAX > 1)\n    {\n      static charclass zeroclass;\n      work_mbc->invert = invert;\n      work_mbc->cset = equal(ccl, zeroclass) ? -1 : charclass_index(ccl);\n      return MBCSET;\n    }\n\n  if (invert)\n    {\n      assert(MB_CUR_MAX == 1);\n      notset(ccl);\n      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n        clrbit(eolbyte, ccl);\n    }\n\n  return CSET + charclass_index(ccl);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "EGexecute (char const *buf, size_t size, size_t *match_size,\n           char const *start_ptr)\n{\n  char const *buflim, *beg, *end, *match, *best_match, *mb_start;\n  char eol = eolbyte;\n  int backref, start, len, best_len;\n  struct kwsmatch kwsm;\n  size_t i, ret_val;\n  if (MB_CUR_MAX > 1)\n    {\n      if (match_icase)\n        {\n          /* mbtolower adds a NUL byte at the end.  That will provide\n             space for the sentinel byte dfaexec may add.  */\n          char *case_buf = mbtolower (buf, &size);\n          if (start_ptr)\n            start_ptr = case_buf + (start_ptr - buf);\n          buf = case_buf;\n        }\n    }\n\n  mb_start = buf;\n  buflim = buf + size;\n\n  for (beg = end = buf; end < buflim; beg = end)\n    {\n      if (!start_ptr)\n        {\n          /* We don't care about an exact match.  */\n          if (kwset)\n            {\n              /* Find a possible match using the KWset matcher. */\n              size_t offset = kwsexec (kwset, beg, buflim - beg, &kwsm);\n              if (offset == (size_t) -1)\n                goto failure;\n              beg += offset;\n              /* Narrow down to the line containing the candidate, and\n                 run it through DFA. */\n              if ((end = memchr(beg, eol, buflim - beg)) != NULL)\n                end++;\n              else\n                end = buflim;\n              match = beg;\n              while (beg > buf && beg[-1] != eol)\n                --beg;\n              if (kwsm.index < kwset_exact_matches)\n                {\n                  if (!MBS_SUPPORT)\n                    goto success;\n\n                  if (mb_start < beg)\n                    mb_start = beg;\n                  if (MB_CUR_MAX == 1\n                      || !is_mb_middle (&mb_start, match, buflim,\n                                        kwsm.size[0]))\n                    goto success;\n                }\n              if (dfaexec (dfa, beg, (char *) end, 0, NULL, &backref) == NULL)\n                continue;\n            }\n          else\n            {\n              /* No good fixed strings; start with DFA. */\n              char const *next_beg = dfaexec (dfa, beg, (char *) buflim,\n                                              0, NULL, &backref);\n              if (next_beg == NULL)\n                break;\n              /* Narrow down to the line we've found. */\n              beg = next_beg;\n              if ((end = memchr(beg, eol, buflim - beg)) != NULL)\n                end++;\n              else\n                end = buflim;\n              while (beg > buf && beg[-1] != eol)\n                --beg;\n            }\n          /* Successful, no backreferences encountered! */\n          if (!backref)\n            goto success;\n        }\n      else\n        {\n          /* We are looking for the leftmost (then longest) exact match.\n             We will go through the outer loop only once.  */\n          beg = start_ptr;\n          end = buflim;\n        }\n\n      /* If we've made it to this point, this means DFA has seen\n         a probable match, and we need to run it through Regex. */\n      best_match = end;\n      best_len = 0;\n      for (i = 0; i < pcount; i++)\n        {\n          patterns[i].regexbuf.not_eol = 0;\n          if (0 <= (start = re_search (&(patterns[i].regexbuf),\n                                       buf, end - buf - 1,\n                                       beg - buf, end - beg - 1,\n                                       &(patterns[i].regs))))\n            {\n              len = patterns[i].regs.end[0] - start;\n              match = buf + start;\n              if (match > best_match)\n                continue;\n              if (start_ptr && !match_words)\n                goto assess_pattern_match;\n              if ((!match_lines && !match_words)\n                  || (match_lines && len == end - beg - 1))\n                {\n                  match = beg;\n                  len = end - beg;\n                  goto assess_pattern_match;\n                }\n              /* If -w, check if the match aligns with word boundaries.\n                 We do this iteratively because:\n                 (a) the line may contain more than one occurence of the\n                 pattern, and\n                 (b) Several alternatives in the pattern might be valid at a\n                 given point, and we may need to consider a shorter one to\n                 find a word boundary.  */\n              if (match_words)\n                while (match <= best_match)\n                  {\n                    if ((match == buf || !WCHAR ((unsigned char) match[-1]))\n                        && (start + len == end - buf - 1\n                            || !WCHAR ((unsigned char) match[len])))\n                      goto assess_pattern_match;\n                    if (len > 0)\n                      {\n                        /* Try a shorter length anchored at the same place. */\n                        --len;\n                        patterns[i].regexbuf.not_eol = 1;\n                        len = re_match (&(patterns[i].regexbuf),\n                                        buf, match + len - beg, match - buf,\n                                        &(patterns[i].regs));\n                      }\n                    if (len <= 0)\n                      {\n                        /* Try looking further on. */\n                        if (match == end - 1)\n                          break;\n                        match++;\n                        patterns[i].regexbuf.not_eol = 0;\n                        start = re_search (&(patterns[i].regexbuf),\n                                           buf, end - buf - 1,\n                                           match - buf, end - match - 1,\n                                           &(patterns[i].regs));\n                        if (start < 0)\n                          break;\n                        len = patterns[i].regs.end[0] - start;\n                        match = buf + start;\n                      }\n                  } /* while (match <= best_match) */\n              continue;\n            assess_pattern_match:\n              if (!start_ptr)\n                {\n                  /* Good enough for a non-exact match.\n                     No need to look at further patterns, if any.  */\n                  goto success;\n                }\n              if (match < best_match || (match == best_match && len > best_len))\n                {\n                  /* Best exact match:  leftmost, then longest.  */\n                  best_match = match;\n                  best_len = len;\n                }\n            } /* if re_search >= 0 */\n        } /* for Regex patterns.  */\n        if (best_match < end)\n          {\n            /* We have found an exact match.  We were just\n               waiting for the best one (leftmost then longest).  */\n            beg = best_match;\n            len = best_len;\n            goto success_in_len;\n          }\n    } /* for (beg = end ..) */\n\n failure:\n  ret_val = -1;\n  goto out;\n\n success:\n  len = end - beg;\n success_in_len:\n  *match_size = len;\n  ret_val = beg - buf;\n out:\n  return ret_val;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "free_mbdata (struct dfa *d)\n{\n  unsigned int i;\n\n  free(d->multibyte_prop);\n  d->multibyte_prop = NULL;\n\n  for (i = 0; i < d->nmbcsets; ++i)\n    {\n      unsigned int j;\n      struct mb_char_classes *p = &(d->mbcsets[i]);\n      free(p->chars);\n      free(p->ch_classes);\n      free(p->range_sts);\n      free(p->range_ends);\n\n      for (j = 0; j < p->nequivs; ++j)\n        free(p->equivs[j]);\n      free(p->equivs);\n\n      for (j = 0; j < p->ncoll_elems; ++j)\n        free(p->coll_elems[j]);\n      free(p->coll_elems);\n    }\n\n  free(d->mbcsets);\n  d->mbcsets = NULL;\n  d->nmbcsets = 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfaexec (struct dfa *d, char const *begin, char *end,\n         int allow_nl, int *count, int *backref)\n{\n  int s, s1;\t\t/* Current state. */\n  unsigned char const *p; /* Current input character. */\n  int **trans, *t;\t/* Copy of d->trans so it can be optimized\n                                   into a register. */\n  unsigned char eol = eolbyte;\t/* Likewise for eolbyte.  */\n  unsigned char saved_end;\n\n  if (! d->tralloc)\n    build_state_zero(d);\n\n  s = s1 = 0;\n  p = (unsigned char const *) begin;\n  trans = d->trans;\n  saved_end = *(unsigned char *) end;\n  *end = eol;\n\n  if (d->mb_cur_max > 1)\n    {\n      MALLOC(mblen_buf, end - begin + 2);\n      MALLOC(inputwcs, end - begin + 2);\n      memset(&mbs, 0, sizeof(mbstate_t));\n      prepare_wc_buf ((const char *) p, end);\n    }\n\n  for (;;)\n    {\n      if (d->mb_cur_max > 1)\n        while ((t = trans[s]) != NULL)\n          {\n            if (p > buf_end)\n              break;\n            s1 = s;\n            SKIP_REMAINS_MB_IF_INITIAL_STATE(s, p);\n\n            if (d->states[s].mbps.nelem == 0)\n              {\n                s = t[*p++];\n                continue;\n              }\n\n            /* Falling back to the glibc matcher in this case gives\n               better performance (up to 25% better on [a-z], for\n               example) and enables support for collating symbols and\n               equivalence classes.  */\n            if (backref)\n              {\n                *backref = 1;\n                free(mblen_buf);\n                free(inputwcs);\n                *end = saved_end;\n                return (char *) p;\n              }\n\n            /* Can match with a multibyte character (and multi character\n               collating element).  Transition table might be updated.  */\n            s = transit_state(d, s, &p);\n            trans = d->trans;\n          }\n      else\n        {\n          while ((t = trans[s]) != NULL)\n            {\n              s1 = t[*p++];\n              if ((t = trans[s1]) == NULL)\n                {\n                  int tmp = s; s = s1; s1 = tmp; /* swap */\n                  break;\n                }\n              s = t[*p++];\n            }\n        }\n\n      if (s >= 0 && (char *) p <= end && d->fails[s])\n        {\n          if (d->success[s] & sbit[*p])\n            {\n              if (backref)\n                *backref = (d->states[s].backref != 0);\n              if (d->mb_cur_max > 1)\n                {\n                  free(mblen_buf);\n                  free(inputwcs);\n                }\n              *end = saved_end;\n              return (char *) p;\n            }\n\n          s1 = s;\n          if (d->mb_cur_max > 1)\n            {\n              /* Can match with a multibyte character (and multicharacter\n                 collating element).  Transition table might be updated.  */\n              s = transit_state(d, s, &p);\n              trans = d->trans;\n            }\n          else\n            s = d->fails[s][*p++];\n          continue;\n        }\n\n      /* If the previous character was a newline, count it. */\n      if ((char *) p <= end && p[-1] == eol)\n        {\n          if (count)\n            ++*count;\n\n          if (d->mb_cur_max > 1)\n            prepare_wc_buf ((const char *) p, end);\n        }\n\n      /* Check if we've run off the end of the buffer. */\n      if ((char *) p > end)\n        {\n          if (d->mb_cur_max > 1)\n            {\n              free(mblen_buf);\n              free(inputwcs);\n            }\n          *end = saved_end;\n          return NULL;\n        }\n\n      if (s >= 0)\n        {\n          build_state(s, d);\n          trans = d->trans;\n          continue;\n        }\n\n      if (p[-1] == eol && allow_nl)\n        {\n          s = d->newlines[s1];\n          continue;\n        }\n\n      s = 0;\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "dfamust (struct dfa *d)\n{\n  must *musts;\n  must *mp;\n  char *result;\n  int ri;\n  int i;\n  int exact;\n  token t;\n  static must must0;\n  struct dfamust *dm;\n  static char empty_string[] = \"\";\n\n  result = empty_string;\n  exact = 0;\n  MALLOC (musts, d->tindex + 1);\n  mp = musts;\n  for (i = 0; i <= d->tindex; ++i)\n    mp[i] = must0;\n  for (i = 0; i <= d->tindex; ++i)\n    {\n      mp[i].in = xmalloc(sizeof *mp[i].in);\n      mp[i].left = xmalloc(2);\n      mp[i].right = xmalloc(2);\n      mp[i].is = xmalloc(2);\n      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\\0';\n      mp[i].in[0] = NULL;\n    }\n#ifdef DEBUG\n  fprintf(stderr, \"dfamust:\\n\");\n  for (i = 0; i < d->tindex; ++i)\n    {\n      fprintf(stderr, \" %d:\", i);\n      prtok(d->tokens[i]);\n    }\n  putc('\\n', stderr);\n#endif\n  for (ri = 0; ri < d->tindex; ++ri)\n    {\n      switch (t = d->tokens[ri])\n        {\n        case LPAREN:\n        case RPAREN:\n          assert (!\"neither LPAREN nor RPAREN may appear here\");\n        case EMPTY:\n        case BEGLINE:\n        case ENDLINE:\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n        case BACKREF:\n          resetmust(mp);\n          break;\n        case STAR:\n        case QMARK:\n          assert (musts < mp);\n          --mp;\n          resetmust(mp);\n          break;\n        case OR:\n          assert (&musts[2] <= mp);\n          {\n            char **new;\n            must *lmp;\n            must *rmp;\n            int j, ln, rn, n;\n\n            rmp = --mp;\n            lmp = --mp;\n            /* Guaranteed to be.  Unlikely, but. . . */\n            if (!STREQ (lmp->is, rmp->is))\n              lmp->is[0] = '\\0';\n            /* Left side--easy */\n            i = 0;\n            while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n              ++i;\n            lmp->left[i] = '\\0';\n            /* Right side */\n            ln = strlen(lmp->right);\n            rn = strlen(rmp->right);\n            n = ln;\n            if (n > rn)\n              n = rn;\n            for (i = 0; i < n; ++i)\n              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n                break;\n            for (j = 0; j < i; ++j)\n              lmp->right[j] = lmp->right[(ln - i) + j];\n            lmp->right[j] = '\\0';\n            new = inboth(lmp->in, rmp->in);\n            if (new == NULL)\n              goto done;\n            freelist(lmp->in);\n            free(lmp->in);\n            lmp->in = new;\n          }\n          break;\n        case PLUS:\n          assert (musts < mp);\n          --mp;\n          mp->is[0] = '\\0';\n          break;\n        case END:\n          assert (mp == &musts[1]);\n          for (i = 0; musts[0].in[i] != NULL; ++i)\n            if (strlen(musts[0].in[i]) > strlen(result))\n              result = musts[0].in[i];\n          if (STREQ (result, musts[0].is))\n            exact = 1;\n          goto done;\n        case CAT:\n          assert (&musts[2] <= mp);\n          {\n            must *lmp;\n            must *rmp;\n\n            rmp = --mp;\n            lmp = --mp;\n            /* In.  Everything in left, plus everything in\n               right, plus catenation of\n               left's right and right's left. */\n            lmp->in = addlists(lmp->in, rmp->in);\n            if (lmp->in == NULL)\n              goto done;\n            if (lmp->right[0] != '\\0' &&\n                rmp->left[0] != '\\0')\n              {\n                char *tp;\n\n                tp = icpyalloc(lmp->right);\n                tp = icatalloc(tp, rmp->left);\n                lmp->in = enlist(lmp->in, tp, strlen(tp));\n                free(tp);\n                if (lmp->in == NULL)\n                  goto done;\n              }\n            /* Left-hand */\n            if (lmp->is[0] != '\\0')\n              {\n                lmp->left = icatalloc(lmp->left,\n                                      rmp->left);\n                if (lmp->left == NULL)\n                  goto done;\n              }\n            /* Right-hand */\n            if (rmp->is[0] == '\\0')\n              lmp->right[0] = '\\0';\n            lmp->right = icatalloc(lmp->right, rmp->right);\n            if (lmp->right == NULL)\n              goto done;\n            /* Guaranteed to be */\n            if (lmp->is[0] != '\\0' && rmp->is[0] != '\\0')\n              {\n                lmp->is = icatalloc(lmp->is, rmp->is);\n                if (lmp->is == NULL)\n                  goto done;\n              }\n            else\n              lmp->is[0] = '\\0';\n          }\n          break;\n        default:\n          if (t < END)\n            {\n              assert (!\"oops! t >= END\");\n            }\n          else if (t == '\\0')\n            {\n              /* not on *my* shift */\n              goto done;\n            }\n          else if (t >= CSET\n                   || !MBS_SUPPORT\n                   || t == ANYCHAR\n                   || t == MBCSET\n                   )\n            {\n              /* easy enough */\n              resetmust(mp);\n            }\n          else\n            {\n              /* plain character */\n              resetmust(mp);\n              mp->is[0] = mp->left[0] = mp->right[0] = t;\n              mp->is[1] = mp->left[1] = mp->right[1] = '\\0';\n              mp->in = enlist(mp->in, mp->is, (size_t)1);\n              if (mp->in == NULL)\n                goto done;\n            }\n          break;\n        }\n#ifdef DEBUG\n      fprintf(stderr, \" node: %d:\", ri);\n      prtok(d->tokens[ri]);\n      fprintf(stderr, \"\\n  in:\");\n      for (i = 0; mp->in[i]; ++i)\n        fprintf(stderr, \" \\\"%s\\\"\", mp->in[i]);\n      fprintf(stderr, \"\\n  is: \\\"%s\\\"\\n\", mp->is);\n      fprintf(stderr, \"  left: \\\"%s\\\"\\n\", mp->left);\n      fprintf(stderr, \"  right: \\\"%s\\\"\\n\", mp->right);\n#endif\n      ++mp;\n    }\n done:\n  if (strlen(result))\n    {\n      MALLOC(dm, 1);\n      dm->exact = exact;\n      MALLOC(dm->must, strlen(result) + 1);\n      strcpy(dm->must, result);\n      dm->next = d->musts;\n      d->musts = dm;\n    }\n  mp = musts;\n  for (i = 0; i <= d->tindex; ++i)\n    {\n      freelist(mp[i].in);\n      free(mp[i].in);\n      free(mp[i].left);\n      free(mp[i].right);\n      free(mp[i].is);\n    }\n  free(mp);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "closure (void)\n{\n  int tindex, ntokens, i;\n\n  atom();\n  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)\n    if (tok == REPMN && (minrep || maxrep))\n      {\n        ntokens = nsubtoks(dfa->tindex);\n        tindex = dfa->tindex - ntokens;\n        if (maxrep < 0)\n          addtok(PLUS);\n        if (minrep == 0)\n          addtok(QMARK);\n        for (i = 1; i < minrep; ++i)\n          {\n            copytoks(tindex, ntokens);\n            addtok(CAT);\n          }\n        for (; i < maxrep; ++i)\n          {\n            copytoks(tindex, ntokens);\n            addtok(QMARK);\n            addtok(CAT);\n          }\n        tok = lex();\n      }\n    else if (tok == REPMN)\n      {\n        dfa->tindex -= nsubtoks(dfa->tindex);\n        tok = lex();\n        closure();\n      }\n    else\n      {\n        addtok(tok);\n        tok = lex();\n      }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src/kwset.h (struct kwsmatch.index): Now size_t, not int."}
{"func": "grepbuf (char const *beg, char const *lim)\n{\n  int nlines, n;\n  char const *p;\n  size_t match_offset;\n  size_t match_size;\n\n  nlines = 0;\n  p = beg;\n  while ((match_offset = do_execute (p, lim - p, &match_size,\n                                     NULL)) != (size_t) -1)\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n          outleft--;\n          if (!outleft || done_on_match)\n            {\n              if (exit_on_match)\n                exit (EXIT_SUCCESS);\n              after_last_match = bufoffset - (buflim - endp);\n              return nlines;\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "grepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n\n  filename = (file ? file : label ? label : _(\"(standard input)\"));\n\n  if (! file)\n    desc = STDIN_FILENO;\n  else if (devices == SKIP_DEVICES)\n    {\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n\n      status = !count;\n      if (list_files == 1 - 2 * status)\n        {\n          print_filename ();\n          fputc ('\\n' & filename_mask, stdout);\n        }\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n\n  return status;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "prepend_default_options (char const *options, int *pargc, char ***pargv)\n{\n  if (options && *options)\n    {\n      char *buf = xmalloc (strlen (options) + 1);\n      int prepended = prepend_args (options, buf, (char **) NULL);\n      int argc = *pargc;\n      char *const *argv = *pargv;\n      char **pp = xmalloc ((prepended + argc + 1) * sizeof *pp);\n      *pargc = prepended + argc;\n      *pargv = pp;\n      *pp++ = *argv++;\n      pp += prepend_args (options, buf, pp);\n      while ((*pp++ = *argv++))\n        continue;\n      return prepended;\n    }\n\n  return 0;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "prepend_args (char const *options, char *buf, char **argv)\n{\n  char const *o = options;\n  char *b = buf;\n  int n = 0;\n\n  for (;;)\n    {\n      while (c_isspace ((unsigned char) *o))\n        o++;\n      if (!*o)\n        return n;\n      if (argv)\n        argv[n] = b;\n      n++;\n\n      do\n        if ((*b++ = *o++) == '\\\\' && *o)\n          b[-1] = *o++;\n      while (*o && ! c_isspace ((unsigned char) *o));\n\n      *b++ = '\\0';\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "main (int argc, char **argv)\n{\n  char *keys;\n  size_t keycc, oldcc, keyalloc;\n  int with_filenames;\n  int opt, cc, status, prepended;\n  int prev_optind, last_recursive;\n  int default_context;\n  FILE *fp;\n\n  exit_failure = EXIT_TROUBLE;\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  program_name = argv[0];\n\n  keys = NULL;\n  keycc = 0;\n  with_filenames = 0;\n  eolbyte = '\\n';\n  filename_mask = ~0;\n\n  max_count = TYPE_MAXIMUM (off_t);\n\n  /* The value -1 means to use DEFAULT_CONTEXT. */\n  out_after = out_before = -1;\n  /* Default before/after context: chaged by -C/-NUM options */\n  default_context = 0;\n  /* Changed by -o option */\n  only_matching = 0;\n\n  /* Internationalization. */\n#if defined HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n#if defined ENABLE_NLS\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  exit_failure = EXIT_TROUBLE;\n  atexit (clean_up_stdout);\n\n  last_recursive = 0;\n  prepended = prepend_default_options (getenv (\"GREP_OPTIONS\"), &argc, &argv);\n  setmatcher (NULL);\n\n  while (prev_optind = optind,\n         (opt = get_nondigit_option (argc, argv, &default_context)) != -1)\n    switch (opt)\n      {\n      case 'A':\n        context_length_arg (optarg, &out_after);\n        break;\n\n      case 'B':\n        context_length_arg (optarg, &out_before);\n        break;\n\n      case 'C':\n        /* Set output match context, but let any explicit leading or\n           trailing amount specified with -A or -B stand. */\n        context_length_arg (optarg, &default_context);\n        break;\n\n      case 'D':\n        if (STREQ (optarg, \"read\"))\n          devices = READ_DEVICES;\n        else if (STREQ (optarg, \"skip\"))\n          devices = SKIP_DEVICES;\n        else\n          error (EXIT_TROUBLE, 0, _(\"unknown devices method\"));\n        break;\n\n      case 'E':\n        setmatcher (\"egrep\");\n        break;\n\n      case 'F':\n        setmatcher (\"fgrep\");\n        break;\n\n      case 'P':\n        setmatcher (\"perl\");\n        break;\n\n      case 'G':\n        setmatcher (\"grep\");\n        break;\n\n      case 'X': /* undocumented on purpose */\n        setmatcher (optarg);\n        break;\n\n      case 'H':\n        with_filenames = 1;\n        no_filenames = 0;\n        break;\n\n      case 'I':\n        binary_files = WITHOUT_MATCH_BINARY_FILES;\n        break;\n\n      case 'T':\n        align_tabs = 1;\n        break;\n\n      case 'U':\n#if defined HAVE_DOS_FILE_CONTENTS\n        dos_use_file_type = DOS_BINARY;\n#endif\n        break;\n\n      case 'u':\n#if defined HAVE_DOS_FILE_CONTENTS\n        dos_report_unix_offset = 1;\n#endif\n        break;\n\n      case 'V':\n        show_version = 1;\n        break;\n\n      case 'a':\n        binary_files = TEXT_BINARY_FILES;\n        break;\n\n      case 'b':\n        out_byte = 1;\n        break;\n\n      case 'c':\n        count_matches = 1;\n        break;\n\n      case 'd':\n        directories = XARGMATCH (\"--directories\", optarg,\n                                 directories_args, directories_types);\n        if (directories == RECURSE_DIRECTORIES)\n          last_recursive = prev_optind;\n        break;\n\n      case 'e':\n        cc = strlen (optarg);\n        keys = xrealloc (keys, keycc + cc + 1);\n        strcpy (&keys[keycc], optarg);\n        keycc += cc;\n        keys[keycc++] = '\\n';\n        break;\n\n      case 'f':\n        fp = STREQ (optarg, \"-\") ? stdin : fopen (optarg, \"r\");\n        if (!fp)\n          error (EXIT_TROUBLE, errno, \"%s\", optarg);\n        for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2)\n          ;\n        keys = xrealloc (keys, keyalloc);\n        oldcc = keycc;\n        while (!feof (fp)\n               && (cc = fread (keys + keycc, 1, keyalloc - 1 - keycc, fp)) > 0)\n          {\n            keycc += cc;\n            if (keycc == keyalloc - 1)\n              keys = x2nrealloc (keys, &keyalloc, sizeof *keys);\n          }\n        if (fp != stdin)\n          fclose (fp);\n        /* Append final newline if file ended in non-newline. */\n        if (oldcc != keycc && keys[keycc - 1] != '\\n')\n          keys[keycc++] = '\\n';\n        break;\n\n      case 'h':\n        with_filenames = 0;\n        no_filenames = 1;\n        break;\n\n      case 'i':\n      case 'y':\t\t\t/* For old-timers . . . */\n        match_icase = 1;\n        break;\n\n      case 'L':\n        /* Like -l, except list files that don't contain matches.\n           Inspired by the same option in Hume's gre. */\n        list_files = -1;\n        break;\n\n      case 'l':\n        list_files = 1;\n        break;\n\n      case 'm':\n        {\n          uintmax_t value;\n          switch (xstrtoumax (optarg, 0, 10, &value, \"\"))\n            {\n            case LONGINT_OK:\n              max_count = value;\n              if (0 <= max_count && max_count == value)\n                break;\n              /* Fall through.  */\n            case LONGINT_OVERFLOW:\n              max_count = TYPE_MAXIMUM (off_t);\n              break;\n\n            default:\n              error (EXIT_TROUBLE, 0, _(\"invalid max count\"));\n            }\n        }\n        break;\n\n      case 'n':\n        out_line = 1;\n        break;\n\n      case 'o':\n        only_matching = 1;\n        break;\n\n      case 'q':\n        exit_on_match = 1;\n        exit_failure = 0;\n        break;\n\n      case 'R':\n      case 'r':\n        directories = RECURSE_DIRECTORIES;\n        last_recursive = prev_optind;\n        break;\n\n      case 's':\n        suppress_errors = 1;\n        break;\n\n      case 'v':\n        out_invert = 1;\n        break;\n\n      case 'w':\n        match_words = 1;\n        break;\n\n      case 'x':\n        match_lines = 1;\n        break;\n\n      case 'Z':\n        filename_mask = 0;\n        break;\n\n      case 'z':\n        eolbyte = '\\0';\n        break;\n\n      case BINARY_FILES_OPTION:\n        if (STREQ (optarg, \"binary\"))\n          binary_files = BINARY_BINARY_FILES;\n        else if (STREQ (optarg, \"text\"))\n          binary_files = TEXT_BINARY_FILES;\n        else if (STREQ (optarg, \"without-match\"))\n          binary_files = WITHOUT_MATCH_BINARY_FILES;\n        else\n          error (EXIT_TROUBLE, 0, _(\"unknown binary-files type\"));\n        break;\n\n      case COLOR_OPTION:\n        if (optarg)\n          {\n            if (!strcasecmp (optarg, \"always\") || !strcasecmp (optarg, \"yes\")\n                || !strcasecmp (optarg, \"force\"))\n              color_option = 1;\n            else if (!strcasecmp (optarg, \"never\") || !strcasecmp (optarg, \"no\")\n                     || !strcasecmp (optarg, \"none\"))\n              color_option = 0;\n            else if (!strcasecmp (optarg, \"auto\") || !strcasecmp (optarg, \"tty\")\n                     || !strcasecmp (optarg, \"if-tty\"))\n              color_option = 2;\n            else\n              show_help = 1;\n          }\n        else\n          color_option = 2;\n        break;\n\n      case EXCLUDE_OPTION:\n        if (!excluded_patterns)\n          excluded_patterns = new_exclude ();\n        add_exclude (excluded_patterns, optarg, EXCLUDE_WILDCARDS);\n        break;\n      case EXCLUDE_FROM_OPTION:\n        if (!excluded_patterns)\n          excluded_patterns = new_exclude ();\n        if (add_exclude_file (add_exclude, excluded_patterns, optarg,\n                              EXCLUDE_WILDCARDS, '\\n') != 0)\n          {\n            error (EXIT_TROUBLE, errno, \"%s\", optarg);\n          }\n        break;\n\n      case EXCLUDE_DIRECTORY_OPTION:\n        if (!excluded_directory_patterns)\n          excluded_directory_patterns = new_exclude ();\n        add_exclude (excluded_directory_patterns, optarg, EXCLUDE_WILDCARDS);\n        break;\n\n      case INCLUDE_OPTION:\n        if (!included_patterns)\n          included_patterns = new_exclude ();\n        add_exclude (included_patterns, optarg,\n                     EXCLUDE_WILDCARDS | EXCLUDE_INCLUDE);\n        break;\n\n      case GROUP_SEPARATOR_OPTION:\n        group_separator = optarg;\n        break;\n\n      case LINE_BUFFERED_OPTION:\n        line_buffered = 1;\n        break;\n\n      case LABEL_OPTION:\n        label = optarg;\n        break;\n\n      case MMAP_OPTION:\n        error (0, 0, _(\"the --mmap option has been a no-op since 2010\"));\n        break;\n\n      case 0:\n        /* long options */\n        break;\n\n      default:\n        usage (EXIT_TROUBLE);\n        break;\n\n      }\n\n  if (color_option == 2)\n    color_option = isatty (STDOUT_FILENO) && should_colorize ();\n  init_colorize ();\n\n  /* POSIX.2 says that -q overrides -l, which in turn overrides the\n     other output options.  */\n  if (exit_on_match)\n    list_files = 0;\n  if (exit_on_match | list_files)\n    {\n      count_matches = 0;\n      done_on_match = 1;\n    }\n  out_quiet = count_matches | done_on_match;\n\n  if (out_after < 0)\n    out_after = default_context;\n  if (out_before < 0)\n    out_before = default_context;\n\n  if (color_option)\n    {\n      /* Legacy.  */\n      char *userval = getenv (\"GREP_COLOR\");\n      if (userval != NULL && *userval != '\\0')\n        selected_match_color = context_match_color = userval;\n\n      /* New GREP_COLORS has priority.  */\n      parse_grep_colors ();\n    }\n\n  if (show_version)\n    {\n      version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS,\n                   (char *) NULL);\n      exit (EXIT_SUCCESS);\n    }\n\n  if (show_help)\n    usage (EXIT_SUCCESS);\n\n  struct stat tmp_stat;\n  if (fstat (STDOUT_FILENO, &tmp_stat) == 0 && S_ISREG (tmp_stat.st_mode))\n    out_stat = tmp_stat;\n\n  if (keys)\n    {\n      if (keycc == 0)\n        {\n          /* No keys were specified (e.g. -f /dev/null).  Match nothing.  */\n          out_invert ^= 1;\n          match_lines = match_words = 0;\n        }\n      else\n        /* Strip trailing newline. */\n        --keycc;\n    }\n  else if (optind < argc)\n    {\n      /* A copy must be made in case of an xrealloc() or free() later.  */\n      keycc = strlen (argv[optind]);\n      keys = xmalloc (keycc + 1);\n      strcpy (keys, argv[optind++]);\n    }\n  else\n    usage (EXIT_TROUBLE);\n\n  compile (keys, keycc);\n  free (keys);\n\n  if ((argc - optind > 1 && !no_filenames) || with_filenames)\n    out_file = 1;\n\n#ifdef SET_BINARY\n  /* Output is set to binary mode because we shouldn't convert\n     NL to CR-LF pairs, especially when grepping binary files.  */\n  if (!isatty (1))\n    SET_BINARY (1);\n#endif\n\n  if (max_count == 0)\n    exit (EXIT_FAILURE);\n\n  if (optind < argc)\n    {\n      status = 1;\n      do\n        {\n          char *file = argv[optind];\n          if (!STREQ (file, \"-\")\n              && (included_patterns || excluded_patterns\n                  || excluded_directory_patterns))\n            {\n              if (isdir (file))\n                {\n                  if (excluded_directory_patterns\n                      && excluded_file_name (excluded_directory_patterns,\n                                             file))\n                    continue;\n                }\n              else\n                {\n                  if (included_patterns\n                      && excluded_file_name (included_patterns, file))\n                    continue;\n                  if (excluded_patterns\n                      && excluded_file_name (excluded_patterns, file))\n                    continue;\n                }\n            }\n          status &= grepfile (STREQ (file, \"-\") ? (char *) NULL : file,\n                              &stats_base);\n        }\n      while (++optind < argc);\n    }\n  else if (directories == RECURSE_DIRECTORIES && prepended < last_recursive)\n    {\n      status = 1;\n      if (stat (\".\", &stats_base.stat) == 0)\n        status = grepdir (NULL, &stats_base);\n      else\n        suppressible_error (\".\", errno);\n    }\n  else\n    status = grepfile ((char *) NULL, &stats_base);\n\n  /* We register via atexit() to test stdout.  */\n  exit (errseen ? EXIT_TROUBLE : status);\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "prtext (char const *beg, char const *lim, int *nlinesp)\n{\n  static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n  char const *bp, *p;\n  char eol = eolbyte;\n  int i, n;\n\n  if (!out_quiet && pending > 0)\n    prpending (beg);\n\n  p = beg;\n\n  if (!out_quiet)\n    {\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "grep (int fd, char const *file, struct stats *stats)\n{\n  int nlines, i;\n  int not_text;\n  size_t residue, save;\n  char oldc;\n  char *beg;\n  char *lim;\n  char eol = eolbyte;\n\n  if (!reset (fd, file, stats))\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "get_nondigit_option (int argc, char *const *argv, int *default_context)\n{\n  static int prev_digit_optind = -1;\n  int opt, this_digit_optind, was_digit;\n  char buf[sizeof (uintmax_t) * CHAR_BIT + 4];\n  char *p = buf;\n\n  was_digit = 0;\n  this_digit_optind = optind;\n  while (opt = getopt_long (argc, (char **) argv, short_options, long_options,\n                            NULL),\n         '0' <= opt && opt <= '9')\n    {\n      if (prev_digit_optind != this_digit_optind || !was_digit)\n        {\n          /* Reset to start another context length argument.  */\n          p = buf;\n        }\n      else\n        {\n          /* Suppress trivial leading zeros, to avoid incorrect\n             diagnostic on strings like 00000000000.  */\n          p -= buf[0] == '0';\n        }\n\n      if (p == buf + sizeof buf - 4)\n        {\n          /* Too many digits.  Append \"...\" to make context_length_arg\n             complain about \"X...\", where X contains the digits seen\n             so far.  */\n          strcpy (p, \"...\");\n          p += 3;\n          break;\n        }\n      *p++ = opt;\n\n      was_digit = 1;\n      prev_digit_optind = this_digit_optind;\n      this_digit_optind = optind;\n    }\n  if (p != buf)\n    {\n      *p = '\\0';\n      context_length_arg (buf, default_context);\n    }\n\n  return opt;\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "context_length_arg (char const *str, int *out)\n{\n  uintmax_t value;\n  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n         && 0 <= (*out = value)\n         && *out == value))\n    {\n      error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n             _(\"invalid context length argument\"));\n    }\n}", "target": 1, "cwe": ["CWE-189"], "message": "grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow."}
{"func": "read_block( IOBUF a, PACKET **pending_pkt, KBNODE *ret_root )\n{\n    int rc;\n    PACKET *pkt;\n    KBNODE root = NULL;\n    int in_cert;\n\n    if( *pending_pkt ) {\n\troot = new_kbnode( *pending_pkt );\n\t*pending_pkt = NULL;\n\tin_cert = 1;\n    }\n    else\n\tin_cert = 0;\n    pkt = xmalloc( sizeof *pkt );\n    init_packet(pkt);\n    while( (rc=parse_packet(a, pkt)) != -1 ) {\n\tif( rc ) {  /* ignore errors */\n\t    if( rc != G10ERR_UNKNOWN_PACKET ) {\n\t\tlog_error(\"read_block: read error: %s\\n\", g10_errstr(rc) );\n\t\trc = G10ERR_INV_KEYRING;\n\t\tgoto ready;\n\t    }\n\t    free_packet( pkt );\n\t    init_packet(pkt);\n\t    continue;\n\t}\n\n\tif( !root && pkt->pkttype == PKT_SIGNATURE\n\t\t  && pkt->pkt.signature->sig_class == 0x20 ) {\n\t    /* this is a revocation certificate which is handled\n\t     * in a special way */\n\t    root = new_kbnode( pkt );\n\t    pkt = NULL;\n\t    goto ready;\n\t}\n\n\t/* make a linked list of all packets */\n\tswitch( pkt->pkttype ) {\n\t  case PKT_COMPRESSED:\n\t    if(check_compress_algo(pkt->pkt.compressed->algorithm))\n\t      {\n\t\trc = G10ERR_COMPR_ALGO;\n\t\tgoto ready;\n\t      }\n\t    else\n\t      {\n\t\tcompress_filter_context_t *cfx = xmalloc_clear( sizeof *cfx );\n\t\tpkt->pkt.compressed->buf = NULL;\n\t\tpush_compress_filter2(a,cfx,pkt->pkt.compressed->algorithm,1);\n\t      }\n\t    free_packet( pkt );\n\t    init_packet(pkt);\n\t    break;\n\n          case PKT_RING_TRUST:\n            /* skip those packets */\n\t    free_packet( pkt );\n\t    init_packet(pkt);\n            break;\n\n\t  case PKT_PUBLIC_KEY:\n\t  case PKT_SECRET_KEY:\n\t    if( in_cert ) { /* store this packet */\n\t\t*pending_pkt = pkt;\n\t\tpkt = NULL;\n\t\tgoto ready;\n\t    }\n\t    in_cert = 1;\n\t  default:\n\t    if( in_cert ) {\n\t\tif( !root )\n\t\t    root = new_kbnode( pkt );\n\t\telse\n\t\t    add_kbnode( root, new_kbnode( pkt ) );\n\t\tpkt = xmalloc( sizeof *pkt );\n\t    }\n\t    init_packet(pkt);\n\t    break;\n\t}\n    }\n  ready:\n    if( rc == -1 && root )\n\trc = 0;\n\n    if( rc )\n\trelease_kbnode( root );\n    else\n\t*ret_root = root;\n    free_packet( pkt );\n    xfree( pkt );\n    return rc;\n}", "target": 1, "cwe": ["CWE-20"], "message": "gpg: Import only packets which are allowed in a keyblock.\n\n* g10/import.c (valid_keyblock_packet): New.\n(read_block): Store only valid packets.\n--\n\nA corrupted key, which for example included a mangled public key\nencrypted packet, used to corrupt the keyring.  This change skips all\npackets which are not allowed in a keyblock.\n\nGnuPG-bug-id: 1455\n\n(cherry-picked from commit f795a0d59e197455f8723c300eebf59e09853efa)"}
{"func": "mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n    }\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                      xmlNode * data, xmlNode ** output_data, int call_options, const char *name)\n{\n    int rc = pcmk_ok;\n\n    xmlNode *op_msg = NULL;\n    xmlNode *op_reply = NULL;\n\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (sync_timer == NULL) {\n        sync_timer = calloc(1, sizeof(struct timer_rec_s));\n    }\n\n    if (cib->state == cib_disconnected) {\n        return -ENOTCONN;\n    }\n\n    if (output_data != NULL) {\n        *output_data = NULL;\n    }\n\n    if (op == NULL) {\n        crm_err(\"No operation specified\");\n        return -EINVAL;\n    }\n\n    cib->call_id++;\n    /* prevent call_id from being negative (or zero) and conflicting\n     *    with the cib_errors enum\n     * use 2 because we use it as (cib->call_id - 1) below\n     */\n    if (cib->call_id < 1) {\n        cib->call_id = 1;\n    }\n\n    op_msg =\n        cib_create_op(cib->call_id, private->callback.token, op, host, section, data, call_options,\n                      NULL);\n    if (op_msg == NULL) {\n        return -EPROTO;\n    }\n\n    crm_trace(\"Sending %s message to CIB service\", op);\n    crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n    free_xml(op_msg);\n\n    if ((call_options & cib_discard_reply)) {\n        crm_trace(\"Discarding reply\");\n        return pcmk_ok;\n\n    } else if (!(call_options & cib_sync_call)) {\n        return cib->call_id;\n    }\n\n    crm_trace(\"Waiting for a syncronous reply\");\n\n    if (cib->call_timeout > 0) {\n        /* We need this, even with msgfromIPC_timeout(), because we might\n         * get other/older replies that don't match the active request\n         */\n        timer_expired = FALSE;\n        sync_timer->call_id = cib->call_id;\n        sync_timer->timeout = cib->call_timeout * 1000;\n        sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);\n    }\n\n    while (timer_expired == FALSE) {\n        int reply_id = -1;\n        int msg_id = cib->call_id;\n\n        op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);\n        if (op_reply == NULL) {\n            break;\n        }\n\n        crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);\n        CRM_CHECK(reply_id > 0, free_xml(op_reply);\n                  if (sync_timer->ref > 0) {\n                  g_source_remove(sync_timer->ref); sync_timer->ref = 0;}\n                  return -ENOMSG) ;\n\n        if (reply_id == msg_id) {\n            break;\n\n        } else if (reply_id < msg_id) {\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n\n        } else if ((reply_id - 10000) > msg_id) {\n            /* wrap-around case */\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n        } else {\n            crm_err(\"Received a __future__ reply:\" \" %d (wanted %d)\", reply_id, msg_id);\n        }\n\n        free_xml(op_reply);\n        op_reply = NULL;\n    }\n\n    if (sync_timer->ref > 0) {\n        g_source_remove(sync_timer->ref);\n        sync_timer->ref = 0;\n    }\n\n    if (timer_expired) {\n        return -ETIME;\n    }\n\n    /* if(IPC_ISRCONN(native->command_channel) == FALSE) { */\n    /*      crm_err(\"CIB disconnected: %d\",  */\n    /*              native->command_channel->ch_status); */\n    /*      cib->state = cib_disconnected; */\n    /* } */\n\n    if (op_reply == NULL) {\n        crm_err(\"No reply message - empty\");\n        return -ENOMSG;\n    }\n\n    crm_trace(\"Syncronous reply received\");\n\n    /* Start processing the reply... */\n    if (crm_element_value_int(op_reply, F_CIB_RC, &rc) != 0) {\n        rc = -EPROTO;\n    }\n\n    if (rc == -pcmk_err_diff_resync) {\n        /* This is an internal value that clients do not and should not care about */\n        rc = pcmk_ok;\n    }\n\n    if (rc == pcmk_ok || rc == -EPERM) {\n        crm_log_xml_debug(op_reply, \"passed\");\n\n    } else {\n/* \t} else if(rc == -ETIME) { */\n        crm_err(\"Call failed: %s\", pcmk_strerror(rc));\n        crm_log_xml_warn(op_reply, \"failed\");\n    }\n\n    if (output_data == NULL) {\n        /* do nothing more */\n\n    } else if (!(call_options & cib_discard_reply)) {\n        xmlNode *tmp = get_message_xml(op_reply, F_CIB_CALLDATA);\n\n        if (tmp == NULL) {\n            crm_trace(\"No output in reply to \\\"%s\\\" command %d\", op, cib->call_id - 1);\n        } else {\n            *output_data = copy_xml(tmp);\n        }\n    }\n\n    free_xml(op_reply);\n\n    return rc;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "do_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    /* send callback to originating child */\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n\n    } else {\n        int rid = 0;\n\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        /* fprintf(stderr, \"entered: '%s'\\n\", buffer); */\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n\n    return rc;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n\n    if (client == NULL) {\n        return;\n    }\n\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n\n#  if 0\n    const char *name = crm_element_name(msg);\n\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n\n        len++;                  /* null char */\n        crm_trace(\"Message size: %d\", len);\n\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n\n    }\n    free(xml_text);\n    return NULL;\n\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    shutdown(private->command.socket, SHUT_RDWR);       /* no more receptions */\n    shutdown(private->callback.socket, SHUT_RDWR);      /* no more receptions */\n    close(private->command.socket);\n    close(private->callback.socket);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n\n    free(reply);\n    return xml;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    /* unset dangerous options */\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        /* fix the command */\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n\n        len++;                  /* null char */\n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n\n    type = crm_element_value(update_msg, F_SUBTYPE);\n\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n\n    CRM_CHECK(cib != NULL, return -EINVAL);\n\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    \n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    \n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n\n            }\n\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "init_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n\n    if (port <= 0) {\n        /* dont start it */\n        return 0;\n    }\n\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n/* \tgnutls_global_set_log_level (10); */\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n\n    /* create server socket */\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n\n    /* reuse address */\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n\n    /* bind server socket */\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n\n    return *ssock;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n\n    /* Always return TRUE, never remove the handler\n     * We do that after the while-loop in cib_native_perform_op()\n     */\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_remote_listen(gpointer data)\n{\n    int lpc = 0;\n    int csock = 0;\n    unsigned laddr;\n    time_t now = 0;\n    time_t start = time(NULL);\n    struct sockaddr_in addr;\n    int ssock = *(int *)data;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    gnutls_session *session = NULL;\n#endif\n    cib_client_t *new_client = NULL;\n\n    xmlNode *login = NULL;\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n\n#ifdef HAVE_DECL_NANOSLEEP\n    const struct timespec sleepfast = { 0, 10000000 };  /* 10 millisec */\n#endif\n\n    static struct mainloop_fd_callbacks remote_client_fd_callbacks = \n        {\n            .dispatch = cib_remote_msg,\n            .destroy = cib_remote_connection_destroy,\n        };    \n    \n    /* accept the connection */\n    laddr = sizeof(addr);\n    csock = accept(ssock, (struct sockaddr *)&addr, &laddr);\n    crm_debug(\"New %s connection from %s\",\n              ssock == remote_tls_fd ? \"secure\" : \"clear-text\", inet_ntoa(addr.sin_addr));\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        /* create gnutls session for the server socket */\n        session = create_tls_session(csock, GNUTLS_SERVER);\n        if (session == NULL) {\n            crm_err(\"TLS session creation failed\");\n            close(csock);\n            return TRUE;\n        }\n#endif\n    }\n\n    do {\n        crm_trace(\"Iter: %d\", lpc++);\n        if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n            login = crm_recv_remote_msg(session, TRUE);\n#endif\n        } else {\n            login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);\n        }\n        if (login != NULL) {\n            break;\n        }\n#ifdef HAVE_DECL_NANOSLEEP\n        nanosleep(&sleepfast, NULL);\n#else\n        sleep(1);\n#endif\n        now = time(NULL);\n\n        /* Peers have 3s to connect */\n    } while (login == NULL && (start - now) < 4);\n\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        goto bail;\n    }\n\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        goto bail;\n    }\n\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        goto bail;\n    }\n\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n\n    /* Non-root daemons can only validate the password of the\n     * user they're running as\n     */\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        goto bail;\n\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        goto bail;\n    }\n\n    /* send ACK */\n    num_clients++;\n    new_client = calloc(1, sizeof(cib_client_t));\n    new_client->name = crm_element_value_copy(login, \"name\");\n\n    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n    new_client->id = crm_generate_uuid();\n\n#if ENABLE_ACL\n    new_client->user = strdup(user);\n#endif\n\n    new_client->callback_id = NULL;\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        new_client->encrypted = TRUE;\n        new_client->session = session;\n#endif\n    } else {\n        new_client->session = GINT_TO_POINTER(csock);\n    }\n\n    free_xml(login);\n    login = create_xml_node(NULL, \"cib_result\");\n    crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);\n    crm_xml_add(login, F_CIB_CLIENTID, new_client->id);\n    crm_send_remote_msg(new_client->session, login, new_client->encrypted);\n    free_xml(login);\n\n    new_client->remote = mainloop_add_fd(\n        \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);\n\n    g_hash_table_insert(client_list, new_client->id, new_client);\n\n    return TRUE;\n\n  bail:\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_bye(*session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*session);\n        gnutls_free(session);\n#endif\n    }\n    close(csock);\n    free_xml(login);\n    return TRUE;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)\n{\n    int sock;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    struct sockaddr_in addr;\n    int rc = 0;\n    char *server = private->server;\n\n    int ret_ga;\n    struct addrinfo *res;\n    struct addrinfo hints;\n\n    xmlNode *answer = NULL;\n    xmlNode *login = NULL;\n\n    static struct mainloop_fd_callbacks cib_fd_callbacks = \n        {\n            .dispatch = cib_remote_dispatch,\n            .destroy = cib_remote_connection_destroy,\n        };\n\n    connection->socket = 0;\n    connection->session = NULL;\n\n    /* create socket */\n    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock == -1) {\n        crm_perror(LOG_ERR, \"Socket creation failed\");\n        return -1;\n    }\n\n    /* getaddrinfo */\n    bzero(&hints, sizeof(struct addrinfo));\n    hints.ai_flags = AI_CANONNAME;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_RAW;\n\n    if (hints.ai_family == AF_INET6) {\n        hints.ai_protocol = IPPROTO_ICMPV6;\n    } else {\n        hints.ai_protocol = IPPROTO_ICMP;\n    }\n\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        close(sock);\n        return -1;\n    }\n\n    if (res->ai_canonname) {\n        server = res->ai_canonname;\n    }\n\n    crm_debug(\"Got address %s for %s\", server, private->server);\n\n    if (!res->ai_addr) {\n        fprintf(stderr, \"getaddrinfo failed\");\n        crm_exit(1);\n    }\n#if 1\n    memcpy(&addr, res->ai_addr, res->ai_addrlen);\n#else\n    /* connect to server */\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = inet_addr(server);\n#endif\n    addr.sin_port = htons(private->port);\n\n    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        crm_perror(LOG_ERR, \"Connection to %s:%d failed\", server, private->port);\n        close(sock);\n        return -1;\n    }\n\n    if (connection->encrypted) {\n        /* initialize GnuTls lib */\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_global_init();\n        gnutls_anon_allocate_client_credentials(&anon_cred_c);\n\n        /* bind the socket to GnuTls lib */\n        connection->session = create_tls_session(sock, GNUTLS_CLIENT);\n        if (connection->session == NULL) {\n            crm_perror(LOG_ERR, \"Session creation for %s:%d failed\", server, private->port);\n            close(sock);\n            cib_tls_close(cib);\n            return -1;\n        }\n#else\n        return -EPROTONOSUPPORT;\n#endif\n    } else {\n        connection->session = GUINT_TO_POINTER(sock);\n    }\n\n    /* login to server */\n    login = create_xml_node(NULL, \"cib_command\");\n    crm_xml_add(login, \"op\", \"authenticate\");\n    crm_xml_add(login, \"user\", private->user);\n    crm_xml_add(login, \"password\", private->passwd);\n    crm_xml_add(login, \"hidden\", \"password\");\n\n    crm_send_remote_msg(connection->session, login, connection->encrypted);\n    free_xml(login);\n\n    answer = crm_recv_remote_msg(connection->session, connection->encrypted);\n    crm_log_xml_trace(answer, \"Reply\");\n    if (answer == NULL) {\n        rc = -EPROTO;\n\n    } else {\n        /* grab the token */\n        const char *msg_type = crm_element_value(answer, F_CIB_OPERATION);\n        const char *tmp_ticket = crm_element_value(answer, F_CIB_CLIENTID);\n\n        if (safe_str_neq(msg_type, CRM_OP_REGISTER)) {\n            crm_err(\"Invalid registration message: %s\", msg_type);\n            rc = -EPROTO;\n\n        } else if (tmp_ticket == NULL) {\n            rc = -EPROTO;\n\n        } else {\n            connection->token = strdup(tmp_ticket);\n        }\n    }\n\n    if (rc != 0) {\n        cib_tls_close(cib);\n    }\n\n    connection->socket = sock;\n    connection->source = mainloop_add_fd(\"cib-remote\", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);\n    return rc;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n\n    buf = calloc(1, chunk_size);\n\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "create_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */ )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n/*      http://www.manpagez.com/info/gnutls/gnutls-2.10.4/gnutls_81.php#Echo-Server-with-anonymous-authentication */\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n/*\tgnutls_priority_set_direct (*session, \"NONE:+VERS-TLS-ALL:+CIPHER-ALL:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-DH\", NULL); */\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n\n    if (session == NULL) {\n        return NULL;\n    }\n\n    buf = calloc(1, chunk_size);\n\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n\n}", "target": 1, "cwe": ["CWE-399"], "message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend."}
{"func": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "message": "mount: sanitize paths from non-root users\n\n $ mount /root/.ssh/../../dev/sda2\n mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nthis is too promiscuous. It seems better to ignore on command line\nspecified paths which are not resolve-able for non-root users.\n\nFixed version:\n\n  $ mount /root/.ssh/../../dev/sda2\n  mount: /root/.ssh/../../dev/sda2: Permission denied\n\n  $ mount /dev/sda2\n  mount: only root can mount UUID=17bc65ec-4125-4e7c-8a7d-e2795064c736 on /boot\n\nNote that this bug has no relation to mount(2) permissions evaluation\nin suid mode. The way how non-root user specifies paths on command\nline is completely irrelevant for comparison with fstab entries.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"}
{"func": "int main(int argc, char **argv)\n{\n\tint c, rc = 0, all = 0, recursive = 0;\n\tstruct libmnt_context *cxt;\n\tchar *types = NULL;\n\n\tenum {\n\t\tUMOUNT_OPT_FAKE = CHAR_MAX + 1,\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"detach-loop\", 0, 0, 'd' },\n\t\t{ \"fake\", 0, 0, UMOUNT_OPT_FAKE },\n\t\t{ \"force\", 0, 0, 'f' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"lazy\", 0, 0, 'l' },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"recursive\", 0, 0, 'R' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'R','a' },\t\t\t/* recursive,all */\n\t\t{ 'O','R','t'},\t\t\t/* options,recursive,types */\n\t\t{ 'R','r' },\t\t\t/* recursive,read-only */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"acdfhilnRrO:t:vV\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) && !strchr(\"hdilVv\", c))\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tmnt_context_enable_loopdel(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase UMOUNT_OPT_FAKE:\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_force(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tmnt_context_enable_lazy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tmnt_context_enable_rdonly_umount(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecursive = TRUE;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (all) {\n\t\tif (!types)\n\t\t\ttypes = \"noproc,nodevfs,nodevpts,nosysfs,norpc_pipefs,nonfsd\";\n\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\t\trc = umount_all(cxt);\n\n\t} else if (argc < 1) {\n\t\tusage(stderr);\n\n\t} else if (recursive) {\n\t\twhile (argc--)\n\t\t\trc += umount_recursive(cxt, *argv++);\n\t} else {\n\t\twhile (argc--)\n\t\t\trc += umount_one(cxt, *argv++);\n\t}\n\n\tmnt_free_context(cxt);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "message": "umount: sanitize paths from non-root users\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"}
{"func": "main(int argc, char *argv[]) {\n\tint c, result = 0, specseen;\n\tchar *options = NULL, *test_opts = NULL, *node;\n\tconst char *spec = NULL;\n\tchar *label = NULL;\n\tchar *uuid = NULL;\n\tchar *types = NULL;\n\tchar *p;\n\tstruct mntentchn *mc;\n\tint fd;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tprogname = argv[0];\n\tif ((p = strrchr(progname, '/')) != NULL)\n\t\tprogname = p+1;\n\n\tumask(022);\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n\tfsprobe_init();\n\n#ifdef DO_PS_FIDDLING\n\tinitproctitle(argc, argv);\n#endif\n\n\twhile ((c = getopt_long (argc, argv, \"aBfFhilL:Mno:O:p:rRsU:vVwt:\",\n\t\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\t       /* mount everything in fstab */\n\t\t\t++mount_all;\n\t\t\tbreak;\n\t\tcase 'B': /* bind */\n\t\t\tmounttype = MS_BIND;\n\t\t\tbreak;\n\t\tcase 'f':\t       /* fake: don't actually call mount(2) */\n\t\t\t++fake;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\t++optfork;\n\t\t\tbreak;\n\t\tcase 'h':\t\t/* help */\n\t\t\tusage (stdout, 0);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\texternal_allowed = 0;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_with_volumelabel = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tlabel = optarg;\n\t\t\tbreak;\n\t\tcase 'M': /* move */\n\t\t\tmounttype = MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'n':\t\t/* do not write /etc/mtab */\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\t\t/* specify mount options */\n\t\t\toptions = append_opt(options, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'O':\t\t/* with -t: mount only if (not) opt */\n\t\t\ttest_opts = append_opt(test_opts, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* fd on which to read passwd */\n                        error(\"mount: %s\", _(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* mount readonly */\n\t\t\treadonly = 1;\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'R': /* rbind */\n\t\t\tmounttype = (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase 's':\t\t/* allow sloppy mount options */\n\t\t\tsloppy = 1;\n\t\t\tbreak;\n\t\tcase 't':\t\t/* specify file system types */\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\t\t/* be chatty - more so if repeated */\n\t\t\t++verbose;\n\t\t\tbreak;\n\t\tcase 'V':\t\t/* version */\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase 'w':\t\t/* mount read/write */\n\t\t\treadwrite = 1;\n\t\t\treadonly = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase 134:\n\t\t\t/* undocumented, may go away again:\n\t\t\t   call: mount --guess-fstype device\n\t\t\t   use only for testing purposes -\n\t\t\t   the guessing is not reliable at all */\n\t\t    {\n\t\t\tconst char *fstype;\n\t\t\tfstype = fsprobe_get_fstype_by_devname(optarg);\n\t\t\tprintf(\"%s\\n\", fstype ? fstype : \"unknown\");\n\t\t\texit(fstype ? 0 : EX_FAIL);\n\t\t    }\n\n\t\tcase 136:\n\t\t\tmounttype = MS_SHARED;\n\t\t\tbreak;\n\n\t\tcase 137:\n\t\t\tmounttype = MS_SLAVE;\n\t\t\tbreak;\n\n\t\tcase 138:\n\t\t\tmounttype = MS_PRIVATE;\n\t\t\tbreak;\n\n\t\tcase 139:\n\t\t\tmounttype = MS_UNBINDABLE;\n\t\t\tbreak;\n\n\t\tcase 140:\n\t\t\tmounttype = (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 141:\n\t\t\tmounttype = (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 142:\n\t\t\tmounttype = (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 143:\n\t\t\tmounttype = (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase 144:\n\t\t\tnocanonicalize = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage (stderr, EX_USAGE);\n\t\t}\n\t}\n\n\tif (verbose > 2) {\n\t\tprintf(\"mount: fstab path: \\\"%s\\\"\\n\", _PATH_MNTTAB);\n\t\tprintf(\"mount: mtab path:  \\\"%s\\\"\\n\", _PATH_MOUNTED);\n\t\tprintf(\"mount: lock path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_LOCK);\n\t\tprintf(\"mount: temp path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_TMP);\n\t\tprintf(\"mount: UID:        %u\\n\", getuid());\n\t\tprintf(\"mount: eUID:       %u\\n\", geteuid());\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tspecseen = (uuid || label) ? 1 : 0;\t/* yes, .. i know */\n\n\tif (argc+specseen == 0 && !mount_all) {\n\t\tif (options || mounttype)\n\t\t\tusage (stderr, EX_USAGE);\n\t\treturn print_all (types);\n\t}\n\n\t{\n\t\tconst uid_t ruid = getuid();\n\t\tconst uid_t euid = geteuid();\n\n\t\t/* if we're really root and aren't running setuid */\n\t\tif (((uid_t)0 == ruid) && (ruid == euid)) {\n\t\t\trestricted = 0;\n\t\t}\n\n\t\tif (restricted &&\n\t\t    (types || options || readwrite || nomtab || mount_all ||\n\t\t     nocanonicalize || fake || mounttype ||\n\t\t     (argc + specseen) != 1)) {\n\n\t\t\tif (ruid == 0 && euid != 0)\n\t\t\t\t/* user is root, but setuid to non-root */\n\t\t\t\tdie (EX_USAGE, _(\"mount: only root can do that \"\n\t\t\t\t\t\"(effective UID is %u)\"), euid);\n\n\t\t\tdie (EX_USAGE, _(\"mount: only root can do that\"));\n\t\t}\n\t}\n\n\tatexit(unlock_mtab);\n\n\tswitch (argc+specseen) {\n\tcase 0:\n\t\t/* mount -a */\n\t\tresult = do_mount_all (types, options, test_opts);\n\t\tif (result == 0 && verbose && !fake)\n\t\t\terror(_(\"nothing was mounted\"));\n\t\tbreak;\n\n\tcase 1:\n\t\t/* mount [-nfrvw] [-o options] special | node\n\t\t * mount -L label  (or -U uuid)\n\t\t * (/etc/fstab is necessary)\n\t\t */\n\t\tif (types != NULL)\n\t\t\tusage (stderr, EX_USAGE);\n\n\t\tif (uuid || label)\n\t\t\tmc = getfs(NULL, uuid, label);\n\t\telse\n\t\t\tmc = getfs(*argv, NULL, NULL);\n\n\t\tif (!mc) {\n\t\t\tif (uuid || label)\n\t\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\t\tdie (EX_USAGE,\n\t\t\t     _(\"mount: can't find %s in %s or %s\"),\n\t\t\t     *argv, _PATH_MNTTAB, _PATH_MOUNTED);\n\t\t}\n\n\t\tresult = mount_one (xstrdup (mc->m.mnt_fsname),\n\t\t\t\t    xstrdup (mc->m.mnt_dir),\n\t\t\t\t    xstrdup (mc->m.mnt_type),\n\t\t\t\t    mc->m.mnt_opts, options, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t/* mount special node  (/etc/fstab is not necessary) */\n\t\tif (specseen) {\n\t\t\t/* mount -L label node   (or -U uuid) */\n\t\t\tspec = uuid ?\tfsprobe_get_devname_by_uuid(uuid) :\n\t\t\t\t\tfsprobe_get_devname_by_label(label);\n\t\t\tnode = argv[0];\n\t\t} else {\n\t\t\t/* mount special node */\n\t\t\tspec = argv[0];\n\t\t\tnode = argv[1];\n\t\t}\n\t\tif (!spec)\n\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\tresult = mount_one (spec, node, types, NULL, options, 0, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tusage (stderr, EX_USAGE);\n\t}\n\n\tif (result == EX_SOMEOK)\n\t\tresult = 0;\n\n\tfsprobe_exit();\n\n\texit (result);\n}", "target": 1, "cwe": ["CWE-200"], "message": "mount: (deprecated) drop --guess-fstype\n\nThe option is undocumented and unnecessary.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>"}
{"func": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   /* i_ctx_p is NULL running arg (@) files.\n     * lib_path and mem are never NULL\n     */\n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[4] = { 'r', 0, 0, 0 };           /* room for binary suffix */\n    gx_io_device *iodev = iodev_default(mem);\n    gs_main_instance *minst = get_minst_from_memory(mem);\n    int code;\n\n    /* when starting arg files (@ files) iodev_default is not yet set */\n    if (iodev == 0)\n        iodev = (gx_io_device *)gx_io_device_table[0];\n\n    strcat(fmode, gp_fmode_binary_suffix);\n    if (gp_file_name_is_absolute(fname, flen)) {\n       search_with_no_combine = true;\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }\n    if (minst->search_here_first) {\n      if (search_with_no_combine) {\n        code = lib_file_open_search_with_no_combine(lib_path, mem, i_ctx_p,\n                                                    fname, flen, buffer, blen, pclen, pfile,\n                                                    iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue continue */\n          return code;\n      }\n      if (search_with_combine) {\n        code = lib_file_open_search_with_combine(lib_path, mem, i_ctx_p,\n                                                 fname, flen, buffer, blen, pclen, pfile,\n                                                 iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n    } else {\n      if (search_with_combine) {\n        code = lib_file_open_search_with_combine(lib_path, mem, i_ctx_p,\n                                                 fname, flen, buffer, blen, pclen, pfile,\n                                                 iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n      if (search_with_no_combine) {\n        code = lib_file_open_search_with_no_combine(lib_path, mem, i_ctx_p,\n                                                    fname, flen, buffer, blen, pclen, pfile,\n                                                    iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n    }\n    return_error(e_undefinedfilename);\n}", "target": 1, "cwe": [], "message": "\"starting_arg_file\" should only apply once.\n\nThe \"starting_arg_file == true\" setting should apply to the *first* call to\nlib_file_open() in the context of a given call to runarg(). Previously, it\nremained set for the entire duration of the runarg() call, resulting in the\ncurrent directory being searched for any resource files required by the job.\n\nWe also want \"starting_arg_file == false\" when runarg() is called to execute\nPostscript from a buffer, rather than a file argument.\n\nThere is a very small chance this may cause problems with some strange scripts\nor utilities, but I have been unable to prompt such an issue. If one does arise,\nwe may have rethink this entirely.\n\nNo cluster differences."}
{"func": "runarg(gs_main_instance * minst, const char *pre, const char *arg,\n       const char *post, int options)\n{\n    int len = strlen(pre) + esc_strlen(arg) + strlen(post) + 1;\n    int code;\n    char *line;\n\n    if (options & runInit) {\n        code = gs_main_init2(minst);    /* Finish initialization */\n\n        if (code < 0)\n            return code;\n    }\n    line = (char *)gs_alloc_bytes(minst->heap, len, \"runarg\");\n    if (line == 0) {\n        lprintf(\"Out of memory!\\n\");\n        return_error(e_VMerror);\n    }\n    strcpy(line, pre);\n    esc_strcat(line, arg);\n    strcat(line, post);\n    minst->i_ctx_p->starting_arg_file = true;\n    code = run_string(minst, line, options);\n    minst->i_ctx_p->starting_arg_file = false;\n    gs_free_object(minst->heap, line, \"runarg\");\n    return code;\n}", "target": 1, "cwe": [], "message": "\"starting_arg_file\" should only apply once.\n\nThe \"starting_arg_file == true\" setting should apply to the *first* call to\nlib_file_open() in the context of a given call to runarg(). Previously, it\nremained set for the entire duration of the runarg() call, resulting in the\ncurrent directory being searched for any resource files required by the job.\n\nWe also want \"starting_arg_file == false\" when runarg() is called to execute\nPostscript from a buffer, rather than a file argument.\n\nThere is a very small chance this may cause problems with some strange scripts\nor utilities, but I have been unable to prompt such an issue. If one does arise,\nwe may have rethink this entirely.\n\nNo cluster differences."}
{"func": "swproc(gs_main_instance * minst, const char *arg, arg_list * pal)\n{\n    char sw = arg[1];\n    ref vtrue;\n    int code = 0;\n#undef initial_enter_name\n#define initial_enter_name(nstr, pvalue)\\\n  i_initial_enter_name(minst->i_ctx_p, nstr, pvalue)\n\n    make_true(&vtrue);\n    arg += 2;                   /* skip - and letter */\n    switch (sw) {\n        default:\n            return 1;\n        case 0:         /* read stdin as a file char-by-char */\n            /* This is a ******HACK****** for Ghostview. */\n            minst->heap->gs_lib_ctx->stdin_is_interactive = true;\n            goto run_stdin;\n        case '_':       /* read stdin with normal buffering */\n            minst->heap->gs_lib_ctx->stdin_is_interactive = false;\nrun_stdin:\n            minst->run_start = false;   /* don't run 'start' */\n            /* Set NOPAUSE so showpage won't try to read from stdin. */\n            code = swproc(minst, \"-dNOPAUSE\", pal);\n            if (code)\n                return code;\n            code = gs_main_init2(minst);        /* Finish initialization */\n            if (code < 0)\n                return code;\n\n            code = run_string(minst, \".runstdin\", runFlush);\n            if (code < 0)\n                return code;\n            break;\n        case '-':               /* run with command line args */\n            if (strncmp(arg, \"debug=\", 6) == 0) {\n                code = gs_debug_flags_parse(minst->heap, arg+6);\n                if (code < 0)\n                    return code;\n                break;\n            }\n            /* FALLTHROUGH */\n        case '+':\n            pal->expand_ats = false;\n            /* FALLTHROUGH */\n        case '@':               /* ditto with @-expansion */\n            {\n                const char *psarg = arg_next(pal, &code, minst->heap);\n\n                if (code < 0)\n                    return e_Fatal;\n                if (psarg == 0) {\n                    outprintf(minst->heap, \"Usage: gs ... -%c file.ps arg1 ... argn\\n\", sw);\n                    arg_finit(pal);\n                    return e_Fatal;\n                }\n                psarg = arg_copy(psarg, minst->heap);\n                if (psarg == NULL)\n                    code = e_Fatal;\n                else\n                    code = gs_main_init2(minst);\n                if (code >= 0)\n                    code = run_string(minst, \"userdict/ARGUMENTS[\", 0);\n                if (code >= 0)\n                    while ((arg = arg_next(pal, &code, minst->heap)) != 0) {\n                        code = runarg(minst, \"\", arg, \"\", runInit);\n                        if (code < 0)\n                            break;\n                    }\n                if (code >= 0)\n                    code = runarg(minst, \"]put\", psarg, \".runfile\", runInit | runFlush);\n                arg_free((char *)psarg, minst->heap);\n                if (code >= 0)\n                    code = e_Quit;\n                \n                return code;\n            }\n        case 'A':               /* trace allocator */\n            switch (*arg) {\n                case 0:\n                    gs_alloc_debug = 1;\n                    break;\n                case '-':\n                    gs_alloc_debug = 0;\n                    break;\n                default:\n                    puts(minst->heap, \"-A may only be followed by -\");\n                    return e_Fatal;\n            }\n            break;\n        case 'B':               /* set run_string buffer size */\n            if (*arg == '-')\n                minst->run_buffer_size = 0;\n            else {\n                uint bsize;\n\n                if (sscanf((const char *)arg, \"%u\", &bsize) != 1 ||\n                    bsize <= 0 || bsize > MAX_BUFFERED_SIZE\n                    ) {\n                    outprintf(minst->heap,\n                              \"-B must be followed by - or size between 1 and %u\\n\",\n                              MAX_BUFFERED_SIZE);\n                    return e_Fatal;\n                }\n                minst->run_buffer_size = bsize;\n            }\n            break;\n        case 'c':               /* code follows */\n            {\n                bool ats = pal->expand_ats;\n\n                code = gs_main_init2(minst);\n                if (code < 0)\n                    return code;\n                pal->expand_ats = false;\n                while ((arg = arg_next(pal, &code, minst->heap)) != 0) {\n                    if (arg[0] == '@' ||\n                        (arg[0] == '-' && !isdigit((unsigned char)arg[1]))\n                        )\n                        break;\n                    code = runarg(minst, \"\", arg, \".runstring\", 0);\n                    if (code < 0)\n                        return code;\n                }\n                if (code < 0)\n                    return e_Fatal;\n                if (arg != 0) {\n                    char *p = arg_copy(arg, minst->heap);\n                    if (p == NULL)\n                        return e_Fatal;\n                    arg_push_string(pal, p, true);\n                }\n                pal->expand_ats = ats;\n                break;\n            }\n        case 'E':               /* log errors */\n            switch (*arg) {\n                case 0:\n                    gs_log_errors = 1;\n                    break;\n                case '-':\n                    gs_log_errors = 0;\n                    break;\n                default:\n                    puts(minst->heap, \"-E may only be followed by -\");\n                    return e_Fatal;\n            }\n            break;\n        case 'f':               /* run file of arbitrary name */\n            if (*arg != 0) {\n                code = argproc(minst, arg);\n                if (code < 0)\n                    return code;\n            }\n            break;\n        case 'F':               /* run file with buffer_size = 1 */\n            if (!*arg) {\n                puts(minst->heap, \"-F requires a file name\");\n                return e_Fatal;\n            } {\n                uint bsize = minst->run_buffer_size;\n\n                minst->run_buffer_size = 1;\n                code = argproc(minst, arg);\n                minst->run_buffer_size = bsize;\n                if (code < 0)\n                    return code;\n            }\n            break;\n        case 'g':               /* define device geometry */\n            {\n                long width, height;\n                ref value;\n\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                if (sscanf((const char *)arg, \"%ldx%ld\", &width, &height) != 2) {\n                    puts(minst->heap, \"-g must be followed by <width>x<height>\");\n                    return e_Fatal;\n                }\n                make_int(&value, width);\n                initial_enter_name(\"DEVICEWIDTH\", &value);\n                make_int(&value, height);\n                initial_enter_name(\"DEVICEHEIGHT\", &value);\n                initial_enter_name(\"FIXEDMEDIA\", &vtrue);\n                break;\n            }\n        case 'h':               /* print help */\n        case '?':               /* ditto */\n            print_help(minst);\n            return e_Info;      /* show usage info on exit */\n        case 'I':               /* specify search path */\n            {\n                const char *path;\n\n                if (arg[0] == 0) {\n                    path = arg_next(pal, &code, minst->heap);\n                    if (code < 0)\n                        return code;\n                } else\n                    path = arg;\n                if (path == NULL)\n                    return e_Fatal;\n                path = arg_copy(path, minst->heap);\n                if (path == NULL)\n                    return e_Fatal;\n                gs_main_add_lib_path(minst, path);\n            }\n            break;\n        case 'K':               /* set malloc limit */\n            {\n                long msize = 0;\n                gs_malloc_memory_t *rawheap = gs_malloc_wrapped_contents(minst->heap);\n\n                sscanf((const char *)arg, \"%ld\", &msize);\n                if (msize <= 0 || msize > max_long >> 10) {\n                    outprintf(minst->heap, \"-K<numK> must have 1 <= numK <= %ld\\n\",\n                              max_long >> 10);\n                    return e_Fatal;\n                }\n                rawheap->limit = msize << 10;\n            }\n            break;\n        case 'M':               /* set memory allocation increment */\n            {\n                unsigned msize = 0;\n\n                sscanf((const char *)arg, \"%u\", &msize);\n#if ARCH_INTS_ARE_SHORT\n                if (msize <= 0 || msize >= 64) {\n                    puts(minst->heap, \"-M must be between 1 and 63\");\n                    return e_Fatal;\n                }\n#endif\n                minst->memory_chunk_size = msize << 10;\n            }\n            break;\n        case 'N':               /* set size of name table */\n            {\n                unsigned nsize = 0;\n\n                sscanf((const char *)arg, \"%d\", &nsize);\n#if ARCH_INTS_ARE_SHORT\n                if (nsize < 2 || nsize > 64) {\n                    puts(minst->heap, \"-N must be between 2 and 64\");\n                    return e_Fatal;\n                }\n#endif\n                minst->name_table_size = (ulong) nsize << 10;\n            }\n            break;\n        case 'o':               /* set output file name and batch mode */\n            {\n                const char *adef;\n                char *str;\n                ref value;\n                int len;\n\n                if (arg[0] == 0) {\n                    adef = arg_next(pal, &code, minst->heap);\n                    if (code < 0)\n                        return code;\n                } else\n                    adef = arg;\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                len = strlen(adef);\n                str = (char *)gs_alloc_bytes(minst->heap, (uint)len, \"-o\");\n                if (str == NULL)\n                    return e_VMerror;\n                memcpy(str, adef, len);\n                make_const_string(&value, a_readonly | avm_foreign,\n                                  len, (const byte *)str);\n                initial_enter_name(\"OutputFile\", &value);\n                initial_enter_name(\"NOPAUSE\", &vtrue);\n                initial_enter_name(\"BATCH\", &vtrue);\n            }\n            break;\n        case 'P':               /* choose whether search '.' first */\n            if (!strcmp(arg, \"\"))\n                minst->search_here_first = true;\n            else if (!strcmp(arg, \"-\"))\n                minst->search_here_first = false;\n            else {\n                puts(minst->heap, \"Only -P or -P- is allowed.\");\n                return e_Fatal;\n            }\n            break;\n        case 'q':               /* quiet startup */\n            if ((code = gs_main_init1(minst)) < 0)\n                return code;\n            initial_enter_name(\"QUIET\", &vtrue);\n            break;\n        case 'r':               /* define device resolution */\n            {\n                float xres, yres;\n                ref value;\n\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                switch (sscanf((const char *)arg, \"%fx%f\", &xres, &yres)) {\n                    default:\n                        puts(minst->heap, \"-r must be followed by <res> or <xres>x<yres>\");\n                        return e_Fatal;\n                    case 1:     /* -r<res> */\n                        yres = xres;\n                    case 2:     /* -r<xres>x<yres> */\n                        make_real(&value, xres);\n                        initial_enter_name(\"DEVICEXRESOLUTION\", &value);\n                        make_real(&value, yres);\n                        initial_enter_name(\"DEVICEYRESOLUTION\", &value);\n                        initial_enter_name(\"FIXEDRESOLUTION\", &vtrue);\n                }\n                break;\n            }\n        case 'D':               /* define name */\n        case 'd':\n        case 'S':               /* define name as string */\n        case 's':\n            {\n                char *adef = arg_copy(arg, minst->heap);\n                char *eqp;\n                bool isd = (sw == 'D' || sw == 'd');\n                ref value;\n\n                if (adef == NULL)\n                    return e_Fatal;\n                eqp = strchr(adef, '=');\n\n                if (eqp == NULL)\n                    eqp = strchr(adef, '#');\n                /* Initialize the object memory, scanner, and */\n                /* name table now if needed. */\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                if (eqp == adef) {\n                    puts(minst->heap, \"Usage: -dNAME, -dNAME=TOKEN, -sNAME=STRING\");\n                    return e_Fatal;\n                }\n                if (eqp == NULL) {\n                    if (isd)\n                        make_true(&value);\n                    else\n                        make_empty_string(&value, a_readonly);\n                } else {\n                    int code;\n                    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n                    uint space = icurrent_space;\n\n                    *eqp++ = 0;\n                    ialloc_set_space(idmemory, avm_system);\n                    if (isd) {\n                        int num, i;\n\n                        /* Check for numbers so we can provide for suffix scalers */\n                        /* Note the check for '#' is for PS \"radix\" numbers such as 16#ff */\n                        /* and check for '.' and 'e' or 'E' which are 'real' numbers */\n                        if ((strchr(eqp, '#') == NULL) && (strchr(eqp, '.') == NULL) &&\n                            (strchr(eqp, 'e') == NULL) && (strchr(eqp, 'E') == NULL) &&\n                            ((i = sscanf((const char *)eqp, \"%d\", &num)) == 1)) {\n                            char suffix = eqp[strlen(eqp) - 1];\n\n                            switch (suffix) {\n                                case 'k':\n                                case 'K':\n                                    num *= 1024;\n                                    break;\n                                case 'm':\n                                case 'M':\n                                    num *= 1024 * 1024;\n                                    break;\n                                case 'g':\n                                case 'G':\n                                    /* caveat emptor: more than 2g will overflow */\n                                    /* and really should produce a 'real', so don't do this */\n                                    num *= 1024 * 1024 * 1024;\n                                    break;\n                                default:\n                                    break;   /* not a valid suffix or last char was digit */\n                            }\n                            make_int(&value, num);\n                        } else {\n                            /* use the PS scanner to capture other valid token types */\n                            stream astream;\n                            scanner_state state;\n\n                            s_init(&astream, NULL);\n                            sread_string(&astream,\n                                         (const byte *)eqp, strlen(eqp));\n                            gs_scanner_init_stream(&state, &astream);\n                            code = gs_scan_token(minst->i_ctx_p, &value, &state);\n                            if (code) {\n                                outprintf(minst->heap, \"Invalid value for option -d%s, -dNAME= must be followed by a valid token\\n\", arg);\n                                return e_Fatal;\n                            }\n                            if (r_has_type_attrs(&value, t_name,\n                                                 a_executable)) {\n                                ref nsref;\n\n                                name_string_ref(minst->heap, &value, &nsref);\n#undef string_is\n#define string_is(nsref, str, len)\\\n       (r_size(&(nsref)) == (len) &&\\\n       !strncmp((const char *)(nsref).value.const_bytes, str, (len)))\n                                if (string_is(nsref, \"null\", 4))\n                                    make_null(&value);\n                                else if (string_is(nsref, \"true\", 4))\n                                    make_true(&value);\n                                else if (string_is(nsref, \"false\", 5))\n                                    make_false(&value);\n                                else {\n                                    outprintf(minst->heap, \"Invalid value for option -d%s, use -sNAME= to define string constants\\n\", arg);\n                                    return e_Fatal;\n                                }\n                            }\n                        }\n                    } else {\n                        int len = strlen(eqp);\n                        char *str =\n                        (char *)gs_alloc_bytes(minst->heap,\n                                               (uint) len, \"-s\");\n\n                        if (str == 0) {\n                            lprintf(\"Out of memory!\\n\");\n                            return e_Fatal;\n                        }\n                        memcpy(str, eqp, len);\n                        make_const_string(&value,\n                                          a_readonly | avm_foreign,\n                                          len, (const byte *)str);\n                        if ((code = try_stdout_redirect(minst, adef, eqp)) < 0)\n                            return code;\n                    }\n                    ialloc_set_space(idmemory, space);\n                }\n                /* Enter the name in systemdict. */\n                initial_enter_name(adef, &value);\n                break;\n            }\n        case 'T':\n            set_debug_flags(arg, vd_flags);\n            break;\n        case 'u':               /* undefine name */\n            if (!*arg) {\n                puts(minst->heap, \"-u requires a name to undefine.\");\n                return e_Fatal;\n            }\n            if ((code = gs_main_init1(minst)) < 0)\n                return code;\n            i_initial_remove_name(minst->i_ctx_p, arg);\n            break;\n        case 'v':               /* print revision */\n            print_revision(minst);\n            return e_Info;\n/*#ifdef DEBUG */\n            /*\n             * Here we provide a place for inserting debugging code that can be\n             * run in place of the normal interpreter code.\n             */\n        case 'X':\n            code = gs_main_init2(minst);\n            if (code < 0)\n                return code;\n            {\n                int xec;        /* exit_code */\n                ref xeo;        /* error_object */\n\n#define start_x()\\\n  gs_main_run_string_begin(minst, 1, &xec, &xeo)\n#define run_x(str)\\\n  gs_main_run_string_continue(minst, str, strlen(str), 1, &xec, &xeo)\n#define stop_x()\\\n  gs_main_run_string_end(minst, 1, &xec, &xeo)\n                start_x();\n                run_x(\"\\216\\003abc\");\n                run_x(\"== flush\\n\");\n                stop_x();\n            }\n            return e_Quit;\n/*#endif */\n        case 'Z':\n            set_debug_flags(arg, gs_debug);\n            break;\n    }\n    return 0;\n}", "target": 1, "cwe": [], "message": "\"starting_arg_file\" should only apply once.\n\nThe \"starting_arg_file == true\" setting should apply to the *first* call to\nlib_file_open() in the context of a given call to runarg(). Previously, it\nremained set for the entire duration of the runarg() call, resulting in the\ncurrent directory being searched for any resource files required by the job.\n\nWe also want \"starting_arg_file == false\" when runarg() is called to execute\nPostscript from a buffer, rather than a file argument.\n\nThere is a very small chance this may cause problems with some strange scripts\nor utilities, but I have been unable to prompt such an issue. If one does arise,\nwe may have rethink this entirely.\n\nNo cluster differences."}
{"func": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   /* i_ctx_p is NULL running arg (@) files.\n     * lib_path and mem are never NULL\n     */\n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[4] = { 'r', 0, 0, 0 };           /* room for binary suffix */\n    gx_io_device *iodev = iodev_default(mem);\n    gs_main_instance *minst = get_minst_from_memory(mem);\n    int code;\n\n    /* Once we've opened the arg file, prevent searching current dir from now on */\n    /* If this causes problems with \"strange\" scripts and utlities, we have to rethink */\n    if (i_ctx_p)\n        i_ctx_p->starting_arg_file = false;\n\n    /* when starting arg files (@ files) iodev_default is not yet set */\n    if (iodev == 0)\n        iodev = (gx_io_device *)gx_io_device_table[0];\n\n    strcat(fmode, gp_fmode_binary_suffix);\n    if (gp_file_name_is_absolute(fname, flen)) {\n       search_with_no_combine = true;\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }\n    if (minst->search_here_first) {\n      if (search_with_no_combine) {\n        code = lib_file_open_search_with_no_combine(lib_path, mem, i_ctx_p,\n                                                    fname, flen, buffer, blen, pclen, pfile,\n                                                    iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue continue */\n          return code;\n      }\n      if (search_with_combine) {\n        code = lib_file_open_search_with_combine(lib_path, mem, i_ctx_p,\n                                                 fname, flen, buffer, blen, pclen, pfile,\n                                                 iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n    } else {\n      if (search_with_combine) {\n        code = lib_file_open_search_with_combine(lib_path, mem, i_ctx_p,\n                                                 fname, flen, buffer, blen, pclen, pfile,\n                                                 iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n      if (search_with_no_combine) {\n        code = lib_file_open_search_with_no_combine(lib_path, mem, i_ctx_p,\n                                                    fname, flen, buffer, blen, pclen, pfile,\n                                                    iodev, starting_arg_file, fmode);\n        if (code <= 0) /* +ve means continue searching */\n          return code;\n      }\n    }\n    return_error(e_undefinedfilename);\n}", "target": 1, "cwe": [], "message": "Bug 695711: Resolve issue with relative paths for FONTPATH\n\nCheck whether a \"lib\" file exists, and whether we are allowed to open it,\nbefore we try to open it.\n\nThis reverts \"\"starting_arg_file\" should only apply once.\" (commit\n407cc61e87b0fd9d44d72ca740af7d3c85dee78d).\n\nWhich caused problems with, for example, the \"-sFONTPATH=...\" option when the\npath is relative rather than absolute.\n\nNo cluster differences."}
{"func": "lib_file_open_search_with_no_combine(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                                     const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile,\n                                     gx_io_device *iodev, bool starting_arg_file, char *fmode)\n{\n    stream *s;\n    uint blen1 = blen;\n    if (gp_file_name_reduce(fname, flen, buffer, &blen1) != gp_combine_success)\n      goto skip;\n    if (iodev_os_open_file(iodev, (const char *)buffer, blen1,\n                           (const char *)fmode, &s, (gs_memory_t *)mem) == 0) {\n      if (starting_arg_file ||\n          check_file_permissions_aux(i_ctx_p, buffer, blen1) >= 0) {\n        *pclen = blen1;\n        make_stream_file(pfile, s, \"r\");\n        return 0;\n      }\n      sclose(s);\n      return_error(e_invalidfileaccess);\n    }\n skip:;\n    return 1;\n}", "target": 1, "cwe": [], "message": "Bug 695711: Resolve issue with relative paths for FONTPATH\n\nCheck whether a \"lib\" file exists, and whether we are allowed to open it,\nbefore we try to open it.\n\nThis reverts \"\"starting_arg_file\" should only apply once.\" (commit\n407cc61e87b0fd9d44d72ca740af7d3c85dee78d).\n\nWhich caused problems with, for example, the \"-sFONTPATH=...\" option when the\npath is relative rather than absolute.\n\nNo cluster differences."}
{"func": "swproc(gs_main_instance * minst, const char *arg, arg_list * pal)\n{\n    char sw = arg[1];\n    ref vtrue;\n    int code = 0;\n#undef initial_enter_name\n#define initial_enter_name(nstr, pvalue)\\\n  i_initial_enter_name(minst->i_ctx_p, nstr, pvalue)\n\n    make_true(&vtrue);\n    arg += 2;                   /* skip - and letter */\n    switch (sw) {\n        default:\n            return 1;\n        case 0:         /* read stdin as a file char-by-char */\n            /* This is a ******HACK****** for Ghostview. */\n            minst->heap->gs_lib_ctx->stdin_is_interactive = true;\n            goto run_stdin;\n        case '_':       /* read stdin with normal buffering */\n            minst->heap->gs_lib_ctx->stdin_is_interactive = false;\nrun_stdin:\n            minst->run_start = false;   /* don't run 'start' */\n            /* Set NOPAUSE so showpage won't try to read from stdin. */\n            code = swproc(minst, \"-dNOPAUSE\", pal);\n            if (code)\n                return code;\n            code = gs_main_init2(minst);        /* Finish initialization */\n            if (code < 0)\n                return code;\n\n            code = run_string(minst, \".runstdin\", runFlush);\n            if (code < 0)\n                return code;\n            if (minst->saved_pages_test_mode) {\n                gx_device *pdev;\n\n                /* get the current device */\n                pdev = gs_currentdevice(minst->i_ctx_p->pgs);\n                if ((code = gx_saved_pages_param_process((gx_device_printer *)pdev,\n                           (byte *)\"print normal flush\", 18)) < 0)\n                    return code;\n                if (code > 0)\n                    if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0)\n                        return code;\n            }\n            break;\n        case '-':               /* run with command line args */\n            if (strncmp(arg, \"debug=\", 6) == 0) {\n                code = gs_debug_flags_parse(minst->heap, arg+6);\n                if (code < 0)\n                    return code;\n                break;\n            } else if (strncmp(arg, \"saved-pages=\", 12) == 0) {\n                gx_device *pdev;\n                gx_device_printer *ppdev;\n\n                /* If init2 not yet done, just save the argument for processing then */\n                if (minst->init_done < 2) {\n                    if (minst->saved_pages_initial_arg == NULL) {\n                        /* Tuck the parameters away for later when init2 is done */\n                        minst->saved_pages_initial_arg = (char *)arg+12;\n                    } else {\n                        outprintf(minst->heap,\n                                  \"   Only one --saved-pages=... command allowed before processing input\\n\");\n                        arg_finit(pal);\n                        return e_Fatal;\n                    }\n                } else {\n                    /* get the current device */\n                    pdev = gs_currentdevice(minst->i_ctx_p->pgs);\n                    if (dev_proc(pdev, dev_spec_op)(pdev, gxdso_supports_saved_pages, NULL, 0) == 0) {\n                        outprintf(minst->heap,\n                                  \"   --saved-pages not supported by the '%s' device.\\n\",\n                                  pdev->dname);\n                        arg_finit(pal);\n                        return e_Fatal;\n                    }\n                    ppdev = (gx_device_printer *)pdev;\n                    code = gx_saved_pages_param_process(ppdev, (byte *)arg+12, strlen(arg+12));\n                    if (code > 0)\n                        if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0)\n                            return code;\n                }\n                break;\n            /* The following code is only to allow regression testing of saved-pages */\n            } else if (strncmp(arg, \"saved-pages-test\", 16) == 0) {\n                minst->saved_pages_test_mode = true;\n                break;\n            }\n            /* FALLTHROUGH */\n        case '+':\n            pal->expand_ats = false;\n            /* FALLTHROUGH */\n        case '@':               /* ditto with @-expansion */\n            {\n                const char *psarg = arg_next(pal, &code, minst->heap);\n\n                if (code < 0)\n                    return e_Fatal;\n                if (psarg == 0) {\n                    outprintf(minst->heap, \"Usage: gs ... -%c file.ps arg1 ... argn\\n\", sw);\n                    arg_finit(pal);\n                    return e_Fatal;\n                }\n                psarg = arg_copy(psarg, minst->heap);\n                if (psarg == NULL)\n                    code = e_Fatal;\n                else\n                    code = gs_main_init2(minst);\n                if (code >= 0)\n                    code = run_string(minst, \"userdict/ARGUMENTS[\", 0);\n                if (code >= 0)\n                    while ((arg = arg_next(pal, &code, minst->heap)) != 0) {\n                        code = runarg(minst, \"\", arg, \"\", runInit);\n                        if (code < 0)\n                            break;\n                    }\n                if (code >= 0)\n                    code = runarg(minst, \"]put\", psarg, \".runfile\", runInit | runFlush);\n                arg_free((char *)psarg, minst->heap);\n                if (code >= 0)\n                    code = e_Quit;\n                \n                return code;\n            }\n        case 'A':               /* trace allocator */\n            switch (*arg) {\n                case 0:\n                    gs_alloc_debug = 1;\n                    break;\n                case '-':\n                    gs_alloc_debug = 0;\n                    break;\n                default:\n                    puts(minst->heap, \"-A may only be followed by -\");\n                    return e_Fatal;\n            }\n            break;\n        case 'B':               /* set run_string buffer size */\n            if (*arg == '-')\n                minst->run_buffer_size = 0;\n            else {\n                uint bsize;\n\n                if (sscanf((const char *)arg, \"%u\", &bsize) != 1 ||\n                    bsize <= 0 || bsize > MAX_BUFFERED_SIZE\n                    ) {\n                    outprintf(minst->heap,\n                              \"-B must be followed by - or size between 1 and %u\\n\",\n                              MAX_BUFFERED_SIZE);\n                    return e_Fatal;\n                }\n                minst->run_buffer_size = bsize;\n            }\n            break;\n        case 'c':               /* code follows */\n            {\n                bool ats = pal->expand_ats;\n\n                code = gs_main_init2(minst);\n                if (code < 0)\n                    return code;\n                pal->expand_ats = false;\n                while ((arg = arg_next(pal, &code, minst->heap)) != 0) {\n                    if (arg[0] == '@' ||\n                        (arg[0] == '-' && !isdigit((unsigned char)arg[1]))\n                        )\n                        break;\n                    code = runarg(minst, \"\", arg, \".runstring\", runBuffer);\n                    if (code < 0)\n                        return code;\n                }\n                if (code < 0)\n                    return e_Fatal;\n                if (arg != 0) {\n                    char *p = arg_copy(arg, minst->heap);\n                    if (p == NULL)\n                        return e_Fatal;\n                    arg_push_string(pal, p, true);\n                }\n                pal->expand_ats = ats;\n                break;\n            }\n        case 'E':               /* log errors */\n            switch (*arg) {\n                case 0:\n                    gs_log_errors = 1;\n                    break;\n                case '-':\n                    gs_log_errors = 0;\n                    break;\n                default:\n                    puts(minst->heap, \"-E may only be followed by -\");\n                    return e_Fatal;\n            }\n            break;\n        case 'f':               /* run file of arbitrary name */\n            if (*arg != 0) {\n                code = argproc(minst, arg);\n                if (code < 0)\n                    return code;\n                if (minst->saved_pages_test_mode) {\n                    gx_device *pdev;\n\n                    /* get the current device */\n                    pdev = gs_currentdevice(minst->i_ctx_p->pgs);\n                        return code;\n                    if ((code = gx_saved_pages_param_process((gx_device_printer *)pdev,\n                               (byte *)\"print normal flush\", 18)) < 0)\n                        return code;\n                    if (code > 0)\n                        if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0)\n                            return code;\n                }\n            }\n            break;\n        case 'F':               /* run file with buffer_size = 1 */\n            if (!*arg) {\n                puts(minst->heap, \"-F requires a file name\");\n                return e_Fatal;\n            } {\n                uint bsize = minst->run_buffer_size;\n\n                minst->run_buffer_size = 1;\n                code = argproc(minst, arg);\n                minst->run_buffer_size = bsize;\n                if (code < 0)\n                    return code;\n                if (minst->saved_pages_test_mode) {\n                    gx_device *pdev;\n\n                    /* get the current device */\n                    pdev = gs_currentdevice(minst->i_ctx_p->pgs);\n                    if ((code = gx_saved_pages_param_process((gx_device_printer *)pdev,\n                               (byte *)\"print normal flush\", 18)) < 0)\n                        return code;\n                    if (code > 0)\n                        if ((code = gs_erasepage(minst->i_ctx_p->pgs)) < 0)\n                            return code;\n                }\n            }\n            break;\n        case 'g':               /* define device geometry */\n            {\n                long width, height;\n                ref value;\n\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                if (sscanf((const char *)arg, \"%ldx%ld\", &width, &height) != 2) {\n                    puts(minst->heap, \"-g must be followed by <width>x<height>\");\n                    return e_Fatal;\n                }\n                make_int(&value, width);\n                initial_enter_name(\"DEVICEWIDTH\", &value);\n                make_int(&value, height);\n                initial_enter_name(\"DEVICEHEIGHT\", &value);\n                initial_enter_name(\"FIXEDMEDIA\", &vtrue);\n                break;\n            }\n        case 'h':               /* print help */\n        case '?':               /* ditto */\n            print_help(minst);\n            return e_Info;      /* show usage info on exit */\n        case 'I':               /* specify search path */\n            {\n                const char *path;\n\n                if (arg[0] == 0) {\n                    path = arg_next(pal, &code, minst->heap);\n                    if (code < 0)\n                        return code;\n                } else\n                    path = arg;\n                if (path == NULL)\n                    return e_Fatal;\n                path = arg_copy(path, minst->heap);\n                if (path == NULL)\n                    return e_Fatal;\n                gs_main_add_lib_path(minst, path);\n            }\n            break;\n        case 'K':               /* set malloc limit */\n            {\n                long msize = 0;\n                gs_malloc_memory_t *rawheap = gs_malloc_wrapped_contents(minst->heap);\n\n                sscanf((const char *)arg, \"%ld\", &msize);\n                if (msize <= 0 || msize > max_long >> 10) {\n                    outprintf(minst->heap, \"-K<numK> must have 1 <= numK <= %ld\\n\",\n                              max_long >> 10);\n                    return e_Fatal;\n                }\n                rawheap->limit = msize << 10;\n            }\n            break;\n        case 'M':               /* set memory allocation increment */\n            {\n                unsigned msize = 0;\n\n                sscanf((const char *)arg, \"%u\", &msize);\n#if ARCH_INTS_ARE_SHORT\n                if (msize <= 0 || msize >= 64) {\n                    puts(minst->heap, \"-M must be between 1 and 63\");\n                    return e_Fatal;\n                }\n#endif\n                minst->memory_chunk_size = msize << 10;\n            }\n            break;\n        case 'N':               /* set size of name table */\n            {\n                unsigned nsize = 0;\n\n                sscanf((const char *)arg, \"%d\", &nsize);\n#if ARCH_INTS_ARE_SHORT\n                if (nsize < 2 || nsize > 64) {\n                    puts(minst->heap, \"-N must be between 2 and 64\");\n                    return e_Fatal;\n                }\n#endif\n                minst->name_table_size = (ulong) nsize << 10;\n            }\n            break;\n        case 'o':               /* set output file name and batch mode */\n            {\n                const char *adef;\n                char *str;\n                ref value;\n                int len;\n\n                if (arg[0] == 0) {\n                    adef = arg_next(pal, &code, minst->heap);\n                    if (code < 0)\n                        return code;\n                } else\n                    adef = arg;\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                len = strlen(adef);\n                str = (char *)gs_alloc_bytes(minst->heap, (uint)len, \"-o\");\n                if (str == NULL)\n                    return e_VMerror;\n                memcpy(str, adef, len);\n                make_const_string(&value, a_readonly | avm_foreign,\n                                  len, (const byte *)str);\n                initial_enter_name(\"OutputFile\", &value);\n                initial_enter_name(\"NOPAUSE\", &vtrue);\n                initial_enter_name(\"BATCH\", &vtrue);\n            }\n            break;\n        case 'P':               /* choose whether search '.' first */\n            if (!strcmp(arg, \"\"))\n                minst->search_here_first = true;\n            else if (!strcmp(arg, \"-\"))\n                minst->search_here_first = false;\n            else {\n                puts(minst->heap, \"Only -P or -P- is allowed.\");\n                return e_Fatal;\n            }\n            break;\n        case 'q':               /* quiet startup */\n            if ((code = gs_main_init1(minst)) < 0)\n                return code;\n            initial_enter_name(\"QUIET\", &vtrue);\n            break;\n        case 'r':               /* define device resolution */\n            {\n                float xres, yres;\n                ref value;\n\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                switch (sscanf((const char *)arg, \"%fx%f\", &xres, &yres)) {\n                    default:\n                        puts(minst->heap, \"-r must be followed by <res> or <xres>x<yres>\");\n                        return e_Fatal;\n                    case 1:     /* -r<res> */\n                        yres = xres;\n                    case 2:     /* -r<xres>x<yres> */\n                        make_real(&value, xres);\n                        initial_enter_name(\"DEVICEXRESOLUTION\", &value);\n                        make_real(&value, yres);\n                        initial_enter_name(\"DEVICEYRESOLUTION\", &value);\n                        initial_enter_name(\"FIXEDRESOLUTION\", &vtrue);\n                }\n                break;\n            }\n        case 'D':               /* define name */\n        case 'd':\n        case 'S':               /* define name as string */\n        case 's':\n            {\n                char *adef = arg_copy(arg, minst->heap);\n                char *eqp;\n                bool isd = (sw == 'D' || sw == 'd');\n                ref value;\n\n                if (adef == NULL)\n                    return e_Fatal;\n                eqp = strchr(adef, '=');\n\n                if (eqp == NULL)\n                    eqp = strchr(adef, '#');\n                /* Initialize the object memory, scanner, and */\n                /* name table now if needed. */\n                if ((code = gs_main_init1(minst)) < 0)\n                    return code;\n                if (eqp == adef) {\n                    puts(minst->heap, \"Usage: -dNAME, -dNAME=TOKEN, -sNAME=STRING\");\n                    return e_Fatal;\n                }\n                if (eqp == NULL) {\n                    if (isd)\n                        make_true(&value);\n                    else\n                        make_empty_string(&value, a_readonly);\n                } else {\n                    int code;\n                    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n                    uint space = icurrent_space;\n\n                    *eqp++ = 0;\n                    ialloc_set_space(idmemory, avm_system);\n                    if (isd) {\n                        int num, i;\n\n                        /* Check for numbers so we can provide for suffix scalers */\n                        /* Note the check for '#' is for PS \"radix\" numbers such as 16#ff */\n                        /* and check for '.' and 'e' or 'E' which are 'real' numbers */\n                        if ((strchr(eqp, '#') == NULL) && (strchr(eqp, '.') == NULL) &&\n                            (strchr(eqp, 'e') == NULL) && (strchr(eqp, 'E') == NULL) &&\n                            ((i = sscanf((const char *)eqp, \"%d\", &num)) == 1)) {\n                            char suffix = eqp[strlen(eqp) - 1];\n\n                            switch (suffix) {\n                                case 'k':\n                                case 'K':\n                                    num *= 1024;\n                                    break;\n                                case 'm':\n                                case 'M':\n                                    num *= 1024 * 1024;\n                                    break;\n                                case 'g':\n                                case 'G':\n                                    /* caveat emptor: more than 2g will overflow */\n                                    /* and really should produce a 'real', so don't do this */\n                                    num *= 1024 * 1024 * 1024;\n                                    break;\n                                default:\n                                    break;   /* not a valid suffix or last char was digit */\n                            }\n                            make_int(&value, num);\n                        } else {\n                            /* use the PS scanner to capture other valid token types */\n                            stream astream;\n                            scanner_state state;\n\n                            s_init(&astream, NULL);\n                            sread_string(&astream,\n                                         (const byte *)eqp, strlen(eqp));\n                            gs_scanner_init_stream(&state, &astream);\n                            code = gs_scan_token(minst->i_ctx_p, &value, &state);\n                            if (code) {\n                                outprintf(minst->heap, \"Invalid value for option -d%s, -dNAME= must be followed by a valid token\\n\", arg);\n                                return e_Fatal;\n                            }\n                            if (r_has_type_attrs(&value, t_name,\n                                                 a_executable)) {\n                                ref nsref;\n\n                                name_string_ref(minst->heap, &value, &nsref);\n#undef string_is\n#define string_is(nsref, str, len)\\\n       (r_size(&(nsref)) == (len) &&\\\n       !strncmp((const char *)(nsref).value.const_bytes, str, (len)))\n                                if (string_is(nsref, \"null\", 4))\n                                    make_null(&value);\n                                else if (string_is(nsref, \"true\", 4))\n                                    make_true(&value);\n                                else if (string_is(nsref, \"false\", 5))\n                                    make_false(&value);\n                                else {\n                                    outprintf(minst->heap, \"Invalid value for option -d%s, use -sNAME= to define string constants\\n\", arg);\n                                    return e_Fatal;\n                                }\n                            }\n                        }\n                    } else {\n                        int len = strlen(eqp);\n                        char *str =\n                        (char *)gs_alloc_bytes(minst->heap,\n                                               (uint) len, \"-s\");\n\n                        if (str == 0) {\n                            lprintf(\"Out of memory!\\n\");\n                            return e_Fatal;\n                        }\n                        memcpy(str, eqp, len);\n                        make_const_string(&value,\n                                          a_readonly | avm_foreign,\n                                          len, (const byte *)str);\n                        if ((code = try_stdout_redirect(minst, adef, eqp)) < 0)\n                            return code;\n                    }\n                    ialloc_set_space(idmemory, space);\n                }\n                /* Enter the name in systemdict. */\n                initial_enter_name(adef, &value);\n                break;\n            }\n        case 'T':\n            set_debug_flags(arg, vd_flags);\n            break;\n        case 'u':               /* undefine name */\n            if (!*arg) {\n                puts(minst->heap, \"-u requires a name to undefine.\");\n                return e_Fatal;\n            }\n            if ((code = gs_main_init1(minst)) < 0)\n                return code;\n            i_initial_remove_name(minst->i_ctx_p, arg);\n            break;\n        case 'v':               /* print revision */\n            print_revision(minst);\n            return e_Info;\n/*#ifdef DEBUG */\n            /*\n             * Here we provide a place for inserting debugging code that can be\n             * run in place of the normal interpreter code.\n             */\n        case 'X':\n            code = gs_main_init2(minst);\n            if (code < 0)\n                return code;\n            {\n                int xec;        /* exit_code */\n                ref xeo;        /* error_object */\n\n#define start_x()\\\n  gs_main_run_string_begin(minst, 1, &xec, &xeo)\n#define run_x(str)\\\n  gs_main_run_string_continue(minst, str, strlen(str), 1, &xec, &xeo)\n#define stop_x()\\\n  gs_main_run_string_end(minst, 1, &xec, &xeo)\n                start_x();\n                run_x(\"\\216\\003abc\");\n                run_x(\"== flush\\n\");\n                stop_x();\n            }\n            return e_Quit;\n/*#endif */\n        case 'Z':\n            set_debug_flags(arg, gs_debug);\n            break;\n    }\n    return 0;\n}", "target": 1, "cwe": [], "message": "Bug 695711: Resolve issue with relative paths for FONTPATH\n\nCheck whether a \"lib\" file exists, and whether we are allowed to open it,\nbefore we try to open it.\n\nThis reverts \"\"starting_arg_file\" should only apply once.\" (commit\n407cc61e87b0fd9d44d72ca740af7d3c85dee78d).\n\nWhich caused problems with, for example, the \"-sFONTPATH=...\" option when the\npath is relative rather than absolute.\n\nNo cluster differences."}
{"func": "runarg(gs_main_instance * minst, const char *pre, const char *arg,\n       const char *post, int options)\n{\n    int len = strlen(pre) + esc_strlen(arg) + strlen(post) + 1;\n    int code;\n    char *line;\n\n    if (options & runInit) {\n        code = gs_main_init2(minst);    /* Finish initialization */\n\n        if (code < 0)\n            return code;\n    }\n    line = (char *)gs_alloc_bytes(minst->heap, len, \"runarg\");\n    if (line == 0) {\n        lprintf(\"Out of memory!\\n\");\n        return_error(e_VMerror);\n    }\n    strcpy(line, pre);\n    esc_strcat(line, arg);\n    strcat(line, post);\n    /* If we're running PS from a buffer (i.e. from the \"-c\" option\n       we don't want lib_file_open() to search the current directory\n       during this call to run_string()\n     */\n    if ((options & runBuffer)) {\n        minst->i_ctx_p->starting_arg_file = false;\n    }\n    else {\n        minst->i_ctx_p->starting_arg_file = true;\n    }\n    code = run_string(minst, line, options);\n    minst->i_ctx_p->starting_arg_file = false;\n    gs_free_object(minst->heap, line, \"runarg\");\n    return code;\n}", "target": 1, "cwe": [], "message": "Bug 695711: Resolve issue with relative paths for FONTPATH\n\nCheck whether a \"lib\" file exists, and whether we are allowed to open it,\nbefore we try to open it.\n\nThis reverts \"\"starting_arg_file\" should only apply once.\" (commit\n407cc61e87b0fd9d44d72ca740af7d3c85dee78d).\n\nWhich caused problems with, for example, the \"-sFONTPATH=...\" option when the\npath is relative rather than absolute.\n\nNo cluster differences."}
{"func": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\n\tinotify_enabled = 1;\n}", "target": 1, "cwe": ["CWE-200"], "message": "Revert \"Cronie disables inotify support when the /etc/crontab file does not exist at startup.\"\n\nThis reverts commit acdf4ae8456888ed78201906ef528f4c28f54582 as it introduces\nfd leaks."}
{"func": "int main(void)\n{\n\tint fd, len, sock_opt;\n\tint error;\n\tstruct cn_msg *message;\n\tstruct pollfd pfd;\n\tstruct nlmsghdr *incoming_msg;\n\tstruct cn_msg\t*incoming_cn_msg;\n\tstruct hv_kvp_msg *hv_msg;\n\tchar\t*p;\n\tchar\t*key_value;\n\tchar\t*key_name;\n\n\tdaemon(1, 0);\n\topenlog(\"KVP\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"KVP starting; pid is:%d\", getpid());\n\t/*\n\t * Retrieve OS release information.\n\t */\n\tkvp_get_os_info();\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, \"Failed to initialize the pools\");\n\t\texit(-1);\n\t}\n\n\tfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (fd < 0) {\n\t\tsyslog(LOG_ERR, \"netlink socket creation failed; error:%d\", fd);\n\t\texit(-1);\n\t}\n\taddr.nl_family = AF_NETLINK;\n\taddr.nl_pad = 0;\n\taddr.nl_pid = 0;\n\taddr.nl_groups = CN_KVP_IDX;\n\n\n\terror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\n\tif (error < 0) {\n\t\tsyslog(LOG_ERR, \"bind failed; error:%d\", error);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\tsock_opt = addr.nl_groups;\n\tsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\n\t/*\n\t * Register ourselves with the kernel.\n\t */\n\tmessage = (struct cn_msg *)kvp_send_buffer;\n\tmessage->id.idx = CN_KVP_IDX;\n\tmessage->id.val = CN_KVP_VAL;\n\n\thv_msg = (struct hv_kvp_msg *)message->data;\n\thv_msg->kvp_hdr.operation = KVP_OP_REGISTER;\n\tmessage->ack = 0;\n\tmessage->len = sizeof(struct hv_kvp_msg);\n\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:\n\t\t\t/*\n\t\t\t * Driver is registering with us; stash away the version\n\t\t\t * information.\n\t\t\t */\n\t\t\tp = (char *)hv_msg->body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, \"KVP LIC Version: %s\",\n\t\t\t\t\tlic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The current protocol with the kernel component uses a\n\t\t * NULL key name to pass an error condition.\n\t\t * For the SET, GET and DELETE operations,\n\t\t * use the existing protocol to pass back error.\n\t\t */\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_set.data.key, \"\");\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_delete.key,\n\t\t\t\t\thv_msg->body.kvp_delete.key_size))\n\t\t\t\tstrcpy(hv_msg->body.kvp_delete.key, \"\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t/*\n\t\t * If the pool is KVP_POOL_AUTO, dynamically generate\n\t\t * both the key and the value; if not read from the\n\t\t * appropriate pool.\n\t\t */\n\t\tif (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) {\n\t\t\tkvp_pool_enumerate(hv_msg->kvp_hdr.pool,\n\t\t\t\t\thv_msg->body.kvp_enum_data.index,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\t\tkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg->body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tkvp_get_domain_name(key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"FullyQualifiedDomainName\");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, \"IntegrationServicesVersion\");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_address(AF_INET, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv4\");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_address(AF_INET6, key_value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv6\");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSBuildNumber\");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, \"OSName\");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, \"OSMajorVersion\");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, \"OSMinorVersion\");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSVersion\");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, \"ProcessorArchitecture\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(key_value, \"Unknown Key\");\n\t\t\t/*\n\t\t\t * We use a null key name to terminate enumeration.\n\t\t\t */\n\t\t\tstrcpy(key_name, \"\");\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Send the value back to the kernel. The response is\n\t\t * already in the receive buffer. Update the cn_msg header to\n\t\t * reflect the key value that has been added to the message\n\t\t */\nkvp_done:\n\n\t\tincoming_cn_msg->id.idx = CN_KVP_IDX;\n\t\tincoming_cn_msg->id.val = CN_KVP_VAL;\n\t\tincoming_cn_msg->ack = 0;\n\t\tincoming_cn_msg->len = sizeof(struct hv_kvp_msg);\n\n\t\tlen = netlink_send(fd, incoming_cn_msg);\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"net_link send failed; error:%d\", len);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n}", "target": 1, "cwe": ["CWE-20"], "message": "Tools: hv: verify origin of netlink connector message\n\nThe SuSE security team suggested to use recvfrom instead of recv to be\ncertain that the connector message is originated from kernel.\n\nCVE-2012-2669\n\nSigned-off-by: Olaf Hering <olaf@aepfle.de>\nSigned-off-by: Marcus Meissner <meissner@suse.de>\nSigned-off-by: Sebastian Krahmer <krahmer@suse.de>\nSigned-off-by: K. Y. Srinivasan <kys@microsoft.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"}
{"func": "build_object (GoaProvider         *provider,\n              GoaObjectSkeleton   *object,\n              GKeyFile            *key_file,\n              const gchar         *group,\n              GDBusConnection     *connection,\n              gboolean             just_added,\n              GError             **error)\n{\n  GoaAccount *account;\n  GoaCalendar *calendar;\n  GoaContacts *contacts;\n  GoaFiles *files;\n  GoaPasswordBased *password_based;\n  SoupURI *uri;\n  gboolean calendar_enabled;\n  gboolean contacts_enabled;\n  gboolean files_enabled;\n  gboolean ret;\n  const gchar *identity;\n  gchar *uri_string;\n\n  account = NULL;\n  calendar = NULL;\n  contacts = NULL;\n  files = NULL;\n  password_based = NULL;\n  uri = NULL;\n  uri_string = NULL;\n\n  ret = FALSE;\n\n  /* Chain up */\n  if (!GOA_PROVIDER_CLASS (goa_owncloud_provider_parent_class)->build_object (provider,\n                                                                              object,\n                                                                              key_file,\n                                                                              group,\n                                                                              connection,\n                                                                              just_added,\n                                                                              error))\n    goto out;\n\n  password_based = goa_object_get_password_based (GOA_OBJECT (object));\n  if (password_based == NULL)\n    {\n      password_based = goa_password_based_skeleton_new ();\n      /* Ensure D-Bus method invocations run in their own thread */\n      g_dbus_interface_skeleton_set_flags (G_DBUS_INTERFACE_SKELETON (password_based),\n                                           G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD);\n      goa_object_skeleton_set_password_based (object, password_based);\n      g_signal_connect (password_based,\n                        \"handle-get-password\",\n                        G_CALLBACK (on_handle_get_password),\n                        NULL);\n    }\n\n  account = goa_object_get_account (GOA_OBJECT (object));\n  identity = goa_account_get_identity (account);\n  uri_string = g_key_file_get_string (key_file, group, \"Uri\", NULL);\n  uri = soup_uri_new (uri_string);\n  if (uri != NULL)\n    soup_uri_set_user (uri, identity);\n\n  /* Calendar */\n  calendar = goa_object_get_calendar (GOA_OBJECT (object));\n  calendar_enabled = g_key_file_get_boolean (key_file, group, \"CalendarEnabled\", NULL);\n  if (calendar_enabled)\n    {\n      if (calendar == NULL)\n        {\n          gchar *uri_caldav;\n\n          uri_caldav = NULL;\n\n          if (uri != NULL)\n            {\n              gchar *uri_tmp;\n\n              uri_tmp = soup_uri_to_string (uri, FALSE);\n              uri_caldav = g_strconcat (uri_tmp, CALDAV_ENDPOINT, NULL);\n              g_free (uri_tmp);\n            }\n\n          calendar = goa_calendar_skeleton_new ();\n          g_object_set (G_OBJECT (calendar), \"uri\", uri_caldav, NULL);\n          goa_object_skeleton_set_calendar (object, calendar);\n          g_free (uri_caldav);\n        }\n    }\n  else\n    {\n      if (calendar != NULL)\n        goa_object_skeleton_set_calendar (object, NULL);\n    }\n\n  /* Contacts */\n  contacts = goa_object_get_contacts (GOA_OBJECT (object));\n  contacts_enabled = g_key_file_get_boolean (key_file, group, \"ContactsEnabled\", NULL);\n  if (contacts_enabled)\n    {\n      if (contacts == NULL)\n        {\n          gchar *uri_carddav;\n\n          uri_carddav = NULL;\n\n          if (uri != NULL)\n            {\n              gchar *uri_tmp;\n\n              uri_tmp = soup_uri_to_string (uri, FALSE);\n              uri_carddav = g_strconcat (uri_tmp, CARDDAV_ENDPOINT, NULL);\n              g_free (uri_tmp);\n            }\n\n          contacts = goa_contacts_skeleton_new ();\n          g_object_set (G_OBJECT (contacts), \"uri\", uri_carddav, NULL);\n          goa_object_skeleton_set_contacts (object, contacts);\n          g_free (uri_carddav);\n        }\n    }\n  else\n    {\n      if (contacts != NULL)\n        goa_object_skeleton_set_contacts (object, NULL);\n    }\n\n  /* Files */\n  files = goa_object_get_files (GOA_OBJECT (object));\n  files_enabled = g_key_file_get_boolean (key_file, group, \"FilesEnabled\", NULL);\n  if (files_enabled)\n    {\n      if (files == NULL)\n        {\n          gchar *uri_webdav;\n\n          uri_webdav = NULL;\n\n          if (uri != NULL)\n            {\n              const gchar *scheme;\n              gchar *uri_tmp;\n\n              scheme = soup_uri_get_scheme (uri);\n              if (g_strcmp0 (scheme, SOUP_URI_SCHEME_HTTPS) == 0)\n                soup_uri_set_scheme (uri, \"davs\");\n              else\n                soup_uri_set_scheme (uri, \"dav\");\n\n              uri_tmp = soup_uri_to_string (uri, FALSE);\n              uri_webdav = g_strconcat (uri_tmp, WEBDAV_ENDPOINT, NULL);\n              g_free (uri_tmp);\n            }\n\n          files = goa_files_skeleton_new ();\n          g_object_set (G_OBJECT (files), \"uri\", uri_webdav, NULL);\n          goa_object_skeleton_set_files (object, files);\n          g_free (uri_webdav);\n        }\n    }\n  else\n    {\n      if (files != NULL)\n        goa_object_skeleton_set_files (object, NULL);\n    }\n\n  if (just_added)\n    {\n      goa_account_set_calendar_disabled (account, !calendar_enabled);\n      goa_account_set_contacts_disabled (account, !contacts_enabled);\n      goa_account_set_files_disabled (account, !files_enabled);\n\n      g_signal_connect (account,\n                        \"notify::calendar-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"CalendarEnabled\");\n      g_signal_connect (account,\n                        \"notify::contacts-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"ContactsEnabled\");\n      g_signal_connect (account,\n                        \"notify::files-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"FilesEnabled\");\n    }\n\n  ret = TRUE;\n\n out:\n  g_clear_object (&calendar);\n  g_clear_object (&contacts);\n  g_clear_object (&files);\n  g_clear_object (&password_based);\n  g_clear_pointer (&uri, (GDestroyNotify *) soup_uri_free);\n  g_free (uri_string);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "ews_client_autodiscover_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  AutodiscoverData *data = user_data;\n  gboolean op_res;\n  guint status;\n  gint idx;\n  gsize size;\n  xmlDoc *doc;\n  xmlNode *node;\n\n  status = msg->status_code;\n  if (status == SOUP_STATUS_NONE)\n    return;\n\n  error = NULL;\n  op_res = FALSE;\n  size = sizeof (data->msgs) / sizeof (data->msgs[0]);\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] == msg)\n        break;\n    }\n  if (idx == size)\n    return;\n\n  data->msgs[idx] = NULL;\n\n  if (status == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (status != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   status);\n      goto out;\n    }\n\n  soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->response_body));\n  g_debug (\"The response headers\");\n  g_debug (\"===================\");\n  g_debug (\"%s\", SOUP_MESSAGE (msg)->response_body->data);\n\n  doc = xmlReadMemory (msg->response_body->data, msg->response_body->length, \"autodiscover.xml\", NULL, 0);\n  if (doc == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to parse autodiscover response XML\"));\n      goto out;\n    }\n\n  node = xmlDocGetRootElement (doc);\n  if (g_strcmp0 ((gchar *) node->name, \"Autodiscover\"))\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Autodiscover element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Response\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Response element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Account\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Account element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Protocol\"))\n        {\n          op_res = ews_client_autodiscover_parse_protocol (node);\n          break;\n        }\n    }\n  if (!op_res)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific*/\n                   _(\"Failed to find ASUrl and OABUrl in autodiscover response\"));\n      goto out;\n    }\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] != NULL)\n        {\n          /* Since we are cancelling from the same thread that we queued the\n           * message, the callback (ie. this function) will be invoked before\n           * soup_session_cancel_message returns.\n           */\n          soup_session_cancel_message (data->session, data->msgs[idx], SOUP_STATUS_NONE);\n          data->msgs[idx] = NULL;\n        }\n    }\n\n out:\n  /* error == NULL, if we are being aborted by the GCancellable */\n  if (!op_res)\n    {\n      for (idx = 0; idx < size; idx++)\n        {\n          if (data->msgs[idx] != NULL)\n            {\n              /* There's another request outstanding.\n               * Hope that it has better luck.\n               */\n              g_clear_error (&error);\n              return;\n            }\n        }\n      if (error != NULL)\n        g_simple_async_result_take_error (data->res, error);\n    }\n\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (ews_client_autodiscover_data_free, data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  gboolean op_res;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_ews_client_autodiscover (GoaEwsClient        *client,\n                             const gchar         *email,\n                             const gchar         *password,\n                             const gchar         *username,\n                             const gchar         *server,\n                             GCancellable        *cancellable,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)\n{\n  AutodiscoverData *data;\n  AutodiscoverAuthData *auth;\n  gchar *url1;\n  gchar *url2;\n  xmlDoc *doc;\n  xmlOutputBuffer *buf;\n\n  g_return_if_fail (GOA_IS_EWS_CLIENT (client));\n  g_return_if_fail (email != NULL || email[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (server != NULL || server[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  doc = ews_client_create_autodiscover_xml (email);\n  buf = xmlAllocOutputBuffer (NULL);\n  xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);\n  xmlOutputBufferFlush (buf);\n\n  url1 = g_strdup_printf (\"https://%s/autodiscover/autodiscover.xml\", server);\n  url2 = g_strdup_printf (\"https://autodiscover.%s/autodiscover/autodiscover.xml\", server);\n\n  /* http://msdn.microsoft.com/en-us/library/ee332364.aspx says we are\n   * supposed to try $domain and then autodiscover.$domain. But some\n   * people have broken firewalls on the former which drop packets\n   * instead of rejecting connections, and make the request take ages\n   * to time out. So run both queries in parallel and let the fastest\n   * (successful) one win.\n   */\n  data = g_slice_new0 (AutodiscoverData);\n  data->buf = buf;\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_ews_client_autodiscover);\n  data->msgs[0] = ews_client_create_msg_for_url (url1, buf);\n  data->msgs[1] = ews_client_create_msg_for_url (url2, buf);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_USE_NTLM, TRUE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (ews_client_autodiscover_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (AutodiscoverAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (ews_client_authenticate),\n                         auth,\n                         ews_client_autodiscover_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n  soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n\n  g_free (url2);\n  g_free (url1);\n  xmlFreeDoc (doc);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "refresh_account (GoaProvider    *provider,\n                 GoaClient      *client,\n                 GoaObject      *object,\n                 GtkWindow      *parent,\n                 GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder builder;\n  GoaAccount *account;\n  GoaHttpClient *http_client;\n  GtkWidget *dialog;\n  GtkWidget *vbox;\n  gboolean ret;\n  const gchar *password;\n  const gchar *username;\n  gchar *uri;\n  gchar *uri_webdav;\n  gint response;\n\n  g_return_val_if_fail (GOA_IS_OWNCLOUD_PROVIDER (provider), FALSE);\n  g_return_val_if_fail (GOA_IS_CLIENT (client), FALSE);\n  g_return_val_if_fail (GOA_IS_OBJECT (object), FALSE);\n  g_return_val_if_fail (parent == NULL || GTK_IS_WINDOW (parent), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  http_client = NULL;\n  uri = NULL;\n  uri_webdav = NULL;\n\n  ret = FALSE;\n\n  dialog = gtk_dialog_new_with_buttons (NULL,\n                                        parent,\n                                        GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n                                        NULL);\n  gtk_container_set_border_width (GTK_CONTAINER (dialog), 12);\n  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);\n  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n  vbox = gtk_dialog_get_content_area (GTK_DIALOG (dialog));\n  gtk_box_set_spacing (GTK_BOX (vbox), 12);\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.cancellable = g_cancellable_new ();\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = GTK_DIALOG (dialog);\n  data.error = NULL;\n\n  create_account_details_ui (provider, GTK_DIALOG (dialog), GTK_BOX (vbox), FALSE, &data);\n\n  uri = goa_util_lookup_keyfile_string (object, \"Uri\");\n  gtk_entry_set_text (GTK_ENTRY (data.uri), uri);\n  gtk_editable_set_editable (GTK_EDITABLE (data.uri), FALSE);\n\n  account = goa_object_peek_account (object);\n  username = goa_account_get_identity (account);\n  gtk_entry_set_text (GTK_ENTRY (data.username), username);\n  gtk_editable_set_editable (GTK_EDITABLE (data.username), FALSE);\n\n  gtk_widget_show_all (dialog);\n  g_signal_connect (dialog, \"response\", G_CALLBACK (dialog_response_cb), &data);\n\n  http_client = goa_http_client_new ();\n  uri_webdav = g_strconcat (uri, WEBDAV_ENDPOINT, NULL);\n\n http_again:\n  response = gtk_dialog_run (GTK_DIALOG (dialog));\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  g_cancellable_reset (data.cancellable);\n  goa_http_client_check (http_client,\n                         uri_webdav,\n                         username,\n                         password,\n                         data.cancellable,\n                         check_cb,\n                         &data);\n  gtk_widget_set_sensitive (data.connect_button, FALSE);\n  gtk_widget_show (data.progress_grid);\n  g_main_loop_run (data.loop);\n\n  if (g_cancellable_is_cancelled (data.cancellable))\n    {\n      g_prefix_error (&data.error,\n                      _(\"Dialog was dismissed (%s, %d): \"),\n                      g_quark_to_string (data.error->domain),\n                      data.error->code);\n      data.error->domain = GOA_ERROR;\n      data.error->code = GOA_ERROR_DIALOG_DISMISSED;\n      goto out;\n    }\n  else if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to ownCloud server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      gtk_button_set_label (GTK_BUTTON (data.connect_button), _(\"_Try Again\"));\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto http_again;\n    }\n\n  /* TODO: run in worker thread */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&builder, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  if (!goa_utils_store_credentials_for_object_sync (provider,\n                                                    object,\n                                                    g_variant_builder_end (&builder),\n                                                    NULL, /* GCancellable */\n                                                    &data.error))\n    goto out;\n\n  goa_account_call_ensure_credentials (account,\n                                       NULL, /* GCancellable */\n                                       NULL, NULL); /* callback, user_data */\n\n  ret = TRUE;\n\n out:\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n\n  gtk_widget_destroy (dialog);\n  g_free (uri);\n  g_free (uri_webdav);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  g_clear_object (&data.cancellable);\n  g_clear_object (&http_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "add_account (GoaProvider    *provider,\n             GoaClient      *client,\n             GtkDialog      *dialog,\n             GtkBox         *vbox,\n             GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder credentials;\n  GVariantBuilder details;\n  GoaHttpClient *http_client;\n  GoaObject *ret;\n  const gchar *uri_text;\n  const gchar *password;\n  const gchar *username;\n  const gchar *provider_type;\n  gchar *presentation_identity;\n  gchar *server;\n  gchar *uri;\n  gchar *uri_webdav;\n  gint response;\n\n  http_client = NULL;\n  presentation_identity = NULL;\n  server = NULL;\n  uri = NULL;\n\n  ret = NULL;\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.cancellable = g_cancellable_new ();\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = dialog;\n  data.error = NULL;\n\n  create_account_details_ui (provider, dialog, vbox, TRUE, &data);\n  gtk_widget_show_all (GTK_WIDGET (vbox));\n  g_signal_connect (dialog, \"response\", G_CALLBACK (dialog_response_cb), &data);\n\n  http_client = goa_http_client_new ();\n\n http_again:\n  response = gtk_dialog_run (dialog);\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  uri_text = gtk_entry_get_text (GTK_ENTRY (data.uri));\n  username = gtk_entry_get_text (GTK_ENTRY (data.username));\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n\n  /* See if there's already an account of this type with the\n   * given identity\n   */\n  provider_type = goa_provider_get_provider_type (provider);\n  if (!goa_utils_check_duplicate (client,\n                                  username,\n                                  provider_type,\n                                  (GoaPeekInterfaceFunc) goa_object_peek_password_based,\n                                  &data.error))\n    goto out;\n\n  uri = normalize_uri (uri_text, &server);\n  uri_webdav = g_strconcat (uri, WEBDAV_ENDPOINT, NULL);\n  g_cancellable_reset (data.cancellable);\n  goa_http_client_check (http_client,\n                         uri_webdav,\n                         username,\n                         password,\n                         data.cancellable,\n                         check_cb,\n                         &data);\n  g_free (uri_webdav);\n\n  gtk_widget_set_sensitive (data.connect_button, FALSE);\n  gtk_widget_show (data.progress_grid);\n  g_main_loop_run (data.loop);\n\n  if (g_cancellable_is_cancelled (data.cancellable))\n    {\n      g_prefix_error (&data.error,\n                      _(\"Dialog was dismissed (%s, %d): \"),\n                      g_quark_to_string (data.error->domain),\n                      data.error->code);\n      data.error->domain = GOA_ERROR;\n      data.error->code = GOA_ERROR_DIALOG_DISMISSED;\n      goto out;\n    }\n  else if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to ownCloud server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      gtk_button_set_label (GTK_BUTTON (data.connect_button), _(\"_Try Again\"));\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n\n      g_clear_pointer (&server, g_free);\n      g_clear_pointer (&uri, g_free);\n      goto http_again;\n    }\n\n  gtk_widget_hide (GTK_WIDGET (dialog));\n\n  g_variant_builder_init (&credentials, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&credentials, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  g_variant_builder_init (&details, G_VARIANT_TYPE (\"a{ss}\"));\n  g_variant_builder_add (&details, \"{ss}\", \"CalendarEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"ContactsEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"FilesEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"Uri\", uri);\n\n  /* OK, everything is dandy, add the account */\n  /* we want the GoaClient to update before this method returns (so it\n   * can create a proxy for the new object) so run the mainloop while\n   * waiting for this to complete\n   */\n  presentation_identity = g_strconcat (username, \"@\", server, NULL);\n  goa_manager_call_add_account (goa_client_get_manager (client),\n                                goa_provider_get_provider_type (provider),\n                                username,\n                                presentation_identity,\n                                g_variant_builder_end (&credentials),\n                                g_variant_builder_end (&details),\n                                NULL, /* GCancellable* */\n                                (GAsyncReadyCallback) add_account_cb,\n                                &data);\n  g_main_loop_run (data.loop);\n  if (data.error != NULL)\n    goto out;\n\n  ret = GOA_OBJECT (g_dbus_object_manager_get_object (goa_client_get_object_manager (client),\n                                                      data.account_object_path));\n\n out:\n  /* We might have an object even when data.error is set.\n   * eg., if we failed to store the credentials in the keyring.\n   */\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n  else\n    g_assert (ret != NULL);\n\n  g_free (presentation_identity);\n  g_free (server);\n  g_free (uri);\n  g_free (data.account_object_path);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  g_clear_object (&data.cancellable);\n  g_clear_object (&http_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "build_object (GoaProvider         *provider,\n              GoaObjectSkeleton   *object,\n              GKeyFile            *key_file,\n              const gchar         *group,\n              GDBusConnection     *connection,\n              gboolean             just_added,\n              GError             **error)\n{\n  GoaAccount *account;\n  GoaCalendar *calendar;\n  GoaContacts *contacts;\n  GoaExchange *exchange;\n  GoaMail *mail;\n  GoaPasswordBased *password_based;\n  gboolean calendar_enabled;\n  gboolean contacts_enabled;\n  gboolean mail_enabled;\n  gboolean ret;\n\n  account = NULL;\n  calendar = NULL;\n  contacts = NULL;\n  exchange = NULL;\n  mail = NULL;\n  password_based = NULL;\n  ret = FALSE;\n\n  /* Chain up */\n  if (!GOA_PROVIDER_CLASS (goa_exchange_provider_parent_class)->build_object (provider,\n                                                                              object,\n                                                                              key_file,\n                                                                              group,\n                                                                              connection,\n                                                                              just_added,\n                                                                              error))\n    goto out;\n\n  password_based = goa_object_get_password_based (GOA_OBJECT (object));\n  if (password_based == NULL)\n    {\n      password_based = goa_password_based_skeleton_new ();\n      /* Ensure D-Bus method invocations run in their own thread */\n      g_dbus_interface_skeleton_set_flags (G_DBUS_INTERFACE_SKELETON (password_based),\n                                           G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD);\n      goa_object_skeleton_set_password_based (object, password_based);\n      g_signal_connect (password_based,\n                        \"handle-get-password\",\n                        G_CALLBACK (on_handle_get_password),\n                        NULL);\n    }\n\n  account = goa_object_get_account (GOA_OBJECT (object));\n\n  /* Email */\n  mail = goa_object_get_mail (GOA_OBJECT (object));\n  mail_enabled = g_key_file_get_boolean (key_file, group, \"MailEnabled\", NULL);\n  if (mail_enabled)\n    {\n      if (mail == NULL)\n        {\n          const gchar *email_address;\n\n          email_address = goa_account_get_presentation_identity (account);\n          mail = goa_mail_skeleton_new ();\n          g_object_set (G_OBJECT (mail), \"email-address\", email_address, NULL);\n          goa_object_skeleton_set_mail (object, mail);\n        }\n    }\n  else\n    {\n      if (mail != NULL)\n        goa_object_skeleton_set_mail (object, NULL);\n    }\n\n  /* Calendar */\n  calendar = goa_object_get_calendar (GOA_OBJECT (object));\n  calendar_enabled = g_key_file_get_boolean (key_file, group, \"CalendarEnabled\", NULL);\n  if (calendar_enabled)\n    {\n      if (calendar == NULL)\n        {\n          calendar = goa_calendar_skeleton_new ();\n          goa_object_skeleton_set_calendar (object, calendar);\n        }\n    }\n  else\n    {\n      if (calendar != NULL)\n        goa_object_skeleton_set_calendar (object, NULL);\n    }\n\n  /* Contacts */\n  contacts = goa_object_get_contacts (GOA_OBJECT (object));\n  contacts_enabled = g_key_file_get_boolean (key_file, group, \"ContactsEnabled\", NULL);\n  if (contacts_enabled)\n    {\n      if (contacts == NULL)\n        {\n          contacts = goa_contacts_skeleton_new ();\n          goa_object_skeleton_set_contacts (object, contacts);\n        }\n    }\n  else\n    {\n      if (contacts != NULL)\n        goa_object_skeleton_set_contacts (object, NULL);\n    }\n\n  /* Exchange */\n  exchange = goa_object_get_exchange (GOA_OBJECT (object));\n  if (exchange == NULL)\n    {\n      gchar *host;\n\n      host = g_key_file_get_string (key_file, group, \"Host\", NULL);\n      exchange = goa_exchange_skeleton_new ();\n      g_object_set (G_OBJECT (exchange), \"host\", host, NULL);\n      goa_object_skeleton_set_exchange (object, exchange);\n      g_free (host);\n    }\n\n  if (just_added)\n    {\n      goa_account_set_mail_disabled (account, !mail_enabled);\n      goa_account_set_calendar_disabled (account, !calendar_enabled);\n      goa_account_set_contacts_disabled (account, !contacts_enabled);\n\n      g_signal_connect (account,\n                        \"notify::mail-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"MailEnabled\");\n      g_signal_connect (account,\n                        \"notify::calendar-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"CalendarEnabled\");\n      g_signal_connect (account,\n                        \"notify::contacts-disabled\",\n                        G_CALLBACK (goa_util_account_notify_property_cb),\n                        \"ContactsEnabled\");\n    }\n\n  ret = TRUE;\n\n out:\n  if (exchange != NULL)\n    g_object_unref (exchange);\n  if (contacts != NULL)\n    g_object_unref (contacts);\n  if (calendar != NULL)\n    g_object_unref (calendar);\n  if (mail != NULL)\n    g_object_unref (mail);\n  if (password_based != NULL)\n    g_object_unref (password_based);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "ensure_credentials_sync (GoaProvider         *provider,\n                         GoaObject           *object,\n                         gint                *out_expires_in,\n                         GCancellable        *cancellable,\n                         GError             **error)\n{\n  GVariant *credentials;\n  GoaAccount *account;\n  GoaEwsClient *ews_client;\n  GoaExchange *exchange;\n  gboolean ret;\n  const gchar *email_address;\n  const gchar *server;\n  const gchar *username;\n  gchar *password;\n\n  credentials = NULL;\n  ews_client = NULL;\n  password = NULL;\n\n  ret = FALSE;\n\n  credentials = goa_utils_lookup_credentials_sync (provider,\n                                                   object,\n                                                   cancellable,\n                                                   error);\n  if (credentials == NULL)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error, _(\"Credentials not found in keyring (%s, %d): \"),\n                          g_quark_to_string ((*error)->domain), (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n  account = goa_object_peek_account (object);\n  email_address = goa_account_get_presentation_identity (account);\n  username = goa_account_get_identity (account);\n\n  if (!g_variant_lookup (credentials, \"password\", \"s\", &password))\n    {\n      if (error != NULL)\n        {\n          *error = g_error_new (GOA_ERROR,\n                                GOA_ERROR_NOT_AUTHORIZED,\n                                _(\"Did not find password with username `%s' in credentials\"),\n                                username);\n        }\n      goto out;\n    }\n\n  exchange = goa_object_peek_exchange (object);\n  server = goa_exchange_get_host (exchange);\n\n  ews_client = goa_ews_client_new ();\n  ret = goa_ews_client_autodiscover_sync (ews_client,\n                                          email_address,\n                                          password,\n                                          username,\n                                          server,\n                                          cancellable,\n                                          error);\n  if (!ret)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error,\n                          /* Translators: the first %s is the username\n                           * (eg., debarshi.ray@gmail.com or rishi), and the\n                           * (%s, %d) is the error domain and code.\n                           */\n                          _(\"Invalid password with username `%s' (%s, %d): \"),\n                          username,\n                          g_quark_to_string ((*error)->domain),\n                          (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n  if (out_expires_in != NULL)\n    *out_expires_in = 0;\n\n out:\n  if (ews_client != NULL)\n    g_object_unref (ews_client);\n  g_free (password);\n  if (credentials != NULL)\n    g_variant_unref (credentials);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "refresh_account (GoaProvider    *provider,\n                 GoaClient      *client,\n                 GoaObject      *object,\n                 GtkWindow      *parent,\n                 GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder builder;\n  GoaAccount *account;\n  GoaEwsClient *ews_client;\n  GoaExchange *exchange;\n  GtkWidget *dialog;\n  GtkWidget *vbox;\n  gboolean ret;\n  const gchar *email_address;\n  const gchar *server;\n  const gchar *password;\n  const gchar *username;\n  gint response;\n\n  g_return_val_if_fail (GOA_IS_EXCHANGE_PROVIDER (provider), FALSE);\n  g_return_val_if_fail (GOA_IS_CLIENT (client), FALSE);\n  g_return_val_if_fail (GOA_IS_OBJECT (object), FALSE);\n  g_return_val_if_fail (parent == NULL || GTK_IS_WINDOW (parent), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ews_client = NULL;\n  ret = FALSE;\n\n  dialog = gtk_dialog_new_with_buttons (NULL,\n                                        parent,\n                                        GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n                                        NULL);\n  gtk_container_set_border_width (GTK_CONTAINER (dialog), 12);\n  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);\n  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n  vbox = gtk_dialog_get_content_area (GTK_DIALOG (dialog));\n  gtk_box_set_spacing (GTK_BOX (vbox), 12);\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.cancellable = g_cancellable_new ();\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = GTK_DIALOG (dialog);\n  data.error = NULL;\n\n  create_account_details_ui (provider, GTK_DIALOG (dialog), GTK_BOX (vbox), FALSE, &data);\n\n  account = goa_object_peek_account (object);\n  email_address = goa_account_get_presentation_identity (account);\n  gtk_entry_set_text (GTK_ENTRY (data.email_address), email_address);\n  gtk_editable_set_editable (GTK_EDITABLE (data.email_address), FALSE);\n\n  gtk_widget_show_all (dialog);\n  g_signal_connect (dialog, \"response\", G_CALLBACK (dialog_response_cb), &data);\n\n  ews_client = goa_ews_client_new ();\n\n ews_again:\n  response = gtk_dialog_run (GTK_DIALOG (dialog));\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  username = goa_account_get_identity (account);\n\n  exchange = goa_object_peek_exchange (object);\n  server = goa_exchange_get_host (exchange);\n\n  g_cancellable_reset (data.cancellable);\n  goa_ews_client_autodiscover (ews_client,\n                               email_address,\n                               password,\n                               username,\n                               server,\n                               data.cancellable,\n                               autodiscover_cb,\n                               &data);\n  gtk_widget_set_sensitive (data.connect_button, FALSE);\n  gtk_widget_show (data.progress_grid);\n  g_main_loop_run (data.loop);\n\n  if (g_cancellable_is_cancelled (data.cancellable))\n    {\n      g_prefix_error (&data.error,\n                      _(\"Dialog was dismissed (%s, %d): \"),\n                      g_quark_to_string (data.error->domain),\n                      data.error->code);\n      data.error->domain = GOA_ERROR;\n      data.error->code = GOA_ERROR_DIALOG_DISMISSED;\n      goto out;\n    }\n  else if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to Microsoft Exchange server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      gtk_button_set_label (GTK_BUTTON (data.connect_button), _(\"_Try Again\"));\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto ews_again;\n    }\n\n  /* TODO: run in worker thread */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&builder, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  if (!goa_utils_store_credentials_for_object_sync (provider,\n                                                    object,\n                                                    g_variant_builder_end (&builder),\n                                                    NULL, /* GCancellable */\n                                                    &data.error))\n    goto out;\n\n  goa_account_call_ensure_credentials (account,\n                                       NULL, /* GCancellable */\n                                       NULL, NULL); /* callback, user_data */\n\n  ret = TRUE;\n\n out:\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n\n  gtk_widget_destroy (dialog);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  g_clear_object (&data.cancellable);\n  if (ews_client != NULL)\n    g_object_unref (ews_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "ensure_credentials_sync (GoaProvider         *provider,\n                         GoaObject           *object,\n                         gint                *out_expires_in,\n                         GCancellable        *cancellable,\n                         GError             **error)\n{\n  GVariant *credentials;\n  GoaAccount *account;\n  GoaHttpClient *http_client;\n  gboolean ret;\n  const gchar *username;\n  gchar *password;\n  gchar *uri;\n  gchar *uri_webdav;\n\n  credentials = NULL;\n  http_client = NULL;\n  password = NULL;\n  uri = NULL;\n  uri_webdav = NULL;\n\n  ret = FALSE;\n\n  credentials = goa_utils_lookup_credentials_sync (provider,\n                                                   object,\n                                                   cancellable,\n                                                   error);\n  if (credentials == NULL)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error, _(\"Credentials not found in keyring (%s, %d): \"),\n                          g_quark_to_string ((*error)->domain), (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n  uri = goa_util_lookup_keyfile_string (object, \"Uri\");\n  uri_webdav = g_strconcat (uri, WEBDAV_ENDPOINT, NULL);\n\n  account = goa_object_peek_account (object);\n  username = goa_account_get_identity (account);\n\n  if (!g_variant_lookup (credentials, \"password\", \"s\", &password))\n    {\n      if (error != NULL)\n        {\n          *error = g_error_new (GOA_ERROR,\n                                GOA_ERROR_NOT_AUTHORIZED,\n                                _(\"Did not find password with username `%s' in credentials\"),\n                                username);\n        }\n      goto out;\n    }\n\n  http_client = goa_http_client_new ();\n  ret = goa_http_client_check_sync (http_client,\n                                    uri_webdav,\n                                    username,\n                                    password,\n                                    cancellable,\n                                    error);\n  if (!ret)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error,\n                          /* Translators: the first %s is the username\n                           * (eg., debarshi.ray@gmail.com or rishi), and the\n                           * (%s, %d) is the error domain and code.\n                           */\n                          _(\"Invalid password with username `%s' (%s, %d): \"),\n                          username,\n                          g_quark_to_string ((*error)->domain),\n                          (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n  if (out_expires_in != NULL)\n    *out_expires_in = 0;\n\n out:\n  g_clear_object (&http_client);\n  g_free (password);\n  g_free (uri);\n  g_free (uri_webdav);\n  if (credentials != NULL)\n    g_variant_unref (credentials);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "ensure_credentials_sync (GoaProvider   *provider,\n                         GoaObject     *object,\n                         gint          *out_expires_in,\n                         GCancellable  *cancellable,\n                         GError       **error)\n{\n  GVariant *credentials;\n  GoaAccount *account;\n  GoaHttpClient *http_client;\n  gboolean ret;\n  const gchar *username;\n  gchar *password;\n  gchar *uri_caldav;\n\n  credentials = NULL;\n  http_client = NULL;\n  password = NULL;\n  uri_caldav = NULL;\n\n  ret = FALSE;\n\n  /* Chain up */\n  if (!GOA_PROVIDER_CLASS (goa_google_provider_parent_class)->ensure_credentials_sync (provider,\n                                                                                       object,\n                                                                                       out_expires_in,\n                                                                                       cancellable,\n                                                                                       error))\n    goto out;\n\n  credentials = goa_utils_lookup_credentials_sync (provider,\n                                                   object,\n                                                   cancellable,\n                                                   error);\n  if (credentials == NULL)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error,\n                          _(\"Credentials not found in keyring (%s, %d): \"),\n                          g_quark_to_string ((*error)->domain),\n                          (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n  account = goa_object_peek_account (object);\n  username = goa_account_get_presentation_identity (account);\n  uri_caldav = g_strdup_printf (CALDAV_ENDPOINT, username);\n\n  if (!g_variant_lookup (credentials, \"password\", \"s\", &password))\n    {\n      if (error != NULL)\n        {\n          *error = g_error_new (GOA_ERROR,\n                                GOA_ERROR_NOT_AUTHORIZED,\n                                _(\"Did not find password with username `%s' in credentials\"),\n                                username);\n        }\n      goto out;\n    }\n\n  http_client = goa_http_client_new ();\n  ret = goa_http_client_check_sync (http_client,\n                                    uri_caldav,\n                                    username,\n                                    password,\n                                    cancellable,\n                                    error);\n  if (!ret)\n    {\n      if (error != NULL)\n        {\n          g_prefix_error (error,\n                          /* Translators: the first %s is the username\n                           * (eg., debarshi.ray@gmail.com or rishi), and the\n                           * (%s, %d) is the error domain and code.\n                           */\n                          _(\"Invalid password with username `%s' (%s, %d): \"),\n                          username,\n                          g_quark_to_string ((*error)->domain),\n                          (*error)->code);\n          (*error)->domain = GOA_ERROR;\n          (*error)->code = GOA_ERROR_NOT_AUTHORIZED;\n        }\n      goto out;\n    }\n\n out:\n  g_clear_object (&http_client);\n  g_free (password);\n  g_free (uri_caldav);\n  g_clear_pointer (&credentials, (GDestroyNotify) g_variant_unref);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_web_view_init (GoaWebView *self)\n{\n  GoaWebViewPrivate *priv;\n  GtkWidget *scrolled_window;\n  SoupCookieJar *cookie_jar;\n  SoupLogger *logger;\n  SoupSession *session;\n  WebKitWebSettings *settings;\n\n  self->priv = GOA_WEB_VIEW_GET_PRIVATE (self);\n  priv = self->priv;\n\n  session = webkit_get_default_session ();\n\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_DEFAULT);\n  g_object_set (session, \"accept-language-auto\", TRUE, NULL);\n\n  soup_session_remove_feature_by_type (session, SOUP_TYPE_COOKIE_JAR);\n  cookie_jar = soup_cookie_jar_new ();\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (cookie_jar));\n  g_object_unref (cookie_jar);\n\n  logger = soup_logger_new (SOUP_LOGGER_LOG_BODY, -1);\n  soup_logger_set_printer (logger, web_view_log_printer, NULL, NULL);\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n  g_object_unref (logger);\n\n  scrolled_window = gtk_scrolled_window_new (NULL, NULL);\n  gtk_widget_set_size_request (scrolled_window, 500, 400);\n  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolled_window), GTK_SHADOW_IN);\n  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),\n                                  GTK_POLICY_AUTOMATIC,\n                                  GTK_POLICY_AUTOMATIC);\n  gtk_container_add (GTK_CONTAINER (self), scrolled_window);\n\n  priv->web_view = webkit_web_view_new ();\n  priv->status = WEBKIT_LOAD_PROVISIONAL;\n  gtk_container_add (GTK_CONTAINER (scrolled_window), priv->web_view);\n\n  settings = webkit_web_view_get_settings (WEBKIT_WEB_VIEW (priv->web_view));\n  g_object_set (settings, \"user-stylesheet-uri\", \"file://\" PACKAGE_DATA_DIR \"/goawebview.css\", NULL);\n\n  /* statusbar is hidden by default */\n  priv->floating_bar = nautilus_floating_bar_new (NULL, FALSE);\n  gtk_widget_set_halign (priv->floating_bar, GTK_ALIGN_START);\n  gtk_widget_set_valign (priv->floating_bar, GTK_ALIGN_END);\n  gtk_widget_set_no_show_all (priv->floating_bar, TRUE);\n  gtk_overlay_add_overlay (GTK_OVERLAY (self), priv->floating_bar);\n\n  priv->progress_bar = gtk_progress_bar_new ();\n  gtk_style_context_add_class (gtk_widget_get_style_context (priv->progress_bar),\n                               GTK_STYLE_CLASS_OSD);\n  gtk_widget_set_halign (priv->progress_bar, GTK_ALIGN_FILL);\n  gtk_widget_set_valign (priv->progress_bar, GTK_ALIGN_START);\n  gtk_overlay_add_overlay (GTK_OVERLAY (self), priv->progress_bar);\n\n  priv->notify_progress_id = g_signal_connect (priv->web_view,\n                                               \"notify::progress\",\n                                               G_CALLBACK (web_view_notify_progress_cb),\n                                               self);\n  priv->notify_load_status_id = g_signal_connect (priv->web_view,\n                                                  \"notify::load-status\",\n                                                  G_CALLBACK (web_view_notify_load_status_cb),\n                                                  self);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "add_account (GoaProvider    *provider,\n             GoaClient      *client,\n             GtkDialog      *dialog,\n             GtkBox         *vbox,\n             GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder credentials;\n  GVariantBuilder details;\n  GoaEwsClient *ews_client;\n  GoaObject *ret;\n  const gchar *email_address;\n  const gchar *server;\n  const gchar *password;\n  const gchar *username;\n  const gchar *provider_type;\n  gint response;\n\n  ews_client = NULL;\n  ret = NULL;\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.cancellable = g_cancellable_new ();\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = dialog;\n  data.error = NULL;\n\n  create_account_details_ui (provider, dialog, vbox, TRUE, &data);\n  gtk_widget_show_all (GTK_WIDGET (vbox));\n  g_signal_connect (dialog, \"response\", G_CALLBACK (dialog_response_cb), &data);\n\n  ews_client = goa_ews_client_new ();\n\n ews_again:\n  response = gtk_dialog_run (dialog);\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  email_address = gtk_entry_get_text (GTK_ENTRY (data.email_address));\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  username = gtk_entry_get_text (GTK_ENTRY (data.username));\n  server = gtk_entry_get_text (GTK_ENTRY (data.server));\n\n  /* See if there's already an account of this type with the\n   * given identity\n   */\n  provider_type = goa_provider_get_provider_type (provider);\n  if (!goa_utils_check_duplicate (client,\n                                  username,\n                                  provider_type,\n                                  (GoaPeekInterfaceFunc) goa_object_peek_password_based,\n                                  &data.error))\n    goto out;\n\n  g_cancellable_reset (data.cancellable);\n  goa_ews_client_autodiscover (ews_client,\n                               email_address,\n                               password,\n                               username,\n                               server,\n                               data.cancellable,\n                               autodiscover_cb,\n                               &data);\n  gtk_widget_set_sensitive (data.connect_button, FALSE);\n  gtk_widget_show (data.progress_grid);\n  g_main_loop_run (data.loop);\n\n  if (g_cancellable_is_cancelled (data.cancellable))\n    {\n      g_prefix_error (&data.error,\n                      _(\"Dialog was dismissed (%s, %d): \"),\n                      g_quark_to_string (data.error->domain),\n                      data.error->code);\n      data.error->domain = GOA_ERROR;\n      data.error->code = GOA_ERROR_DIALOG_DISMISSED;\n      goto out;\n    }\n  else if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to Microsoft Exchange server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      gtk_button_set_label (GTK_BUTTON (data.connect_button), _(\"_Try Again\"));\n      gtk_expander_set_expanded (GTK_EXPANDER (data.expander), TRUE);\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto ews_again;\n    }\n\n  gtk_widget_hide (GTK_WIDGET (dialog));\n\n  g_variant_builder_init (&credentials, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&credentials, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  g_variant_builder_init (&details, G_VARIANT_TYPE (\"a{ss}\"));\n  g_variant_builder_add (&details, \"{ss}\", \"MailEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"CalendarEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"ContactsEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"Host\", server);\n\n  /* OK, everything is dandy, add the account */\n  /* we want the GoaClient to update before this method returns (so it\n   * can create a proxy for the new object) so run the mainloop while\n   * waiting for this to complete\n   */\n  goa_manager_call_add_account (goa_client_get_manager (client),\n                                goa_provider_get_provider_type (provider),\n                                username,\n                                email_address,\n                                g_variant_builder_end (&credentials),\n                                g_variant_builder_end (&details),\n                                NULL, /* GCancellable* */\n                                (GAsyncReadyCallback) add_account_cb,\n                                &data);\n  g_main_loop_run (data.loop);\n  if (data.error != NULL)\n    goto out;\n\n  ret = GOA_OBJECT (g_dbus_object_manager_get_object (goa_client_get_object_manager (client),\n                                                      data.account_object_path));\n\n out:\n  /* We might have an object even when data.error is set.\n   * eg., if we failed to store the credentials in the keyring.\n   */\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n  else\n    g_assert (ret != NULL);\n\n  g_free (data.account_object_path);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  g_clear_object (&data.cancellable);\n  if (ews_client != NULL)\n    g_object_unref (ews_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_http_client_check (GoaHttpClient       *client,\n                       const gchar         *uri,\n                       const gchar         *username,\n                       const gchar         *password,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CheckData *data;\n  CheckAuthData *auth;\n  SoupLogger *logger;\n\n  g_return_if_fail (GOA_IS_HTTP_CLIENT (client));\n  g_return_if_fail (uri != NULL || uri[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  data = g_slice_new0 (CheckData);\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_http_client_check);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  logger = soup_logger_new (SOUP_LOGGER_LOG_BODY, -1);\n  soup_logger_set_printer (logger, http_client_log_printer, NULL, NULL);\n  soup_session_add_feature (data->session, SOUP_SESSION_FEATURE (logger));\n  g_object_unref (logger);\n\n  data->msg = soup_message_new (SOUP_METHOD_GET, uri);\n  soup_message_headers_append (data->msg->request_headers, \"Connection\", \"close\");\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (http_client_check_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (CheckAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (http_client_authenticate),\n                         auth,\n                         http_client_check_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msg, http_client_check_response_cb, data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_web_view_init (GoaWebView *self)\n{\n  GoaWebViewPrivate *priv;\n  GtkWidget *scrolled_window;\n  SoupCookieJar *cookie_jar;\n  SoupSession *session;\n  WebKitWebSettings *settings;\n\n  self->priv = GOA_WEB_VIEW_GET_PRIVATE (self);\n  priv = self->priv;\n\n  session = webkit_get_default_session ();\n\n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n  g_object_set (session, \"accept-language-auto\", TRUE, NULL);\n\n  soup_session_remove_feature_by_type (session, SOUP_TYPE_COOKIE_JAR);\n  cookie_jar = soup_cookie_jar_new ();\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (cookie_jar));\n  g_object_unref (cookie_jar);\n\n  gtk_style_context_add_class (gtk_widget_get_style_context (GTK_WIDGET (self)),\n                               GTK_STYLE_CLASS_OSD);\n\n  scrolled_window = gtk_scrolled_window_new (NULL, NULL);\n  gtk_widget_set_size_request (scrolled_window, 500, 400);\n  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolled_window), GTK_SHADOW_IN);\n  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),\n                                  GTK_POLICY_AUTOMATIC,\n                                  GTK_POLICY_AUTOMATIC);\n  gtk_container_add (GTK_CONTAINER (self), scrolled_window);\n\n  priv->web_view = webkit_web_view_new ();\n  priv->status = WEBKIT_LOAD_PROVISIONAL;\n  gtk_container_add (GTK_CONTAINER (scrolled_window), priv->web_view);\n\n  settings = webkit_web_view_get_settings (WEBKIT_WEB_VIEW (priv->web_view));\n  g_object_set (settings, \"user-stylesheet-uri\", \"file://\" PACKAGE_DATA_DIR \"/goawebview.css\", NULL);\n\n  /* statusbar is hidden by default */\n  priv->floating_bar = nautilus_floating_bar_new (NULL, FALSE);\n  gtk_widget_set_halign (priv->floating_bar, GTK_ALIGN_START);\n  gtk_widget_set_valign (priv->floating_bar, GTK_ALIGN_END);\n  gtk_widget_set_no_show_all (priv->floating_bar, TRUE);\n  gtk_overlay_add_overlay (GTK_OVERLAY (self), priv->floating_bar);\n\n  priv->progress_bar = gtk_progress_bar_new ();\n  gtk_widget_set_halign (priv->progress_bar, GTK_ALIGN_FILL);\n  gtk_widget_set_valign (priv->progress_bar, GTK_ALIGN_START);\n  gtk_overlay_add_overlay (GTK_OVERLAY (self), priv->progress_bar);\n\n  priv->notify_progress_id = g_signal_connect (priv->web_view,\n                                               \"notify::progress\",\n                                               G_CALLBACK (web_view_notify_progress_cb),\n                                               self);\n  priv->notify_load_status_id = g_signal_connect (priv->web_view,\n                                                  \"notify::load-status\",\n                                                  G_CALLBACK (web_view_notify_load_status_cb),\n                                                  self);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "refresh_account (GoaProvider    *provider,\n                 GoaClient      *client,\n                 GoaObject      *object,\n                 GtkWindow      *parent,\n                 GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder builder;\n  GoaAccount *account;\n  GoaEwsClient *ews_client;\n  GoaExchange *exchange;\n  GtkWidget *dialog;\n  GtkWidget *vbox;\n  gboolean ret;\n  const gchar *email_address;\n  const gchar *server;\n  const gchar *password;\n  const gchar *username;\n  gint response;\n\n  g_return_val_if_fail (GOA_IS_EXCHANGE_PROVIDER (provider), FALSE);\n  g_return_val_if_fail (GOA_IS_CLIENT (client), FALSE);\n  g_return_val_if_fail (GOA_IS_OBJECT (object), FALSE);\n  g_return_val_if_fail (parent == NULL || GTK_IS_WINDOW (parent), FALSE);\n  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  ews_client = NULL;\n  ret = FALSE;\n\n  dialog = gtk_dialog_new_with_buttons (NULL,\n                                        parent,\n                                        GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n                                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,\n                                        NULL);\n  gtk_container_set_border_width (GTK_CONTAINER (dialog), 12);\n  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);\n  gtk_window_set_resizable (GTK_WINDOW (dialog), FALSE);\n\n  vbox = gtk_dialog_get_content_area (GTK_DIALOG (dialog));\n  gtk_box_set_spacing (GTK_BOX (vbox), 12);\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = GTK_DIALOG (dialog);\n  data.error = NULL;\n\n  create_account_details_ui (provider, GTK_DIALOG (dialog), GTK_BOX (vbox), FALSE, &data);\n\n  account = goa_object_peek_account (object);\n  email_address = goa_account_get_presentation_identity (account);\n  gtk_entry_set_text (GTK_ENTRY (data.email_address), email_address);\n  gtk_editable_set_editable (GTK_EDITABLE (data.email_address), FALSE);\n\n  gtk_widget_show_all (dialog);\n\n  ews_client = goa_ews_client_new ();\n\n ews_again:\n  response = gtk_dialog_run (GTK_DIALOG (dialog));\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  username = goa_account_get_identity (account);\n\n  exchange = goa_object_peek_exchange (object);\n  server = goa_exchange_get_host (exchange);\n\n  goa_ews_client_autodiscover (ews_client,\n                               email_address,\n                               password,\n                               username,\n                               server,\n                               NULL,\n                               autodiscover_cb,\n                               &data);\n  goa_spinner_button_start (GOA_SPINNER_BUTTON (data.spinner_button));\n  g_main_loop_run (data.loop);\n\n  if (data.error != NULL)\n    {\n      GtkWidget *button;\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to Microsoft Exchange server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      button = gtk_dialog_get_widget_for_response (data.dialog, GTK_RESPONSE_OK);\n      gtk_button_set_label (GTK_BUTTON (button), _(\"_Try Again\"));\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto ews_again;\n    }\n\n  /* TODO: run in worker thread */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&builder, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  if (!goa_utils_store_credentials_for_object_sync (provider,\n                                                    object,\n                                                    g_variant_builder_end (&builder),\n                                                    NULL, /* GCancellable */\n                                                    error))\n    goto out;\n\n  goa_account_call_ensure_credentials (account,\n                                       NULL, /* GCancellable */\n                                       NULL, NULL); /* callback, user_data */\n\n  ret = TRUE;\n\n out:\n  gtk_widget_destroy (dialog);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  if (ews_client != NULL)\n    g_object_unref (ews_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  gboolean op_res;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  http_client_check_data_free (data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_ews_client_autodiscover (GoaEwsClient        *client,\n                             const gchar         *email,\n                             const gchar         *password,\n                             const gchar         *username,\n                             const gchar         *server,\n                             GCancellable        *cancellable,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)\n{\n  AutodiscoverData *data;\n  AutodiscoverAuthData *auth;\n  gchar *url1;\n  gchar *url2;\n  xmlDoc *doc;\n  xmlOutputBuffer *buf;\n\n  g_return_if_fail (GOA_IS_EWS_CLIENT (client));\n  g_return_if_fail (email != NULL || email[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (server != NULL || server[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  doc = ews_client_create_autodiscover_xml (email);\n  buf = xmlAllocOutputBuffer (NULL);\n  xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);\n  xmlOutputBufferFlush (buf);\n\n  url1 = g_strdup_printf (\"https://%s/autodiscover/autodiscover.xml\", server);\n  url2 = g_strdup_printf (\"https://autodiscover.%s/autodiscover/autodiscover.xml\", server);\n\n  /* http://msdn.microsoft.com/en-us/library/ee332364.aspx says we are\n   * supposed to try $domain and then autodiscover.$domain. But some\n   * people have broken firewalls on the former which drop packets\n   * instead of rejecting connections, and make the request take ages\n   * to time out. So run both queries in parallel and let the fastest\n   * (successful) one win.\n   */\n  data = g_slice_new0 (AutodiscoverData);\n  data->buf = buf;\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_ews_client_autodiscover);\n  data->msgs[0] = ews_client_create_msg_for_url (url1, buf);\n  data->msgs[1] = ews_client_create_msg_for_url (url2, buf);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_USE_NTLM, TRUE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (ews_client_autodiscover_cancelled_cb),\n                                                    data,\n                                                    NULL);\n    }\n\n  auth = g_slice_new0 (AutodiscoverAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (ews_client_authenticate),\n                         auth,\n                         ews_client_autodiscover_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n  soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n\n  g_free (url2);\n  g_free (url1);\n  xmlFreeDoc (doc);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "goa_http_client_check (GoaHttpClient       *client,\n                       const gchar         *uri,\n                       const gchar         *username,\n                       const gchar         *password,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CheckData *data;\n  CheckAuthData *auth;\n\n  g_return_if_fail (GOA_IS_HTTP_CLIENT (client));\n  g_return_if_fail (uri != NULL || uri[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  data = g_slice_new0 (CheckData);\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_http_client_check);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n\n  data->msg = soup_message_new (SOUP_METHOD_GET, uri);\n  soup_message_headers_append (data->msg->request_headers, \"Connection\", \"close\");\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (http_client_check_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (CheckAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (http_client_authenticate),\n                         auth,\n                         http_client_check_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msg, http_client_check_response_cb, data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "add_account (GoaProvider    *provider,\n             GoaClient      *client,\n             GtkDialog      *dialog,\n             GtkBox         *vbox,\n             GError        **error)\n{\n  AddAccountData data;\n  GVariantBuilder credentials;\n  GVariantBuilder details;\n  GoaEwsClient *ews_client;\n  GoaObject *ret;\n  const gchar *email_address;\n  const gchar *server;\n  const gchar *password;\n  const gchar *username;\n  const gchar *provider_type;\n  gint response;\n\n  ews_client = NULL;\n  ret = NULL;\n\n  memset (&data, 0, sizeof (AddAccountData));\n  data.loop = g_main_loop_new (NULL, FALSE);\n  data.dialog = dialog;\n  data.error = NULL;\n\n  create_account_details_ui (provider, dialog, vbox, TRUE, &data);\n  gtk_widget_show_all (GTK_WIDGET (vbox));\n\n  ews_client = goa_ews_client_new ();\n\n ews_again:\n  response = gtk_dialog_run (dialog);\n  if (response != GTK_RESPONSE_OK)\n    {\n      g_set_error (&data.error,\n                   GOA_ERROR,\n                   GOA_ERROR_DIALOG_DISMISSED,\n                   _(\"Dialog was dismissed\"));\n      goto out;\n    }\n\n  email_address = gtk_entry_get_text (GTK_ENTRY (data.email_address));\n  password = gtk_entry_get_text (GTK_ENTRY (data.password));\n  username = gtk_entry_get_text (GTK_ENTRY (data.username));\n  server = gtk_entry_get_text (GTK_ENTRY (data.server));\n\n  /* See if there's already an account of this type with the\n   * given identity\n   */\n  provider_type = goa_provider_get_provider_type (provider);\n  if (!goa_utils_check_duplicate (client,\n                                  username,\n                                  provider_type,\n                                  (GoaPeekInterfaceFunc) goa_object_peek_password_based,\n                                  &data.error))\n    goto out;\n\n  goa_ews_client_autodiscover (ews_client,\n                               email_address,\n                               password,\n                               username,\n                               server,\n                               NULL,\n                               autodiscover_cb,\n                               &data);\n  goa_spinner_button_start (GOA_SPINNER_BUTTON (data.spinner_button));\n  g_main_loop_run (data.loop);\n\n  if (data.error != NULL)\n    {\n      gchar *markup;\n\n      markup = g_strdup_printf (\"<b>%s:</b> %s\",\n                                _(\"Error connecting to Microsoft Exchange server\"),\n                                data.error->message);\n      g_clear_error (&data.error);\n\n      gtk_label_set_markup (GTK_LABEL (data.cluebar_label), markup);\n      g_free (markup);\n\n      goa_spinner_button_set_label (GOA_SPINNER_BUTTON (data.spinner_button), _(\"_Try Again\"));\n      gtk_expander_set_expanded (GTK_EXPANDER (data.expander), TRUE);\n      gtk_widget_set_no_show_all (data.cluebar, FALSE);\n      gtk_widget_show_all (data.cluebar);\n      goto ews_again;\n    }\n\n  gtk_widget_hide (GTK_WIDGET (dialog));\n\n  g_variant_builder_init (&credentials, G_VARIANT_TYPE_VARDICT);\n  g_variant_builder_add (&credentials, \"{sv}\", \"password\", g_variant_new_string (password));\n\n  g_variant_builder_init (&details, G_VARIANT_TYPE (\"a{ss}\"));\n  g_variant_builder_add (&details, \"{ss}\", \"MailEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"CalendarEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"ContactsEnabled\", \"true\");\n  g_variant_builder_add (&details, \"{ss}\", \"Host\", server);\n\n  /* OK, everything is dandy, add the account */\n  /* we want the GoaClient to update before this method returns (so it\n   * can create a proxy for the new object) so run the mainloop while\n   * waiting for this to complete\n   */\n  goa_manager_call_add_account (goa_client_get_manager (client),\n                                goa_provider_get_provider_type (provider),\n                                username,\n                                email_address,\n                                g_variant_builder_end (&credentials),\n                                g_variant_builder_end (&details),\n                                NULL, /* GCancellable* */\n                                (GAsyncReadyCallback) add_account_cb,\n                                &data);\n  g_main_loop_run (data.loop);\n  if (data.error != NULL)\n    goto out;\n\n  ret = GOA_OBJECT (g_dbus_object_manager_get_object (goa_client_get_object_manager (client),\n                                                      data.account_object_path));\n\n out:\n  /* We might have an object even when data.error is set.\n   * eg., if we failed to store the credentials in the keyring.\n   */\n  if (data.error != NULL)\n    g_propagate_error (error, data.error);\n  else\n    g_assert (ret != NULL);\n\n  g_free (data.account_object_path);\n  if (data.loop != NULL)\n    g_main_loop_unref (data.loop);\n  if (ews_client != NULL)\n    g_object_unref (ews_client);\n  return ret;\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
{"func": "ews_client_autodiscover_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  AutodiscoverData *data = user_data;\n  gboolean op_res;\n  guint status;\n  gint idx;\n  gsize size;\n  xmlDoc *doc;\n  xmlNode *node;\n\n  status = msg->status_code;\n  if (status == SOUP_STATUS_CANCELLED)\n    return;\n\n  error = NULL;\n  op_res = FALSE;\n  size = sizeof (data->msgs) / sizeof (data->msgs[0]);\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] == msg)\n        break;\n    }\n  if (idx == size)\n    return;\n\n  data->msgs[idx] = NULL;\n\n  if (status != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   status);\n      goto out;\n    }\n\n  soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->response_body));\n  g_debug (\"The response headers\");\n  g_debug (\"===================\");\n  g_debug (\"%s\", SOUP_MESSAGE (msg)->response_body->data);\n\n  doc = xmlReadMemory (msg->response_body->data, msg->response_body->length, \"autodiscover.xml\", NULL, 0);\n  if (doc == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to parse autodiscover response XML\"));\n      goto out;\n    }\n\n  node = xmlDocGetRootElement (doc);\n  if (g_strcmp0 ((gchar *) node->name, \"Autodiscover\"))\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Autodiscover element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Response\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Response element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Account\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Account element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Protocol\"))\n        {\n          op_res = ews_client_autodiscover_parse_protocol (node);\n          break;\n        }\n    }\n  if (!op_res)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific*/\n                   _(\"Failed to find ASUrl and OABUrl in autodiscover response\"));\n      goto out;\n    }\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] != NULL)\n        {\n          /* Since we are cancelling from the same thread that we queued the\n           * message, the callback (ie. this function) will be invoked before\n           * soup_session_cancel_message returns.\n           */\n          soup_session_cancel_message (data->session, data->msgs[idx], SOUP_STATUS_CANCELLED);\n          data->msgs[idx] = NULL;\n        }\n    }\n\n out:\n  if (error != NULL)\n    {\n      for (idx = 0; idx < size; idx++)\n        {\n          if (data->msgs[idx] != NULL)\n            {\n              /* There's another request outstanding.\n               * Hope that it has better luck.\n               */\n              g_clear_error (&error);\n              return;\n            }\n        }\n      g_simple_async_result_set_from_error (data->res, error);\n    }\n  else\n    g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  ews_client_autodiscover_data_free (data);\n}", "target": 1, "cwe": ["CWE-310"], "message": "Guard against invalid SSL certificates\n\nNone of the branded providers (eg., Google, Facebook and Windows Live)\nshould ever have an invalid certificate. So set \"ssl-strict\" on the\nSoupSession object being used by GoaWebView.\n\nProviders like ownCloud and Exchange might have to deal with\ncertificates that are not up to the mark. eg., self-signed\ncertificates. For those, show a warning when the account is being\ncreated, and only proceed if the user decides to ignore it. In any\ncase, save the status of the certificate that was used to create the\naccount. So an account created with a valid certificate will never\nwork with an invalid one, and one created with an invalid certificate\nwill not throw any further warnings.\n\nFixes: CVE-2013-0240"}
